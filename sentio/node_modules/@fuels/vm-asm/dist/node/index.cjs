'use strict';

let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}
/**
 * Construct a `GM` instruction from its arguments.
 * @param {number} ra
 * @param {GMArgs} args
 * @returns {Instruction}
 */
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `GM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {GTFArgs} args
 * @returns {Instruction}
 */
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQCM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {NarrowMathArgs} args
 * @returns {Instruction}
 */
function niop_args(ra, rb, rc, args) {
    _assertClass(args, NarrowMathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.niop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDCM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {CompareArgs} args
 * @returns {Instruction}
 */
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQCM` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {CompareArgs} args
 * @returns {Instruction}
 */
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDOP` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MathArgs} args
 * @returns {Instruction}
 */
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQOP` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MathArgs} args
 * @returns {Instruction}
 */
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDML` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MulArgs} args
 * @returns {Instruction}
 */
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQML` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {MulArgs} args
 * @returns {Instruction}
 */
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WDDV` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {DivArgs} args
 * @returns {Instruction}
 */
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Construct a `WQDV` instruction from its arguments.
 * @param {number} ra
 * @param {number} rb
 * @param {number} rc
 * @param {DivArgs} args
 * @returns {Instruction}
 */
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
 * Adds two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ANDs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Divides two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for equality.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Raises one register to the power of another.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for greater-than.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Compares two registers for less-than.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * The integer logarithm of a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * The integer root of a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Modulo remainder of two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Copy from one register to another.
 * @param {number} dst
 * @param {number} src
 * @returns {Instruction}
 */
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
 * Multiplies two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise NOT a register.
 * @param {number} dst
 * @param {number} arg
 * @returns {Instruction}
 */
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ORs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Left shifts a register by a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Right shifts a register by a register.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Subtracts two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise XORs two registers.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide with arbitrary precision intermediate step.
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * Narrow-integer arithmetic operation.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function niop(dst, lhs, rhs, flags) {
    const ret = wasm$1.niop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Return from context.
 * @param {number} value
 * @returns {Instruction}
 */
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
 * Return from context with data.
 * @param {number} addr
 * @param {number} len
 * @returns {Instruction}
 */
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Allocate a number of bytes from the heap.
 * @param {number} bytes
 * @returns {Instruction}
 */
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
 * Clear a variable number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Copy a variable number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Compare bytes in memory.
 * @param {number} result
 * @param {number} lhs_addr
 * @param {number} rhs_addr
 * @param {number} len
 * @returns {Instruction}
 */
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get block header hash for height.
 * @param {number} dst
 * @param {number} heigth
 * @returns {Instruction}
 */
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
 * Get current block height.
 * @param {number} dst
 * @returns {Instruction}
 */
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
 * Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
 * @param {number} amount
 * @param {number} sub_id_addr
 * @returns {Instruction}
 */
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Call a contract.
 * @param {number} target_struct
 * @param {number} fwd_coins
 * @param {number} asset_id_addr
 * @param {number} fwd_gas
 * @returns {Instruction}
 */
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
 * Copy contract code for a contract.
 * @param {number} dst_addr
 * @param {number} contract_id_addr
 * @param {number} offset
 * @param {number} len
 * @returns {Instruction}
 */
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
 * Get code root of a contract.
 * @param {number} dst_addr
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Get code size of a contract.
 * @param {number} dst
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Get current block proposer's address.
 * @param {number} dst
 * @returns {Instruction}
 */
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
 * Load code as executable either from contract, blob, or memory.
 * @param {number} src_addr
 * @param {number} offset
 * @param {number} len
 * @param {number} mode
 * @returns {Instruction}
 */
function ldc(src_addr, offset, len, mode) {
    const ret = wasm$1.ldc(src_addr, offset, len, mode);
    return Instruction.__wrap(ret);
}

/**
 * Log an event.
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @returns {Instruction}
 */
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
 * Log data.
 * @param {number} a
 * @param {number} b
 * @param {number} addr
 * @param {number} len
 * @returns {Instruction}
 */
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
 * @param {number} amount
 * @param {number} sub_id_addr
 * @returns {Instruction}
 */
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Halt execution, reverting state changes and returning a value.
 * @param {number} value
 * @returns {Instruction}
 */
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
 * Clear a series of slots from contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} lenq
 * @returns {Instruction}
 */
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Load a word from contract storage.
 * @param {number} dst
 * @param {number} status
 * @param {number} key_addr
 * @returns {Instruction}
 */
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
 * Load a series of 32 byte slots from contract storage.
 * @param {number} dst_addr
 * @param {number} status
 * @param {number} key_addr
 * @param {number} lenq
 * @returns {Instruction}
 */
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Store a word in contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} value
 * @returns {Instruction}
 */
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
 * Store a series of 32 byte slots in contract storage.
 * @param {number} key_addr
 * @param {number} status
 * @param {number} src_addr
 * @param {number} lenq
 * @returns {Instruction}
 */
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
 * Transfer coins to a contract unconditionally.
 * @param {number} contract_id_addr
 * @param {number} amount
 * @param {number} asset_id_addr
 * @returns {Instruction}
 */
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Transfer coins to a variable output.
 * @param {number} contract_id_addr
 * @param {number} output_index
 * @param {number} amount
 * @param {number} asset_id_addr
 * @returns {Instruction}
 */
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 * @param {number} dst_addr
 * @param {number} sig_addr
 * @param {number} msg_hash_addr
 * @returns {Instruction}
 */
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
 * The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 * @param {number} dst_addr
 * @param {number} sig_addr
 * @param {number} msg_hash_addr
 * @returns {Instruction}
 */
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
 * Verify ED25519 public key and signature match a message.
 * @param {number} pub_key_addr
 * @param {number} sig_addr
 * @param {number} msg_addr
 * @param {number} msg_len
 * @returns {Instruction}
 */
function ed19(pub_key_addr, sig_addr, msg_addr, msg_len) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_addr, msg_len);
    return Instruction.__wrap(ret);
}

/**
 * The keccak-256 hash of a slice.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * The SHA-2-256 hash of a slice.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get timestamp of block at given height.
 * @param {number} dst
 * @param {number} heigth
 * @returns {Instruction}
 */
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
 * Performs no operation.
 * @returns {Instruction}
 */
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
 * Set flag register to a register.
 * @param {number} value
 * @returns {Instruction}
 */
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
 * Get the balance of contract of an asset ID.
 * @param {number} dst
 * @param {number} asset_id_addr
 * @param {number} contract_id_addr
 * @returns {Instruction}
 */
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic jump.
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Conditional dynamic jump.
 * @param {number} abs_target
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Send a message to recipient address with call abi, coins, and output.
 * @param {number} recipient_addr
 * @param {number} data_addr
 * @param {number} data_len
 * @param {number} coins
 * @returns {Instruction}
 */
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
 * Adds a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ANDs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Divides a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Raises one register to the power of an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Modulo remainder of a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Multiplies a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise ORs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Left shifts a register by an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Right shifts a register by an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Subtracts a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Bitwise XORs a register and an immediate value.
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @returns {Instruction}
 */
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
 * Conditional jump.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
 * A byte is loaded from the specified address offset by an immediate value.
 * @param {number} dst
 * @param {number} addr
 * @param {number} offset
 * @returns {Instruction}
 */
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
 * A word is loaded from the specified address offset by an immediate value.
 * @param {number} dst
 * @param {number} addr
 * @param {number} offset
 * @returns {Instruction}
 */
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
 * Write the least significant byte of a register to memory.
 * @param {number} addr
 * @param {number} value
 * @param {number} offset
 * @returns {Instruction}
 */
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
 * Write a register to memory.
 * @param {number} addr
 * @param {number} value
 * @param {number} offset
 * @returns {Instruction}
 */
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
 * Copy an immediate number of bytes in memory.
 * @param {number} dst_addr
 * @param {number} src_addr
 * @param {number} len
 * @returns {Instruction}
 */
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
 * Get transaction fields.
 * @param {number} dst
 * @param {number} arg
 * @param {number} selector
 * @returns {Instruction}
 */
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
 * Load quarterword (u16).
 * @param {number} dst
 * @param {number} arg
 * @param {number} offset
 * @returns {Instruction}
 */
function lqw(dst, arg, offset) {
    const ret = wasm$1.lqw(dst, arg, offset);
    return Instruction.__wrap(ret);
}

/**
 * Load halfword (u32).
 * @param {number} dst
 * @param {number} arg
 * @param {number} offset
 * @returns {Instruction}
 */
function lhw(dst, arg, offset) {
    const ret = wasm$1.lhw(dst, arg, offset);
    return Instruction.__wrap(ret);
}

/**
 * Store quarterword (u16).
 * @param {number} dst
 * @param {number} arg
 * @param {number} offset
 * @returns {Instruction}
 */
function sqw(dst, arg, offset) {
    const ret = wasm$1.sqw(dst, arg, offset);
    return Instruction.__wrap(ret);
}

/**
 * Store halfword (u32).
 * @param {number} dst
 * @param {number} arg
 * @param {number} offset
 * @returns {Instruction}
 */
function shw(dst, arg, offset) {
    const ret = wasm$1.shw(dst, arg, offset);
    return Instruction.__wrap(ret);
}

/**
 * Clear an immediate number of bytes in memory.
 * @param {number} addr
 * @param {number} count
 * @returns {Instruction}
 */
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
 * Get metadata from memory.
 * @param {number} dst
 * @param {number} selector
 * @returns {Instruction}
 */
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
 * Copy immediate value into a register
 * @param {number} dst
 * @param {number} val
 * @returns {Instruction}
 */
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
 * Conditional jump against zero.
 * @param {number} cond_nz
 * @param {number} abs_target
 * @returns {Instruction}
 */
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Unconditional dynamic relative jump forwards, with a constant offset.
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Unconditional dynamic relative jump backwards, with a constant offset.
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump forwards, conditional against zero, with a constant offset.
 * @param {number} cond_nz
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump backwards, conditional against zero, with a constant offset.
 * @param {number} cond_nz
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
 * @param {number} cond_lhs
 * @param {number} cond_rhs
 * @param {number} dynamic
 * @param {number} fixed
 * @returns {Instruction}
 */
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
 * Jump.
 * @param {number} abs_target
 * @returns {Instruction}
 */
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
 * Extend the current call frame's stack by an immediate value.
 * @param {number} amount
 * @returns {Instruction}
 */
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
 * Shrink the current call frame's stack by an immediate value.
 * @param {number} amount
 * @returns {Instruction}
 */
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
 * Extend the current call frame's stack
 * @param {number} amount
 * @returns {Instruction}
 */
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
 * Shrink the current call frame's stack
 * @param {number} amount
 * @returns {Instruction}
 */
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
 * Push a bitmask-selected set of registers in range 16..40 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Push a bitmask-selected set of registers in range 40..64 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Pop a bitmask-selected set of registers in range 16..40 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Pop a bitmask-selected set of registers in range 40..64 to the stack.
 * @param {number} bitmask
 * @returns {Instruction}
 */
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
 * Store return address and jump to an absolute address.
 * @param {number} ret_addr
 * @param {number} target
 * @param {number} offset
 * @returns {Instruction}
 */
function jal(ret_addr, target, offset) {
    const ret = wasm$1.jal(ret_addr, target, offset);
    return Instruction.__wrap(ret);
}

/**
 * Compare 128bit integers
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Compare 256bit integers
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Simple 128bit operations
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Simple 256bit operations
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Multiply 128bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Multiply 256bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Divide 128bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Divide 256bit
 * @param {number} dst
 * @param {number} lhs
 * @param {number} rhs
 * @param {number} flags
 * @returns {Instruction}
 */
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide 128bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * Fused multiply-divide 256bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} divisor
 * @returns {Instruction}
 */
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
 * AddMod 128bit
 * @param {number} dst
 * @param {number} add_lhs
 * @param {number} add_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * AddMod 256bit
 * @param {number} dst
 * @param {number} add_lhs
 * @param {number} add_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * MulMod 128bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * MulMod 256bit
 * @param {number} dst
 * @param {number} mul_lhs
 * @param {number} mul_rhs
 * @param {number} modulo
 * @returns {Instruction}
 */
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
 * Call external function
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @returns {Instruction}
 */
function ecal(a, b, c, d) {
    const ret = wasm$1.ecal(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
 * Get blob size
 * @param {number} dst
 * @param {number} blob_id_ptr
 * @returns {Instruction}
 */
function bsiz(dst, blob_id_ptr) {
    const ret = wasm$1.bsiz(dst, blob_id_ptr);
    return Instruction.__wrap(ret);
}

/**
 * Load blob as data
 * @param {number} dst_ptr
 * @param {number} blob_id_ptr
 * @param {number} offset
 * @param {number} len
 * @returns {Instruction}
 */
function bldd(dst_ptr, blob_id_ptr, offset, len) {
    const ret = wasm$1.bldd(dst_ptr, blob_id_ptr, offset, len);
    return Instruction.__wrap(ret);
}

/**
 * Given some curve, performs an operation on points
 * @param {number} dst
 * @param {number} curve_id
 * @param {number} operation_type
 * @param {number} points_ptr
 * @returns {Instruction}
 */
function ecop(dst, curve_id, operation_type, points_ptr) {
    const ret = wasm$1.ecop(dst, curve_id, operation_type, points_ptr);
    return Instruction.__wrap(ret);
}

/**
 * Given some curve, performs a pairing on groups of points
 * @param {number} success
 * @param {number} curve_id
 * @param {number} number_elements
 * @param {number} points_ptr
 * @returns {Instruction}
 */
function epar(success, curve_id, number_elements, points_ptr) {
    const ret = wasm$1.epar(success, curve_id, number_elements, points_ptr);
    return Instruction.__wrap(ret);
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm$1.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm$1.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
 * Comparison mode used by WDCM and WQCM instructions.
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
const CompareMode = Object.freeze({
    /**
     * Equality (`==`)
     */
    EQ: 0, "0": "EQ",
    /**
     * Inequality (`!=`)
     */
    NE: 1, "1": "NE",
    /**
     * Less than (`<`)
     */
    LT: 2, "2": "LT",
    /**
     * Greater than (`>`)
     */
    GT: 3, "3": "GT",
    /**
     * Less than or equals (`>=`)
     */
    LTE: 4, "4": "LTE",
    /**
     * Greater than or equals (`>=`)
     */
    GTE: 5, "5": "GTE",
    /**
     * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
     */
    LZC: 6, "6": "LZC",
});
/**
 * r" Argument list for GM (get metadata) instruction
 * r" The VM is the only who should match this struct, and it *MUST* always perform
 * r" exhaustive match so all offered variants are covered.
 * @enum {1 | 2 | 3 | 4 | 5 | 6 | 7}
 */
const GMArgs = Object.freeze({
    /**
     * r" Get if caller is external.
     */
    IsCallerExternal: 1, "1": "IsCallerExternal",
    /**
     * r" Get caller's contract ID.
     */
    GetCaller: 2, "2": "GetCaller",
    /**
     * r" Get index of current predicate.
     */
    GetVerifyingPredicate: 3, "3": "GetVerifyingPredicate",
    /**
     * r" Get the Chain ID this VM is operating within
     */
    GetChainId: 4, "4": "GetChainId",
    /**
     * r" Get memory address where the transaction is located
     */
    TxStart: 5, "5": "TxStart",
    /**
     * r" Get memory address of base asset ID
     */
    BaseAssetId: 6, "6": "BaseAssetId",
    /**
     * r" Get gas price for block
     */
    GetGasPrice: 7, "7": "GetGasPrice",
});
/**
 * r" Argument list for GTF (get tx fields) instruction
 * r" The VM is the only who should match this struct, and it *MUST* always perform
 * r" exhaustive match so all offered variants are covered.
 * @enum {1 | 2 | 3 | 4 | 5 | 6 | 7 | 9 | 10 | 11 | 12 | 13 | 14 | 257 | 258 | 259 | 260 | 261 | 262 | 263 | 264 | 265 | 266 | 512 | 513 | 514 | 515 | 516 | 517 | 518 | 519 | 521 | 522 | 523 | 524 | 525 | 544 | 545 | 549 | 576 | 577 | 578 | 579 | 580 | 581 | 582 | 583 | 584 | 585 | 586 | 587 | 768 | 769 | 770 | 771 | 772 | 775 | 776 | 1024 | 1025 | 1280 | 1281 | 1282 | 1283 | 1284 | 1285 | 1536 | 1537 | 1538 | 1539 | 1540 | 1541 | 1792 | 1793 | 2048 | 2304 | 2305 | 2306 | 2307 | 2308 | 2309}
 */
const GTFArgs = Object.freeze({
    /**
     * r" Set `$rA` to `tx.type`
     */
    Type: 1, "1": "Type",
    /**
     * r" Set `$rA` to `tx.scriptGasLimit`
     */
    ScriptGasLimit: 2, "2": "ScriptGasLimit",
    /**
     * r" Set `$rA` to `tx.scriptLength`
     */
    ScriptLength: 3, "3": "ScriptLength",
    /**
     * r" Set `$rA` to `tx.scriptDataLength`
     */
    ScriptDataLength: 4, "4": "ScriptDataLength",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    ScriptInputsCount: 5, "5": "ScriptInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    ScriptOutputsCount: 6, "6": "ScriptOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    ScriptWitnessesCount: 7, "7": "ScriptWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.script`
     */
    Script: 9, "9": "Script",
    /**
     * r" Set `$rA` to `Memory address of tx.scriptData`
     */
    ScriptData: 10, "10": "ScriptData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    ScriptInputAtIndex: 11, "11": "ScriptInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    ScriptOutputAtIndex: 12, "12": "ScriptOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    ScriptWitnessAtIndex: 13, "13": "ScriptWitnessAtIndex",
    /**
     * r" Set `$rA` to size of the transaction in memory, in bytes
     */
    TxLength: 14, "14": "TxLength",
    /**
     * r" Set `$rA` to `tx.bytecodeWitnessIndex`
     */
    CreateBytecodeWitnessIndex: 257, "257": "CreateBytecodeWitnessIndex",
    /**
     * r" Set `$rA` to `tx.storageSlotsCount`
     */
    CreateStorageSlotsCount: 258, "258": "CreateStorageSlotsCount",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    CreateInputsCount: 259, "259": "CreateInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    CreateOutputsCount: 260, "260": "CreateOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    CreateWitnessesCount: 261, "261": "CreateWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.salt`
     */
    CreateSalt: 262, "262": "CreateSalt",
    /**
     * r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
     */
    CreateStorageSlotAtIndex: 263, "263": "CreateStorageSlotAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    CreateInputAtIndex: 264, "264": "CreateInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    CreateOutputAtIndex: 265, "265": "CreateOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    CreateWitnessAtIndex: 266, "266": "CreateWitnessAtIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].type`
     */
    InputType: 512, "512": "InputType",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
     */
    InputCoinTxId: 513, "513": "InputCoinTxId",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
     */
    InputCoinOutputIndex: 514, "514": "InputCoinOutputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
     */
    InputCoinOwner: 515, "515": "InputCoinOwner",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].amount`
     */
    InputCoinAmount: 516, "516": "InputCoinAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
     */
    InputCoinAssetId: 517, "517": "InputCoinAssetId",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
     */
    InputCoinTxPointer: 518, "518": "InputCoinTxPointer",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
     */
    InputCoinWitnessIndex: 519, "519": "InputCoinWitnessIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
     */
    InputCoinPredicateLength: 521, "521": "InputCoinPredicateLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
     */
    InputCoinPredicateDataLength: 522, "522": "InputCoinPredicateDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
     */
    InputCoinPredicate: 523, "523": "InputCoinPredicate",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
     */
    InputCoinPredicateData: 524, "524": "InputCoinPredicateData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
     */
    InputCoinPredicateGasUsed: 525, "525": "InputCoinPredicateGasUsed",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
     */
    InputContractTxId: 544, "544": "InputContractTxId",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
     */
    InputContractOutputIndex: 545, "545": "InputContractOutputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
     */
    InputContractId: 549, "549": "InputContractId",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
     */
    InputMessageSender: 576, "576": "InputMessageSender",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
     */
    InputMessageRecipient: 577, "577": "InputMessageRecipient",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].amount`
     */
    InputMessageAmount: 578, "578": "InputMessageAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
     */
    InputMessageNonce: 579, "579": "InputMessageNonce",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
     */
    InputMessageWitnessIndex: 580, "580": "InputMessageWitnessIndex",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].dataLength`
     */
    InputMessageDataLength: 581, "581": "InputMessageDataLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
     */
    InputMessagePredicateLength: 582, "582": "InputMessagePredicateLength",
    /**
     * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
     */
    InputMessagePredicateDataLength: 583, "583": "InputMessagePredicateDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
     */
    InputMessageData: 584, "584": "InputMessageData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
     */
    InputMessagePredicate: 585, "585": "InputMessagePredicate",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
     */
    InputMessagePredicateData: 586, "586": "InputMessagePredicateData",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
     */
    InputMessagePredicateGasUsed: 587, "587": "InputMessagePredicateGasUsed",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].type`
     */
    OutputType: 768, "768": "OutputType",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
     */
    OutputCoinTo: 769, "769": "OutputCoinTo",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].amount`
     */
    OutputCoinAmount: 770, "770": "OutputCoinAmount",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
     */
    OutputCoinAssetId: 771, "771": "OutputCoinAssetId",
    /**
     * r" Set `$rA` to `tx.outputs[$rB].inputIndex`
     */
    OutputContractInputIndex: 772, "772": "OutputContractInputIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
     */
    OutputContractCreatedContractId: 775, "775": "OutputContractCreatedContractId",
    /**
     * r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
     */
    OutputContractCreatedStateRoot: 776, "776": "OutputContractCreatedStateRoot",
    /**
     * r" Set `$rA` to `tx.witnesses[$rB].dataLength`
     */
    WitnessDataLength: 1024, "1024": "WitnessDataLength",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
     */
    WitnessData: 1025, "1025": "WitnessData",
    /**
     * r" Set `$rA` to `tx.policyTypes`
     */
    PolicyTypes: 1280, "1280": "PolicyTypes",
    /**
     * r" Set `$rA` to `tx.policies[0x00].gasPrice`
     */
    PolicyTip: 1281, "1281": "PolicyTip",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
     */
    PolicyWitnessLimit: 1282, "1282": "PolicyWitnessLimit",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
     */
    PolicyMaturity: 1283, "1283": "PolicyMaturity",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
     */
    PolicyMaxFee: 1284, "1284": "PolicyMaxFee",
    /**
     * r" Set `$rA` to `tx.policies[count_ones(0b11111 & tx.policyTypes) - 1].expiration`
     */
    PolicyExpiration: 1285, "1285": "PolicyExpiration",
    /**
     * r" Set `$rA` to `Memory address of tx.root`
     */
    UploadRoot: 1536, "1536": "UploadRoot",
    /**
     * r" Set `$rA` to `tx.witnessIndex`
     */
    UploadWitnessIndex: 1537, "1537": "UploadWitnessIndex",
    /**
     * r" Set `$rA` to `tx.subsectionIndex`
     */
    UploadSubsectionIndex: 1538, "1538": "UploadSubsectionIndex",
    /**
     * r" Set `$rA` to `tx.subsectionsNumber`
     */
    UploadSubsectionsCount: 1539, "1539": "UploadSubsectionsCount",
    /**
     * r" Set `$rA` to `tx.proofSetCount`
     */
    UploadProofSetCount: 1540, "1540": "UploadProofSetCount",
    /**
     * r" Set `$rA` to `Memory address of tx.proofSet[$rB]`
     */
    UploadProofSetAtIndex: 1541, "1541": "UploadProofSetAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.id`
     */
    BlobId: 1792, "1792": "BlobId",
    /**
     * r" Set `$rA` to `tx.witnessIndex`
     */
    BlobWitnessIndex: 1793, "1793": "BlobWitnessIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.purpose`
     */
    UpgradePurpose: 2048, "2048": "UpgradePurpose",
    /**
     * r" Set `$rA` to `tx.inputsCount`
     */
    TxInputsCount: 2304, "2304": "TxInputsCount",
    /**
     * r" Set `$rA` to `tx.outputsCount`
     */
    TxOutputsCount: 2305, "2305": "TxOutputsCount",
    /**
     * r" Set `$rA` to `tx.witnessesCount`
     */
    TxWitnessesCount: 2306, "2306": "TxWitnessesCount",
    /**
     * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
     */
    TxInputAtIndex: 2307, "2307": "TxInputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of t.outputs[$rB]`
     */
    TxOutputAtIndex: 2308, "2308": "TxOutputAtIndex",
    /**
     * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
     */
    TxWitnessAtIndex: 2309, "2309": "TxWitnessAtIndex",
});
/**
 * The operation performed by WDOP and WQOP instructions, determined as
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7}
 */
const MathOp = Object.freeze({
    /**
     * Add
     */
    ADD: 0, "0": "ADD",
    /**
     * Subtract
     */
    SUB: 1, "1": "SUB",
    /**
     * Invert bits (discards rhs)
     */
    NOT: 2, "2": "NOT",
    /**
     * Bitwise or
     */
    OR: 3, "3": "OR",
    /**
     * Bitwise exclusive or
     */
    XOR: 4, "4": "XOR",
    /**
     * Bitwise and
     */
    AND: 5, "5": "AND",
    /**
     * Shift left
     */
    SHL: 6, "6": "SHL",
    /**
     * Shift right
     */
    SHR: 7, "7": "SHR",
});
/**
 * The operation performed by the NIOP instruction.
 * @enum {0 | 1 | 2 | 3 | 4 | 5}
 */
const NarrowMathOp = Object.freeze({
    /**
     * Add
     */
    ADD: 0, "0": "ADD",
    /**
     * Subtract
     */
    SUB: 1, "1": "SUB",
    /**
     * Multiply
     */
    MUL: 2, "2": "MUL",
    /**
     * Exponentiate
     */
    EXP: 3, "3": "EXP",
    /**
     * Bit shift left
     */
    SLL: 4, "4": "SLL",
    /**
     * XNOR
     */
    XNOR: 5, "5": "XNOR",
});
/**
 * Operation width
 * @enum {0 | 1 | 2}
 */
const OpWidth = Object.freeze({
    /**
     * 8-bit
     */
    U8: 0, "0": "U8",
    /**
     * 16-bit
     */
    U16: 1, "1": "U16",
    /**
     * 32-bit
     */
    U32: 2, "2": "U32",
});
/**
 * r" Panic reason representation for the interpreter.
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64}
 */
const PanicReason = Object.freeze({
    /**
     * r" The byte can't be mapped to any known `PanicReason`.
     */
    UnknownPanicReason: 0, "0": "UnknownPanicReason",
    /**
     * r" Found `RVRT` instruction.
     */
    Revert: 1, "1": "Revert",
    /**
     * r" Execution ran out of gas.
     */
    OutOfGas: 2, "2": "OutOfGas",
    /**
     * r" The transaction validity is violated.
     */
    TransactionValidity: 3, "3": "TransactionValidity",
    /**
     * r" Attempt to write outside interpreter memory boundaries.
     */
    MemoryOverflow: 4, "4": "MemoryOverflow",
    /**
     * r" Overflow while executing arithmetic operation.
     * r" These errors are ignored using the WRAPPING flag.
     */
    ArithmeticOverflow: 5, "5": "ArithmeticOverflow",
    /**
     * r" Designed contract was not found in the storage.
     */
    ContractNotFound: 6, "6": "ContractNotFound",
    /**
     * r" Memory ownership rules are violated.
     */
    MemoryOwnership: 7, "7": "MemoryOwnership",
    /**
     * r" The asset ID balance isn't enough for the instruction.
     */
    NotEnoughBalance: 8, "8": "NotEnoughBalance",
    /**
     * r" The interpreter is expected to be in internal context.
     */
    ExpectedInternalContext: 9, "9": "ExpectedInternalContext",
    /**
     * r" The queried asset ID was not found in the state.
     */
    AssetIdNotFound: 10, "10": "AssetIdNotFound",
    /**
     * r" The provided input is not found in the transaction.
     */
    InputNotFound: 11, "11": "InputNotFound",
    /**
     * r" The provided output is not found in the transaction.
     */
    OutputNotFound: 12, "12": "OutputNotFound",
    /**
     * r" The provided witness is not found in the transaction.
     */
    WitnessNotFound: 13, "13": "WitnessNotFound",
    /**
     * r" The transaction maturity is not valid for this request.
     */
    TransactionMaturity: 14, "14": "TransactionMaturity",
    /**
     * r" The metadata identifier is invalid.
     */
    InvalidMetadataIdentifier: 15, "15": "InvalidMetadataIdentifier",
    /**
     * r" The call structure is not valid.
     */
    MalformedCallStructure: 16, "16": "MalformedCallStructure",
    /**
     * r" The provided register does not allow write operations.
     */
    ReservedRegisterNotWritable: 17, "17": "ReservedRegisterNotWritable",
    /**
     * r" The execution resulted in an erroneous state of the interpreter.
     */
    InvalidFlags: 18, "18": "InvalidFlags",
    /**
     * r" The provided immediate value is not valid for this instruction.
     */
    InvalidImmediateValue: 19, "19": "InvalidImmediateValue",
    /**
     * r" The provided transaction input is not of type `Coin`.
     */
    ExpectedCoinInput: 20, "20": "ExpectedCoinInput",
    /**
     * r" `ECAL` instruction failed.
     */
    EcalError: 21, "21": "EcalError",
    /**
     * r" Two segments of the interpreter memory should not intersect for write operations.
     */
    MemoryWriteOverlap: 22, "22": "MemoryWriteOverlap",
    /**
     * r" The requested contract is not listed in the transaction inputs.
     */
    ContractNotInInputs: 23, "23": "ContractNotInInputs",
    /**
     * r" The internal asset ID balance overflowed with the provided instruction.
     */
    InternalBalanceOverflow: 24, "24": "InternalBalanceOverflow",
    /**
     * r" The maximum allowed contract size is violated.
     */
    ContractMaxSize: 25, "25": "ContractMaxSize",
    /**
     * r" This instruction expects the stack area to be unallocated for this call.
     */
    ExpectedUnallocatedStack: 26, "26": "ExpectedUnallocatedStack",
    /**
     * r" The maximum allowed number of static contracts was reached for this transaction.
     */
    MaxStaticContractsReached: 27, "27": "MaxStaticContractsReached",
    /**
     * r" The requested transfer amount cannot be zero.
     */
    TransferAmountCannotBeZero: 28, "28": "TransferAmountCannotBeZero",
    /**
     * r" The provided transaction output should be of type `Variable`.
     */
    ExpectedOutputVariable: 29, "29": "ExpectedOutputVariable",
    /**
     * r" The expected context of the stack parent is internal.
     */
    ExpectedParentInternalContext: 30, "30": "ExpectedParentInternalContext",
    /**
     * r" The predicate returned non `1`. The `1` means successful verification
     * r" of the predicate, all other values means unsuccessful.
     */
    PredicateReturnedNonOne: 31, "31": "PredicateReturnedNonOne",
    /**
     * r" The contract ID is already deployed and can't be overwritten.
     */
    ContractIdAlreadyDeployed: 32, "32": "ContractIdAlreadyDeployed",
    /**
     * r" The loaded contract mismatch expectations.
     */
    ContractMismatch: 33, "33": "ContractMismatch",
    /**
     * r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
     */
    MessageDataTooLong: 34, "34": "MessageDataTooLong",
    /**
     * r" Mathematically invalid arguments where given to an arithmetic instruction.
     * r" For instance, division by zero produces this.
     * r" These errors are ignored using the UNSAFEMATH flag.
     */
    ArithmeticError: 35, "35": "ArithmeticError",
    /**
     * r" The contract instruction is not allowed in predicates.
     */
    ContractInstructionNotAllowed: 36, "36": "ContractInstructionNotAllowed",
    /**
     * r" Transfer of zero coins is not allowed.
     */
    TransferZeroCoins: 37, "37": "TransferZeroCoins",
    /**
     * r" Attempted to execute an invalid instruction
     */
    InvalidInstruction: 38, "38": "InvalidInstruction",
    /**
     * r" Memory outside $is..$ssp range is not executable
     */
    MemoryNotExecutable: 39, "39": "MemoryNotExecutable",
    /**
     * r" The policy is not set.
     */
    PolicyIsNotSet: 40, "40": "PolicyIsNotSet",
    /**
     * r" The policy is not found across policies.
     */
    PolicyNotFound: 41, "41": "PolicyNotFound",
    /**
     * r" Receipt context is full
     */
    TooManyReceipts: 42, "42": "TooManyReceipts",
    /**
     * r" Balance of a contract overflowed
     */
    BalanceOverflow: 43, "43": "BalanceOverflow",
    /**
     * r" Block height value is invalid, typically because it is too large
     */
    InvalidBlockHeight: 44, "44": "InvalidBlockHeight",
    /**
     * r" Attempt to use sequential memory instructions with too large slot count,
     * r" typically because it cannot fit into usize
     */
    TooManySlots: 45, "45": "TooManySlots",
    /**
     * r" Caller of this internal context is also expected to be internal,
     * r" i.e. $fp->$fp must be non-zero.
     */
    ExpectedNestedCaller: 46, "46": "ExpectedNestedCaller",
    /**
     * r" During memory growth, the stack overlapped with the heap
     */
    MemoryGrowthOverlap: 47, "47": "MemoryGrowthOverlap",
    /**
     * r" Attempting to read or write uninitialized memory.
     * r" Also occurs when boundary crosses from stack to heap.
     */
    UninitalizedMemoryAccess: 48, "48": "UninitalizedMemoryAccess",
    /**
     * r" Overriding consensus parameters is not allowed.
     */
    OverridingConsensusParameters: 49, "49": "OverridingConsensusParameters",
    /**
     * r" The storage doesn't know about the hash of the state transition bytecode.
     */
    UnknownStateTransactionBytecodeRoot: 50, "50": "UnknownStateTransactionBytecodeRoot",
    /**
     * r" Overriding the state transition bytecode is not allowed.
     */
    OverridingStateTransactionBytecode: 51, "51": "OverridingStateTransactionBytecode",
    /**
     * r" The bytecode is already uploaded and cannot be uploaded again.
     */
    BytecodeAlreadyUploaded: 52, "52": "BytecodeAlreadyUploaded",
    /**
     * r" The part of the bytecode is not sequentially connected to the previous parts.
     */
    ThePartIsNotSequentiallyConnected: 53, "53": "ThePartIsNotSequentiallyConnected",
    /**
     * r" The requested blob is not found.
     */
    BlobNotFound: 54, "54": "BlobNotFound",
    /**
     * r" The blob was already
     */
    BlobIdAlreadyUploaded: 55, "55": "BlobIdAlreadyUploaded",
    /**
     * r" Active gas costs do not define the cost for this instruction.
     */
    GasCostNotDefined: 56, "56": "GasCostNotDefined",
    /**
     * r" The curve id is not supported.
     */
    UnsupportedCurveId: 57, "57": "UnsupportedCurveId",
    /**
     * r" The operation type is not supported.
     */
    UnsupportedOperationType: 58, "58": "UnsupportedOperationType",
    /**
     * r" Read alt_bn_128 curve point is invalid.
     */
    InvalidEllipticCurvePoint: 59, "59": "InvalidEllipticCurvePoint",
    /**
     * r" Given input contract does not exist.
     */
    InputContractDoesNotExist: 60, "60": "InputContractDoesNotExist",
    /**
     * r" Storage slot in Create not found
     */
    StorageSlotsNotFound: 61, "61": "StorageSlotsNotFound",
    /**
     * r" Proof in Upload not found
     */
    ProofInUploadNotFound: 62, "62": "ProofInUploadNotFound",
    /**
     * r" Invalid purpose type in Upgrade
     */
    InvalidUpgradePurposeType: 63, "63": "InvalidUpgradePurposeType",
    /**
     * r" Cannot get gas price in predicate
     */
    CanNotGetGasPriceInPredicate: 64, "64": "CanNotGetGasPriceInPredicate",
});

const ADDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_add_free(ptr >>> 0, 1));
/**
 * Adds two registers.
 */
class ADD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ADDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_addi_free(ptr >>> 0, 1));
/**
 * Adds a register and an immediate value.
 */
class ADDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const ALOCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_aloc_free(ptr >>> 0, 1));
/**
 * Allocate a number of bytes from the heap.
 */
class ALOC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ALOCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} bytes
     */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        ALOCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_and_free(ptr >>> 0, 1));
/**
 * Bitwise ANDs two registers.
 */
class AND {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_andi_free(ptr >>> 0, 1));
/**
 * Bitwise ANDs a register and an immediate value.
 */
class ANDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const BALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bal_free(ptr >>> 0, 1));
/**
 * Get the balance of contract of an asset ID.
 */
class BAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} asset_id_addr
     * @param {RegId} contract_id_addr
     */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        BALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhei_free(ptr >>> 0, 1));
/**
 * Get current block height.
 */
class BHEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        BHEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHSHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhsh_free(ptr >>> 0, 1));
/**
 * Get block header hash for height.
 */
class BHSH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHSHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} heigth
     */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BHSHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BLDDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bldd_free(ptr >>> 0, 1));
/**
 * Load blob as data
 */
class BLDD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BLDDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bldd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_ptr
     * @param {RegId} blob_id_ptr
     * @param {RegId} offset
     * @param {RegId} len
     */
    constructor(dst_ptr, blob_id_ptr, offset, len) {
        _assertClass(dst_ptr, RegId);
        var ptr0 = dst_ptr.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        BLDDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bsiz_free(ptr >>> 0, 1));
/**
 * Get blob size
 */
class BSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bsiz_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} blob_id_ptr
     */
    constructor(dst, blob_id_ptr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BURNFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_burn_free(ptr >>> 0, 1));
/**
 * Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
 */
class BURN {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BURNFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     * @param {RegId} sub_id_addr
     */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BURNFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CALLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_call_free(ptr >>> 0, 1));
/**
 * Call a contract.
 */
class CALL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CALLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} target_struct
     * @param {RegId} fwd_coins
     * @param {RegId} asset_id_addr
     * @param {RegId} fwd_gas
     */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CALLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cb_free(ptr >>> 0, 1));
/**
 * Get current block proposer's address.
 */
class CB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ccp_free(ptr >>> 0, 1));
/**
 * Copy contract code for a contract.
 */
class CCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} contract_id_addr
     * @param {RegId} offset
     * @param {RegId} len
     */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfe_free(ptr >>> 0, 1));
/**
 * Extend the current call frame's stack
 */
class CFE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfei_free(ptr >>> 0, 1));
/**
 * Extend the current call frame's stack by an immediate value.
 */
class CFEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} amount
     */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CFSFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfs_free(ptr >>> 0, 1));
/**
 * Shrink the current call frame's stack
 */
class CFS {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFSIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfsi_free(ptr >>> 0, 1));
/**
 * Shrink the current call frame's stack by an immediate value.
 */
class CFSI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} amount
     */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_croo_free(ptr >>> 0, 1));
/**
 * Get code root of a contract.
 */
class CROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} contract_id_addr
     */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_csiz_free(ptr >>> 0, 1));
/**
 * Get code size of a contract.
 */
class CSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} contract_id_addr
     */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CompareArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compareargs_free(ptr >>> 0, 1));
/**
 * Arguments for WDCM and WQCM instructions.
 */
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;
        CompareArgsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompareArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr, 0);
    }
    /**
     * Comparison mode
     * @returns {CompareMode}
     */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret;
    }
    /**
     * Comparison mode
     * @param {CompareMode} arg0
     */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
     * Convert to immediate value.
     * @returns {Imm06}
     */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
     * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
     * @param {Imm06} bits
     * @returns {CompareArgs | undefined}
     */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}

const DIVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_div_free(ptr >>> 0, 1));
/**
 * Divides two registers.
 */
class DIV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const DIVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divi_free(ptr >>> 0, 1));
/**
 * Divides a register and an immediate value.
 */
class DIVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const DivArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WMDV and WDDV instructions.
 */
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DivArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr, 0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const ECALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecal_free(ptr >>> 0, 1));
/**
 * Call external function
 */
class ECAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecal_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} c
     * @param {RegId} d
     */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ECALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECK1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eck1_free(ptr >>> 0, 1));
/**
 * The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 */
class ECK1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECK1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_hash_addr
     */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECK1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecop_free(ptr >>> 0, 1));
/**
 * Given some curve, performs an operation on points
 */
class ECOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecop_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} curve_id
     * @param {RegId} operation_type
     * @param {RegId} points_ptr
     */
    constructor(dst, curve_id, operation_type, points_ptr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(curve_id, RegId);
        var ptr1 = curve_id.__destroy_into_raw();
        _assertClass(operation_type, RegId);
        var ptr2 = operation_type.__destroy_into_raw();
        _assertClass(points_ptr, RegId);
        var ptr3 = points_ptr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ECOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECR1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecr1_free(ptr >>> 0, 1));
/**
 * The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
 */
class ECR1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECR1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_hash_addr
     */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECR1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ED19Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ed19_free(ptr >>> 0, 1));
/**
 * Verify ED25519 public key and signature match a message.
 */
class ED19 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ED19Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} pub_key_addr
     * @param {RegId} sig_addr
     * @param {RegId} msg_addr
     * @param {RegId} msg_len
     */
    constructor(pub_key_addr, sig_addr, msg_addr, msg_len) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_addr, RegId);
        var ptr2 = msg_addr.__destroy_into_raw();
        _assertClass(msg_len, RegId);
        var ptr3 = msg_len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ED19Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EPARFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_epar_free(ptr >>> 0, 1));
/**
 * Given some curve, performs a pairing on groups of points
 */
class EPAR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EPARFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_epar_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} success
     * @param {RegId} curve_id
     * @param {RegId} number_elements
     * @param {RegId} points_ptr
     */
    constructor(success, curve_id, number_elements, points_ptr) {
        _assertClass(success, RegId);
        var ptr0 = success.__destroy_into_raw();
        _assertClass(curve_id, RegId);
        var ptr1 = curve_id.__destroy_into_raw();
        _assertClass(number_elements, RegId);
        var ptr2 = number_elements.__destroy_into_raw();
        _assertClass(points_ptr, RegId);
        var ptr3 = points_ptr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        EPARFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eq_free(ptr >>> 0, 1));
/**
 * Compares two registers for equality.
 */
class EQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_exp_free(ptr >>> 0, 1));
/**
 * Raises one register to the power of another.
 */
class EXP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_expi_free(ptr >>> 0, 1));
/**
 * Raises one register to the power of an immediate value.
 */
class EXPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const FLAGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_flag_free(ptr >>> 0, 1));
/**
 * Set flag register to a register.
 */
class FLAG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FLAGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        FLAGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gm_free(ptr >>> 0, 1));
/**
 * Get metadata from memory.
 */
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;
        GMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr, 0);
    }
    /**
     * Construct a `GM` instruction from its arguments.
     * @param {RegId} ra
     * @param {GMArgs} args
     * @returns {GM}
     */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {Imm18} selector
     */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        GMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const GTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gt_free(ptr >>> 0, 1));
/**
 * Compares two registers for greater-than.
 */
class GT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GTFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gtf_free(ptr >>> 0, 1));
/**
 * Get transaction fields.
 */
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;
        GTFFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr, 0);
    }
    /**
     * Construct a `GTF` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {GTFArgs} args
     * @returns {GTF}
     */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} selector
     */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.gtf_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const Imm06Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm06_free(ptr >>> 0, 1));
/**
 * Represents a 6-bit immediate value, guaranteed to be masked by construction.
 */
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;
        Imm06Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm06Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr, 0);
    }
}

const Imm12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm12_free(ptr >>> 0, 1));
/**
 * Represents a 12-bit immediate value, guaranteed to be masked by construction.
 */
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;
        Imm12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr, 0);
    }
}

const Imm18Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm18_free(ptr >>> 0, 1));
/**
 * Represents a 18-bit immediate value, guaranteed to be masked by construction.
 */
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;
        Imm18Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm18Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr, 0);
    }
}

const Imm24Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm24_free(ptr >>> 0, 1));
/**
 * Represents a 24-bit immediate value, guaranteed to be masked by construction.
 */
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;
        Imm24Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm24Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr, 0);
    }
}

const InstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_instruction_free(ptr >>> 0, 1));
/**
 * Representation of a single instruction for the interpreter.
 *
 * The opcode is represented in the tag (variant), or may be retrieved in the
 * form of an `Opcode` byte using the `opcode` method.
 *
 * The register and immediate data associated with the instruction is represented
 * within an inner unit type wrapper around the 3 remaining bytes.
 */
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;
        InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr, 0);
    }
    /**
     * Convenience method for converting to bytes
     * @returns {Uint8Array}
     */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
     * Size of an instruction in bytes
     * @returns {number}
     */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}

const JALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jal_free(ptr >>> 0, 1));
/**
 * Store return address and jump to an absolute address.
 */
class JAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jal_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} ret_addr
     * @param {RegId} target
     * @param {Imm12} offset
     */
    constructor(ret_addr, target, offset) {
        _assertClass(ret_addr, RegId);
        var ptr0 = ret_addr.__destroy_into_raw();
        _assertClass(target, RegId);
        var ptr1 = target.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ji_free(ptr >>> 0, 1));
/**
 * Jump.
 */
class JI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} abs_target
     */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const JMPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmp_free(ptr >>> 0, 1));
/**
 * Dynamic jump.
 */
class JMP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} abs_target
     */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JMPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JMPBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpb_free(ptr >>> 0, 1));
/**
 * Unconditional dynamic relative jump backwards, with a constant offset.
 */
class JMPB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dynamic
     * @param {Imm18} fixed
     */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JMPFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpf_free(ptr >>> 0, 1));
/**
 * Unconditional dynamic relative jump forwards, with a constant offset.
 */
class JMPF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dynamic
     * @param {Imm18} fixed
     */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JNEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jne_free(ptr >>> 0, 1));
/**
 * Conditional dynamic jump.
 */
class JNE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} abs_target
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JNEBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jneb_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
 */
class JNEB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {RegId} dynamic
     * @param {Imm06} fixed
     */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnef_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
 */
class JNEF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {RegId} dynamic
     * @param {Imm06} fixed
     */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnei_free(ptr >>> 0, 1));
/**
 * Conditional jump.
 */
class JNEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_lhs
     * @param {RegId} cond_rhs
     * @param {Imm12} abs_target
     */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzb_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump backwards, conditional against zero, with a constant offset.
 */
class JNZB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {RegId} dynamic
     * @param {Imm12} fixed
     */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzf_free(ptr >>> 0, 1));
/**
 * Dynamic relative jump forwards, conditional against zero, with a constant offset.
 */
class JNZF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {RegId} dynamic
     * @param {Imm12} fixed
     */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzi_free(ptr >>> 0, 1));
/**
 * Conditional jump against zero.
 */
class JNZI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} cond_nz
     * @param {Imm18} abs_target
     */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JNZIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const K256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_k256_free(ptr >>> 0, 1));
/**
 * The keccak-256 hash of a slice.
 */
class K256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        K256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        K256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lb_free(ptr >>> 0, 1));
/**
 * A byte is loaded from the specified address offset by an immediate value.
 */
class LB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} addr
     * @param {Imm12} offset
     */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LDCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ldc_free(ptr >>> 0, 1));
/**
 * Load code as executable either from contract, blob, or memory.
 */
class LDC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LDCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} src_addr
     * @param {RegId} offset
     * @param {RegId} len
     * @param {Imm06} mode
     */
    constructor(src_addr, offset, len, mode) {
        _assertClass(src_addr, RegId);
        var ptr0 = src_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        _assertClass(mode, Imm06);
        var ptr3 = mode.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LDCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const LHWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lhw_free(ptr >>> 0, 1));
/**
 * Load halfword (u32).
 */
class LHW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LHWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lhw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} offset
     */
    constructor(dst, arg, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LHWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_log_free(ptr >>> 0, 1));
/**
 * Log an event.
 */
class LOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} c
     * @param {RegId} d
     */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LOGDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_logd_free(ptr >>> 0, 1));
/**
 * Log data.
 */
class LOGD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} a
     * @param {RegId} b
     * @param {RegId} addr
     * @param {RegId} len
     */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LQWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lqw_free(ptr >>> 0, 1));
/**
 * Load quarterword (u16).
 */
class LQW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LQWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lqw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} offset
     */
    constructor(dst, arg, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LQWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lt_free(ptr >>> 0, 1));
/**
 * Compares two registers for less-than.
 */
class LT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lw_free(ptr >>> 0, 1));
/**
 * A word is loaded from the specified address offset by an immediate value.
 */
class LW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} addr
     * @param {Imm12} offset
     */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MCLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcl_free(ptr >>> 0, 1));
/**
 * Clear a variable number of bytes in memory.
 */
class MCL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} len
     */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcli_free(ptr >>> 0, 1));
/**
 * Clear an immediate number of bytes in memory.
 */
class MCLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {Imm18} count
     */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcp_free(ptr >>> 0, 1));
/**
 * Copy a variable number of bytes in memory.
 */
class MCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcpi_free(ptr >>> 0, 1));
/**
 * Copy an immediate number of bytes in memory.
 */
class MCPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {Imm12} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MEQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_meq_free(ptr >>> 0, 1));
/**
 * Compare bytes in memory.
 */
class MEQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MEQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} result
     * @param {RegId} lhs_addr
     * @param {RegId} rhs_addr
     * @param {RegId} len
     */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MEQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MINTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mint_free(ptr >>> 0, 1));
/**
 * Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
 */
class MINT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MINTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} amount
     * @param {RegId} sub_id_addr
     */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MINTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mldv_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide with arbitrary precision intermediate step.
 */
class MLDV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MLDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mlog_free(ptr >>> 0, 1));
/**
 * The integer logarithm of a register.
 */
class MLOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MLOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mod_free(ptr >>> 0, 1));
/**
 * Modulo remainder of two registers.
 */
class MOD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_modi_free(ptr >>> 0, 1));
/**
 * Modulo remainder of a register and an immediate value.
 */
class MODI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MOVEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_move_free(ptr >>> 0, 1));
/**
 * Copy from one register to another.
 */
class MOVE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} src
     */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MOVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_movi_free(ptr >>> 0, 1));
/**
 * Copy immediate value into a register
 */
class MOVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {Imm18} val
     */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 18-bit immediate value.
     * @returns {Imm18}
     */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mroo_free(ptr >>> 0, 1));
/**
 * The integer root of a register.
 */
class MROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mul_free(ptr >>> 0, 1));
/**
 * Multiplies two registers.
 */
class MUL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_muli_free(ptr >>> 0, 1));
/**
 * Multiplies a register and an immediate value.
 */
class MULI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MathArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mathargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WDOP and WQOP instructions.
 */
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MathArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr, 0);
    }
    /**
     * Create a new `MathArgs` instance from operation and width.
     * @param {NarrowMathOp} op
     * @param {OpWidth} width
     */
    constructor(op, width) {
        const ret = wasm$1.mathargs_new(op, width);
        return NarrowMathArgs.__wrap(ret);
    }
    /**
     * The operation to perform
     * @returns {MathOp}
     */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
     * The operation to perform
     * @param {MathOp} arg0
     */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const MulArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mulargs_free(ptr >>> 0, 1));
/**
 * Additional arguments for WDML and WQML instructions.
 */
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MulArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr, 0);
    }
    /**
     * Load LHSS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load LHSS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @returns {boolean}
     */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Load RHS from register if true, otherwise zero-extend register value
     * @param {boolean} arg0
     */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const NIOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_niop_free(ptr >>> 0, 1));
/**
 * Narrow-integer arithmetic operation.
 */
class NIOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NIOP.prototype);
        obj.__wbg_ptr = ptr;
        NIOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NIOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_niop_free(ptr, 0);
    }
    /**
     * Construct a `NIOP` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {NarrowMathArgs} args
     * @returns {NIOP}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, NarrowMathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.niop_from_args(ptr0, ptr1, ptr2, ptr3);
        return NIOP.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        NIOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const NOOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_noop_free(ptr >>> 0, 1));
/**
 * Performs no operation.
 */
class NOOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr, 0);
    }
    /**
     * Construct the instruction.
     */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        this.__wbg_ptr = ret >>> 0;
        NOOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
}

const NOTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_not_free(ptr >>> 0, 1));
/**
 * Bitwise NOT a register.
 */
class NOT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        NOTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const NarrowMathArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_narrowmathargs_free(ptr >>> 0, 1));
/**
 * Immediate value arguments for the NIOP instruction
 */
class NarrowMathArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NarrowMathArgs.prototype);
        obj.__wbg_ptr = ptr;
        NarrowMathArgsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NarrowMathArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_narrowmathargs_free(ptr, 0);
    }
    /**
     * The operation to perform
     * @returns {NarrowMathOp}
     */
    get op() {
        const ret = wasm$1.__wbg_get_narrowmathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
     * The operation to perform
     * @param {NarrowMathOp} arg0
     */
    set op(arg0) {
        wasm$1.__wbg_set_narrowmathargs_op(this.__wbg_ptr, arg0);
    }
    /**
     * Width of the operation
     * @returns {OpWidth}
     */
    get width() {
        const ret = wasm$1.__wbg_get_narrowmathargs_width(this.__wbg_ptr);
        return ret;
    }
    /**
     * Width of the operation
     * @param {OpWidth} arg0
     */
    set width(arg0) {
        wasm$1.__wbg_set_narrowmathargs_width(this.__wbg_ptr, arg0);
    }
}

const ORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_or_free(ptr >>> 0, 1));
/**
 * Bitwise ORs two registers.
 */
class OR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ori_free(ptr >>> 0, 1));
/**
 * Bitwise ORs a register and an immediate value.
 */
class ORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const POPHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_poph_free(ptr >>> 0, 1));
/**
 * Pop a bitmask-selected set of registers in range 40..64 to the stack.
 */
class POPH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const POPLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_popl_free(ptr >>> 0, 1));
/**
 * Pop a bitmask-selected set of registers in range 16..40 to the stack.
 */
class POPL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshh_free(ptr >>> 0, 1));
/**
 * Push a bitmask-selected set of registers in range 40..64 to the stack.
 */
class PSHH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshl_free(ptr >>> 0, 1));
/**
 * Push a bitmask-selected set of registers in range 16..40 to the stack.
 */
class PSHL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {Imm24} bitmask
     */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the 24-bit immediate value.
     * @returns {Imm24}
     */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PanicInstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_panicinstruction_free(ptr >>> 0, 1));
/**
 * Describe a panic reason with the instruction that generated it
 */
class PanicInstruction {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PanicInstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr, 0);
    }
    /**
     * Represents an error described by a reason and an instruction.
     * @param {PanicReason} reason
     * @param {number} instruction
     */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        this.__wbg_ptr = ret >>> 0;
        PanicInstructionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Underlying panic reason
     * @returns {PanicReason}
     */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret;
    }
    /**
     * Underlying instruction
     * @returns {number}
     */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const RETFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ret_free(ptr >>> 0, 1));
/**
 * Return from context.
 */
class RET {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RETFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RETDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_retd_free(ptr >>> 0, 1));
/**
 * Return from context with data.
 */
class RETD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} len
     */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        RETDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RVRTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_rvrt_free(ptr >>> 0, 1));
/**
 * Halt execution, reverting state changes and returning a value.
 */
class RVRT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RVRTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} value
     */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RVRTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RegIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_regid_free(ptr >>> 0, 1));
/**
 * Represents a 6-bit register ID, guaranteed to be masked by construction.
 */
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;
        RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr, 0);
    }
    /**
     * Construct a register ID from the given value.
     *
     * Returns `None` if the value is outside the 6-bit value range.
     * @param {number} u
     * @returns {RegId | undefined}
     */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
     * Received balance for this context.
     * @returns {RegId}
     */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
     * Remaining gas in the context.
     * @returns {RegId}
     */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
     * Error codes for particular operations.
     * @returns {RegId}
     */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
     * Flags register.
     * @returns {RegId}
     */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
     * Frame pointer. Memory address of beginning of current call frame.
     * @returns {RegId}
     */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
     * Remaining gas globally.
     * @returns {RegId}
     */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
     * Heap pointer. Memory address below the current bottom of the heap (points to free
     * memory).
     * @returns {RegId}
     */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
     * Instructions start. Pointer to the start of the currently-executing code.
     * @returns {RegId}
     */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
     * Contains overflow/underflow of addition, subtraction, and multiplication.
     * @returns {RegId}
     */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
     * Contains one (1), for convenience.
     * @returns {RegId}
     */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
     * The program counter. Memory address of the current instruction.
     * @returns {RegId}
     */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
     * Return value or pointer.
     * @returns {RegId}
     */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
     * Return value length in bytes.
     * @returns {RegId}
     */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
     * Stack pointer. Memory address on top of current writable stack area (points to
     * free memory).
     * @returns {RegId}
     */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
     * Stack start pointer. Memory address of bottom of current writable stack area.
     * @returns {RegId}
     */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
     * Smallest writable register.
     * @returns {RegId}
     */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
     * Contains zero (0), for convenience.
     * @returns {RegId}
     */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
     * Construct a register ID from the given value.
     *
     * The given value will be masked to 6 bits.
     * @param {number} u
     */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        this.__wbg_ptr = ret >>> 0;
        RegIdFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * A const alternative to the `Into<u8>` implementation.
     * @returns {number}
     */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}

const S256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_s256_free(ptr >>> 0, 1));
/**
 * The SHA-2-256 hash of a slice.
 */
class S256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        S256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} src_addr
     * @param {RegId} len
     */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        S256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sb_free(ptr >>> 0, 1));
/**
 * Write the least significant byte of a register to memory.
 */
class SB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} value
     * @param {Imm12} offset
     */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SCWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_scwq_free(ptr >>> 0, 1));
/**
 * Clear a series of slots from contract storage.
 */
class SCWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SCWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} lenq
     */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SCWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SHWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shw_free(ptr >>> 0, 1));
/**
 * Store halfword (u32).
 */
class SHW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SHWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} offset
     */
    constructor(dst, arg, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SHWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SLLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sll_free(ptr >>> 0, 1));
/**
 * Left shifts a register by a register.
 */
class SLL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_slli_free(ptr >>> 0, 1));
/**
 * Left shifts a register by an immediate value.
 */
class SLLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SMOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_smo_free(ptr >>> 0, 1));
/**
 * Send a message to recipient address with call abi, coins, and output.
 */
class SMO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SMOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} recipient_addr
     * @param {RegId} data_addr
     * @param {RegId} data_len
     * @param {RegId} coins
     */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SMOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SQWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sqw_free(ptr >>> 0, 1));
/**
 * Store quarterword (u16).
 */
class SQW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SQWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sqw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} arg
     * @param {Imm12} offset
     */
    constructor(dst, arg, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SQWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SRLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srl_free(ptr >>> 0, 1));
/**
 * Right shifts a register by a register.
 */
class SRL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srli_free(ptr >>> 0, 1));
/**
 * Right shifts a register by an immediate value.
 */
class SRLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SRWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srw_free(ptr >>> 0, 1));
/**
 * Load a word from contract storage.
 */
class SRW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} status
     * @param {RegId} key_addr
     */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srwq_free(ptr >>> 0, 1));
/**
 * Load a series of 32 byte slots from contract storage.
 */
class SRWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst_addr
     * @param {RegId} status
     * @param {RegId} key_addr
     * @param {RegId} lenq
     */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SRWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sub_free(ptr >>> 0, 1));
/**
 * Subtracts two registers.
 */
class SUB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_subi_free(ptr >>> 0, 1));
/**
 * Subtracts a register and an immediate value.
 */
class SUBI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sw_free(ptr >>> 0, 1));
/**
 * Write a register to memory.
 */
class SW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} addr
     * @param {RegId} value
     * @param {Imm12} offset
     */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sww_free(ptr >>> 0, 1));
/**
 * Store a word in contract storage.
 */
class SWW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} value
     */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SWWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_swwq_free(ptr >>> 0, 1));
/**
 * Store a series of 32 byte slots in contract storage.
 */
class SWWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} key_addr
     * @param {RegId} status
     * @param {RegId} src_addr
     * @param {RegId} lenq
     */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SWWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TIMEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_time_free(ptr >>> 0, 1));
/**
 * Get timestamp of block at given height.
 */
class TIME {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TIMEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} heigth
     */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        TIMEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TRFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tr_free(ptr >>> 0, 1));
/**
 * Transfer coins to a contract unconditionally.
 */
class TR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TRFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} contract_id_addr
     * @param {RegId} amount
     * @param {RegId} asset_id_addr
     */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        TRFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TROFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tro_free(ptr >>> 0, 1));
/**
 * Transfer coins to a variable output.
 */
class TRO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TROFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} contract_id_addr
     * @param {RegId} output_index
     * @param {RegId} amount
     * @param {RegId} asset_id_addr
     */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        TROFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdam_free(ptr >>> 0, 1));
/**
 * AddMod 128bit
 */
class WDAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} add_lhs
     * @param {RegId} add_rhs
     * @param {RegId} modulo
     */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdcm_free(ptr >>> 0, 1));
/**
 * Compare 128bit integers
 */
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;
        WDCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr, 0);
    }
    /**
     * Construct a `WDCM` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {CompareArgs} args
     * @returns {WDCM}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wddv_free(ptr >>> 0, 1));
/**
 * Divide 128bit
 */
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;
        WDDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr, 0);
    }
    /**
     * Construct a `WDDV` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {DivArgs} args
     * @returns {WDDV}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmd_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide 128bit
 */
class WDMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdml_free(ptr >>> 0, 1));
/**
 * Multiply 128bit
 */
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;
        WDMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr, 0);
    }
    /**
     * Construct a `WDML` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MulArgs} args
     * @returns {WDML}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmm_free(ptr >>> 0, 1));
/**
 * MulMod 128bit
 */
class WDMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} modulo
     */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdop_free(ptr >>> 0, 1));
/**
 * Simple 128bit operations
 */
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;
        WDOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr, 0);
    }
    /**
     * Construct a `WDOP` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MathArgs} args
     * @returns {WDOP}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqam_free(ptr >>> 0, 1));
/**
 * AddMod 256bit
 */
class WQAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} add_lhs
     * @param {RegId} add_rhs
     * @param {RegId} modulo
     */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqcm_free(ptr >>> 0, 1));
/**
 * Compare 256bit integers
 */
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;
        WQCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr, 0);
    }
    /**
     * Construct a `WQCM` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {CompareArgs} args
     * @returns {WQCM}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqdv_free(ptr >>> 0, 1));
/**
 * Divide 256bit
 */
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;
        WQDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr, 0);
    }
    /**
     * Construct a `WQDV` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {DivArgs} args
     * @returns {WQDV}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmd_free(ptr >>> 0, 1));
/**
 * Fused multiply-divide 256bit
 */
class WQMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} divisor
     */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqml_free(ptr >>> 0, 1));
/**
 * Multiply 256bit
 */
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;
        WQMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr, 0);
    }
    /**
     * Construct a `WQML` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MulArgs} args
     * @returns {WQML}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmm_free(ptr >>> 0, 1));
/**
 * MulMod 256bit
 */
class WQMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} mul_lhs
     * @param {RegId} mul_rhs
     * @param {RegId} modulo
     */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register D.
     * @returns {RegId}
     */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqop_free(ptr >>> 0, 1));
/**
 * Simple 256bit operations
 */
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;
        WQOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr, 0);
    }
    /**
     * Construct a `WQOP` instruction from its arguments.
     * @param {RegId} ra
     * @param {RegId} rb
     * @param {RegId} rc
     * @param {MathArgs} args
     * @returns {WQOP}
     */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     * @param {Imm06} flags
     */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.niop_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 6-bit immediate value.
     * @returns {Imm06}
     */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const XORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xor_free(ptr >>> 0, 1));
/**
 * Bitwise XORs two registers.
 */
class XOR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {RegId} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register C.
     * @returns {RegId}
     */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const XORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xori_free(ptr >>> 0, 1));
/**
 * Bitwise XORs a register and an immediate value.
 */
class XORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr, 0);
    }
    /**
     * Construct the instruction from its parts.
     * @param {RegId} dst
     * @param {RegId} lhs
     * @param {Imm12} rhs
     */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Access the ID for register A.
     * @returns {RegId}
     */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the ID for register B.
     * @returns {RegId}
     */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
     * Access the 12-bit immediate value.
     * @returns {Imm12}
     */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;



    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module);
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');
        }
    }

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path);
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead');
        }
    }
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABQQtgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38Bf2ACf38AYAABf2AFf39/f38Bf2ABfwBgA39/fwBgBH9/f38AYAAAAhgBA3diZxBfX3diaW5kZ2VuX3Rocm93AAQDnAKaAgEDAQAEBAMEAwQDBAEBBAQEBAEJAQEBAQEDAQQEAQEEAgICAgICAgEBAQQDAgEBAQMDAwMDAwMDAQQEBAQEAAICAgMDAwMDAwMDAwMEBAADAQEEBAQDAgEAAAIEAQEEBAQEAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAQEBAQEBAQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcBAAEBAQMEAwYBBwcHAQEBAQEBBQEBAQEDAQEDAQYCAgYHBAQAAgAHAQgBAwEKBAEBBAcBBQQFBQUFBQUFBQUFBQUFBQUFBQUGBgYDAgIDAgYGAAAIAAQFAXABCAgFAwEAEQYJAX8BQYCAwAALB+NSigYGbWVtb3J5AgAZX193YmdfbmFycm93bWF0aGFyZ3NfZnJlZQA6G19fd2JnX2dldF9uYXJyb3dtYXRoYXJnc19vcABRG19fd2JnX3NldF9uYXJyb3dtYXRoYXJnc19vcABNHl9fd2JnX2dldF9uYXJyb3dtYXRoYXJnc193aWR0aABSHl9fd2JnX3NldF9uYXJyb3dtYXRoYXJnc193aWR0aABODG1hdGhhcmdzX25ldwBQFl9fd2JnX2NvbXBhcmVhcmdzX2ZyZWUAOxpfX3diZ19nZXRfY29tcGFyZWFyZ3NfbW9kZQBRGl9fd2JnX3NldF9jb21wYXJlYXJnc19tb2RlADwiX193YmdfZ2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwBSIl9fd2JnX3NldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMAVBJjb21wYXJlYXJnc190b19pbW0AWBRjb21wYXJlYXJnc19mcm9tX2ltbQAuFV9fd2JnX2dldF9tYXRoYXJnc19vcABRFV9fd2JnX3NldF9tYXRoYXJnc19vcAA9El9fd2JnX211bGFyZ3NfZnJlZQA+Hl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X3JocwBRHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwBVEl9fd2JnX2RpdmFyZ3NfZnJlZQBcHl9fd2JnX2dldF9kaXZhcmdzX2luZGlyZWN0X3JocwDSAR5fX3diZ19zZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAywEbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlABwhcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AFYXcGFuaWNpbnN0cnVjdGlvbl9yZWFzb24AXRxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAF4MZ21fZnJvbV9hcmdzAPABDWd0Zl9mcm9tX2FyZ3MA6QEHZ21fYXJncwDKAQhndGZfYXJncwCPAQ5uaW9wX2Zyb21fYXJncwBACW5pb3BfYXJncwAhDndkY21fZnJvbV9hcmdzAEEOd2RvcF9mcm9tX2FyZ3MAQQ53ZG1sX2Zyb21fYXJncwBCDndkZHZfZnJvbV9hcmdzAOMBCXdkY21fYXJncwAiCXdxY21fYXJncwAjCXdkb3BfYXJncwAkCXdxb3BfYXJncwAlCXdkbWxfYXJncwAmCXdxbWxfYXJncwAnCXdkZHZfYXJncwBjCXdxZHZfYXJncwBkEF9fd2JnX2ltbTA2X2ZyZWUAXxBfX3diZ19pbW0xMl9mcmVlAGAQX193YmdfaW1tMThfZnJlZQBhDl9fd2JnX2FkZF9mcmVlAB0PX193Ymdfbm9vcF9mcmVlABASYWRkX25ld190eXBlc2NyaXB0AFkGYWRkX3JhAC8GYWRkX3JiABcGYWRkX3JjAB4DYWRkAMYBA2FuZACQAQNkaXYAkQECZXEAkgEDZXhwAJMBAmd0AJQBAmx0AJUBBG1sb2cAlgEEbXJvbwCXAQRtb2RfAJgBBW1vdmVfAEMDbXVsAJkBA25vdABEAm9yAJoBA3NsbACbAQNzcmwAnAEDc3ViAJ0BA3hvcgCeAQRtbGR2AGUTbmlvcF9uZXdfdHlwZXNjcmlwdADkAQRuaW9wAGYDcmV0ANMBBHJldGQAMRNhbG9jX25ld190eXBlc2NyaXB0AIYBB2Fsb2NfcmEAKgRhbG9jANQBA21jbABFA21jcACfAQNtZXEAZxNiaHNoX25ld190eXBlc2NyaXB0ACwEYmhzaABGBGJoZWkA1QEEYnVybgBHBGNhbGwAaANjY3AAaQRjcm9vAEgEY3NpegBJAmNiANYBA2xkYwBqA2xvZwBrBGxvZ2QAbARtaW50ADIEcnZydADXAQRzY3dxAKABA3NydwChAQRzcndxAG0Dc3d3AKIBBHN3d3EAbgJ0cgCjAQN0cm8AbwRlY2sxAKQBBGVjcjEApQEEZWQxOQBwBGsyNTYApgEEczI1NgCnAQR0aW1lAEoTbm9vcF9uZXdfdHlwZXNjcmlwdADYAQRub29wAPkBBGZsYWcA2QEDYmFsAKgBA2ptcADaAQNqbmUAqQEDc21vAHETYWRkaV9uZXdfdHlwZXNjcmlwdABaCmFkZGlfaW1tMTIADQRhZGRpAKoBBGFuZGkAqwEEZGl2aQCsAQRleHBpAK0BBG1vZGkArgEEbXVsaQCvAQNvcmkAsAEEc2xsaQCxAQRzcmxpALIBBHN1YmkAswEEeG9yaQC0AQRqbmVpALUBAmxiALYBAmx3ALcBAnNiALgBAnN3ALkBBG1jcGkAugESZ3RmX25ld190eXBlc2NyaXB0AOsBA2d0ZgC7AQNscXcAvAEDbGh3AL0BA3NxdwC+AQNzaHcAvwEEbWNsaQAzEWdtX25ld190eXBlc2NyaXB0AEsIZ21faW1tMTgAEwJnbQA0BG1vdmkANQRqbnppADYEam1wZgA3E2ptcGJfbmV3X3R5cGVzY3JpcHQAGgRqbXBiADgEam56ZgDAAQRqbnpiAMEBBGpuZWYAcgpqbmViX2ltbTA2ADAEam5lYgBzAmppAIcBE2NmZWlfbmV3X3R5cGVzY3JpcHQAOQpjZmVpX2ltbTI0AA4EY2ZlaQCIAQRjZnNpAIkBA2NmZQDbAQNjZnMA3AEEcHNobACKAQRwc2hoAIsBBHBvcGwAjAEEcG9waACNAQNqYWwAwgEEd2RjbQB0BHdxY20AdQR3ZG9wAHYEd3FvcAB3BHdkbWwAeAR3cW1sAHkEd2RkdgB6BHdxZHYAewR3ZG1kAHwEd3FtZAB9BHdkYW0AfgR3cWFtAH8Ed2RtbQCAAQR3cW1tAIEBBGVjYWwAggEEYnNpegBME2JsZGRfbmV3X3R5cGVzY3JpcHQAVwdibGRkX3JkADAEYmxkZACDAQRlY29wAIQBBGVwYXIAhQEWX193YmdfaW5zdHJ1Y3Rpb25fZnJlZQASFGluc3RydWN0aW9uX3RvX2J5dGVzAAoQaW5zdHJ1Y3Rpb25fc2l6ZQCMAhFyZWdpZF9uZXdfY2hlY2tlZADOAQlyZWdpZF9iYWwA+wEKcmVnaWRfY2dhcwD8AQlyZWdpZF9lcnIA/QEKcmVnaWRfZmxhZwD+AQhyZWdpZF9mcAD/AQpyZWdpZF9nZ2FzAIACCHJlZ2lkX2hwAIECCHJlZ2lkX2lzAIICCHJlZ2lkX29mAIMCCXJlZ2lkX29uZQCEAghyZWdpZF9wYwCFAglyZWdpZF9yZXQAhgIKcmVnaWRfcmV0bACHAghyZWdpZF9zcACIAglyZWdpZF9zcHAAiQIOcmVnaWRfd3JpdGFibGUAigIKcmVnaWRfemVybwCLAhRyZWdpZF9uZXdfdHlwZXNjcmlwdAD0AQtyZWdpZF90b191OAD1ARJhbmRfbmV3X3R5cGVzY3JpcHQAWRJkaXZfbmV3X3R5cGVzY3JpcHQAWRFlcV9uZXdfdHlwZXNjcmlwdABZEmV4cF9uZXdfdHlwZXNjcmlwdABZEWd0X25ld190eXBlc2NyaXB0AFkRbHRfbmV3X3R5cGVzY3JpcHQAWRNtbG9nX25ld190eXBlc2NyaXB0AFkTbXJvb19uZXdfdHlwZXNjcmlwdABZEm1vZF9uZXdfdHlwZXNjcmlwdABZEm11bF9uZXdfdHlwZXNjcmlwdABZEW9yX25ld190eXBlc2NyaXB0AFkSc2xsX25ld190eXBlc2NyaXB0AFkSc3JsX25ld190eXBlc2NyaXB0AFkSc3ViX25ld190eXBlc2NyaXB0AFkSeG9yX25ld190eXBlc2NyaXB0AFkSbWNwX25ld190eXBlc2NyaXB0AFkTc2N3cV9uZXdfdHlwZXNjcmlwdABZEnNyd19uZXdfdHlwZXNjcmlwdABZEnN3d19uZXdfdHlwZXNjcmlwdABZEXRyX25ld190eXBlc2NyaXB0AFkTZWNrMV9uZXdfdHlwZXNjcmlwdABZE2VjcjFfbmV3X3R5cGVzY3JpcHQAWRNrMjU2X25ld190eXBlc2NyaXB0AFkTczI1Nl9uZXdfdHlwZXNjcmlwdABZEmJhbF9uZXdfdHlwZXNjcmlwdABZEmpuZV9uZXdfdHlwZXNjcmlwdABZE2FuZGlfbmV3X3R5cGVzY3JpcHQAWhNkaXZpX25ld190eXBlc2NyaXB0AFoTZXhwaV9uZXdfdHlwZXNjcmlwdABaE21vZGlfbmV3X3R5cGVzY3JpcHQAWhNtdWxpX25ld190eXBlc2NyaXB0AFoSb3JpX25ld190eXBlc2NyaXB0AFoTc2xsaV9uZXdfdHlwZXNjcmlwdABaE3NybGlfbmV3X3R5cGVzY3JpcHQAWhNzdWJpX25ld190eXBlc2NyaXB0AFoTeG9yaV9uZXdfdHlwZXNjcmlwdABaE2puZWlfbmV3X3R5cGVzY3JpcHQAWhFsYl9uZXdfdHlwZXNjcmlwdABaEWx3X25ld190eXBlc2NyaXB0AFoRc2JfbmV3X3R5cGVzY3JpcHQAWhFzd19uZXdfdHlwZXNjcmlwdABaE21jcGlfbmV3X3R5cGVzY3JpcHQAWhJscXdfbmV3X3R5cGVzY3JpcHQAWhJsaHdfbmV3X3R5cGVzY3JpcHQAWhJzcXdfbmV3X3R5cGVzY3JpcHQAWhJzaHdfbmV3X3R5cGVzY3JpcHQAWhNqbnpmX25ld190eXBlc2NyaXB0AFoTam56Yl9uZXdfdHlwZXNjcmlwdABaEmphbF9uZXdfdHlwZXNjcmlwdABaEWppX25ld190eXBlc2NyaXB0ADkTY2ZzaV9uZXdfdHlwZXNjcmlwdAA5E3BzaGxfbmV3X3R5cGVzY3JpcHQAORNwc2hoX25ld190eXBlc2NyaXB0ADkTcG9wbF9uZXdfdHlwZXNjcmlwdAA5E3BvcGhfbmV3X3R5cGVzY3JpcHQAORNtb3ZpX25ld190eXBlc2NyaXB0ABoTbWNsaV9uZXdfdHlwZXNjcmlwdAAaE2puemlfbmV3X3R5cGVzY3JpcHQAGhNqbXBmX25ld190eXBlc2NyaXB0ABoSbm90X25ld190eXBlc2NyaXB0ACwTcmV0ZF9uZXdfdHlwZXNjcmlwdAAsE21vdmVfbmV3X3R5cGVzY3JpcHQALBJtY2xfbmV3X3R5cGVzY3JpcHQALBNidXJuX25ld190eXBlc2NyaXB0ACwTY3Jvb19uZXdfdHlwZXNjcmlwdAAsE2NzaXpfbmV3X3R5cGVzY3JpcHQALBNtaW50X25ld190eXBlc2NyaXB0ACwTdGltZV9uZXdfdHlwZXNjcmlwdAAsE2JzaXpfbmV3X3R5cGVzY3JpcHQALBNtbGR2X25ld190eXBlc2NyaXB0AFcSbWVxX25ld190eXBlc2NyaXB0AFcSY2NwX25ld190eXBlc2NyaXB0AFcSbG9nX25ld190eXBlc2NyaXB0AFcTbG9nZF9uZXdfdHlwZXNjcmlwdABXE3Nyd3FfbmV3X3R5cGVzY3JpcHQAVxNzd3dxX25ld190eXBlc2NyaXB0AFcSdHJvX25ld190eXBlc2NyaXB0AFcTZWQxOV9uZXdfdHlwZXNjcmlwdABXEnNtb19uZXdfdHlwZXNjcmlwdABXEmxkY19uZXdfdHlwZXNjcmlwdABXE2puZWZfbmV3X3R5cGVzY3JpcHQAVxN3ZG1kX25ld190eXBlc2NyaXB0AFcTd3FtZF9uZXdfdHlwZXNjcmlwdABXE3dkYW1fbmV3X3R5cGVzY3JpcHQAVxN3cWFtX25ld190eXBlc2NyaXB0AFcTd2RtbV9uZXdfdHlwZXNjcmlwdABXE3dxbW1fbmV3X3R5cGVzY3JpcHQAVxNlY2FsX25ld190eXBlc2NyaXB0AFcTY2FsbF9uZXdfdHlwZXNjcmlwdABXE2Vjb3BfbmV3X3R5cGVzY3JpcHQAVxNlcGFyX25ld190eXBlc2NyaXB0AFcfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwBUHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X2xocwBUEnJldF9uZXdfdHlwZXNjcmlwdACGARNiaGVpX25ld190eXBlc2NyaXB0AIYBEWNiX25ld190eXBlc2NyaXB0AIYBE3J2cnRfbmV3X3R5cGVzY3JpcHQAhgETZmxhZ19uZXdfdHlwZXNjcmlwdACGARJqbXBfbmV3X3R5cGVzY3JpcHQAhgESY2ZlX25ld190eXBlc2NyaXB0AIYBEmNmc19uZXdfdHlwZXNjcmlwdACGAR5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9saHMAUh9fX3diZ19nZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAFITd3Fkdl9uZXdfdHlwZXNjcmlwdADkARN3cW1sX25ld190eXBlc2NyaXB0AOQBE3dkbWxfbmV3X3R5cGVzY3JpcHQA5AETd3FvcF9uZXdfdHlwZXNjcmlwdADkARN3ZG9wX25ld190eXBlc2NyaXB0AOQBE3dxY21fbmV3X3R5cGVzY3JpcHQA5AETd2Rkdl9uZXdfdHlwZXNjcmlwdADkARN3ZGNtX25ld190eXBlc2NyaXB0AOQBDndxb3BfZnJvbV9hcmdzAEEOd3FtbF9mcm9tX2FyZ3MAQg53cWR2X2Zyb21fYXJncwDjAQ53cWNtX2Zyb21fYXJncwBBE2puZWJfbmV3X3R5cGVzY3JpcHQAVxBfX3diZ19yZWdpZF9mcmVlAF8QX193YmdfaW1tMjRfZnJlZQBhE19fd2JnX21hdGhhcmdzX2ZyZWUAOw9fX3diZ19tb3ZpX2ZyZWUAHQ5fX3diZ190cm9fZnJlZQAdD19fd2JnX2xvZ2RfZnJlZQAdDl9fd2JnX2ptcF9mcmVlAB0PX193YmdfYW5kaV9mcmVlAB0OX193YmdfYmFsX2ZyZWUAHQ5fX3diZ19scXdfZnJlZQAdDl9fd2JnX2phbF9mcmVlAB0Gam1wX3JhACoPX193YmdfYmhlaV9mcmVlAB0PX193Ymdfc3JsaV9mcmVlAB0FY2JfcmEAKg1fX3diZ19jYl9mcmVlAB0OX193Ymdfc3JsX2ZyZWUAHQ9fX3diZ19tbG9nX2ZyZWUAHQ5fX3diZ19saHdfZnJlZQAdDl9fd2JnX2puZV9mcmVlAB0PX193YmdfbW9kaV9mcmVlAB0HcnZydF9yYQAqD19fd2JnX3J2cnRfZnJlZQAdD19fd2JnX2syNTZfZnJlZQAdDV9fd2JnX2VxX2ZyZWUAHQ1fX3diZ19sYl9mcmVlAB0PX193YmdfbW92ZV9mcmVlAB0NX193YmdfbHRfZnJlZQAdB2JoZWlfcmEAKg9fX3diZ19hbG9jX2ZyZWUAHQZyZXRfcmEAKg5fX3diZ19yZXRfZnJlZQAdDl9fd2JnX2d0Zl9mcmVlAB0PX193YmdfYnNpel9mcmVlAB0PX193YmdfZWNhbF9mcmVlAB0OX193YmdfbWVxX2ZyZWUAHQ9fX3diZ193cW1kX2ZyZWUAHQ5fX3diZ19zbGxfZnJlZQAdD19fd2JnX2JsZGRfZnJlZQAdDl9fd2JnX21jcF9mcmVlAB0PX193Ymdfam5lZl9mcmVlAB0OX193YmdfY2NwX2ZyZWUAHQ9fX3diZ19wb3BsX2ZyZWUAHQ9fX3diZ193cWFtX2ZyZWUAHQ1fX3diZ19nbV9mcmVlAB0PX193Ymdfd2RhbV9mcmVlAB0PX193YmdfY2FsbF9mcmVlAB0OX193Ymdfc21vX2ZyZWUAHQpwb3BsX2ltbTI0AA4NX193YmdfamlfZnJlZQAdDl9fd2JnX2FuZF9mcmVlAB0OX193YmdfZXhwX2ZyZWUAHQ1fX3diZ19sd19mcmVlAB0NX193Ymdfc2JfZnJlZQAdD19fd2JnX3MyNTZfZnJlZQAdDl9fd2JnX29yaV9mcmVlAB0NX193YmdfZ3RfZnJlZQAdD19fd2JnX21yb29fZnJlZQAdD19fd2JnX3dxZHZfZnJlZQAdD19fd2JnX3dkZHZfZnJlZQAdD19fd2JnX2puemJfZnJlZQAdDl9fd2JnX3hvcl9mcmVlAB0PX193YmdfZWQxOV9mcmVlAB0IamlfaW1tMjQADg9fX3diZ19jZnNpX2ZyZWUAHQ9fX3diZ19qbXBiX2ZyZWUAHQ5fX3diZ19zcXdfZnJlZQAdDl9fd2JnX3Nod19mcmVlAB0OX193YmdfbWNsX2ZyZWUAHQ9fX3diZ19lY29wX2ZyZWUAHQ9fX3diZ19qbmVpX2ZyZWUAHQ9fX3diZ19zd3dxX2ZyZWUAHQ5fX3diZ19zcndfZnJlZQAdDl9fd2JnX21vZF9mcmVlAB0PX193Ymdfd2RtbV9mcmVlAB0NX193YmdfdHJfZnJlZQAdDV9fd2JnX3N3X2ZyZWUAHQ5fX3diZ19sZGNfZnJlZQAdDl9fd2JnX3N3d19mcmVlAB0KY2ZzaV9pbW0yNAAOD19fd2JnX2NmZWlfZnJlZQAdD19fd2JnX3Nyd3FfZnJlZQAdD19fd2JnX2Nyb29fZnJlZQAdDV9fd2JnX29yX2ZyZWUAHQ5fX3diZ19sb2dfZnJlZQAdD19fd2JnX21sZHZfZnJlZQAdD19fd2JnX2J1cm5fZnJlZQAdD19fd2JnX211bGlfZnJlZQAdD19fd2JnX3dxbW1fZnJlZQAdB2ZsYWdfcmEAKg9fX3diZ19mbGFnX2ZyZWUAHQ9fX3diZ19qbnppX2ZyZWUAHQpwb3BoX2ltbTI0AA4PX193YmdfcG9waF9mcmVlAB0GY2ZzX3JhACoOX193YmdfY2ZzX2ZyZWUAHQ5fX3diZ19kaXZfZnJlZQAdCnBzaGxfaW1tMjQADg9fX3diZ19wc2hsX2ZyZWUAHQ5fX3diZ19zdWJfZnJlZQAdD19fd2JnX3N1YmlfZnJlZQAdD19fd2JnX2VwYXJfZnJlZQAdD19fd2JnX2NzaXpfZnJlZQAdD19fd2JnX25pb3BfZnJlZQAdCnBzaGhfaW1tMjQADg9fX3diZ19wc2hoX2ZyZWUAHQ5fX3diZ19ub3RfZnJlZQAdD19fd2JnX2puZWJfZnJlZQAdBmNmZV9yYQAqDl9fd2JnX2NmZV9mcmVlAB0PX193YmdfbWNsaV9mcmVlAB0PX193Ymdfd3FtbF9mcmVlAB0PX193YmdfYWRkaV9mcmVlAB0PX193YmdfYmhzaF9mcmVlAB0PX193YmdfZXhwaV9mcmVlAB0PX193Ymdfc2N3cV9mcmVlAB0PX193YmdfbWludF9mcmVlAB0PX193YmdfdGltZV9mcmVlAB0PX193YmdfeG9yaV9mcmVlAB0PX193Ymdfd2RvcF9mcmVlAB0PX193YmdfcmV0ZF9mcmVlAB0PX193Ymdfd3FvcF9mcmVlAB0PX193YmdfZWNrMV9mcmVlAB0PX193Ymdfc2xsaV9mcmVlAB0PX193Ymdfd2RtZF9mcmVlAB0PX193YmdfbWNwaV9mcmVlAB0PX193Ymdfam1wZl9mcmVlAB0PX193Ymdfd2RjbV9mcmVlAB0PX193Ymdfd2RtbF9mcmVlAB0PX193Ymdfam56Zl9mcmVlAB0PX193YmdfZWNyMV9mcmVlAB0OX193YmdfbXVsX2ZyZWUAHQ9fX3diZ193cWNtX2ZyZWUAHQ9fX3diZ19kaXZpX2ZyZWUAHQdtb3ZpX3JhAC8FZXFfcmIAFwVlcV9yYQAvB2xvZ2RfcmMAHgdsb2dkX3JiABcHbG9nZF9yYQAvCmFuZGlfaW1tMTIADQdhbmRpX3JiABcHYW5kaV9yYQAvBnRyb19yZAAwBnRyb19yYwAeBnRyb19yYgAXBnRyb19yYQAvCWxxd19pbW0xMgANBmxxd19yYgAXBmxxd19yYQAvCWphbF9pbW0xMgANBmphbF9yYgAXBmphbF9yYQAvCnNybGlfaW1tMTIADQdzcmxpX3JiABcHc3JsaV9yYQAvBnNybF9yYwAeBnNybF9yYgAXBnNybF9yYQAvB21sb2dfcmMAHgdtbG9nX3JiABcHbWxvZ19yYQAvCWxod19pbW0xMgANBmxod19yYgAXBmxod19yYQAvBmpuZV9yYwAeBmpuZV9yYgAXBmpuZV9yYQAvCm1vZGlfaW1tMTIADQdtb2RpX3JiABcHbW9kaV9yYQAvB2syNTZfcmMAHgdrMjU2X3JiABcHazI1Nl9yYQAvBWVxX3JjAB4GYmFsX3JiABcGYmFsX3JhAC8IbGJfaW1tMTIADQVsYl9yYgAXBWxiX3JhAC8HbW92ZV9yYgAXB21vdmVfcmEALwVsdF9yYwAeBWx0X3JiABcFbHRfcmEALwlndGZfaW1tMTIADQZndGZfcmIAFwZndGZfcmEALwdic2l6X3JiABcHYnNpel9yYQAvB2xvZ2RfcmQAMAdlY2FsX3JjAB4HZWNhbF9yYgAXB2VjYWxfcmEALwZtZXFfcmQAMAZtZXFfcmMAHgZtZXFfcmIAFwZtZXFfcmEALwd3cW1kX3JkADAHd3FtZF9yYwAeB3dxbWRfcmIAFwd3cW1kX3JhAC8Gc2xsX3JjAB4Gc2xsX3JiABcGc2xsX3JhAC8HZWNhbF9yZAAwB2JsZGRfcmMAHgdibGRkX3JiABcHYmxkZF9yYQAvBm1jcF9yYwAeBm1jcF9yYgAXBm1jcF9yYQAvB2puZWZfcmMAHgdqbmVmX3JiABcHam5lZl9yYQAvBmNjcF9yZAAwBmNjcF9yYwAeBmNjcF9yYgAXBmNjcF9yYQAvB3dxYW1fcmQAMAd3cWFtX3JjAB4Hd3FhbV9yYgAXB3dxYW1fcmEALwptb3ZpX2ltbTE4ABMFZ21fcmEALwd3ZGFtX3JkADAHd2RhbV9yYwAeB3dkYW1fcmIAFwd3ZGFtX3JhAC8HY2FsbF9yZAAwB2NhbGxfcmMAHgdjYWxsX3JiABcHY2FsbF9yYQAvBnNtb19yZAAwBnNtb19yYwAeBnNtb19yYgAXBnNtb19yYQAvBmJhbF9yYwAeBmFuZF9yYgAXBmFuZF9yYQAvBmV4cF9yYwAeBmV4cF9yYgAXBmV4cF9yYQAvCGx3X2ltbTEyAA0FbHdfcmIAFwVsd19yYQAvCHNiX2ltbTEyAA0Fc2JfcmIAFwVzYl9yYQAvB3MyNTZfcmMAHgdzMjU2X3JiABcHczI1Nl9yYQAvCW9yaV9pbW0xMgANBm9yaV9yYgAXBm9yaV9yYQAvBWd0X3JjAB4FZ3RfcmIAFwVndF9yYQAvB21yb29fcmMAHgdtcm9vX3JiABcHbXJvb19yYQAvCndxZHZfaW1tMDYAMAd3cWR2X3JjAB4Hd3Fkdl9yYgAXB3dxZHZfcmEALwp3ZGR2X2ltbTA2ADAHd2Rkdl9yYwAeB3dkZHZfcmIAFwd3ZGR2X3JhAC8Kam56Yl9pbW0xMgANB2puemJfcmIAFwdqbnpiX3JhAC8GeG9yX3JjAB4GeG9yX3JiABcGeG9yX3JhAC8HZWQxOV9yZAAwB2VkMTlfcmMAHgdlZDE5X3JiABcHZWQxOV9yYQAvCmptcGJfaW1tMTgAEwdqbXBiX3JhAC8Jc3F3X2ltbTEyAA0Gc3F3X3JiABcGc3F3X3JhAC8Jc2h3X2ltbTEyAA0Gc2h3X3JiABcGc2h3X3JhAC8GbWNsX3JiABcGbWNsX3JhAC8HZWNvcF9yZAAwB2Vjb3BfcmMAHgdlY29wX3JiABcHZWNvcF9yYQAvCmpuZWlfaW1tMTIADQdqbmVpX3JiABcHam5laV9yYQAvB3N3d3FfcmQAMAdzd3dxX3JjAB4Hc3d3cV9yYgAXB3N3d3FfcmEALwZzcndfcmMAHgZzcndfcmIAFwZzcndfcmEALwZtb2RfcmMAHgZtb2RfcmIAFwZtb2RfcmEALwd3ZG1tX3JkADAHd2RtbV9yYwAeB3dkbW1fcmIAFwd3ZG1tX3JhAC8FdHJfcmMAHgV0cl9yYgAXBXRyX3JhAC8Ic3dfaW1tMTIADQVzd19yYgAXBXN3X3JhAC8JbGRjX2ltbTA2ADAGbGRjX3JjAB4GbGRjX3JiABcGbGRjX3JhAC8Gc3d3X3JjAB4Gc3d3X3JiABcGc3d3X3JhAC8Hc3J3cV9yZAAwB3Nyd3FfcmMAHgdzcndxX3JiABcHc3J3cV9yYQAvB2Nyb29fcmIAFwdjcm9vX3JhAC8Fb3JfcmMAHgVvcl9yYgAXBW9yX3JhAC8GbG9nX3JkADAGbG9nX3JjAB4GbG9nX3JiABcGbG9nX3JhAC8HbWxkdl9yZAAwB21sZHZfcmMAHgdtbGR2X3JiABcHbWxkdl9yYQAvB2J1cm5fcmIAFwdidXJuX3JhAC8KbXVsaV9pbW0xMgANB211bGlfcmIAFwdtdWxpX3JhAC8Hd3FtbV9yZAAwB3dxbW1fcmMAHgd3cW1tX3JiABcHd3FtbV9yYQAvCmpuemlfaW1tMTgAEwdqbnppX3JhAC8GZGl2X3JjAB4GZGl2X3JiABcGZGl2X3JhAC8Gc3ViX3JjAB4Gc3ViX3JiABcGc3ViX3JhAC8Kc3ViaV9pbW0xMgANB3N1YmlfcmIAFwdzdWJpX3JhAC8HZXBhcl9yZAAwB2VwYXJfcmMAHgdlcGFyX3JiABcHZXBhcl9yYQAvB2NzaXpfcmIAFwdjc2l6X3JhAC8KbmlvcF9pbW0wNgAwB25pb3BfcmMAHgduaW9wX3JiABcHbmlvcF9yYQAvBm5vdF9yYgAXBm5vdF9yYQAvCmpuZWZfaW1tMDYAMAdqbmViX3JjAB4Ham5lYl9yYgAXB2puZWJfcmEALwptY2xpX2ltbTE4ABMHbWNsaV9yYQAvCndxbWxfaW1tMDYAMAd3cW1sX3JjAB4Hd3FtbF9yYgAXB3dxbWxfcmEALwZhbmRfcmMAHgdhZGRpX3JiABcHYWRkaV9yYQAvB2Joc2hfcmIAFwdiaHNoX3JhAC8KZXhwaV9pbW0xMgANB2V4cGlfcmIAFwdleHBpX3JhAC8Hc2N3cV9yYwAeB3Njd3FfcmIAFwdzY3dxX3JhAC8HbWludF9yYgAXB21pbnRfcmEALwd0aW1lX3JiABcHdGltZV9yYQAvCnhvcmlfaW1tMTIADQd4b3JpX3JiABcHeG9yaV9yYQAvCndkb3BfaW1tMDYAMAd3ZG9wX3JjAB4Hd2RvcF9yYgAXB3dkb3BfcmEALwdyZXRkX3JiABcHcmV0ZF9yYQAvCndxb3BfaW1tMDYAMAd3cW9wX3JjAB4Hd3FvcF9yYgAXB3dxb3BfcmEALwdlY2sxX3JjAB4HZWNrMV9yYgAXB2VjazFfcmEALwpzbGxpX2ltbTEyAA0Hc2xsaV9yYgAXB3NsbGlfcmEALwd3ZG1kX3JkADAHd2RtZF9yYwAeB3dkbWRfcmIAFwd3ZG1kX3JhAC8KbWNwaV9pbW0xMgANB21jcGlfcmIAFwdtY3BpX3JhAC8Kam1wZl9pbW0xOAATB2ptcGZfcmEALwp3ZGNtX2ltbTA2ADAHd2RjbV9yYwAeB3dkY21fcmIAFwd3ZGNtX3JhAC8Kd2RtbF9pbW0wNgAwB3dkbWxfcmMAHgd3ZG1sX3JiABcHd2RtbF9yYQAvCmpuemZfaW1tMTIADQdq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EPIBAAsQACAAIAEgAiADQeoAEI0CCxAAIAAgASACIANB6wAQjQILDwAgACABIAIgA0ESEI4CCw8AIAAgASACIANBExCPAgsPACAAIAEgAiADQRkQjgILDwAgACABIAIgA0EdEI4CCw8AIAAgASACIANBHhCOAgsPACAAIAEgAiADQSIQjwILDwAgACABIAIgA0EjEI4CCw8AIAAgASACIANBJBCOAgsPACAAIAEgAiADQSkQjgILDwAgACABIAIgA0ErEI4CCw8AIAAgASACIANBLRCOAgsPACAAIAEgAiADQTAQjgILDwAgACABIAIgA0E5EI4CCxAAIAAgASACIANB2AAQjwILEAAgACABIAIgA0HZABCPAgsQACAAIAEgAiADQeQAEI8CCxAAIAAgASACIANB5QAQjwILEAAgACABIAIgA0HmABCPAgsQACAAIAEgAiADQecAEI8CCxAAIAAgASACIANB6AAQjwILEAAgACABIAIgA0HpABCPAgsQACAAIAEgAiADQeoAEI8CCxAAIAAgASACIANB6wAQjwILEAAgACABIAIgA0HsABCOAgsQACAAIAEgAiADQe0AEI4CCxAAIAAgASACIANB7gAQjgILEAAgACABIAIgA0HvABCOAgsQACAAIAEgAiADQfAAEI4CCxAAIAAgASACIANB8QAQjgILEAAgACABIAIgA0HyABCOAgsQACAAIAEgAiADQfQAEI4CCxAAIAAgASACIANB9QAQjgILEAAgACABIAIgA0H2ABCOAgszAQF/IAAQHyEBQRBBBBDMASIAQoGAgIAQNwIAIAAgAUECdEH8AXGtQiCGNwIIIABBCGoLCgAgAEHaABCQAgsKACAAQdsAEJACCwoAIABB3AAQkAILCgAgAEHfABCQAgsKACAAQeAAEJACCwoAIABB4QAQkAILCgAgAEHiABCQAgvqAQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQQUgASgCCCIALQAIIAAtAAkQFAALIAAgAzYCBCAAIAI2AgAgAEEGIAEoAggiAC0ACCAALQAJEBQACysAIAIQAyECIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQT0EIdEHLAHIQ7QEQyAELDQAgACABIAJBARCRAgsNACAAIAEgAkECEJECCw0AIAAgASACQQMQkQILDQAgACABIAJBBBCRAgsNACAAIAEgAkEFEJECCw0AIAAgASACQQYQkQILDQAgACABIAJBBxCRAgsNACAAIAEgAkEIEJECCw0AIAAgASACQQkQkQILDQAgACABIAJBCxCRAgsNACAAIAEgAkENEJECCw0AIAAgASACQQ4QkQILDQAgACABIAJBDxCRAgsNACAAIAEgAkEQEJECCw0AIAAgASACQREQkQILDQAgACABIAJBGBCRAgsNACAAIAEgAkEnEJECCw0AIAAgASACQSgQkQILDQAgACABIAJBKhCRAgsNACAAIAEgAkEsEJECCw0AIAAgASACQS4QkQILDQAgACABIAJBLxCRAgsNACAAIAEgAkExEJECCw0AIAAgASACQTIQkQILDQAgACABIAJBNhCRAgsNACAAIAEgAkE4EJECCw0AIAAgASACQToQkgILDQAgACABIAJBOxCSAgsNACAAIAEgAkE8EJICCw0AIAAgASACQT0QkgILDQAgACABIAJBPhCSAgsNACAAIAEgAkE/EJICCw4AIAAgASACQcAAEJICCw4AIAAgASACQcEAEJICCw4AIAAgASACQcIAEJICCw4AIAAgASACQcMAEJICCw4AIAAgASACQcQAEJICCw4AIAAgASACQcUAEJICCw4AIAAgASACQcYAEJICCw4AIAAgASACQccAEJICCw4AIAAgASACQcgAEJICCw4AIAAgASACQckAEJICCw4AIAAgASACQcoAEJICCw4AIAAgASACQcsAEJICCw4AIAAgASACQcwAEJICCw4AIAAgASACQc0AEJICCw4AIAAgASACQc4AEJICCw4AIAAgASACQc8AEJICCw4AIAAgASACQdYAEJICCw4AIAAgASACQdcAEJICCw4AIAAgASACQeMAEJICCygAIAEoAgBFBEAgAUF/NgIAIAAgATYCBCAAIAFBBGo2AgAPCxDyAQALJwEBfwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCAB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', imports)}

async function initWasm () {
  return await __wbg_init({ module_or_path: wasm() });
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

exports.ADD = ADD;
exports.ADDI = ADDI;
exports.ALOC = ALOC;
exports.AND = AND;
exports.ANDI = ANDI;
exports.BAL = BAL;
exports.BHEI = BHEI;
exports.BHSH = BHSH;
exports.BLDD = BLDD;
exports.BSIZ = BSIZ;
exports.BURN = BURN;
exports.CALL = CALL;
exports.CB = CB;
exports.CCP = CCP;
exports.CFE = CFE;
exports.CFEI = CFEI;
exports.CFS = CFS;
exports.CFSI = CFSI;
exports.CROO = CROO;
exports.CSIZ = CSIZ;
exports.CompareArgs = CompareArgs;
exports.CompareMode = CompareMode;
exports.DIV = DIV;
exports.DIVI = DIVI;
exports.DivArgs = DivArgs;
exports.ECAL = ECAL;
exports.ECK1 = ECK1;
exports.ECOP = ECOP;
exports.ECR1 = ECR1;
exports.ED19 = ED19;
exports.EPAR = EPAR;
exports.EQ = EQ;
exports.EXP = EXP;
exports.EXPI = EXPI;
exports.FLAG = FLAG;
exports.GM = GM;
exports.GMArgs = GMArgs;
exports.GT = GT;
exports.GTF = GTF;
exports.GTFArgs = GTFArgs;
exports.Imm06 = Imm06;
exports.Imm12 = Imm12;
exports.Imm18 = Imm18;
exports.Imm24 = Imm24;
exports.Instruction = Instruction;
exports.JAL = JAL;
exports.JI = JI;
exports.JMP = JMP;
exports.JMPB = JMPB;
exports.JMPF = JMPF;
exports.JNE = JNE;
exports.JNEB = JNEB;
exports.JNEF = JNEF;
exports.JNEI = JNEI;
exports.JNZB = JNZB;
exports.JNZF = JNZF;
exports.JNZI = JNZI;
exports.K256 = K256;
exports.LB = LB;
exports.LDC = LDC;
exports.LHW = LHW;
exports.LOG = LOG;
exports.LOGD = LOGD;
exports.LQW = LQW;
exports.LT = LT;
exports.LW = LW;
exports.MCL = MCL;
exports.MCLI = MCLI;
exports.MCP = MCP;
exports.MCPI = MCPI;
exports.MEQ = MEQ;
exports.MINT = MINT;
exports.MLDV = MLDV;
exports.MLOG = MLOG;
exports.MOD = MOD;
exports.MODI = MODI;
exports.MOVE = MOVE;
exports.MOVI = MOVI;
exports.MROO = MROO;
exports.MUL = MUL;
exports.MULI = MULI;
exports.MathArgs = MathArgs;
exports.MathOp = MathOp;
exports.MulArgs = MulArgs;
exports.NIOP = NIOP;
exports.NOOP = NOOP;
exports.NOT = NOT;
exports.NarrowMathArgs = NarrowMathArgs;
exports.NarrowMathOp = NarrowMathOp;
exports.OR = OR;
exports.ORI = ORI;
exports.OpWidth = OpWidth;
exports.POPH = POPH;
exports.POPL = POPL;
exports.PSHH = PSHH;
exports.PSHL = PSHL;
exports.PanicInstruction = PanicInstruction;
exports.PanicReason = PanicReason;
exports.RET = RET;
exports.RETD = RETD;
exports.RVRT = RVRT;
exports.RegId = RegId;
exports.S256 = S256;
exports.SB = SB;
exports.SCWQ = SCWQ;
exports.SHW = SHW;
exports.SLL = SLL;
exports.SLLI = SLLI;
exports.SMO = SMO;
exports.SQW = SQW;
exports.SRL = SRL;
exports.SRLI = SRLI;
exports.SRW = SRW;
exports.SRWQ = SRWQ;
exports.SUB = SUB;
exports.SUBI = SUBI;
exports.SW = SW;
exports.SWW = SWW;
exports.SWWQ = SWWQ;
exports.TIME = TIME;
exports.TR = TR;
exports.TRO = TRO;
exports.WDAM = WDAM;
exports.WDCM = WDCM;
exports.WDDV = WDDV;
exports.WDMD = WDMD;
exports.WDML = WDML;
exports.WDMM = WDMM;
exports.WDOP = WDOP;
exports.WQAM = WQAM;
exports.WQCM = WQCM;
exports.WQDV = WQDV;
exports.WQMD = WQMD;
exports.WQML = WQML;
exports.WQMM = WQMM;
exports.WQOP = WQOP;
exports.XOR = XOR;
exports.XORI = XORI;
exports.add = add;
exports.addi = addi;
exports.aloc = aloc;
exports.and = and;
exports.andi = andi;
exports.bal = bal;
exports.bhei = bhei;
exports.bhsh = bhsh;
exports.bldd = bldd;
exports.bsiz = bsiz;
exports.burn = burn;
exports.call = call;
exports.cb = cb;
exports.ccp = ccp;
exports.cfe = cfe;
exports.cfei = cfei;
exports.cfs = cfs;
exports.cfsi = cfsi;
exports.croo = croo;
exports.csiz = csiz;
exports.div = div;
exports.divi = divi;
exports.ecal = ecal;
exports.eck1 = eck1;
exports.ecop = ecop;
exports.ecr1 = ecr1;
exports.ed19 = ed19;
exports.epar = epar;
exports.eq = eq;
exports.exp = exp;
exports.expi = expi;
exports.flag = flag;
exports.gm = gm;
exports.gm_args = gm_args;
exports.gt = gt;
exports.gtf = gtf;
exports.gtf_args = gtf_args;
exports.initSync = initSync;
exports.initWasm = initWasm;
exports.jal = jal;
exports.ji = ji;
exports.jmp = jmp;
exports.jmpb = jmpb;
exports.jmpf = jmpf;
exports.jne = jne;
exports.jneb = jneb;
exports.jnef = jnef;
exports.jnei = jnei;
exports.jnzb = jnzb;
exports.jnzf = jnzf;
exports.jnzi = jnzi;
exports.k256 = k256;
exports.lb = lb;
exports.ldc = ldc;
exports.lhw = lhw;
exports.log = log;
exports.logd = logd;
exports.lqw = lqw;
exports.lt = lt;
exports.lw = lw;
exports.mcl = mcl;
exports.mcli = mcli;
exports.mcp = mcp;
exports.mcpi = mcpi;
exports.meq = meq;
exports.mint = mint;
exports.mldv = mldv;
exports.mlog = mlog;
exports.mod_ = mod_;
exports.modi = modi;
exports.move_ = move_;
exports.movi = movi;
exports.mroo = mroo;
exports.mul = mul;
exports.muli = muli;
exports.niop = niop;
exports.niop_args = niop_args;
exports.noop = noop;
exports.not = not;
exports.or = or;
exports.ori = ori;
exports.poph = poph;
exports.popl = popl;
exports.pshh = pshh;
exports.pshl = pshl;
exports.ret = ret;
exports.retd = retd;
exports.rvrt = rvrt;
exports.s256 = s256;
exports.sb = sb;
exports.scwq = scwq;
exports.shw = shw;
exports.sll = sll;
exports.slli = slli;
exports.smo = smo;
exports.sqw = sqw;
exports.srl = srl;
exports.srli = srli;
exports.srw = srw;
exports.srwq = srwq;
exports.sub = sub;
exports.subi = subi;
exports.sw = sw;
exports.sww = sww;
exports.swwq = swwq;
exports.time = time;
exports.tr = tr;
exports.tro = tro;
exports.wdam = wdam;
exports.wdcm = wdcm;
exports.wdcm_args = wdcm_args;
exports.wddv = wddv;
exports.wddv_args = wddv_args;
exports.wdmd = wdmd;
exports.wdml = wdml;
exports.wdml_args = wdml_args;
exports.wdmm = wdmm;
exports.wdop = wdop;
exports.wdop_args = wdop_args;
exports.wqam = wqam;
exports.wqcm = wqcm;
exports.wqcm_args = wqcm_args;
exports.wqdv = wqdv;
exports.wqdv_args = wqdv_args;
exports.wqmd = wqmd;
exports.wqml = wqml;
exports.wqml_args = wqml_args;
exports.wqmm = wqmm;
exports.wqop = wqop;
exports.wqop_args = wqop_args;
exports.xor = xor;
exports.xori = xori;
