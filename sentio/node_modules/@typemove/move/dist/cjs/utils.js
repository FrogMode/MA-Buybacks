"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VECTOR_STR = exports.SPLITTER = void 0;
exports.isFrameworkAccount = isFrameworkAccount;
exports.accountTypeString = accountTypeString;
exports.isValidMoveAddress = isValidMoveAddress;
exports.accountAddressString = accountAddressString;
exports.normalizeToJSName = normalizeToJSName;
exports.moduleQnameForType = moduleQnameForType;
exports.moduleQname = moduleQname;
exports.structQname = structQname;
exports.upperFirst = upperFirst;
exports.camel = camel;
const radash_1 = require("radash");
exports.SPLITTER = '::';
exports.VECTOR_STR = 'vector';
function isFrameworkAccount(account) {
    const n = parseInt(account, 16);
    if (Number.isNaN(n)) {
        return false;
    }
    return n >= 0 && n < 16;
}
// strip any lead 0
function accountTypeString(account) {
    const withoutPrefix = account.toLowerCase().replace(/^(0x)/, '');
    return '0x' + withoutPrefix.replace(/^0*/, '');
}
const MOVE_ADDRESS_LENGTH = 32;
function isHex(value) {
    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value);
}
function getHexByteLength(value) {
    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
function isValidMoveAddress(value) {
    return isHex(value) && getHexByteLength(value) <= MOVE_ADDRESS_LENGTH;
}
// Get full address with 32 bytes
function accountAddressString(account) {
    if (!isValidMoveAddress(account)) {
        throw Error('Not valid move address');
    }
    const address = account.toLowerCase().replace(/^(0x)/, '');
    return `0x${address.padStart(MOVE_ADDRESS_LENGTH * 2, '0')}`;
}
// https://github.com/microsoft/TypeScript/issues/2536
const KEYWORDS = new Set([
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'null',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'as',
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'any',
    'boolean',
    'constructor',
    'declare',
    // 'get',
    'module',
    // 'require',
    'number',
    // 'set',
    'string',
    'symbol',
    'type',
    'from',
    // 'of',
    'async',
    'await',
    'bigint',
    'object',
    'volatile',
    'namespace'
]);
function normalizeToJSName(name) {
    if (KEYWORDS.has(name)) {
        return name + '$';
    }
    return name;
}
function moduleQnameForType(type) {
    const parts = type.split(exports.SPLITTER).slice(0, 2);
    return [parts[0], parts[1]];
}
function moduleQname(module) {
    return accountTypeString(module.address) + exports.SPLITTER + module.name;
}
function structQname(module, struct) {
    return [accountTypeString(module.address), module.name, struct.name].join(exports.SPLITTER);
}
function upperFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function camel(str) {
    const base = (0, radash_1.camel)(str);
    return str.endsWith('_') ? base + '_' : base;
}
//# sourceMappingURL=utils.js.map