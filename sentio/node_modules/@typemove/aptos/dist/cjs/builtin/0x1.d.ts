import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId } from "@aptos-labs/ts-sdk";
export declare namespace acl {
    interface ACL {
        list: MoveAddressType[];
    }
    namespace ACL {
        const TYPE_QNAME = "0x1::acl::ACL";
        function type(): TypeDescriptor<ACL>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace any$ {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::any::Any";
        function type(): TypeDescriptor<Any>;
    }
    type AnyInstance = TypedEventInstance<Any> & {
        data_decoded: Any;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace cmp {
    interface Ordering {
    }
    namespace Ordering {
        const TYPE_QNAME = "0x1::cmp::Ordering";
        function type(): TypeDescriptor<Ordering>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace dkg {
    interface DKGSessionMetadata {
        dealer_epoch: bigint;
        randomness_config: randomness_config.RandomnessConfig;
        dealer_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
        target_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
    }
    namespace DKGSessionMetadata {
        const TYPE_QNAME = "0x1::dkg::DKGSessionMetadata";
        function type(): TypeDescriptor<DKGSessionMetadata>;
    }
    interface DKGSessionState {
        metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
        transcript: string;
    }
    namespace DKGSessionState {
        const TYPE_QNAME = "0x1::dkg::DKGSessionState";
        function type(): TypeDescriptor<DKGSessionState>;
    }
    interface DKGStartEvent {
        session_metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
    }
    namespace DKGStartEvent {
        const TYPE_QNAME = "0x1::dkg::DKGStartEvent";
        function type(): TypeDescriptor<DKGStartEvent>;
    }
    type DKGStartEventInstance = TypedEventInstance<DKGStartEvent> & {
        data_decoded: DKGStartEvent;
        type_arguments: [];
    };
    interface DKGState {
        last_completed: option.Option<dkg.DKGSessionState>;
        in_progress: option.Option<dkg.DKGSessionState>;
    }
    namespace DKGState {
        const TYPE_QNAME = "0x1::dkg::DKGState";
        function type(): TypeDescriptor<DKGState>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace mem {
    namespace entry { }
    namespace view { }
}
export declare namespace code {
    interface AllowedDep {
        account: MoveAddressType;
        module_name: string;
    }
    namespace AllowedDep {
        const TYPE_QNAME = "0x1::code::AllowedDep";
        function type(): TypeDescriptor<AllowedDep>;
    }
    interface CodePublishingPermission {
        dummy_field: boolean;
    }
    namespace CodePublishingPermission {
        const TYPE_QNAME = "0x1::code::CodePublishingPermission";
        function type(): TypeDescriptor<CodePublishingPermission>;
    }
    interface ModuleMetadata {
        name: string;
        source: string;
        source_map: string;
        extension: option.Option<copyable_any.Any>;
    }
    namespace ModuleMetadata {
        const TYPE_QNAME = "0x1::code::ModuleMetadata";
        function type(): TypeDescriptor<ModuleMetadata>;
    }
    interface PackageDep {
        account: MoveAddressType;
        package_name: string;
    }
    namespace PackageDep {
        const TYPE_QNAME = "0x1::code::PackageDep";
        function type(): TypeDescriptor<PackageDep>;
    }
    interface PackageMetadata {
        name: string;
        upgrade_policy: code.UpgradePolicy;
        upgrade_number: bigint;
        source_digest: string;
        manifest: string;
        modules: code.ModuleMetadata[];
        deps: code.PackageDep[];
        extension: option.Option<copyable_any.Any>;
    }
    namespace PackageMetadata {
        const TYPE_QNAME = "0x1::code::PackageMetadata";
        function type(): TypeDescriptor<PackageMetadata>;
    }
    interface PackageRegistry {
        packages: code.PackageMetadata[];
    }
    namespace PackageRegistry {
        const TYPE_QNAME = "0x1::code::PackageRegistry";
        function type(): TypeDescriptor<PackageRegistry>;
    }
    interface PublishPackage {
        code_address: MoveAddressType;
        is_upgrade: boolean;
    }
    namespace PublishPackage {
        const TYPE_QNAME = "0x1::code::PublishPackage";
        function type(): TypeDescriptor<PublishPackage>;
    }
    type PublishPackageInstance = TypedEventInstance<PublishPackage> & {
        data_decoded: PublishPackage;
        type_arguments: [];
    };
    interface UpgradePolicy {
        policy: number;
    }
    namespace UpgradePolicy {
        const TYPE_QNAME = "0x1::code::UpgradePolicy";
        function type(): TypeDescriptor<UpgradePolicy>;
    }
    namespace entry {
        function publishPackageTxn(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace coin {
    interface Deposit<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::coin::Deposit";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Deposit<T0>>;
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::coin::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    type DepositEventInstance = TypedEventInstance<DepositEvent> & {
        data_decoded: DepositEvent;
        type_arguments: [];
    };
    interface Withdraw<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::coin::Withdraw";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Withdraw<T0>>;
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::coin::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    type WithdrawEventInstance = TypedEventInstance<WithdrawEvent> & {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    };
    interface AggregatableCoin<T0> {
        value: aggregator.Aggregator;
    }
    namespace AggregatableCoin {
        const TYPE_QNAME = "0x1::coin::AggregatableCoin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatableCoin<T0>>;
    }
    interface BurnCapability<T0> {
        dummy_field: boolean;
    }
    namespace BurnCapability {
        const TYPE_QNAME = "0x1::coin::BurnCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BurnCapability<T0>>;
    }
    interface BurnRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace BurnRefReceipt {
        const TYPE_QNAME = "0x1::coin::BurnRefReceipt";
        function type(): TypeDescriptor<BurnRefReceipt>;
    }
    interface Coin<T0> {
        value: bigint;
    }
    namespace Coin {
        const TYPE_QNAME = "0x1::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinConversionMap {
        coin_to_fungible_asset_map: table.Table<type_info.TypeInfo, object$.Object<fungible_asset.Metadata>>;
    }
    namespace CoinConversionMap {
        const TYPE_QNAME = "0x1::coin::CoinConversionMap";
        function type(): TypeDescriptor<CoinConversionMap>;
    }
    interface CoinDeposit {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinDeposit {
        const TYPE_QNAME = "0x1::coin::CoinDeposit";
        function type(): TypeDescriptor<CoinDeposit>;
    }
    type CoinDepositInstance = TypedEventInstance<CoinDeposit> & {
        data_decoded: CoinDeposit;
        type_arguments: [];
    };
    interface CoinEventHandleDeletion {
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinEventHandleDeletion {
        const TYPE_QNAME = "0x1::coin::CoinEventHandleDeletion";
        function type(): TypeDescriptor<CoinEventHandleDeletion>;
    }
    type CoinEventHandleDeletionInstance = TypedEventInstance<CoinEventHandleDeletion> & {
        data_decoded: CoinEventHandleDeletion;
        type_arguments: [];
    };
    interface CoinInfo<T0> {
        name: string;
        symbol: string;
        decimals: number;
        supply: option.Option<optional_aggregator.OptionalAggregator>;
    }
    namespace CoinInfo {
        const TYPE_QNAME = "0x1::coin::CoinInfo";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinInfo<T0>>;
    }
    interface CoinStore<T0> {
        coin: coin.Coin<T0>;
        frozen: boolean;
        deposit_events: event.EventHandle<coin.DepositEvent>;
        withdraw_events: event.EventHandle<coin.WithdrawEvent>;
    }
    namespace CoinStore {
        const TYPE_QNAME = "0x1::coin::CoinStore";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinStore<T0>>;
    }
    interface CoinStoreDeletion {
        coin_type: string;
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinStoreDeletion {
        const TYPE_QNAME = "0x1::coin::CoinStoreDeletion";
        function type(): TypeDescriptor<CoinStoreDeletion>;
    }
    type CoinStoreDeletionInstance = TypedEventInstance<CoinStoreDeletion> & {
        data_decoded: CoinStoreDeletion;
        type_arguments: [];
    };
    interface CoinWithdraw {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinWithdraw {
        const TYPE_QNAME = "0x1::coin::CoinWithdraw";
        function type(): TypeDescriptor<CoinWithdraw>;
    }
    type CoinWithdrawInstance = TypedEventInstance<CoinWithdraw> & {
        data_decoded: CoinWithdraw;
        type_arguments: [];
    };
    interface FreezeCapability<T0> {
        dummy_field: boolean;
    }
    namespace FreezeCapability {
        const TYPE_QNAME = "0x1::coin::FreezeCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<FreezeCapability<T0>>;
    }
    interface MigrationFlag {
        dummy_field: boolean;
    }
    namespace MigrationFlag {
        const TYPE_QNAME = "0x1::coin::MigrationFlag";
        function type(): TypeDescriptor<MigrationFlag>;
    }
    interface MintCapability<T0> {
        dummy_field: boolean;
    }
    namespace MintCapability {
        const TYPE_QNAME = "0x1::coin::MintCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<MintCapability<T0>>;
    }
    interface MintRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MintRefReceipt {
        const TYPE_QNAME = "0x1::coin::MintRefReceipt";
        function type(): TypeDescriptor<MintRefReceipt>;
    }
    interface PairCreation {
        coin_type: type_info.TypeInfo;
        fungible_asset_metadata_address: MoveAddressType;
    }
    namespace PairCreation {
        const TYPE_QNAME = "0x1::coin::PairCreation";
        function type(): TypeDescriptor<PairCreation>;
    }
    type PairCreationInstance = TypedEventInstance<PairCreation> & {
        data_decoded: PairCreation;
        type_arguments: [];
    };
    interface PairedCoinType {
        type: type_info.TypeInfo;
    }
    namespace PairedCoinType {
        const TYPE_QNAME = "0x1::coin::PairedCoinType";
        function type(): TypeDescriptor<PairedCoinType>;
    }
    interface PairedFungibleAssetRefs {
        mint_ref_opt: option.Option<fungible_asset.MintRef>;
        transfer_ref_opt: option.Option<fungible_asset.TransferRef>;
        burn_ref_opt: option.Option<fungible_asset.BurnRef>;
    }
    namespace PairedFungibleAssetRefs {
        const TYPE_QNAME = "0x1::coin::PairedFungibleAssetRefs";
        function type(): TypeDescriptor<PairedFungibleAssetRefs>;
    }
    interface SupplyConfig {
        allow_upgrades: boolean;
    }
    namespace SupplyConfig {
        const TYPE_QNAME = "0x1::coin::SupplyConfig";
        function type(): TypeDescriptor<SupplyConfig>;
    }
    interface TransferRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace TransferRefReceipt {
        const TYPE_QNAME = "0x1::coin::TransferRefReceipt";
        function type(): TypeDescriptor<TransferRefReceipt>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createCoinConversionMap(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createPairing<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function freezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function migrateCoinStoreToFungibleStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function migrateToFungibleStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unfreezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeSupply<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
        function symbol$<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[number]>;
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function coinSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function isAccountRegistered<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isCoinInitialized<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function isCoinStoreFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function pairedBurnRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function pairedCoin(client: Aptos, request: {
            functionArguments: [object$.Object<fungible_asset.Metadata>];
        }, version?: bigint): Promise<[option.Option<type_info.TypeInfo>]>;
        function pairedMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<object$.Object<fungible_asset.Metadata>>]>;
        function pairedMintRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function pairedTransferRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace guid {
    interface GUID {
        id: guid.ID;
    }
    namespace GUID {
        const TYPE_QNAME = "0x1::guid::GUID";
        function type(): TypeDescriptor<GUID>;
    }
    type GUIDInstance = TypedEventInstance<GUID> & {
        data_decoded: GUID;
        type_arguments: [];
    };
    interface ID {
        creation_num: bigint;
        addr: MoveAddressType;
    }
    namespace ID {
        const TYPE_QNAME = "0x1::guid::ID";
        function type(): TypeDescriptor<ID>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace hash {
    namespace entry { }
    namespace view { }
}
export declare namespace jwks {
    interface AllProvidersJWKs {
        entries: jwks.ProviderJWKs[];
    }
    namespace AllProvidersJWKs {
        const TYPE_QNAME = "0x1::jwks::AllProvidersJWKs";
        function type(): TypeDescriptor<AllProvidersJWKs>;
    }
    interface FederatedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace FederatedJWKs {
        const TYPE_QNAME = "0x1::jwks::FederatedJWKs";
        function type(): TypeDescriptor<FederatedJWKs>;
    }
    interface JWK {
        variant: copyable_any.Any;
    }
    namespace JWK {
        const TYPE_QNAME = "0x1::jwks::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwks::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface ObservedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKs {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKs";
        function type(): TypeDescriptor<ObservedJWKs>;
    }
    interface ObservedJWKsUpdated {
        epoch: bigint;
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKsUpdated {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKsUpdated";
        function type(): TypeDescriptor<ObservedJWKsUpdated>;
    }
    type ObservedJWKsUpdatedInstance = TypedEventInstance<ObservedJWKsUpdated> & {
        data_decoded: ObservedJWKsUpdated;
        type_arguments: [];
    };
    interface Patch {
        variant: copyable_any.Any;
    }
    namespace Patch {
        const TYPE_QNAME = "0x1::jwks::Patch";
        function type(): TypeDescriptor<Patch>;
    }
    interface PatchRemoveAll {
        dummy_field: boolean;
    }
    namespace PatchRemoveAll {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveAll";
        function type(): TypeDescriptor<PatchRemoveAll>;
    }
    interface PatchRemoveIssuer {
        issuer: string;
    }
    namespace PatchRemoveIssuer {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveIssuer";
        function type(): TypeDescriptor<PatchRemoveIssuer>;
    }
    interface PatchRemoveJWK {
        issuer: string;
        jwk_id: string;
    }
    namespace PatchRemoveJWK {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveJWK";
        function type(): TypeDescriptor<PatchRemoveJWK>;
    }
    interface PatchUpsertJWK {
        issuer: string;
        jwk: jwks.JWK;
    }
    namespace PatchUpsertJWK {
        const TYPE_QNAME = "0x1::jwks::PatchUpsertJWK";
        function type(): TypeDescriptor<PatchUpsertJWK>;
    }
    interface PatchedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace PatchedJWKs {
        const TYPE_QNAME = "0x1::jwks::PatchedJWKs";
        function type(): TypeDescriptor<PatchedJWKs>;
    }
    interface Patches {
        patches: jwks.Patch[];
    }
    namespace Patches {
        const TYPE_QNAME = "0x1::jwks::Patches";
        function type(): TypeDescriptor<Patches>;
    }
    interface ProviderJWKs {
        issuer: string;
        version: bigint;
        jwks: jwks.JWK[];
    }
    namespace ProviderJWKs {
        const TYPE_QNAME = "0x1::jwks::ProviderJWKs";
        function type(): TypeDescriptor<ProviderJWKs>;
    }
    interface RSA_JWK {
        kid: string;
        kty: string;
        alg: string;
        e: string;
        n: string;
    }
    namespace RSA_JWK {
        const TYPE_QNAME = "0x1::jwks::RSA_JWK";
        function type(): TypeDescriptor<RSA_JWK>;
    }
    interface SupportedOIDCProviders {
        providers: jwks.OIDCProvider[];
    }
    namespace SupportedOIDCProviders {
        const TYPE_QNAME = "0x1::jwks::SupportedOIDCProviders";
        function type(): TypeDescriptor<SupportedOIDCProviders>;
    }
    interface UnsupportedJWK {
        id: string;
        payload: string;
    }
    namespace UnsupportedJWK {
        const TYPE_QNAME = "0x1::jwks::UnsupportedJWK";
        function type(): TypeDescriptor<UnsupportedJWK>;
    }
    namespace entry {
        function updateFederatedJwkSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[], string[], string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace util {
    namespace entry { }
    namespace view { }
}
export declare namespace block {
    interface BlockResource {
        height: bigint;
        epoch_interval: bigint;
        new_block_events: event.EventHandle<block.NewBlockEvent>;
        update_epoch_interval_events: event.EventHandle<block.UpdateEpochIntervalEvent>;
    }
    namespace BlockResource {
        const TYPE_QNAME = "0x1::block::BlockResource";
        function type(): TypeDescriptor<BlockResource>;
    }
    interface CommitHistory {
        max_capacity: number;
        next_idx: number;
        table: table_with_length.TableWithLength<number, block.NewBlockEvent>;
    }
    namespace CommitHistory {
        const TYPE_QNAME = "0x1::block::CommitHistory";
        function type(): TypeDescriptor<CommitHistory>;
    }
    interface NewBlock {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlock {
        const TYPE_QNAME = "0x1::block::NewBlock";
        function type(): TypeDescriptor<NewBlock>;
    }
    type NewBlockInstance = TypedEventInstance<NewBlock> & {
        data_decoded: NewBlock;
        type_arguments: [];
    };
    interface NewBlockEvent {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlockEvent {
        const TYPE_QNAME = "0x1::block::NewBlockEvent";
        function type(): TypeDescriptor<NewBlockEvent>;
    }
    type NewBlockEventInstance = TypedEventInstance<NewBlockEvent> & {
        data_decoded: NewBlockEvent;
        type_arguments: [];
    };
    interface UpdateEpochInterval {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochInterval {
        const TYPE_QNAME = "0x1::block::UpdateEpochInterval";
        function type(): TypeDescriptor<UpdateEpochInterval>;
    }
    type UpdateEpochIntervalInstance = TypedEventInstance<UpdateEpochInterval> & {
        data_decoded: UpdateEpochInterval;
        type_arguments: [];
    };
    interface UpdateEpochIntervalEvent {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochIntervalEvent {
        const TYPE_QNAME = "0x1::block::UpdateEpochIntervalEvent";
        function type(): TypeDescriptor<UpdateEpochIntervalEvent>;
    }
    type UpdateEpochIntervalEventInstance = TypedEventInstance<UpdateEpochIntervalEvent> & {
        data_decoded: UpdateEpochIntervalEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view {
        function getCurrentBlockHeight(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getEpochIntervalSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace debug {
    namespace entry { }
    namespace view { }
}
export declare namespace error {
    namespace entry { }
    namespace view { }
}
export declare namespace event {
    interface EventHandle<T0> {
        counter: bigint;
        guid: guid.GUID;
    }
    namespace EventHandle {
        const TYPE_QNAME = "0x1::event::EventHandle";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<EventHandle<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace stake {
    interface AddStake {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::stake::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::stake::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface AllowedValidators {
        accounts: MoveAddressType[];
    }
    namespace AllowedValidators {
        const TYPE_QNAME = "0x1::stake::AllowedValidators";
        function type(): TypeDescriptor<AllowedValidators>;
    }
    interface AptosCoinCapabilities {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::stake::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface DistributeRewards {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewards {
        const TYPE_QNAME = "0x1::stake::DistributeRewards";
        function type(): TypeDescriptor<DistributeRewards>;
    }
    type DistributeRewardsInstance = TypedEventInstance<DistributeRewards> & {
        data_decoded: DistributeRewards;
        type_arguments: [];
    };
    interface DistributeRewardsEvent {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewardsEvent {
        const TYPE_QNAME = "0x1::stake::DistributeRewardsEvent";
        function type(): TypeDescriptor<DistributeRewardsEvent>;
    }
    type DistributeRewardsEventInstance = TypedEventInstance<DistributeRewardsEvent> & {
        data_decoded: DistributeRewardsEvent;
        type_arguments: [];
    };
    interface DistributeTransactionFee {
        pool_address: MoveAddressType;
        fee_amount: bigint;
    }
    namespace DistributeTransactionFee {
        const TYPE_QNAME = "0x1::stake::DistributeTransactionFee";
        function type(): TypeDescriptor<DistributeTransactionFee>;
    }
    type DistributeTransactionFeeInstance = TypedEventInstance<DistributeTransactionFee> & {
        data_decoded: DistributeTransactionFee;
        type_arguments: [];
    };
    interface IncreaseLockup {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockup {
        const TYPE_QNAME = "0x1::stake::IncreaseLockup";
        function type(): TypeDescriptor<IncreaseLockup>;
    }
    type IncreaseLockupInstance = TypedEventInstance<IncreaseLockup> & {
        data_decoded: IncreaseLockup;
        type_arguments: [];
    };
    interface IncreaseLockupEvent {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockupEvent {
        const TYPE_QNAME = "0x1::stake::IncreaseLockupEvent";
        function type(): TypeDescriptor<IncreaseLockupEvent>;
    }
    type IncreaseLockupEventInstance = TypedEventInstance<IncreaseLockupEvent> & {
        data_decoded: IncreaseLockupEvent;
        type_arguments: [];
    };
    interface IndividualValidatorPerformance {
        successful_proposals: bigint;
        failed_proposals: bigint;
    }
    namespace IndividualValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::IndividualValidatorPerformance";
        function type(): TypeDescriptor<IndividualValidatorPerformance>;
    }
    type IndividualValidatorPerformanceInstance = TypedEventInstance<IndividualValidatorPerformance> & {
        data_decoded: IndividualValidatorPerformance;
        type_arguments: [];
    };
    interface JoinValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSet {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSet";
        function type(): TypeDescriptor<JoinValidatorSet>;
    }
    type JoinValidatorSetInstance = TypedEventInstance<JoinValidatorSet> & {
        data_decoded: JoinValidatorSet;
        type_arguments: [];
    };
    interface JoinValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSetEvent";
        function type(): TypeDescriptor<JoinValidatorSetEvent>;
    }
    type JoinValidatorSetEventInstance = TypedEventInstance<JoinValidatorSetEvent> & {
        data_decoded: JoinValidatorSetEvent;
        type_arguments: [];
    };
    interface LeaveValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSet {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSet";
        function type(): TypeDescriptor<LeaveValidatorSet>;
    }
    type LeaveValidatorSetInstance = TypedEventInstance<LeaveValidatorSet> & {
        data_decoded: LeaveValidatorSet;
        type_arguments: [];
    };
    interface LeaveValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSetEvent";
        function type(): TypeDescriptor<LeaveValidatorSetEvent>;
    }
    type LeaveValidatorSetEventInstance = TypedEventInstance<LeaveValidatorSetEvent> & {
        data_decoded: LeaveValidatorSetEvent;
        type_arguments: [];
    };
    interface OwnerCapability {
        pool_address: MoveAddressType;
    }
    namespace OwnerCapability {
        const TYPE_QNAME = "0x1::stake::OwnerCapability";
        function type(): TypeDescriptor<OwnerCapability>;
    }
    interface PendingTransactionFee {
        pending_fee_by_validator: big_ordered_map.BigOrderedMap<bigint, aggregator_v2.Aggregator<bigint>>;
    }
    namespace PendingTransactionFee {
        const TYPE_QNAME = "0x1::stake::PendingTransactionFee";
        function type(): TypeDescriptor<PendingTransactionFee>;
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::stake::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    type ReactivateStakeInstance = TypedEventInstance<ReactivateStake> & {
        data_decoded: ReactivateStake;
        type_arguments: [];
    };
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::stake::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    type ReactivateStakeEventInstance = TypedEventInstance<ReactivateStakeEvent> & {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    };
    interface RegisterValidatorCandidate {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidate {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidate";
        function type(): TypeDescriptor<RegisterValidatorCandidate>;
    }
    type RegisterValidatorCandidateInstance = TypedEventInstance<RegisterValidatorCandidate> & {
        data_decoded: RegisterValidatorCandidate;
        type_arguments: [];
    };
    interface RegisterValidatorCandidateEvent {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidateEvent {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidateEvent";
        function type(): TypeDescriptor<RegisterValidatorCandidateEvent>;
    }
    type RegisterValidatorCandidateEventInstance = TypedEventInstance<RegisterValidatorCandidateEvent> & {
        data_decoded: RegisterValidatorCandidateEvent;
        type_arguments: [];
    };
    interface RotateConsensusKey {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKey {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKey";
        function type(): TypeDescriptor<RotateConsensusKey>;
    }
    type RotateConsensusKeyInstance = TypedEventInstance<RotateConsensusKey> & {
        data_decoded: RotateConsensusKey;
        type_arguments: [];
    };
    interface RotateConsensusKeyEvent {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKeyEvent {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKeyEvent";
        function type(): TypeDescriptor<RotateConsensusKeyEvent>;
    }
    type RotateConsensusKeyEventInstance = TypedEventInstance<RotateConsensusKeyEvent> & {
        data_decoded: RotateConsensusKeyEvent;
        type_arguments: [];
    };
    interface SetOperator {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperator {
        const TYPE_QNAME = "0x1::stake::SetOperator";
        function type(): TypeDescriptor<SetOperator>;
    }
    type SetOperatorInstance = TypedEventInstance<SetOperator> & {
        data_decoded: SetOperator;
        type_arguments: [];
    };
    interface SetOperatorEvent {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperatorEvent {
        const TYPE_QNAME = "0x1::stake::SetOperatorEvent";
        function type(): TypeDescriptor<SetOperatorEvent>;
    }
    type SetOperatorEventInstance = TypedEventInstance<SetOperatorEvent> & {
        data_decoded: SetOperatorEvent;
        type_arguments: [];
    };
    interface StakeManagementPermission {
        dummy_field: boolean;
    }
    namespace StakeManagementPermission {
        const TYPE_QNAME = "0x1::stake::StakeManagementPermission";
        function type(): TypeDescriptor<StakeManagementPermission>;
    }
    interface StakePool {
        active: coin.Coin<aptos_coin.AptosCoin>;
        inactive: coin.Coin<aptos_coin.AptosCoin>;
        pending_active: coin.Coin<aptos_coin.AptosCoin>;
        pending_inactive: coin.Coin<aptos_coin.AptosCoin>;
        locked_until_secs: bigint;
        operator_address: MoveAddressType;
        delegated_voter: MoveAddressType;
        initialize_validator_events: event.EventHandle<stake.RegisterValidatorCandidateEvent>;
        set_operator_events: event.EventHandle<stake.SetOperatorEvent>;
        add_stake_events: event.EventHandle<stake.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<stake.ReactivateStakeEvent>;
        rotate_consensus_key_events: event.EventHandle<stake.RotateConsensusKeyEvent>;
        update_network_and_fullnode_addresses_events: event.EventHandle<stake.UpdateNetworkAndFullnodeAddressesEvent>;
        increase_lockup_events: event.EventHandle<stake.IncreaseLockupEvent>;
        join_validator_set_events: event.EventHandle<stake.JoinValidatorSetEvent>;
        distribute_rewards_events: event.EventHandle<stake.DistributeRewardsEvent>;
        unlock_stake_events: event.EventHandle<stake.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<stake.WithdrawStakeEvent>;
        leave_validator_set_events: event.EventHandle<stake.LeaveValidatorSetEvent>;
    }
    namespace StakePool {
        const TYPE_QNAME = "0x1::stake::StakePool";
        function type(): TypeDescriptor<StakePool>;
    }
    interface TransactionFeeConfig {
    }
    namespace TransactionFeeConfig {
        const TYPE_QNAME = "0x1::stake::TransactionFeeConfig";
        function type(): TypeDescriptor<TransactionFeeConfig>;
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::stake::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::stake::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface UpdateNetworkAndFullnodeAddresses {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddresses {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddresses";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddresses>;
    }
    type UpdateNetworkAndFullnodeAddressesInstance = TypedEventInstance<UpdateNetworkAndFullnodeAddresses> & {
        data_decoded: UpdateNetworkAndFullnodeAddresses;
        type_arguments: [];
    };
    interface UpdateNetworkAndFullnodeAddressesEvent {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddressesEvent {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddressesEvent";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddressesEvent>;
    }
    type UpdateNetworkAndFullnodeAddressesEventInstance = TypedEventInstance<UpdateNetworkAndFullnodeAddressesEvent> & {
        data_decoded: UpdateNetworkAndFullnodeAddressesEvent;
        type_arguments: [];
    };
    interface ValidatorConfig {
        consensus_pubkey: string;
        network_addresses: string;
        fullnode_addresses: string;
        validator_index: bigint;
    }
    namespace ValidatorConfig {
        const TYPE_QNAME = "0x1::stake::ValidatorConfig";
        function type(): TypeDescriptor<ValidatorConfig>;
    }
    interface ValidatorFees {
        fees_table: table.Table<MoveAddressType, coin.Coin<aptos_coin.AptosCoin>>;
    }
    namespace ValidatorFees {
        const TYPE_QNAME = "0x1::stake::ValidatorFees";
        function type(): TypeDescriptor<ValidatorFees>;
    }
    interface ValidatorInfo {
        addr: MoveAddressType;
        voting_power: bigint;
        config: stake.ValidatorConfig;
    }
    namespace ValidatorInfo {
        const TYPE_QNAME = "0x1::stake::ValidatorInfo";
        function type(): TypeDescriptor<ValidatorInfo>;
    }
    interface ValidatorPerformance {
        validators: stake.IndividualValidatorPerformance[];
    }
    namespace ValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::ValidatorPerformance";
        function type(): TypeDescriptor<ValidatorPerformance>;
    }
    interface ValidatorSet {
        consensus_scheme: number;
        active_validators: stake.ValidatorInfo[];
        pending_inactive: stake.ValidatorInfo[];
        pending_active: stake.ValidatorInfo[];
        total_voting_power: bigint;
        total_joining_power: bigint;
    }
    namespace ValidatorSet {
        const TYPE_QNAME = "0x1::stake::ValidatorSet";
        function type(): TypeDescriptor<ValidatorSet>;
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::stake::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    type WithdrawStakeInstance = TypedEventInstance<WithdrawStake> & {
        data_decoded: WithdrawStake;
        type_arguments: [];
    };
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::stake::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    type WithdrawStakeEventInstance = TypedEventInstance<WithdrawStakeEvent> & {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    };
    namespace entry {
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function increaseLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeStakeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeValidator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function joinValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function leaveValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateConsensusKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateNetworkAndFullnodeAddresses(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getCurrentEpochProposalCounts(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function getCurrentEpochVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegatedVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getPendingTransactionFee(client: Aptos, version?: bigint): Promise<[bigint[]]>;
        function getRemainingLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getValidatorConfig(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string, string, string]>;
        function getValidatorIndex(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getValidatorState(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace table {
    interface Box<T0> {
        val: T0;
    }
    namespace Box {
        const TYPE_QNAME = "0x1::table::Box";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Box<T0>>;
    }
    interface Table<T0, T1> {
        handle: MoveAddressType;
    }
    namespace Table {
        const TYPE_QNAME = "0x1::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace base16 {
    namespace entry { }
    namespace view { }
}
export declare namespace math64 {
    namespace entry { }
    namespace view { }
}
export declare namespace object$ {
    interface ConstructorRef {
        self: MoveAddressType;
        can_delete: boolean;
    }
    namespace ConstructorRef {
        const TYPE_QNAME = "0x1::object::ConstructorRef";
        function type(): TypeDescriptor<ConstructorRef>;
    }
    interface DeleteRef {
        self: MoveAddressType;
    }
    namespace DeleteRef {
        const TYPE_QNAME = "0x1::object::DeleteRef";
        function type(): TypeDescriptor<DeleteRef>;
    }
    type DeleteRefInstance = TypedEventInstance<DeleteRef> & {
        data_decoded: DeleteRef;
        type_arguments: [];
    };
    interface DeriveRef {
        self: MoveAddressType;
    }
    namespace DeriveRef {
        const TYPE_QNAME = "0x1::object::DeriveRef";
        function type(): TypeDescriptor<DeriveRef>;
    }
    type DeriveRefInstance = TypedEventInstance<DeriveRef> & {
        data_decoded: DeriveRef;
        type_arguments: [];
    };
    interface ExtendRef {
        self: MoveAddressType;
    }
    namespace ExtendRef {
        const TYPE_QNAME = "0x1::object::ExtendRef";
        function type(): TypeDescriptor<ExtendRef>;
    }
    type ExtendRefInstance = TypedEventInstance<ExtendRef> & {
        data_decoded: ExtendRef;
        type_arguments: [];
    };
    interface LinearTransferRef {
        self: MoveAddressType;
        owner: MoveAddressType;
    }
    namespace LinearTransferRef {
        const TYPE_QNAME = "0x1::object::LinearTransferRef";
        function type(): TypeDescriptor<LinearTransferRef>;
    }
    type Object<T> = MoveAddressType;
    namespace Object {
        const TYPE_QNAME = "0x1::object::Object";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Object<T0>>;
    }
    interface ObjectCore {
        guid_creation_num: bigint;
        owner: MoveAddressType;
        allow_ungated_transfer: boolean;
        transfer_events: event.EventHandle<object$.TransferEvent>;
    }
    namespace ObjectCore {
        const TYPE_QNAME = "0x1::object::ObjectCore";
        function type(): TypeDescriptor<ObjectCore>;
    }
    interface ObjectGroup {
        dummy_field: boolean;
    }
    namespace ObjectGroup {
        const TYPE_QNAME = "0x1::object::ObjectGroup";
        function type(): TypeDescriptor<ObjectGroup>;
    }
    interface TombStone {
        original_owner: MoveAddressType;
    }
    namespace TombStone {
        const TYPE_QNAME = "0x1::object::TombStone";
        function type(): TypeDescriptor<TombStone>;
    }
    interface Transfer {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace Transfer {
        const TYPE_QNAME = "0x1::object::Transfer";
        function type(): TypeDescriptor<Transfer>;
    }
    type TransferInstance = TypedEventInstance<Transfer> & {
        data_decoded: Transfer;
        type_arguments: [];
    };
    interface TransferEvent {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace TransferEvent {
        const TYPE_QNAME = "0x1::object::TransferEvent";
        function type(): TypeDescriptor<TransferEvent>;
    }
    type TransferEventInstance = TypedEventInstance<TransferEvent> & {
        data_decoded: TransferEvent;
        type_arguments: [];
    };
    interface TransferPermission {
        object: MoveAddressType;
    }
    namespace TransferPermission {
        const TYPE_QNAME = "0x1::object::TransferPermission";
        function type(): TypeDescriptor<TransferPermission>;
    }
    interface TransferRef {
        self: MoveAddressType;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::object::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    type TransferRefInstance = TypedEventInstance<TransferRef> & {
        data_decoded: TransferRef;
        type_arguments: [];
    };
    interface Untransferable {
        dummy_field: boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::object::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    namespace entry {
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferToObject<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T1>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unburn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function owner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function isBurnt<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isOwner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function owns<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function rootOwner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
    }
}
export declare namespace option {
    interface Option<T0> {
        vec: T0[];
    }
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace signer {
    namespace entry { }
    namespace view { }
}
export declare namespace string$ {
    interface String {
        bytes: string;
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace vector {
    namespace entry { }
    namespace view { }
}
export declare namespace voting {
    interface CreateProposal {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::voting::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::voting::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Proposal<T0> {
        proposer: MoveAddressType;
        execution_content: option.Option<T0>;
        metadata: simple_map.SimpleMap<string, string>;
        creation_time_secs: bigint;
        execution_hash: string;
        min_vote_threshold: bigint;
        expiration_secs: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        yes_votes: bigint;
        no_votes: bigint;
        is_resolved: boolean;
        resolution_time_secs: bigint;
    }
    namespace Proposal {
        const TYPE_QNAME = "0x1::voting::Proposal";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Proposal<T0>>;
    }
    interface RegisterForum {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForum {
        const TYPE_QNAME = "0x1::voting::RegisterForum";
        function type(): TypeDescriptor<RegisterForum>;
    }
    type RegisterForumInstance = TypedEventInstance<RegisterForum> & {
        data_decoded: RegisterForum;
        type_arguments: [];
    };
    interface RegisterForumEvent {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForumEvent {
        const TYPE_QNAME = "0x1::voting::RegisterForumEvent";
        function type(): TypeDescriptor<RegisterForumEvent>;
    }
    type RegisterForumEventInstance = TypedEventInstance<RegisterForumEvent> & {
        data_decoded: RegisterForumEvent;
        type_arguments: [];
    };
    interface ResolveProposal {
        proposal_id: bigint;
        yes_votes: bigint;
        no_votes: bigint;
        resolved_early: boolean;
    }
    namespace ResolveProposal {
        const TYPE_QNAME = "0x1::voting::ResolveProposal";
        function type(): TypeDescriptor<ResolveProposal>;
    }
    type ResolveProposalInstance = TypedEventInstance<ResolveProposal> & {
        data_decoded: ResolveProposal;
        type_arguments: [];
    };
    interface Vote {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::voting::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::voting::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface VotePermission {
        dummy_field: boolean;
    }
    namespace VotePermission {
        const TYPE_QNAME = "0x1::voting::VotePermission";
        function type(): TypeDescriptor<VotePermission>;
    }
    interface VotingEvents {
        create_proposal_events: event.EventHandle<voting.CreateProposalEvent>;
        register_forum_events: event.EventHandle<voting.RegisterForumEvent>;
        resolve_proposal_events: event.EventHandle<voting.ResolveProposal>;
        vote_events: event.EventHandle<voting.VoteEvent>;
    }
    namespace VotingEvents {
        const TYPE_QNAME = "0x1::voting::VotingEvents";
        function type(): TypeDescriptor<VotingEvents>;
    }
    interface VotingForum<T0> {
        proposals: table.Table<bigint, voting.Proposal<T0>>;
        events: voting.VotingEvents;
        next_proposal_id: bigint;
    }
    namespace VotingForum {
        const TYPE_QNAME = "0x1::voting::VotingForum";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VotingForum<T0>>;
    }
    namespace entry { }
    namespace view {
        function getEarlyResolutionVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function getExecutionHash<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[string]>;
        function getMinVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalCreationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalExpirationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function getProposalMetadataValue<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint, string];
        }, version?: bigint): Promise<[string]>;
        function getProposalState<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposer<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getResolutionTimeSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getVotes<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function isMultiStepProposalInExecution<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isResolved<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isVotingClosed<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function nextProposalId<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace account {
    interface Account {
        authentication_key: string;
        sequence_number: bigint;
        guid_creation_num: bigint;
        coin_register_events: event.EventHandle<account.CoinRegisterEvent>;
        key_rotation_events: event.EventHandle<account.KeyRotationEvent>;
        rotation_capability_offer: account.CapabilityOffer<account.RotationCapability>;
        signer_capability_offer: account.CapabilityOffer<account.SignerCapability>;
    }
    namespace Account {
        const TYPE_QNAME = "0x1::account::Account";
        function type(): TypeDescriptor<Account>;
    }
    interface AccountPermission {
    }
    namespace AccountPermission {
        const TYPE_QNAME = "0x1::account::AccountPermission";
        function type(): TypeDescriptor<AccountPermission>;
    }
    interface CapabilityOffer<T0> {
        for: option.Option<MoveAddressType>;
    }
    namespace CapabilityOffer {
        const TYPE_QNAME = "0x1::account::CapabilityOffer";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapabilityOffer<T0>>;
    }
    interface CoinRegister {
        account: MoveAddressType;
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegister {
        const TYPE_QNAME = "0x1::account::CoinRegister";
        function type(): TypeDescriptor<CoinRegister>;
    }
    type CoinRegisterInstance = TypedEventInstance<CoinRegister> & {
        data_decoded: CoinRegister;
        type_arguments: [];
    };
    interface CoinRegisterEvent {
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegisterEvent {
        const TYPE_QNAME = "0x1::account::CoinRegisterEvent";
        function type(): TypeDescriptor<CoinRegisterEvent>;
    }
    type CoinRegisterEventInstance = TypedEventInstance<CoinRegisterEvent> & {
        data_decoded: CoinRegisterEvent;
        type_arguments: [];
    };
    interface KeyRotation {
        account: MoveAddressType;
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotation {
        const TYPE_QNAME = "0x1::account::KeyRotation";
        function type(): TypeDescriptor<KeyRotation>;
    }
    type KeyRotationInstance = TypedEventInstance<KeyRotation> & {
        data_decoded: KeyRotation;
        type_arguments: [];
    };
    interface KeyRotationEvent {
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotationEvent {
        const TYPE_QNAME = "0x1::account::KeyRotationEvent";
        function type(): TypeDescriptor<KeyRotationEvent>;
    }
    type KeyRotationEventInstance = TypedEventInstance<KeyRotationEvent> & {
        data_decoded: KeyRotationEvent;
        type_arguments: [];
    };
    interface KeyRotationToPublicKey {
        account: MoveAddressType;
        verified_public_key_bit_map: string;
        public_key_scheme: number;
        public_key: string;
        old_auth_key: string;
        new_auth_key: string;
    }
    namespace KeyRotationToPublicKey {
        const TYPE_QNAME = "0x1::account::KeyRotationToPublicKey";
        function type(): TypeDescriptor<KeyRotationToPublicKey>;
    }
    type KeyRotationToPublicKeyInstance = TypedEventInstance<KeyRotationToPublicKey> & {
        data_decoded: KeyRotationToPublicKey;
        type_arguments: [];
    };
    interface OriginatingAddress {
        address_map: table.Table<MoveAddressType, MoveAddressType>;
    }
    namespace OriginatingAddress {
        const TYPE_QNAME = "0x1::account::OriginatingAddress";
        function type(): TypeDescriptor<OriginatingAddress>;
    }
    interface RotationCapability {
        account: MoveAddressType;
    }
    namespace RotationCapability {
        const TYPE_QNAME = "0x1::account::RotationCapability";
        function type(): TypeDescriptor<RotationCapability>;
    }
    type RotationCapabilityInstance = TypedEventInstance<RotationCapability> & {
        data_decoded: RotationCapability;
        type_arguments: [];
    };
    interface RotationCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallenge>;
    }
    interface RotationCapabilityOfferProofChallengeV2 {
        chain_id: number;
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallengeV2>;
    }
    interface RotationProofChallenge {
        sequence_number: bigint;
        originator: MoveAddressType;
        current_auth_key: MoveAddressType;
        new_public_key: string;
    }
    namespace RotationProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationProofChallenge";
        function type(): TypeDescriptor<RotationProofChallenge>;
    }
    interface SignerCapability {
        account: MoveAddressType;
    }
    namespace SignerCapability {
        const TYPE_QNAME = "0x1::account::SignerCapability";
        function type(): TypeDescriptor<SignerCapability>;
    }
    type SignerCapabilityInstance = TypedEventInstance<SignerCapability> & {
        data_decoded: SignerCapability;
        type_arguments: [];
    };
    interface SignerCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallenge>;
    }
    interface SignerCapabilityOfferProofChallengeV2 {
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallengeV2>;
    }
    namespace entry {
        function offerRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function offerSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnyRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnySignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [number, string, number, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyFromPublicKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [number, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyWithRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, number, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOriginatingAddress(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upsertEd25519BackupKeyOnKeylessAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function existsAt(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getAuthenticationKey(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string]>;
        function getGuidNextCreationNum(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getRotationCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getSignerCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function isRotationCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isSignerCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function originatingAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<MoveAddressType>]>;
    }
}
export declare namespace ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignedMessage<T0> {
        type_info: type_info.TypeInfo;
        inner: T0;
    }
    namespace SignedMessage {
        const TYPE_QNAME = "0x1::ed25519::SignedMessage";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SignedMessage<T0>>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace genesis {
    interface AccountMap {
        account_address: MoveAddressType;
        balance: bigint;
    }
    namespace AccountMap {
        const TYPE_QNAME = "0x1::genesis::AccountMap";
        function type(): TypeDescriptor<AccountMap>;
    }
    interface EmployeeAccountMap {
        accounts: MoveAddressType[];
        validator: genesis.ValidatorConfigurationWithCommission;
        vesting_schedule_numerator: bigint[];
        vesting_schedule_denominator: bigint;
        beneficiary_resetter: MoveAddressType;
    }
    namespace EmployeeAccountMap {
        const TYPE_QNAME = "0x1::genesis::EmployeeAccountMap";
        function type(): TypeDescriptor<EmployeeAccountMap>;
    }
    interface ValidatorConfiguration {
        owner_address: MoveAddressType;
        operator_address: MoveAddressType;
        voter_address: MoveAddressType;
        stake_amount: bigint;
        consensus_pubkey: string;
        proof_of_possession: string;
        network_addresses: string;
        full_node_network_addresses: string;
    }
    namespace ValidatorConfiguration {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfiguration";
        function type(): TypeDescriptor<ValidatorConfiguration>;
    }
    interface ValidatorConfigurationWithCommission {
        validator_config: genesis.ValidatorConfiguration;
        commission_percentage: bigint;
        join_during_genesis: boolean;
    }
    namespace ValidatorConfigurationWithCommission {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfigurationWithCommission";
        function type(): TypeDescriptor<ValidatorConfigurationWithCommission>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace keyless {
    interface PublicKey {
        iss: string;
        idc: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::keyless::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math128 {
    namespace entry { }
    namespace view { }
}
export declare namespace version {
    interface SetVersionCapability {
        dummy_field: boolean;
    }
    namespace SetVersionCapability {
        const TYPE_QNAME = "0x1::version::SetVersionCapability";
        function type(): TypeDescriptor<SetVersionCapability>;
    }
    interface Version {
        major: bigint;
    }
    namespace Version {
        const TYPE_QNAME = "0x1::version::Version";
        function type(): TypeDescriptor<Version>;
    }
    namespace entry {
        function setForNextEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVersion(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace vesting {
    interface Distribute {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::vesting::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    type DistributeInstance = TypedEventInstance<Distribute> & {
        data_decoded: Distribute;
        type_arguments: [];
    };
    interface DistributeEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::vesting::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    type DistributeEventInstance = TypedEventInstance<DistributeEvent> & {
        data_decoded: DistributeEvent;
        type_arguments: [];
    };
    interface ResetLockup {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::vesting::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    type ResetLockupInstance = TypedEventInstance<ResetLockup> & {
        data_decoded: ResetLockup;
        type_arguments: [];
    };
    interface ResetLockupEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::vesting::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    type ResetLockupEventInstance = TypedEventInstance<ResetLockupEvent> & {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    };
    interface UpdateVoter {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::vesting::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    type UpdateVoterInstance = TypedEventInstance<UpdateVoter> & {
        data_decoded: UpdateVoter;
        type_arguments: [];
    };
    interface UpdateVoterEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    type UpdateVoterEventInstance = TypedEventInstance<UpdateVoterEvent> & {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    };
    interface AdminStore {
        vesting_contracts: MoveAddressType[];
        nonce: bigint;
        create_events: event.EventHandle<vesting.CreateVestingContractEvent>;
    }
    namespace AdminStore {
        const TYPE_QNAME = "0x1::vesting::AdminStore";
        function type(): TypeDescriptor<AdminStore>;
    }
    interface AdminWithdraw {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdraw {
        const TYPE_QNAME = "0x1::vesting::AdminWithdraw";
        function type(): TypeDescriptor<AdminWithdraw>;
    }
    type AdminWithdrawInstance = TypedEventInstance<AdminWithdraw> & {
        data_decoded: AdminWithdraw;
        type_arguments: [];
    };
    interface AdminWithdrawEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdrawEvent {
        const TYPE_QNAME = "0x1::vesting::AdminWithdrawEvent";
        function type(): TypeDescriptor<AdminWithdrawEvent>;
    }
    type AdminWithdrawEventInstance = TypedEventInstance<AdminWithdrawEvent> & {
        data_decoded: AdminWithdrawEvent;
        type_arguments: [];
    };
    interface CreateVestingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContract {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContract";
        function type(): TypeDescriptor<CreateVestingContract>;
    }
    type CreateVestingContractInstance = TypedEventInstance<CreateVestingContract> & {
        data_decoded: CreateVestingContract;
        type_arguments: [];
    };
    interface CreateVestingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContractEvent {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContractEvent";
        function type(): TypeDescriptor<CreateVestingContractEvent>;
    }
    type CreateVestingContractEventInstance = TypedEventInstance<CreateVestingContractEvent> & {
        data_decoded: CreateVestingContractEvent;
        type_arguments: [];
    };
    interface SetBeneficiary {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiary {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiary";
        function type(): TypeDescriptor<SetBeneficiary>;
    }
    type SetBeneficiaryInstance = TypedEventInstance<SetBeneficiary> & {
        data_decoded: SetBeneficiary;
        type_arguments: [];
    };
    interface SetBeneficiaryEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryEvent {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiaryEvent";
        function type(): TypeDescriptor<SetBeneficiaryEvent>;
    }
    type SetBeneficiaryEventInstance = TypedEventInstance<SetBeneficiaryEvent> & {
        data_decoded: SetBeneficiaryEvent;
        type_arguments: [];
    };
    interface StakingInfo {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        voter: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace StakingInfo {
        const TYPE_QNAME = "0x1::vesting::StakingInfo";
        function type(): TypeDescriptor<StakingInfo>;
    }
    interface Terminate {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace Terminate {
        const TYPE_QNAME = "0x1::vesting::Terminate";
        function type(): TypeDescriptor<Terminate>;
    }
    type TerminateInstance = TypedEventInstance<Terminate> & {
        data_decoded: Terminate;
        type_arguments: [];
    };
    interface TerminateEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace TerminateEvent {
        const TYPE_QNAME = "0x1::vesting::TerminateEvent";
        function type(): TypeDescriptor<TerminateEvent>;
    }
    type TerminateEventInstance = TypedEventInstance<TerminateEvent> & {
        data_decoded: TerminateEvent;
        type_arguments: [];
    };
    interface UnlockRewards {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewards {
        const TYPE_QNAME = "0x1::vesting::UnlockRewards";
        function type(): TypeDescriptor<UnlockRewards>;
    }
    type UnlockRewardsInstance = TypedEventInstance<UnlockRewards> & {
        data_decoded: UnlockRewards;
        type_arguments: [];
    };
    interface UnlockRewardsEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewardsEvent {
        const TYPE_QNAME = "0x1::vesting::UnlockRewardsEvent";
        function type(): TypeDescriptor<UnlockRewardsEvent>;
    }
    type UnlockRewardsEventInstance = TypedEventInstance<UnlockRewardsEvent> & {
        data_decoded: UnlockRewardsEvent;
        type_arguments: [];
    };
    interface UpdateOperator {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperator {
        const TYPE_QNAME = "0x1::vesting::UpdateOperator";
        function type(): TypeDescriptor<UpdateOperator>;
    }
    type UpdateOperatorInstance = TypedEventInstance<UpdateOperator> & {
        data_decoded: UpdateOperator;
        type_arguments: [];
    };
    interface UpdateOperatorEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperatorEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateOperatorEvent";
        function type(): TypeDescriptor<UpdateOperatorEvent>;
    }
    type UpdateOperatorEventInstance = TypedEventInstance<UpdateOperatorEvent> & {
        data_decoded: UpdateOperatorEvent;
        type_arguments: [];
    };
    interface Vest {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace Vest {
        const TYPE_QNAME = "0x1::vesting::Vest";
        function type(): TypeDescriptor<Vest>;
    }
    type VestInstance = TypedEventInstance<Vest> & {
        data_decoded: Vest;
        type_arguments: [];
    };
    interface VestEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace VestEvent {
        const TYPE_QNAME = "0x1::vesting::VestEvent";
        function type(): TypeDescriptor<VestEvent>;
    }
    type VestEventInstance = TypedEventInstance<VestEvent> & {
        data_decoded: VestEvent;
        type_arguments: [];
    };
    interface VestPermission {
        dummy_field: boolean;
    }
    namespace VestPermission {
        const TYPE_QNAME = "0x1::vesting::VestPermission";
        function type(): TypeDescriptor<VestPermission>;
    }
    interface VestingAccountManagement {
        roles: simple_map.SimpleMap<string, MoveAddressType>;
    }
    namespace VestingAccountManagement {
        const TYPE_QNAME = "0x1::vesting::VestingAccountManagement";
        function type(): TypeDescriptor<VestingAccountManagement>;
    }
    interface VestingContract {
        state: bigint;
        admin: MoveAddressType;
        grant_pool: pool_u64.Pool;
        beneficiaries: simple_map.SimpleMap<MoveAddressType, MoveAddressType>;
        vesting_schedule: vesting.VestingSchedule;
        withdrawal_address: MoveAddressType;
        staking: vesting.StakingInfo;
        remaining_grant: bigint;
        signer_cap: account.SignerCapability;
        update_operator_events: event.EventHandle<vesting.UpdateOperatorEvent>;
        update_voter_events: event.EventHandle<vesting.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<vesting.ResetLockupEvent>;
        set_beneficiary_events: event.EventHandle<vesting.SetBeneficiaryEvent>;
        unlock_rewards_events: event.EventHandle<vesting.UnlockRewardsEvent>;
        vest_events: event.EventHandle<vesting.VestEvent>;
        distribute_events: event.EventHandle<vesting.DistributeEvent>;
        terminate_events: event.EventHandle<vesting.TerminateEvent>;
        admin_withdraw_events: event.EventHandle<vesting.AdminWithdrawEvent>;
    }
    namespace VestingContract {
        const TYPE_QNAME = "0x1::vesting::VestingContract";
        function type(): TypeDescriptor<VestingContract>;
    }
    interface VestingSchedule {
        schedule: fixed_point32.FixedPoint32[];
        start_timestamp_secs: bigint;
        period_duration: bigint;
        last_vested_period: bigint;
    }
    namespace VestingSchedule {
        const TYPE_QNAME = "0x1::vesting::VestingSchedule";
        function type(): TypeDescriptor<VestingSchedule>;
    }
    namespace entry {
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function adminWithdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distributeMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryResetter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setManagementRole(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function terminateVestingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewardsMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vest(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vestMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function operator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function voter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function shareholder(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function beneficiary(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function shareholders(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function accumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function vestingSchedule(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[vesting.VestingSchedule]>;
        function periodDurationSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function remainingGrant(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function totalAccumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function vestingContracts(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function vestingStartSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace bls12381 {
    interface AggrOrMultiSignature {
        bytes: string;
    }
    namespace AggrOrMultiSignature {
        const TYPE_QNAME = "0x1::bls12381::AggrOrMultiSignature";
        function type(): TypeDescriptor<AggrOrMultiSignature>;
    }
    interface AggrPublicKeysWithPoP {
        bytes: string;
    }
    namespace AggrPublicKeysWithPoP {
        const TYPE_QNAME = "0x1::bls12381::AggrPublicKeysWithPoP";
        function type(): TypeDescriptor<AggrPublicKeysWithPoP>;
    }
    interface ProofOfPossession {
        bytes: string;
    }
    namespace ProofOfPossession {
        const TYPE_QNAME = "0x1::bls12381::ProofOfPossession";
        function type(): TypeDescriptor<ProofOfPossession>;
    }
    interface PublicKey {
        bytes: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::bls12381::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    interface PublicKeyWithPoP {
        bytes: string;
    }
    namespace PublicKeyWithPoP {
        const TYPE_QNAME = "0x1::bls12381::PublicKeyWithPoP";
        function type(): TypeDescriptor<PublicKeyWithPoP>;
    }
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::bls12381::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_id {
    interface ChainId {
        id: number;
    }
    namespace ChainId {
        const TYPE_QNAME = "0x1::chain_id::ChainId";
        function type(): TypeDescriptor<ChainId>;
    }
    namespace entry { }
    namespace view {
        function get(client: Aptos, version?: bigint): Promise<[number]>;
    }
}
export declare namespace features {
    interface Features {
        features: string;
    }
    namespace Features {
        const TYPE_QNAME = "0x1::features::Features";
        function type(): TypeDescriptor<Features>;
    }
    interface PendingFeatures {
        features: string;
    }
    namespace PendingFeatures {
        const TYPE_QNAME = "0x1::features::PendingFeatures";
        function type(): TypeDescriptor<PendingFeatures>;
    }
    namespace entry { }
    namespace view {
        function isEnabled(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace from_bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace pool_u64 {
    interface Pool {
        shareholders_limit: bigint;
        total_coins: bigint;
        total_shares: bigint;
        shares: simple_map.SimpleMap<MoveAddressType, bigint>;
        shareholders: MoveAddressType[];
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace auth_data {
    interface AbstractionAuthData {
    }
    namespace AbstractionAuthData {
        const TYPE_QNAME = "0x1::auth_data::AbstractionAuthData";
        function type(): TypeDescriptor<AbstractionAuthData>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multi_key {
    interface MultiKey {
        public_keys: single_key.AnyPublicKey[];
        signatures_required: number;
    }
    namespace MultiKey {
        const TYPE_QNAME = "0x1::multi_key::MultiKey";
        function type(): TypeDescriptor<MultiKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace secp256k1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256k1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    interface ECDSASignature {
        bytes: string;
    }
    namespace ECDSASignature {
        const TYPE_QNAME = "0x1::secp256k1::ECDSASignature";
        function type(): TypeDescriptor<ECDSASignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace secp256r1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256r1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace timestamp {
    interface CurrentTimeMicroseconds {
        microseconds: bigint;
    }
    namespace CurrentTimeMicroseconds {
        const TYPE_QNAME = "0x1::timestamp::CurrentTimeMicroseconds";
        function type(): TypeDescriptor<CurrentTimeMicroseconds>;
    }
    namespace entry { }
    namespace view {
        function nowMicroseconds(client: Aptos, version?: bigint): Promise<[bigint]>;
        function nowSeconds(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace type_info {
    interface TypeInfo {
        account_address: MoveAddressType;
        module_name: string;
        struct_name: string;
    }
    namespace TypeInfo {
        const TYPE_QNAME = "0x1::type_info::TypeInfo";
        function type(): TypeDescriptor<TypeInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator {
    interface Aggregator {
        handle: MoveAddressType;
        key: MoveAddressType;
        limit: bigint;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator::Aggregator";
        function type(): TypeDescriptor<Aggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aptos_coin {
    interface AptosCoin {
        dummy_field: boolean;
    }
    namespace AptosCoin {
        const TYPE_QNAME = "0x1::aptos_coin::AptosCoin";
        function type(): TypeDescriptor<AptosCoin>;
    }
    interface DelegatedMintCapability {
        to: MoveAddressType;
    }
    namespace DelegatedMintCapability {
        const TYPE_QNAME = "0x1::aptos_coin::DelegatedMintCapability";
        function type(): TypeDescriptor<DelegatedMintCapability>;
    }
    interface Delegations {
        inner: aptos_coin.DelegatedMintCapability[];
    }
    namespace Delegations {
        const TYPE_QNAME = "0x1::aptos_coin::Delegations";
        function type(): TypeDescriptor<Delegations>;
    }
    interface MintCapStore {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace MintCapStore {
        const TYPE_QNAME = "0x1::aptos_coin::MintCapStore";
        function type(): TypeDescriptor<MintCapStore>;
    }
    namespace entry {
        function mint(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function claimMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace aptos_hash {
    namespace entry { }
    namespace view { }
}
export declare namespace bcs_stream {
    interface BCSStream {
        data: string;
        cur: bigint;
    }
    namespace BCSStream {
        const TYPE_QNAME = "0x1::bcs_stream::BCSStream";
        function type(): TypeDescriptor<BCSStream>;
    }
    namespace entry {
        function deserializeU256Entry(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace big_vector {
    interface BigVector<T0> {
        buckets: table_with_length.TableWithLength<bigint, T0[]>;
        end_index: bigint;
        bucket_size: bigint;
    }
    namespace BigVector {
        const TYPE_QNAME = "0x1::big_vector::BigVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BigVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace capability {
    interface Cap<T0> {
        root: MoveAddressType;
    }
    namespace Cap {
        const TYPE_QNAME = "0x1::capability::Cap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Cap<T0>>;
    }
    interface CapDelegateState<T0> {
        root: MoveAddressType;
    }
    namespace CapDelegateState {
        const TYPE_QNAME = "0x1::capability::CapDelegateState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapDelegateState<T0>>;
    }
    interface CapState<T0> {
        delegates: MoveAddressType[];
    }
    namespace CapState {
        const TYPE_QNAME = "0x1::capability::CapState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapState<T0>>;
    }
    interface LinearCap<T0> {
        root: MoveAddressType;
    }
    namespace LinearCap {
        const TYPE_QNAME = "0x1::capability::LinearCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<LinearCap<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace comparator {
    interface Result {
        inner: number;
    }
    namespace Result {
        const TYPE_QNAME = "0x1::comparator::Result";
        function type(): TypeDescriptor<Result>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math_fixed {
    namespace entry { }
    namespace view { }
}
export declare namespace randomness {
    interface PerBlockRandomness {
        epoch: bigint;
        round: bigint;
        seed: option.Option<string>;
    }
    namespace PerBlockRandomness {
        const TYPE_QNAME = "0x1::randomness::PerBlockRandomness";
        function type(): TypeDescriptor<PerBlockRandomness>;
    }
    interface RandomnessGeneratedEvent {
        dummy_field: boolean;
    }
    namespace RandomnessGeneratedEvent {
        const TYPE_QNAME = "0x1::randomness::RandomnessGeneratedEvent";
        function type(): TypeDescriptor<RandomnessGeneratedEvent>;
    }
    type RandomnessGeneratedEventInstance = TypedEventInstance<RandomnessGeneratedEvent> & {
        data_decoded: RandomnessGeneratedEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace simple_map {
    interface Element<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::simple_map::Element";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Element<T0, T1>>;
    }
    interface SimpleMap<T0, T1> {
        data: simple_map.Element<T0, T1>[];
    }
    namespace SimpleMap {
        const TYPE_QNAME = "0x1::simple_map::SimpleMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SimpleMap<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace single_key {
    interface AnyPublicKey {
    }
    namespace AnyPublicKey {
        const TYPE_QNAME = "0x1::single_key::AnyPublicKey";
        function type(): TypeDescriptor<AnyPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ordered_map {
    interface Entry<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::ordered_map::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface IteratorPtr {
    }
    namespace IteratorPtr {
        const TYPE_QNAME = "0x1::ordered_map::IteratorPtr";
        function type(): TypeDescriptor<IteratorPtr>;
    }
    interface OrderedMap<T0, T1> {
    }
    namespace OrderedMap {
        const TYPE_QNAME = "0x1::ordered_map::OrderedMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<OrderedMap<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_table {
    interface Entry<T0, T1> {
        hash: bigint;
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::smart_table::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface SmartTable<T0, T1> {
        buckets: table_with_length.TableWithLength<bigint, smart_table.Entry<T0, T1>[]>;
        num_buckets: bigint;
        level: number;
        size: bigint;
        split_load_threshold: number;
        target_bucket_size: bigint;
    }
    namespace SmartTable {
        const TYPE_QNAME = "0x1::smart_table::SmartTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SmartTable<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace storage_gas {
    interface GasCurve {
        min_gas: bigint;
        max_gas: bigint;
        points: storage_gas.Point[];
    }
    namespace GasCurve {
        const TYPE_QNAME = "0x1::storage_gas::GasCurve";
        function type(): TypeDescriptor<GasCurve>;
    }
    interface Point {
        x: bigint;
        y: bigint;
    }
    namespace Point {
        const TYPE_QNAME = "0x1::storage_gas::Point";
        function type(): TypeDescriptor<Point>;
    }
    interface StorageGas {
        per_item_read: bigint;
        per_item_create: bigint;
        per_item_write: bigint;
        per_byte_read: bigint;
        per_byte_create: bigint;
        per_byte_write: bigint;
    }
    namespace StorageGas {
        const TYPE_QNAME = "0x1::storage_gas::StorageGas";
        function type(): TypeDescriptor<StorageGas>;
    }
    interface StorageGasConfig {
        item_config: storage_gas.UsageGasConfig;
        byte_config: storage_gas.UsageGasConfig;
    }
    namespace StorageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::StorageGasConfig";
        function type(): TypeDescriptor<StorageGasConfig>;
    }
    interface UsageGasConfig {
        target_usage: bigint;
        read_curve: storage_gas.GasCurve;
        create_curve: storage_gas.GasCurve;
        write_curve: storage_gas.GasCurve;
    }
    namespace UsageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::UsageGasConfig";
        function type(): TypeDescriptor<UsageGasConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_status {
    interface GenesisEndMarker {
        dummy_field: boolean;
    }
    namespace GenesisEndMarker {
        const TYPE_QNAME = "0x1::chain_status::GenesisEndMarker";
        function type(): TypeDescriptor<GenesisEndMarker>;
    }
    namespace entry { }
    namespace view {
        function isGenesis(client: Aptos, version?: bigint): Promise<[boolean]>;
        function isOperating(client: Aptos, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace copyable_any {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::copyable_any::Any";
        function type(): TypeDescriptor<Any>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace gas_schedule {
    interface GasEntry {
        key: string;
        val: bigint;
    }
    namespace GasEntry {
        const TYPE_QNAME = "0x1::gas_schedule::GasEntry";
        function type(): TypeDescriptor<GasEntry>;
    }
    interface GasSchedule {
        entries: gas_schedule.GasEntry[];
    }
    namespace GasSchedule {
        const TYPE_QNAME = "0x1::gas_schedule::GasSchedule";
        function type(): TypeDescriptor<GasSchedule>;
    }
    interface GasScheduleV2 {
        feature_version: bigint;
        entries: gas_schedule.GasEntry[];
    }
    namespace GasScheduleV2 {
        const TYPE_QNAME = "0x1::gas_schedule::GasScheduleV2";
        function type(): TypeDescriptor<GasScheduleV2>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace managed_coin {
    interface Capabilities<T0> {
        burn_cap: coin.BurnCapability<T0>;
        freeze_cap: coin.FreezeCapability<T0>;
        mint_cap: coin.MintCapability<T0>;
    }
    namespace Capabilities {
        const TYPE_QNAME = "0x1::managed_coin::Capabilities";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Capabilities<T0>>;
    }
    namespace entry {
        function initialize<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [string, string, number, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function register<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function destroyCaps<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace math_fixed64 {
    namespace entry { }
    namespace view { }
}
export declare namespace rate_limiter {
    interface RateLimiter {
    }
    namespace RateLimiter {
        const TYPE_QNAME = "0x1::rate_limiter::RateLimiter";
        function type(): TypeDescriptor<RateLimiter>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255 {
    interface CompressedRistretto {
        data: string;
    }
    namespace CompressedRistretto {
        const TYPE_QNAME = "0x1::ristretto255::CompressedRistretto";
        function type(): TypeDescriptor<CompressedRistretto>;
    }
    interface RistrettoPoint {
        handle: bigint;
    }
    namespace RistrettoPoint {
        const TYPE_QNAME = "0x1::ristretto255::RistrettoPoint";
        function type(): TypeDescriptor<RistrettoPoint>;
    }
    interface Scalar {
        data: string;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x1::ristretto255::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_vector {
    interface SmartVector<T0> {
        inline_vec: T0[];
        big_vec: option.Option<big_vector.BigVector<T0>>;
        inline_capacity: option.Option<bigint>;
        bucket_size: option.Option<bigint>;
    }
    namespace SmartVector {
        const TYPE_QNAME = "0x1::smart_vector::SmartVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SmartVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace string_utils {
    interface Cons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace Cons {
        const TYPE_QNAME = "0x1::string_utils::Cons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Cons<T0, T1>>;
    }
    interface FakeCons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace FakeCons {
        const TYPE_QNAME = "0x1::string_utils::FakeCons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<FakeCons<T0, T1>>;
    }
    interface NIL {
        dummy_field: boolean;
    }
    namespace NIL {
        const TYPE_QNAME = "0x1::string_utils::NIL";
        function type(): TypeDescriptor<NIL>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator_v2 {
    interface Aggregator<T0> {
        value: T0;
        max_value: T0;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator_v2::Aggregator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Aggregator<T0>>;
    }
    type AggregatorInstance = TypedEventInstance<Aggregator<any>> & {
        data_decoded: Aggregator<any>;
        type_arguments: [string];
    };
    interface AggregatorSnapshot<T0> {
        value: T0;
    }
    namespace AggregatorSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::AggregatorSnapshot";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatorSnapshot<T0>>;
    }
    type AggregatorSnapshotInstance = TypedEventInstance<AggregatorSnapshot<any>> & {
        data_decoded: AggregatorSnapshot<any>;
        type_arguments: [string];
    };
    interface DerivedStringSnapshot {
        value: string;
        padding: string;
    }
    namespace DerivedStringSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::DerivedStringSnapshot";
        function type(): TypeDescriptor<DerivedStringSnapshot>;
    }
    type DerivedStringSnapshotInstance = TypedEventInstance<DerivedStringSnapshot> & {
        data_decoded: DerivedStringSnapshot;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace aptos_account {
    interface DirectCoinTransferConfigUpdated {
        account: MoveAddressType;
        new_allow_direct_transfers: boolean;
    }
    namespace DirectCoinTransferConfigUpdated {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdated";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdated>;
    }
    type DirectCoinTransferConfigUpdatedInstance = TypedEventInstance<DirectCoinTransferConfigUpdated> & {
        data_decoded: DirectCoinTransferConfigUpdated;
        type_arguments: [];
    };
    interface DirectCoinTransferConfigUpdatedEvent {
        new_allow_direct_transfers: boolean;
    }
    namespace DirectCoinTransferConfigUpdatedEvent {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdatedEvent";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdatedEvent>;
    }
    type DirectCoinTransferConfigUpdatedEventInstance = TypedEventInstance<DirectCoinTransferConfigUpdatedEvent> & {
        data_decoded: DirectCoinTransferConfigUpdatedEvent;
        type_arguments: [];
    };
    interface DirectTransferConfig {
        allow_arbitrary_coin_transfers: boolean;
        update_coin_transfer_events: event.EventHandle<aptos_account.DirectCoinTransferConfigUpdatedEvent>;
    }
    namespace DirectTransferConfig {
        const TYPE_QNAME = "0x1::aptos_account::DirectTransferConfig";
        function type(): TypeDescriptor<DirectTransferConfig>;
    }
    namespace entry {
        function createAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransferFungibleAssets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                object$.Object<fungible_asset.Metadata>,
                MoveAddressType[],
                bigint[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function fungibleTransferOnly(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setAllowDirectCoinTransfers(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferFungibleAssets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                object$.Object<fungible_asset.Metadata>,
                MoveAddressType,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function canReceiveDirectCoinTransfers(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace bn254_algebra {
    interface FormatFq12LscLsb {
        dummy_field: boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bn254_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bn254_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bn254_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bn254_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface FormatFqLsb {
        dummy_field: boolean;
    }
    namespace FormatFqLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqLsb";
        function type(): TypeDescriptor<FormatFqLsb>;
    }
    interface FormatFqMsb {
        dummy_field: boolean;
    }
    namespace FormatFqMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqMsb";
        function type(): TypeDescriptor<FormatFqMsb>;
    }
    interface Fq {
        dummy_field: boolean;
    }
    namespace Fq {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq";
        function type(): TypeDescriptor<Fq>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace config_buffer {
    interface PendingConfigs {
        configs: simple_map.SimpleMap<string, any$.Any>;
    }
    namespace PendingConfigs {
        const TYPE_QNAME = "0x1::config_buffer::PendingConfigs";
        function type(): TypeDescriptor<PendingConfigs>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace create_signer {
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point64 {
    interface FixedPoint64 {
        value: bigint;
    }
    namespace FixedPoint64 {
        const TYPE_QNAME = "0x1::fixed_point64::FixedPoint64";
        function type(): TypeDescriptor<FixedPoint64>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace function_info {
    interface FunctionInfo {
        module_address: MoveAddressType;
        module_name: string;
        function_name: string;
    }
    namespace FunctionInfo {
        const TYPE_QNAME = "0x1::function_info::FunctionInfo";
        function type(): TypeDescriptor<FunctionInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multi_ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::multi_ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace staking_proxy {
    interface StakeProxyPermission {
        dummy_field: boolean;
    }
    namespace StakeProxyPermission {
        const TYPE_QNAME = "0x1::staking_proxy::StakeProxyPermission";
        function type(): TypeDescriptor<StakeProxyPermission>;
    }
    namespace entry {
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace state_storage {
    interface GasParameter {
        usage: state_storage.Usage;
    }
    namespace GasParameter {
        const TYPE_QNAME = "0x1::state_storage::GasParameter";
        function type(): TypeDescriptor<GasParameter>;
    }
    interface StateStorageUsage {
        epoch: bigint;
        usage: state_storage.Usage;
    }
    namespace StateStorageUsage {
        const TYPE_QNAME = "0x1::state_storage::StateStorageUsage";
        function type(): TypeDescriptor<StateStorageUsage>;
    }
    interface Usage {
        items: bigint;
        bytes: bigint;
    }
    namespace Usage {
        const TYPE_QNAME = "0x1::state_storage::Usage";
        function type(): TypeDescriptor<Usage>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace crypto_algebra {
    interface Element<T0> {
        handle: bigint;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::crypto_algebra::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace fungible_asset {
    interface TransferRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::fungible_asset::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    type TransferRefInstance = TypedEventInstance<TransferRef> & {
        data_decoded: TransferRef;
        type_arguments: [];
    };
    interface Untransferable {
        dummy_field: boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::fungible_asset::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    interface BurnRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x1::fungible_asset::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    type BurnRefInstance = TypedEventInstance<BurnRef> & {
        data_decoded: BurnRef;
        type_arguments: [];
    };
    interface ConcurrentFungibleBalance {
        balance: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentFungibleBalance {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentFungibleBalance";
        function type(): TypeDescriptor<ConcurrentFungibleBalance>;
    }
    interface ConcurrentSupply {
        current: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface Deposit {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::fungible_asset::Deposit";
        function type(): TypeDescriptor<Deposit>;
    }
    type DepositInstance = TypedEventInstance<Deposit> & {
        data_decoded: Deposit;
        type_arguments: [];
    };
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::fungible_asset::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    type DepositEventInstance = TypedEventInstance<DepositEvent> & {
        data_decoded: DepositEvent;
        type_arguments: [];
    };
    interface DeriveSupply {
        dispatch_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DeriveSupply {
        const TYPE_QNAME = "0x1::fungible_asset::DeriveSupply";
        function type(): TypeDescriptor<DeriveSupply>;
    }
    interface DispatchFunctionStore {
        withdraw_function: option.Option<function_info.FunctionInfo>;
        deposit_function: option.Option<function_info.FunctionInfo>;
        derived_balance_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DispatchFunctionStore {
        const TYPE_QNAME = "0x1::fungible_asset::DispatchFunctionStore";
        function type(): TypeDescriptor<DispatchFunctionStore>;
    }
    interface Frozen {
        store: MoveAddressType;
        frozen: boolean;
    }
    namespace Frozen {
        const TYPE_QNAME = "0x1::fungible_asset::Frozen";
        function type(): TypeDescriptor<Frozen>;
    }
    type FrozenInstance = TypedEventInstance<Frozen> & {
        data_decoded: Frozen;
        type_arguments: [];
    };
    interface FrozenEvent {
        frozen: boolean;
    }
    namespace FrozenEvent {
        const TYPE_QNAME = "0x1::fungible_asset::FrozenEvent";
        function type(): TypeDescriptor<FrozenEvent>;
    }
    type FrozenEventInstance = TypedEventInstance<FrozenEvent> & {
        data_decoded: FrozenEvent;
        type_arguments: [];
    };
    interface FungibleAsset {
        metadata: object$.Object<fungible_asset.Metadata>;
        amount: bigint;
    }
    namespace FungibleAsset {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAsset";
        function type(): TypeDescriptor<FungibleAsset>;
    }
    interface FungibleAssetEvents {
        deposit_events: event.EventHandle<fungible_asset.DepositEvent>;
        withdraw_events: event.EventHandle<fungible_asset.WithdrawEvent>;
        frozen_events: event.EventHandle<fungible_asset.FrozenEvent>;
    }
    namespace FungibleAssetEvents {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAssetEvents";
        function type(): TypeDescriptor<FungibleAssetEvents>;
    }
    interface FungibleStore {
        metadata: object$.Object<fungible_asset.Metadata>;
        balance: bigint;
        frozen: boolean;
    }
    namespace FungibleStore {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStore";
        function type(): TypeDescriptor<FungibleStore>;
    }
    interface FungibleStoreDeletion {
        store: MoveAddressType;
        owner: MoveAddressType;
        metadata: MoveAddressType;
    }
    namespace FungibleStoreDeletion {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStoreDeletion";
        function type(): TypeDescriptor<FungibleStoreDeletion>;
    }
    type FungibleStoreDeletionInstance = TypedEventInstance<FungibleStoreDeletion> & {
        data_decoded: FungibleStoreDeletion;
        type_arguments: [];
    };
    interface Metadata {
        name: string;
        symbol: string;
        decimals: number;
        icon_uri: string;
        project_uri: string;
    }
    namespace Metadata {
        const TYPE_QNAME = "0x1::fungible_asset::Metadata";
        function type(): TypeDescriptor<Metadata>;
    }
    interface MintRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MintRef {
        const TYPE_QNAME = "0x1::fungible_asset::MintRef";
        function type(): TypeDescriptor<MintRef>;
    }
    type MintRefInstance = TypedEventInstance<MintRef> & {
        data_decoded: MintRef;
        type_arguments: [];
    };
    interface MutateMetadataRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MutateMetadataRef {
        const TYPE_QNAME = "0x1::fungible_asset::MutateMetadataRef";
        function type(): TypeDescriptor<MutateMetadataRef>;
    }
    type MutateMetadataRefInstance = TypedEventInstance<MutateMetadataRef> & {
        data_decoded: MutateMetadataRef;
        type_arguments: [];
    };
    interface RawBalanceRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace RawBalanceRef {
        const TYPE_QNAME = "0x1::fungible_asset::RawBalanceRef";
        function type(): TypeDescriptor<RawBalanceRef>;
    }
    type RawBalanceRefInstance = TypedEventInstance<RawBalanceRef> & {
        data_decoded: RawBalanceRef;
        type_arguments: [];
    };
    interface RawSupplyRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace RawSupplyRef {
        const TYPE_QNAME = "0x1::fungible_asset::RawSupplyRef";
        function type(): TypeDescriptor<RawSupplyRef>;
    }
    type RawSupplyRefInstance = TypedEventInstance<RawSupplyRef> & {
        data_decoded: RawSupplyRef;
        type_arguments: [];
    };
    interface Supply {
        current: bigint;
        maximum: option.Option<bigint>;
    }
    namespace Supply {
        const TYPE_QNAME = "0x1::fungible_asset::Supply";
        function type(): TypeDescriptor<Supply>;
    }
    interface Withdraw {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::fungible_asset::Withdraw";
        function type(): TypeDescriptor<Withdraw>;
    }
    type WithdrawInstance = TypedEventInstance<Withdraw> & {
        data_decoded: Withdraw;
        type_arguments: [];
    };
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    type WithdrawEventInstance = TypedEventInstance<WithdrawEvent> & {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    };
    interface WithdrawPermission {
    }
    namespace WithdrawPermission {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawPermission";
        function type(): TypeDescriptor<WithdrawPermission>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeStoreToConcurrent<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function symbol$<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[number]>;
        function iconUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function projectUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function metadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[fungible_asset.Metadata]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isStoreDispatchable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function maximum<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function storeExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function storeMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[object$.Object<fungible_asset.Metadata>]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
    }
}
export declare namespace staking_config {
    interface StakingConfig {
        minimum_stake: bigint;
        maximum_stake: bigint;
        recurring_lockup_duration_secs: bigint;
        allow_validator_set_change: boolean;
        rewards_rate: bigint;
        rewards_rate_denominator: bigint;
        voting_power_increase_limit: bigint;
    }
    namespace StakingConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingConfig";
        function type(): TypeDescriptor<StakingConfig>;
    }
    interface StakingRewardsConfig {
        rewards_rate: fixed_point64.FixedPoint64;
        min_rewards_rate: fixed_point64.FixedPoint64;
        rewards_rate_period_in_secs: bigint;
        last_rewards_rate_period_start_in_secs: bigint;
        rewards_rate_decrease_rate: fixed_point64.FixedPoint64;
    }
    namespace StakingRewardsConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingRewardsConfig";
        function type(): TypeDescriptor<StakingRewardsConfig>;
    }
    namespace entry { }
    namespace view {
        function rewardRate(client: Aptos, version?: bigint): Promise<[bigint, bigint]>;
    }
}
export declare namespace big_ordered_map {
    interface IteratorPtr<T0> {
    }
    namespace IteratorPtr {
        const TYPE_QNAME = "0x1::big_ordered_map::IteratorPtr";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<IteratorPtr<T0>>;
    }
    interface BigOrderedMap<T0, T1> {
    }
    namespace BigOrderedMap {
        const TYPE_QNAME = "0x1::big_ordered_map::BigOrderedMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<BigOrderedMap<T0, T1>>;
    }
    interface Child<T0> {
    }
    namespace Child {
        const TYPE_QNAME = "0x1::big_ordered_map::Child";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Child<T0>>;
    }
    interface Node<T0, T1> {
    }
    namespace Node {
        const TYPE_QNAME = "0x1::big_ordered_map::Node";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Node<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace delegation_pool {
    interface CreateProposal {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Vote {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::delegation_pool::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::delegation_pool::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface AddStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::delegation_pool::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface ReactivateStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    type ReactivateStakeInstance = TypedEventInstance<ReactivateStake> & {
        data_decoded: ReactivateStake;
        type_arguments: [];
    };
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    type ReactivateStakeEventInstance = TypedEventInstance<ReactivateStakeEvent> & {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    };
    interface UnlockStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface WithdrawStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    type WithdrawStakeInstance = TypedEventInstance<WithdrawStake> & {
        data_decoded: WithdrawStake;
        type_arguments: [];
    };
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    type WithdrawStakeEventInstance = TypedEventInstance<WithdrawStakeEvent> & {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    };
    interface AllowlistDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace AllowlistDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::AllowlistDelegator";
        function type(): TypeDescriptor<AllowlistDelegator>;
    }
    type AllowlistDelegatorInstance = TypedEventInstance<AllowlistDelegator> & {
        data_decoded: AllowlistDelegator;
        type_arguments: [];
    };
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CommissionPercentageChange {
        pool_address: MoveAddressType;
        owner: MoveAddressType;
        commission_percentage_next_lockup_cycle: bigint;
    }
    namespace CommissionPercentageChange {
        const TYPE_QNAME = "0x1::delegation_pool::CommissionPercentageChange";
        function type(): TypeDescriptor<CommissionPercentageChange>;
    }
    type CommissionPercentageChangeInstance = TypedEventInstance<CommissionPercentageChange> & {
        data_decoded: CommissionPercentageChange;
        type_arguments: [];
    };
    interface DelegateVotingPower {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPower {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPower";
        function type(): TypeDescriptor<DelegateVotingPower>;
    }
    type DelegateVotingPowerInstance = TypedEventInstance<DelegateVotingPower> & {
        data_decoded: DelegateVotingPower;
        type_arguments: [];
    };
    interface DelegateVotingPowerEvent {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPowerEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPowerEvent";
        function type(): TypeDescriptor<DelegateVotingPowerEvent>;
    }
    type DelegateVotingPowerEventInstance = TypedEventInstance<DelegateVotingPowerEvent> & {
        data_decoded: DelegateVotingPowerEvent;
        type_arguments: [];
    };
    interface DelegatedVotes {
        active_shares: bigint;
        pending_inactive_shares: bigint;
        active_shares_next_lockup: bigint;
        last_locked_until_secs: bigint;
    }
    namespace DelegatedVotes {
        const TYPE_QNAME = "0x1::delegation_pool::DelegatedVotes";
        function type(): TypeDescriptor<DelegatedVotes>;
    }
    interface DelegationPermission {
    }
    namespace DelegationPermission {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPermission";
        function type(): TypeDescriptor<DelegationPermission>;
    }
    interface DelegationPool {
        active_shares: pool_u64_unbound.Pool;
        observed_lockup_cycle: delegation_pool.ObservedLockupCycle;
        inactive_shares: table.Table<delegation_pool.ObservedLockupCycle, pool_u64_unbound.Pool>;
        pending_withdrawals: table.Table<MoveAddressType, delegation_pool.ObservedLockupCycle>;
        stake_pool_signer_cap: account.SignerCapability;
        total_coins_inactive: bigint;
        operator_commission_percentage: bigint;
        add_stake_events: event.EventHandle<delegation_pool.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<delegation_pool.ReactivateStakeEvent>;
        unlock_stake_events: event.EventHandle<delegation_pool.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<delegation_pool.WithdrawStakeEvent>;
        distribute_commission_events: event.EventHandle<delegation_pool.DistributeCommissionEvent>;
    }
    namespace DelegationPool {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPool";
        function type(): TypeDescriptor<DelegationPool>;
    }
    interface DelegationPoolAllowlisting {
        allowlist: smart_table.SmartTable<MoveAddressType, boolean>;
    }
    namespace DelegationPoolAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolAllowlisting";
        function type(): TypeDescriptor<DelegationPoolAllowlisting>;
    }
    interface DelegationPoolOwnership {
        pool_address: MoveAddressType;
    }
    namespace DelegationPoolOwnership {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolOwnership";
        function type(): TypeDescriptor<DelegationPoolOwnership>;
    }
    interface DisableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace DisableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DisableDelegatorsAllowlisting";
        function type(): TypeDescriptor<DisableDelegatorsAllowlisting>;
    }
    type DisableDelegatorsAllowlistingInstance = TypedEventInstance<DisableDelegatorsAllowlisting> & {
        data_decoded: DisableDelegatorsAllowlisting;
        type_arguments: [];
    };
    interface DistributeCommission {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        beneficiary: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommission {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommission";
        function type(): TypeDescriptor<DistributeCommission>;
    }
    type DistributeCommissionInstance = TypedEventInstance<DistributeCommission> & {
        data_decoded: DistributeCommission;
        type_arguments: [];
    };
    interface DistributeCommissionEvent {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommissionEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommissionEvent";
        function type(): TypeDescriptor<DistributeCommissionEvent>;
    }
    type DistributeCommissionEventInstance = TypedEventInstance<DistributeCommissionEvent> & {
        data_decoded: DistributeCommissionEvent;
        type_arguments: [];
    };
    interface EnableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace EnableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::EnableDelegatorsAllowlisting";
        function type(): TypeDescriptor<EnableDelegatorsAllowlisting>;
    }
    type EnableDelegatorsAllowlistingInstance = TypedEventInstance<EnableDelegatorsAllowlisting> & {
        data_decoded: EnableDelegatorsAllowlisting;
        type_arguments: [];
    };
    interface EvictDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace EvictDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::EvictDelegator";
        function type(): TypeDescriptor<EvictDelegator>;
    }
    type EvictDelegatorInstance = TypedEventInstance<EvictDelegator> & {
        data_decoded: EvictDelegator;
        type_arguments: [];
    };
    interface GovernanceRecords {
        votes: smart_table.SmartTable<delegation_pool.VotingRecordKey, bigint>;
        votes_per_proposal: smart_table.SmartTable<bigint, bigint>;
        vote_delegation: smart_table.SmartTable<MoveAddressType, delegation_pool.VoteDelegation>;
        delegated_votes: smart_table.SmartTable<MoveAddressType, delegation_pool.DelegatedVotes>;
        vote_events: event.EventHandle<delegation_pool.VoteEvent>;
        create_proposal_events: event.EventHandle<delegation_pool.CreateProposalEvent>;
        delegate_voting_power_events: event.EventHandle<delegation_pool.DelegateVotingPowerEvent>;
    }
    namespace GovernanceRecords {
        const TYPE_QNAME = "0x1::delegation_pool::GovernanceRecords";
        function type(): TypeDescriptor<GovernanceRecords>;
    }
    interface NextCommissionPercentage {
        commission_percentage_next_lockup_cycle: bigint;
        effective_after_secs: bigint;
    }
    namespace NextCommissionPercentage {
        const TYPE_QNAME = "0x1::delegation_pool::NextCommissionPercentage";
        function type(): TypeDescriptor<NextCommissionPercentage>;
    }
    interface ObservedLockupCycle {
        index: bigint;
    }
    namespace ObservedLockupCycle {
        const TYPE_QNAME = "0x1::delegation_pool::ObservedLockupCycle";
        function type(): TypeDescriptor<ObservedLockupCycle>;
    }
    interface RemoveDelegatorFromAllowlist {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace RemoveDelegatorFromAllowlist {
        const TYPE_QNAME = "0x1::delegation_pool::RemoveDelegatorFromAllowlist";
        function type(): TypeDescriptor<RemoveDelegatorFromAllowlist>;
    }
    type RemoveDelegatorFromAllowlistInstance = TypedEventInstance<RemoveDelegatorFromAllowlist> & {
        data_decoded: RemoveDelegatorFromAllowlist;
        type_arguments: [];
    };
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    type SetBeneficiaryForOperatorInstance = TypedEventInstance<SetBeneficiaryForOperator> & {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    };
    interface VoteDelegation {
        voter: MoveAddressType;
        pending_voter: MoveAddressType;
        last_locked_until_secs: bigint;
    }
    namespace VoteDelegation {
        const TYPE_QNAME = "0x1::delegation_pool::VoteDelegation";
        function type(): TypeDescriptor<VoteDelegation>;
    }
    interface VotingRecordKey {
        voter: MoveAddressType;
        proposal_id: bigint;
    }
    namespace VotingRecordKey {
        const TYPE_QNAME = "0x1::delegation_pool::VotingRecordKey";
        function type(): TypeDescriptor<VotingRecordKey>;
    }
    namespace entry {
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function allowlistDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateVotingPower(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function disableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enablePartialGovernanceVoting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function evictDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDelegatorFromAllowlist(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function synchronizeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function partialGovernanceVotingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getOwnedPoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function allowlistingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateDelegatorVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVoterTotalVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVotingDelegation(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType, MoveAddressType, bigint]>;
        function canWithdrawPendingInactive(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function delegationPoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function delegatorAllowlisted(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getAddStakeFee(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegationPoolStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getDelegatorsAllowlist(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getPendingWithdrawal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean, bigint]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function isNextCommissionPercentageEffective(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function minRemainingSecsForCommissionChange(client: Aptos, version?: bigint): Promise<[bigint]>;
        function observedLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function operatorCommissionPercentageNextLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function ownerCapExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function shareholdersCountActivePool(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace keyless_account {
    interface Configuration {
        override_aud_vals: string[];
        max_signatures_per_txn: number;
        max_exp_horizon_secs: bigint;
        training_wheels_pubkey: option.Option<string>;
        max_commited_epk_bytes: number;
        max_iss_val_bytes: number;
        max_extra_field_bytes: number;
        max_jwt_header_b64_bytes: number;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::keyless_account::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface Group {
        dummy_field: boolean;
    }
    namespace Group {
        const TYPE_QNAME = "0x1::keyless_account::Group";
        function type(): TypeDescriptor<Group>;
    }
    interface Groth16VerificationKey {
        alpha_g1: string;
        beta_g2: string;
        gamma_g2: string;
        delta_g2: string;
        gamma_abc_g1: string[];
    }
    namespace Groth16VerificationKey {
        const TYPE_QNAME = "0x1::keyless_account::Groth16VerificationKey";
        function type(): TypeDescriptor<Groth16VerificationKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration {
    interface Configuration {
        epoch: bigint;
        last_reconfiguration_time: bigint;
        events: event.EventHandle<reconfiguration.NewEpochEvent>;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::reconfiguration::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface DisableReconfiguration {
        dummy_field: boolean;
    }
    namespace DisableReconfiguration {
        const TYPE_QNAME = "0x1::reconfiguration::DisableReconfiguration";
        function type(): TypeDescriptor<DisableReconfiguration>;
    }
    interface NewEpoch {
        epoch: bigint;
    }
    namespace NewEpoch {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpoch";
        function type(): TypeDescriptor<NewEpoch>;
    }
    type NewEpochInstance = TypedEventInstance<NewEpoch> & {
        data_decoded: NewEpoch;
        type_arguments: [];
    };
    interface NewEpochEvent {
        epoch: bigint;
    }
    namespace NewEpochEvent {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpochEvent";
        function type(): TypeDescriptor<NewEpochEvent>;
    }
    type NewEpochEventInstance = TypedEventInstance<NewEpochEvent> & {
        data_decoded: NewEpochEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace transaction_fee {
    interface AptosCoinCapabilities {
        burn_cap: coin.BurnCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface AptosCoinMintCapability {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinMintCapability {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinMintCapability";
        function type(): TypeDescriptor<AptosCoinMintCapability>;
    }
    interface AptosFABurnCapabilities {
        burn_ref: fungible_asset.BurnRef;
    }
    namespace AptosFABurnCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosFABurnCapabilities";
        function type(): TypeDescriptor<AptosFABurnCapabilities>;
    }
    interface CollectedFeesPerBlock {
        amount: coin.AggregatableCoin<aptos_coin.AptosCoin>;
        proposer: option.Option<MoveAddressType>;
        burn_percentage: number;
    }
    namespace CollectedFeesPerBlock {
        const TYPE_QNAME = "0x1::transaction_fee::CollectedFeesPerBlock";
        function type(): TypeDescriptor<CollectedFeesPerBlock>;
    }
    interface FeeStatement {
        total_charge_gas_units: bigint;
        execution_gas_units: bigint;
        io_gas_units: bigint;
        storage_fee_octas: bigint;
        storage_fee_refund_octas: bigint;
    }
    namespace FeeStatement {
        const TYPE_QNAME = "0x1::transaction_fee::FeeStatement";
        function type(): TypeDescriptor<FeeStatement>;
    }
    type FeeStatementInstance = TypedEventInstance<FeeStatement> & {
        data_decoded: FeeStatement;
        type_arguments: [];
    };
    namespace entry {
        function convertToAptosFaBurnRef(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace aptos_governance {
    interface CreateProposal {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Vote {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::aptos_governance::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::aptos_governance::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface ApprovedExecutionHashes {
        hashes: simple_map.SimpleMap<bigint, string>;
    }
    namespace ApprovedExecutionHashes {
        const TYPE_QNAME = "0x1::aptos_governance::ApprovedExecutionHashes";
        function type(): TypeDescriptor<ApprovedExecutionHashes>;
    }
    interface GovernanceConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace GovernanceConfig {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceConfig";
        function type(): TypeDescriptor<GovernanceConfig>;
    }
    interface GovernanceEvents {
        create_proposal_events: event.EventHandle<aptos_governance.CreateProposalEvent>;
        update_config_events: event.EventHandle<aptos_governance.UpdateConfigEvent>;
        vote_events: event.EventHandle<aptos_governance.VoteEvent>;
    }
    namespace GovernanceEvents {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceEvents";
        function type(): TypeDescriptor<GovernanceEvents>;
    }
    interface GovernancePermission {
        dummy_field: boolean;
    }
    namespace GovernancePermission {
        const TYPE_QNAME = "0x1::aptos_governance::GovernancePermission";
        function type(): TypeDescriptor<GovernancePermission>;
    }
    interface GovernanceResponsbility {
        signer_caps: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace GovernanceResponsbility {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceResponsbility";
        function type(): TypeDescriptor<GovernanceResponsbility>;
    }
    interface RecordKey {
        stake_pool: MoveAddressType;
        proposal_id: bigint;
    }
    namespace RecordKey {
        const TYPE_QNAME = "0x1::aptos_governance::RecordKey";
        function type(): TypeDescriptor<RecordKey>;
    }
    interface UpdateConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfig {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfig";
        function type(): TypeDescriptor<UpdateConfig>;
    }
    type UpdateConfigInstance = TypedEventInstance<UpdateConfig> & {
        data_decoded: UpdateConfig;
        type_arguments: [];
    };
    interface UpdateConfigEvent {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfigEvent {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfigEvent";
        function type(): TypeDescriptor<UpdateConfigEvent>;
    }
    type UpdateConfigEventInstance = TypedEventInstance<UpdateConfigEvent> & {
        data_decoded: UpdateConfigEvent;
        type_arguments: [];
    };
    interface VotingRecords {
        votes: table.Table<aptos_governance.RecordKey, boolean>;
    }
    namespace VotingRecords {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecords";
        function type(): TypeDescriptor<VotingRecords>;
    }
    interface VotingRecordsV2 {
        votes: smart_table.SmartTable<aptos_governance.RecordKey, bigint>;
    }
    namespace VotingRecordsV2 {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecordsV2";
        function type(): TypeDescriptor<VotingRecordsV2>;
    }
    namespace entry {
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposalV2(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reconfigure(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addApprovedScriptHashScript(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchPartialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpochTestOnly(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function partialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getMinVotingThreshold(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getRequiredProposerStake(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getVotingDurationSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
        function hasEntirelyVoted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace bls12381_algebra {
    interface FormatFq12LscLsb {
        dummy_field: boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bls12381_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface HashG1XmdSha256SswuRo {
        dummy_field: boolean;
    }
    namespace HashG1XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG1XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG1XmdSha256SswuRo>;
    }
    interface HashG2XmdSha256SswuRo {
        dummy_field: boolean;
    }
    namespace HashG2XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG2XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG2XmdSha256SswuRo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace consensus_config {
    interface ConsensusConfig {
        config: string;
    }
    namespace ConsensusConfig {
        const TYPE_QNAME = "0x1::consensus_config::ConsensusConfig";
        function type(): TypeDescriptor<ConsensusConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace execution_config {
    interface ExecutionConfig {
        config: string;
    }
    namespace ExecutionConfig {
        const TYPE_QNAME = "0x1::execution_config::ExecutionConfig";
        function type(): TypeDescriptor<ExecutionConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multisig_account {
    interface Vote {
        multisig_account: MoveAddressType;
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::multisig_account::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::multisig_account::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface AddOwners {
        multisig_account: MoveAddressType;
        owners_added: MoveAddressType[];
    }
    namespace AddOwners {
        const TYPE_QNAME = "0x1::multisig_account::AddOwners";
        function type(): TypeDescriptor<AddOwners>;
    }
    type AddOwnersInstance = TypedEventInstance<AddOwners> & {
        data_decoded: AddOwners;
        type_arguments: [];
    };
    interface AddOwnersEvent {
        owners_added: MoveAddressType[];
    }
    namespace AddOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::AddOwnersEvent";
        function type(): TypeDescriptor<AddOwnersEvent>;
    }
    type AddOwnersEventInstance = TypedEventInstance<AddOwnersEvent> & {
        data_decoded: AddOwnersEvent;
        type_arguments: [];
    };
    interface CreateTransaction {
        multisig_account: MoveAddressType;
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransaction {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransaction";
        function type(): TypeDescriptor<CreateTransaction>;
    }
    type CreateTransactionInstance = TypedEventInstance<CreateTransaction> & {
        data_decoded: CreateTransaction;
        type_arguments: [];
    };
    interface CreateTransactionEvent {
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransactionEvent";
        function type(): TypeDescriptor<CreateTransactionEvent>;
    }
    type CreateTransactionEventInstance = TypedEventInstance<CreateTransactionEvent> & {
        data_decoded: CreateTransactionEvent;
        type_arguments: [];
    };
    interface ExecuteRejectedTransaction {
        multisig_account: MoveAddressType;
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransaction {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransaction";
        function type(): TypeDescriptor<ExecuteRejectedTransaction>;
    }
    type ExecuteRejectedTransactionInstance = TypedEventInstance<ExecuteRejectedTransaction> & {
        data_decoded: ExecuteRejectedTransaction;
        type_arguments: [];
    };
    interface ExecuteRejectedTransactionEvent {
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransactionEvent";
        function type(): TypeDescriptor<ExecuteRejectedTransactionEvent>;
    }
    type ExecuteRejectedTransactionEventInstance = TypedEventInstance<ExecuteRejectedTransactionEvent> & {
        data_decoded: ExecuteRejectedTransactionEvent;
        type_arguments: [];
    };
    interface ExecutionError {
        abort_location: string;
        error_type: string;
        error_code: bigint;
    }
    namespace ExecutionError {
        const TYPE_QNAME = "0x1::multisig_account::ExecutionError";
        function type(): TypeDescriptor<ExecutionError>;
    }
    interface MetadataUpdated {
        multisig_account: MoveAddressType;
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdated {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdated";
        function type(): TypeDescriptor<MetadataUpdated>;
    }
    type MetadataUpdatedInstance = TypedEventInstance<MetadataUpdated> & {
        data_decoded: MetadataUpdated;
        type_arguments: [];
    };
    interface MetadataUpdatedEvent {
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdatedEvent {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdatedEvent";
        function type(): TypeDescriptor<MetadataUpdatedEvent>;
    }
    type MetadataUpdatedEventInstance = TypedEventInstance<MetadataUpdatedEvent> & {
        data_decoded: MetadataUpdatedEvent;
        type_arguments: [];
    };
    interface MultisigAccount {
        owners: MoveAddressType[];
        num_signatures_required: bigint;
        transactions: table.Table<bigint, multisig_account.MultisigTransaction>;
        last_executed_sequence_number: bigint;
        next_sequence_number: bigint;
        signer_cap: option.Option<account.SignerCapability>;
        metadata: simple_map.SimpleMap<string, string>;
        add_owners_events: event.EventHandle<multisig_account.AddOwnersEvent>;
        remove_owners_events: event.EventHandle<multisig_account.RemoveOwnersEvent>;
        update_signature_required_events: event.EventHandle<multisig_account.UpdateSignaturesRequiredEvent>;
        create_transaction_events: event.EventHandle<multisig_account.CreateTransactionEvent>;
        vote_events: event.EventHandle<multisig_account.VoteEvent>;
        execute_rejected_transaction_events: event.EventHandle<multisig_account.ExecuteRejectedTransactionEvent>;
        execute_transaction_events: event.EventHandle<multisig_account.TransactionExecutionSucceededEvent>;
        transaction_execution_failed_events: event.EventHandle<multisig_account.TransactionExecutionFailedEvent>;
        metadata_updated_events: event.EventHandle<multisig_account.MetadataUpdatedEvent>;
    }
    namespace MultisigAccount {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccount";
        function type(): TypeDescriptor<MultisigAccount>;
    }
    interface MultisigAccountCreationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationMessage>;
    }
    interface MultisigAccountCreationWithAuthKeyRevocationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationWithAuthKeyRevocationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationWithAuthKeyRevocationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationWithAuthKeyRevocationMessage>;
    }
    interface MultisigTransaction {
        payload: option.Option<string>;
        payload_hash: option.Option<string>;
        votes: simple_map.SimpleMap<MoveAddressType, boolean>;
        creator: MoveAddressType;
        creation_time_secs: bigint;
    }
    namespace MultisigTransaction {
        const TYPE_QNAME = "0x1::multisig_account::MultisigTransaction";
        function type(): TypeDescriptor<MultisigTransaction>;
    }
    interface RemoveOwners {
        multisig_account: MoveAddressType;
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwners {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwners";
        function type(): TypeDescriptor<RemoveOwners>;
    }
    type RemoveOwnersInstance = TypedEventInstance<RemoveOwners> & {
        data_decoded: RemoveOwners;
        type_arguments: [];
    };
    interface RemoveOwnersEvent {
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwnersEvent";
        function type(): TypeDescriptor<RemoveOwnersEvent>;
    }
    type RemoveOwnersEventInstance = TypedEventInstance<RemoveOwnersEvent> & {
        data_decoded: RemoveOwnersEvent;
        type_arguments: [];
    };
    interface TransactionExecutionFailed {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailed {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailed";
        function type(): TypeDescriptor<TransactionExecutionFailed>;
    }
    type TransactionExecutionFailedInstance = TypedEventInstance<TransactionExecutionFailed> & {
        data_decoded: TransactionExecutionFailed;
        type_arguments: [];
    };
    interface TransactionExecutionFailedEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailedEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailedEvent";
        function type(): TypeDescriptor<TransactionExecutionFailedEvent>;
    }
    type TransactionExecutionFailedEventInstance = TypedEventInstance<TransactionExecutionFailedEvent> & {
        data_decoded: TransactionExecutionFailedEvent;
        type_arguments: [];
    };
    interface TransactionExecutionSucceeded {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceeded {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceeded";
        function type(): TypeDescriptor<TransactionExecutionSucceeded>;
    }
    type TransactionExecutionSucceededInstance = TypedEventInstance<TransactionExecutionSucceeded> & {
        data_decoded: TransactionExecutionSucceeded;
        type_arguments: [];
    };
    interface TransactionExecutionSucceededEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceededEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceededEvent";
        function type(): TypeDescriptor<TransactionExecutionSucceededEvent>;
    }
    type TransactionExecutionSucceededEventInstance = TypedEventInstance<TransactionExecutionSucceededEvent> & {
        data_decoded: TransactionExecutionSucceededEvent;
        type_arguments: [];
    };
    interface UpdateSignaturesRequired {
        multisig_account: MoveAddressType;
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequired {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequired";
        function type(): TypeDescriptor<UpdateSignaturesRequired>;
    }
    type UpdateSignaturesRequiredInstance = TypedEventInstance<UpdateSignaturesRequired> & {
        data_decoded: UpdateSignaturesRequired;
        type_arguments: [];
    };
    interface UpdateSignaturesRequiredEvent {
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequiredEvent {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequiredEvent";
        function type(): TypeDescriptor<UpdateSignaturesRequiredEvent>;
    }
    type UpdateSignaturesRequiredEventInstance = TypedEventInstance<UpdateSignaturesRequiredEvent> & {
        data_decoded: UpdateSignaturesRequiredEvent;
        type_arguments: [];
    };
    namespace entry {
        function create(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function approveTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransactionWithHash(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountAndRevokeAuthKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountAndRevokeAuthKeyCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwnersThenRemoveBootstrapper(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rejectTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateMetadata(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransanction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function isOwner(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function metadata(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function vote(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint, MoveAddressType];
        }, version?: bigint): Promise<[boolean, boolean]>;
        function availableTransactionQueueCapacity(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function canBeExecuted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canBeRejected(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canExecute(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canReject(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function numSignaturesRequired(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function owners(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function getNextMultisigAccountAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getNextTransactionPayload(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[string]>;
        function getPendingTransactions(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction[]]>;
        function getTransaction(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction]>;
        function lastResolvedSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function nextSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace nonce_validation {
    interface Bucket {
        nonces_ordered_by_exp_time: big_ordered_map.BigOrderedMap<nonce_validation.NonceKeyWithExpTime, boolean>;
        nonce_to_exp_time_map: big_ordered_map.BigOrderedMap<nonce_validation.NonceKey, bigint>;
    }
    namespace Bucket {
        const TYPE_QNAME = "0x1::nonce_validation::Bucket";
        function type(): TypeDescriptor<Bucket>;
    }
    interface NonceHistory {
        nonce_table: table.Table<bigint, nonce_validation.Bucket>;
        next_key: bigint;
    }
    namespace NonceHistory {
        const TYPE_QNAME = "0x1::nonce_validation::NonceHistory";
        function type(): TypeDescriptor<NonceHistory>;
    }
    interface NonceKey {
        sender_address: MoveAddressType;
        nonce: bigint;
    }
    namespace NonceKey {
        const TYPE_QNAME = "0x1::nonce_validation::NonceKey";
        function type(): TypeDescriptor<NonceKey>;
    }
    interface NonceKeyWithExpTime {
        txn_expiration_time: bigint;
        sender_address: MoveAddressType;
        nonce: bigint;
    }
    namespace NonceKeyWithExpTime {
        const TYPE_QNAME = "0x1::nonce_validation::NonceKeyWithExpTime";
        function type(): TypeDescriptor<NonceKeyWithExpTime>;
    }
    namespace entry {
        function addNonceBuckets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeNonceTable(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace pool_u64_unbound {
    interface Pool {
        total_coins: bigint;
        total_shares: bigint;
        shares: table_with_length.TableWithLength<MoveAddressType, bigint>;
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64_unbound::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace resource_account {
    interface Container {
        store: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace Container {
        const TYPE_QNAME = "0x1::resource_account::Container";
        function type(): TypeDescriptor<Container>;
    }
    namespace entry {
        function createResourceAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndFund(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndPublishPackage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace staking_contract {
    interface AddStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::staking_contract::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface UnlockStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    type SetBeneficiaryForOperatorInstance = TypedEventInstance<SetBeneficiaryForOperator> & {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    };
    interface AddDistribution {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistribution {
        const TYPE_QNAME = "0x1::staking_contract::AddDistribution";
        function type(): TypeDescriptor<AddDistribution>;
    }
    type AddDistributionInstance = TypedEventInstance<AddDistribution> & {
        data_decoded: AddDistribution;
        type_arguments: [];
    };
    interface AddDistributionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistributionEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddDistributionEvent";
        function type(): TypeDescriptor<AddDistributionEvent>;
    }
    type AddDistributionEventInstance = TypedEventInstance<AddDistributionEvent> & {
        data_decoded: AddDistributionEvent;
        type_arguments: [];
    };
    interface CreateStakingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContract {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContract";
        function type(): TypeDescriptor<CreateStakingContract>;
    }
    type CreateStakingContractInstance = TypedEventInstance<CreateStakingContract> & {
        data_decoded: CreateStakingContract;
        type_arguments: [];
    };
    interface CreateStakingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContractEvent {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContractEvent";
        function type(): TypeDescriptor<CreateStakingContractEvent>;
    }
    type CreateStakingContractEventInstance = TypedEventInstance<CreateStakingContractEvent> & {
        data_decoded: CreateStakingContractEvent;
        type_arguments: [];
    };
    interface Distribute {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::staking_contract::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    type DistributeInstance = TypedEventInstance<Distribute> & {
        data_decoded: Distribute;
        type_arguments: [];
    };
    interface DistributeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::staking_contract::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    type DistributeEventInstance = TypedEventInstance<DistributeEvent> & {
        data_decoded: DistributeEvent;
        type_arguments: [];
    };
    interface RequestCommission {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommission {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommission";
        function type(): TypeDescriptor<RequestCommission>;
    }
    type RequestCommissionInstance = TypedEventInstance<RequestCommission> & {
        data_decoded: RequestCommission;
        type_arguments: [];
    };
    interface RequestCommissionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommissionEvent";
        function type(): TypeDescriptor<RequestCommissionEvent>;
    }
    type RequestCommissionEventInstance = TypedEventInstance<RequestCommissionEvent> & {
        data_decoded: RequestCommissionEvent;
        type_arguments: [];
    };
    interface ResetLockup {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    type ResetLockupInstance = TypedEventInstance<ResetLockup> & {
        data_decoded: ResetLockup;
        type_arguments: [];
    };
    interface ResetLockupEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    type ResetLockupEventInstance = TypedEventInstance<ResetLockupEvent> & {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    };
    interface Staker {
        staker: MoveAddressType;
    }
    namespace Staker {
        const TYPE_QNAME = "0x1::staking_contract::Staker";
        function type(): TypeDescriptor<Staker>;
    }
    interface StakingContract {
        principal: bigint;
        pool_address: MoveAddressType;
        owner_cap: stake.OwnerCapability;
        commission_percentage: bigint;
        distribution_pool: pool_u64.Pool;
        signer_cap: account.SignerCapability;
    }
    namespace StakingContract {
        const TYPE_QNAME = "0x1::staking_contract::StakingContract";
        function type(): TypeDescriptor<StakingContract>;
    }
    interface StakingGroupContainer {
        dummy_field: boolean;
    }
    namespace StakingGroupContainer {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupContainer";
        function type(): TypeDescriptor<StakingGroupContainer>;
    }
    interface StakingGroupUpdateCommissionEvent {
        update_commission_events: event.EventHandle<staking_contract.UpdateCommissionEvent>;
    }
    namespace StakingGroupUpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupUpdateCommissionEvent";
        function type(): TypeDescriptor<StakingGroupUpdateCommissionEvent>;
    }
    type StakingGroupUpdateCommissionEventInstance = TypedEventInstance<StakingGroupUpdateCommissionEvent> & {
        data_decoded: StakingGroupUpdateCommissionEvent;
        type_arguments: [];
    };
    interface Store {
        staking_contracts: simple_map.SimpleMap<MoveAddressType, staking_contract.StakingContract>;
        create_staking_contract_events: event.EventHandle<staking_contract.CreateStakingContractEvent>;
        update_voter_events: event.EventHandle<staking_contract.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<staking_contract.ResetLockupEvent>;
        add_stake_events: event.EventHandle<staking_contract.AddStakeEvent>;
        request_commission_events: event.EventHandle<staking_contract.RequestCommissionEvent>;
        unlock_stake_events: event.EventHandle<staking_contract.UnlockStakeEvent>;
        switch_operator_events: event.EventHandle<staking_contract.SwitchOperatorEvent>;
        add_distribution_events: event.EventHandle<staking_contract.AddDistributionEvent>;
        distribute_events: event.EventHandle<staking_contract.DistributeEvent>;
    }
    namespace Store {
        const TYPE_QNAME = "0x1::staking_contract::Store";
        function type(): TypeDescriptor<Store>;
    }
    interface SwitchOperator {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperator {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperator";
        function type(): TypeDescriptor<SwitchOperator>;
    }
    type SwitchOperatorInstance = TypedEventInstance<SwitchOperator> & {
        data_decoded: SwitchOperator;
        type_arguments: [];
    };
    interface SwitchOperatorEvent {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperatorEvent {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperatorEvent";
        function type(): TypeDescriptor<SwitchOperatorEvent>;
    }
    type SwitchOperatorEventInstance = TypedEventInstance<SwitchOperatorEvent> & {
        data_decoded: SwitchOperatorEvent;
        type_arguments: [];
    };
    interface UpdateCommission {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommission {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommission";
        function type(): TypeDescriptor<UpdateCommission>;
    }
    type UpdateCommissionInstance = TypedEventInstance<UpdateCommission> & {
        data_decoded: UpdateCommission;
        type_arguments: [];
    };
    interface UpdateCommissionEvent {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommissionEvent";
        function type(): TypeDescriptor<UpdateCommissionEvent>;
    }
    type UpdateCommissionEventInstance = TypedEventInstance<UpdateCommissionEvent> & {
        data_decoded: UpdateCommissionEvent;
        type_arguments: [];
    };
    interface UpdateVoter {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    type UpdateVoterInstance = TypedEventInstance<UpdateVoter> & {
        data_decoded: UpdateVoter;
        type_arguments: [];
    };
    interface UpdateVoterEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    type UpdateVoterEventInstance = TypedEventInstance<UpdateVoterEvent> & {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    };
    namespace entry {
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createStakingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType,
                bigint,
                bigint,
                string
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function requestCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommision(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function commissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function lastRecordedPrincipal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function pendingDistributionCounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function stakerAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<MoveAddressType>]>;
        function stakingContractAmounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function stakingContractExists(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace system_addresses {
    namespace entry { }
    namespace view { }
}
export declare namespace federated_keyless {
    interface PublicKey {
        jwk_address: MoveAddressType;
        keyless_public_key: keyless.PublicKey;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::federated_keyless::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config {
    interface ConfigOff {
        dummy_field: boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::randomness_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigV1 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV2 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
        fast_path_secrecy_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV2 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV2";
        function type(): TypeDescriptor<ConfigV2>;
    }
    interface RandomnessConfig {
        variant: copyable_any.Any;
    }
    namespace RandomnessConfig {
        const TYPE_QNAME = "0x1::randomness_config::RandomnessConfig";
        function type(): TypeDescriptor<RandomnessConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace table_with_length {
    interface TableWithLength<T0, T1> {
        inner: table.Table<T0, T1>;
        length: bigint;
    }
    namespace TableWithLength {
        const TYPE_QNAME = "0x1::table_with_length::TableWithLength";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<TableWithLength<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator_factory {
    interface AggregatorFactory {
        phantom_table: table.Table<MoveAddressType, bigint>;
    }
    namespace AggregatorFactory {
        const TYPE_QNAME = "0x1::aggregator_factory::AggregatorFactory";
        function type(): TypeDescriptor<AggregatorFactory>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace account_abstraction {
    interface DerivableDispatchableAuthenticator {
    }
    namespace DerivableDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::DerivableDispatchableAuthenticator";
        function type(): TypeDescriptor<DerivableDispatchableAuthenticator>;
    }
    interface DerivableRegisterValue {
    }
    namespace DerivableRegisterValue {
        const TYPE_QNAME = "0x1::account_abstraction::DerivableRegisterValue";
        function type(): TypeDescriptor<DerivableRegisterValue>;
    }
    interface DispatchableAuthenticator {
    }
    namespace DispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::DispatchableAuthenticator";
        function type(): TypeDescriptor<DispatchableAuthenticator>;
    }
    interface RemoveDispatchableAuthenticator {
        account: MoveAddressType;
    }
    namespace RemoveDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::RemoveDispatchableAuthenticator";
        function type(): TypeDescriptor<RemoveDispatchableAuthenticator>;
    }
    type RemoveDispatchableAuthenticatorInstance = TypedEventInstance<RemoveDispatchableAuthenticator> & {
        data_decoded: RemoveDispatchableAuthenticator;
        type_arguments: [];
    };
    interface UpdateDispatchableAuthenticator {
        account: MoveAddressType;
        update: string;
        auth_function: function_info.FunctionInfo;
    }
    namespace UpdateDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::UpdateDispatchableAuthenticator";
        function type(): TypeDescriptor<UpdateDispatchableAuthenticator>;
    }
    type UpdateDispatchableAuthenticatorInstance = TypedEventInstance<UpdateDispatchableAuthenticator> & {
        data_decoded: UpdateDispatchableAuthenticator;
        type_arguments: [];
    };
    namespace entry {
        function initialize(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addDispatchableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function registerDerivableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeAuthenticator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDispatchableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDispatchableAuthenticator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function deriveAccountAddressView(client: Aptos, request: {
            functionArguments: [MoveAddressType, string, string, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function dispatchableAuthenticator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<function_info.FunctionInfo[]>]>;
        function usingDispatchableAuthenticator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace governance_proposal {
    interface GovernanceProposal {
        dummy_field: boolean;
    }
    namespace GovernanceProposal {
        const TYPE_QNAME = "0x1::governance_proposal::GovernanceProposal";
        function type(): TypeDescriptor<GovernanceProposal>;
    }
    type GovernanceProposalInstance = TypedEventInstance<GovernanceProposal> & {
        data_decoded: GovernanceProposal;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace optional_aggregator {
    interface Integer {
        value: bigint;
        limit: bigint;
    }
    namespace Integer {
        const TYPE_QNAME = "0x1::optional_aggregator::Integer";
        function type(): TypeDescriptor<Integer>;
    }
    interface OptionalAggregator {
        aggregator: option.Option<aggregator.Aggregator>;
        integer: option.Option<optional_aggregator.Integer>;
    }
    namespace OptionalAggregator {
        const TYPE_QNAME = "0x1::optional_aggregator::OptionalAggregator";
        function type(): TypeDescriptor<OptionalAggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace permissioned_signer {
    interface GrantedPermissionHandles {
        active_handles: MoveAddressType[];
    }
    namespace GrantedPermissionHandles {
        const TYPE_QNAME = "0x1::permissioned_signer::GrantedPermissionHandles";
        function type(): TypeDescriptor<GrantedPermissionHandles>;
    }
    interface PermissionStorage {
    }
    namespace PermissionStorage {
        const TYPE_QNAME = "0x1::permissioned_signer::PermissionStorage";
        function type(): TypeDescriptor<PermissionStorage>;
    }
    interface PermissionedHandle {
    }
    namespace PermissionedHandle {
        const TYPE_QNAME = "0x1::permissioned_signer::PermissionedHandle";
        function type(): TypeDescriptor<PermissionedHandle>;
    }
    interface RevokePermissionHandlePermission {
        dummy_field: boolean;
    }
    namespace RevokePermissionHandlePermission {
        const TYPE_QNAME = "0x1::permissioned_signer::RevokePermissionHandlePermission";
        function type(): TypeDescriptor<RevokePermissionHandlePermission>;
    }
    interface StorablePermissionedHandle {
    }
    namespace StorablePermissionedHandle {
        const TYPE_QNAME = "0x1::permissioned_signer::StorablePermissionedHandle";
        function type(): TypeDescriptor<StorablePermissionedHandle>;
    }
    interface StoredPermission {
    }
    namespace StoredPermission {
        const TYPE_QNAME = "0x1::permissioned_signer::StoredPermission";
        function type(): TypeDescriptor<StoredPermission>;
    }
    namespace entry {
        function revokeAllHandles(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokePermissionStorageAddress(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace transaction_context {
    interface AUID {
        unique_address: MoveAddressType;
    }
    namespace AUID {
        const TYPE_QNAME = "0x1::transaction_context::AUID";
        function type(): TypeDescriptor<AUID>;
    }
    type AUIDInstance = TypedEventInstance<AUID> & {
        data_decoded: AUID;
        type_arguments: [];
    };
    interface EntryFunctionPayload {
        account_address: MoveAddressType;
        module_name: string;
        function_name: string;
        ty_args_names: string[];
        args: string[];
    }
    namespace EntryFunctionPayload {
        const TYPE_QNAME = "0x1::transaction_context::EntryFunctionPayload";
        function type(): TypeDescriptor<EntryFunctionPayload>;
    }
    interface MultisigPayload {
        multisig_address: MoveAddressType;
        entry_function_payload: option.Option<transaction_context.EntryFunctionPayload>;
    }
    namespace MultisigPayload {
        const TYPE_QNAME = "0x1::transaction_context::MultisigPayload";
        function type(): TypeDescriptor<MultisigPayload>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace jwk_consensus_config {
    interface ConfigOff {
        dummy_field: boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigV1 {
        oidc_providers: jwk_consensus_config.OIDCProvider[];
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwk_consensus_config::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface JWKConsensusConfig {
        variant: copyable_any.Any;
    }
    namespace JWKConsensusConfig {
        const TYPE_QNAME = "0x1::jwk_consensus_config::JWKConsensusConfig";
        function type(): TypeDescriptor<JWKConsensusConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_elgamal {
    interface Ciphertext {
        left: ristretto255.RistrettoPoint;
        right: ristretto255.RistrettoPoint;
    }
    namespace Ciphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::Ciphertext";
        function type(): TypeDescriptor<Ciphertext>;
    }
    interface CompressedCiphertext {
        left: ristretto255.CompressedRistretto;
        right: ristretto255.CompressedRistretto;
    }
    namespace CompressedCiphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedCiphertext";
        function type(): TypeDescriptor<CompressedCiphertext>;
    }
    interface CompressedPubkey {
        point: ristretto255.CompressedRistretto;
    }
    namespace CompressedPubkey {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedPubkey";
        function type(): TypeDescriptor<CompressedPubkey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_state {
    interface State {
        variant: copyable_any.Any;
    }
    namespace State {
        const TYPE_QNAME = "0x1::reconfiguration_state::State";
        function type(): TypeDescriptor<State>;
    }
    interface StateActive {
        start_time_secs: bigint;
    }
    namespace StateActive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateActive";
        function type(): TypeDescriptor<StateActive>;
    }
    interface StateInactive {
        dummy_field: boolean;
    }
    namespace StateInactive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateInactive";
        function type(): TypeDescriptor<StateInactive>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_pedersen {
    interface Commitment {
        point: ristretto255.RistrettoPoint;
    }
    namespace Commitment {
        const TYPE_QNAME = "0x1::ristretto255_pedersen::Commitment";
        function type(): TypeDescriptor<Commitment>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace object_code_deployment {
    interface Freeze {
        object_address: MoveAddressType;
    }
    namespace Freeze {
        const TYPE_QNAME = "0x1::object_code_deployment::Freeze";
        function type(): TypeDescriptor<Freeze>;
    }
    type FreezeInstance = TypedEventInstance<Freeze> & {
        data_decoded: Freeze;
        type_arguments: [];
    };
    interface ManagingRefs {
        extend_ref: object$.ExtendRef;
    }
    namespace ManagingRefs {
        const TYPE_QNAME = "0x1::object_code_deployment::ManagingRefs";
        function type(): TypeDescriptor<ManagingRefs>;
    }
    interface Publish {
        object_address: MoveAddressType;
    }
    namespace Publish {
        const TYPE_QNAME = "0x1::object_code_deployment::Publish";
        function type(): TypeDescriptor<Publish>;
    }
    type PublishInstance = TypedEventInstance<Publish> & {
        data_decoded: Publish;
        type_arguments: [];
    };
    interface Upgrade {
        object_address: MoveAddressType;
    }
    namespace Upgrade {
        const TYPE_QNAME = "0x1::object_code_deployment::Upgrade";
        function type(): TypeDescriptor<Upgrade>;
    }
    type UpgradeInstance = TypedEventInstance<Upgrade> & {
        data_decoded: Upgrade;
        type_arguments: [];
    };
    namespace entry {
        function freezeCodeObject(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [object$.Object<code.PackageRegistry>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function publish(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgrade(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string[],
                object$.Object<code.PackageRegistry>
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace primary_fungible_store {
    interface DeriveRefPod {
        metadata_derive_ref: object$.DeriveRef;
    }
    namespace DeriveRefPod {
        const TYPE_QNAME = "0x1::primary_fungible_store::DeriveRefPod";
        function type(): TypeDescriptor<DeriveRefPod>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object$.Object<T0>,
                MoveAddressType,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function primaryStore<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[object$.Object<fungible_asset.FungibleStore>]>;
        function primaryStoreAddress<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function primaryStoreExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace transaction_validation {
    interface GasPermission {
        dummy_field: boolean;
    }
    namespace GasPermission {
        const TYPE_QNAME = "0x1::transaction_validation::GasPermission";
        function type(): TypeDescriptor<GasPermission>;
    }
    interface ReplayProtector {
    }
    namespace ReplayProtector {
        const TYPE_QNAME = "0x1::transaction_validation::ReplayProtector";
        function type(): TypeDescriptor<ReplayProtector>;
    }
    interface TransactionValidation {
        module_addr: MoveAddressType;
        module_name: string;
        script_prologue_name: string;
        module_prologue_name: string;
        multi_agent_prologue_name: string;
        user_epilogue_name: string;
    }
    namespace TransactionValidation {
        const TYPE_QNAME = "0x1::transaction_validation::TransactionValidation";
        function type(): TypeDescriptor<TransactionValidation>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace permissioned_delegation {
    interface AccountDelegation {
    }
    namespace AccountDelegation {
        const TYPE_QNAME = "0x1::permissioned_delegation::AccountDelegation";
        function type(): TypeDescriptor<AccountDelegation>;
    }
    interface DelegationKey {
    }
    namespace DelegationKey {
        const TYPE_QNAME = "0x1::permissioned_delegation::DelegationKey";
        function type(): TypeDescriptor<DelegationKey>;
    }
    interface RegisteredDelegations {
        delegations: big_ordered_map.BigOrderedMap<permissioned_delegation.DelegationKey, permissioned_delegation.AccountDelegation>;
    }
    namespace RegisteredDelegations {
        const TYPE_QNAME = "0x1::permissioned_delegation::RegisteredDelegations";
        function type(): TypeDescriptor<RegisteredDelegations>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace storage_slots_allocator {
    interface Link<T0> {
    }
    namespace Link {
        const TYPE_QNAME = "0x1::storage_slots_allocator::Link";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Link<T0>>;
    }
    interface ReservedSlot {
        slot_index: bigint;
    }
    namespace ReservedSlot {
        const TYPE_QNAME = "0x1::storage_slots_allocator::ReservedSlot";
        function type(): TypeDescriptor<ReservedSlot>;
    }
    interface StorageSlotsAllocator<T0> {
    }
    namespace StorageSlotsAllocator {
        const TYPE_QNAME = "0x1::storage_slots_allocator::StorageSlotsAllocator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<StorageSlotsAllocator<T0>>;
    }
    interface StoredSlot {
        slot_index: bigint;
    }
    namespace StoredSlot {
        const TYPE_QNAME = "0x1::storage_slots_allocator::StoredSlot";
        function type(): TypeDescriptor<StoredSlot>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_api_v0_config {
    interface AllowCustomMaxGasFlag {
        value: boolean;
    }
    namespace AllowCustomMaxGasFlag {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::AllowCustomMaxGasFlag";
        function type(): TypeDescriptor<AllowCustomMaxGasFlag>;
    }
    interface RequiredGasDeposit {
        gas_amount: option.Option<bigint>;
    }
    namespace RequiredGasDeposit {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::RequiredGasDeposit";
        function type(): TypeDescriptor<RequiredGasDeposit>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config_seqnum {
    interface RandomnessConfigSeqNum {
        seq_num: bigint;
    }
    namespace RandomnessConfigSeqNum {
        const TYPE_QNAME = "0x1::randomness_config_seqnum::RandomnessConfigSeqNum";
        function type(): TypeDescriptor<RandomnessConfigSeqNum>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_with_dkg {
    namespace entry { }
    namespace view { }
}
export declare namespace solana_derivable_account {
    interface SIWSAbstractSignature {
    }
    namespace SIWSAbstractSignature {
        const TYPE_QNAME = "0x1::solana_derivable_account::SIWSAbstractSignature";
        function type(): TypeDescriptor<SIWSAbstractSignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace validator_consensus_info {
    interface ValidatorConsensusInfo {
        addr: MoveAddressType;
        pk_bytes: string;
        voting_power: bigint;
    }
    namespace ValidatorConsensusInfo {
        const TYPE_QNAME = "0x1::validator_consensus_info::ValidatorConsensusInfo";
        function type(): TypeDescriptor<ValidatorConsensusInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_bulletproofs {
    interface RangeProof {
        bytes: string;
    }
    namespace RangeProof {
        const TYPE_QNAME = "0x1::ristretto255_bulletproofs::RangeProof";
        function type(): TypeDescriptor<RangeProof>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ethereum_derivable_account {
    interface SIWEAbstractPublicKey {
        ethereum_address: string;
        domain: string;
    }
    namespace SIWEAbstractPublicKey {
        const TYPE_QNAME = "0x1::ethereum_derivable_account::SIWEAbstractPublicKey";
        function type(): TypeDescriptor<SIWEAbstractPublicKey>;
    }
    interface SIWEAbstractSignature {
    }
    namespace SIWEAbstractSignature {
        const TYPE_QNAME = "0x1::ethereum_derivable_account::SIWEAbstractSignature";
        function type(): TypeDescriptor<SIWEAbstractSignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace dispatchable_fungible_asset {
    interface TransferRefStore {
        transfer_ref: fungible_asset.TransferRef;
    }
    namespace TransferRefStore {
        const TYPE_QNAME = "0x1::dispatchable_fungible_asset::TransferRefStore";
        function type(): TypeDescriptor<TransferRefStore>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object$.Object<T0>,
                object$.Object<T0>,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function derivedBalance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function derivedSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function isDerivedBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace common_account_abstractions_utils {
    namespace entry { }
    namespace view { }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map