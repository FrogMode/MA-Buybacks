"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveCoder = void 0;
exports.defaultMoveCoder = defaultMoveCoder;
const move_1 = require("@typemove/move");
const aptos_chain_adapter_js_1 = require("./aptos-chain-adapter.js");
const to_internal_js_1 = require("./to-internal.js");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
class MoveCoder extends move_1.AbstractMoveCoder {
    ignoreObjectInnerField;
    constructor(client, ignoreObjectInnerField = false) {
        super(new aptos_chain_adapter_js_1.AptosChainAdapter(client));
        this.ignoreObjectInnerField = ignoreObjectInnerField;
    }
    load(module, address) {
        if (!module.abi) {
            throw Error('Module without abi');
        }
        let m = this.moduleMapping.get(module.abi.address + '::' + module.abi.name);
        // if (this.contains(module.abi.address, module.abi.name)) {
        //   return
        // }
        if (m) {
            return m;
        }
        this.accounts.add(module.abi.address);
        m = (0, to_internal_js_1.toInternalModule)(module);
        this.loadInternal(m, address);
        return m;
    }
    decodeEvent(event) {
        // TODO fix type
        return this.decodedStruct(event);
    }
    filterAndDecodeEvents(type, resources) {
        if (typeof type === 'string') {
            type = (0, move_1.parseMoveType)(type);
        }
        // TODO fix type
        return this.filterAndDecodeStruct(type, resources);
    }
    decodeResource(res) {
        return this.decodedStruct(res);
    }
    async decode(data, type) {
        switch (type.qname) {
            case '0x1::object::Object':
                if (this.ignoreObjectInnerField && typeof data === 'string') {
                    return data;
                }
                if (typeof data === 'object' && data?.inner !== undefined && typeof data?.inner === 'string') {
                    return data.inner;
                }
        }
        return super.decode(data, type);
    }
    filterAndDecodeResources(type, resources) {
        if (typeof type === 'string') {
            type = (0, move_1.parseMoveType)(type);
        }
        return this.filterAndDecodeStruct(type, resources);
    }
    async decodeFunctionPayload(payload) {
        const func = await this.getMoveFunction(payload.function);
        const params = this.adapter.getMeaningfulFunctionParams(func.params);
        const argumentsDecoded = await this.decodeArray(payload.arguments, params);
        return {
            ...payload,
            arguments_decoded: argumentsDecoded
        };
    }
    toMoveValue(value) {
        switch (typeof value) {
            case 'boolean':
                return value;
            case 'number':
                return value;
            case 'bigint':
                return value.toString();
            case 'object':
                if (Array.isArray(value)) {
                    return value.map(this.toMoveValue);
                }
                return value;
            default:
                return value.toString();
        }
    }
}
exports.MoveCoder = MoveCoder;
const DEFAULT_CONFIG = new ts_sdk_1.AptosConfig({ network: ts_sdk_1.Network.MAINNET });
const CODER_MAP = new Map();
function defaultMoveCoder(config = DEFAULT_CONFIG) {
    const configKey = config.fullnode ? config.fullnode : config.network;
    let coder = CODER_MAP.get(configKey);
    if (!coder) {
        coder = new MoveCoder(new ts_sdk_1.Aptos(config));
        CODER_MAP.set(configKey, coder);
    }
    return coder;
}
//# sourceMappingURL=move-coder.js.map