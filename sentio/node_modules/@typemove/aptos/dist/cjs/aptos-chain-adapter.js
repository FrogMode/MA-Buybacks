"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosChainAdapter = void 0;
const move_1 = require("@typemove/move");
const to_internal_js_1 = require("./to-internal.js");
class AptosChainAdapter extends move_1.ChainAdapter {
    // static INSTANCE = new AptosChainAdapter()
    client;
    optimisticEventDetection = true;
    constructor(client, optimisticEventDetection = true) {
        super();
        this.client = client;
        this.optimisticEventDetection = optimisticEventDetection;
    }
    async fetchModules(account) {
        return await this.client.getAccountModules({
            accountAddress: account
        });
    }
    async fetchModule(account, module) {
        return await this.client.getAccountModule({
            accountAddress: account,
            moduleName: module
        });
    }
    toInternalModules(modules) {
        return modules.flatMap((m) => (m.abi ? [(0, to_internal_js_1.toInternalModule)(m)] : []));
    }
    getMeaningfulFunctionParams(params) {
        if (params.length === 0) {
            return params;
        }
        if (params[0].qname === 'signer' && params[0].reference) {
            params = params.slice(1);
        }
        return params;
    }
    getAllEventStructs(modules) {
        const eventMap = new Map();
        const structMap = new Map();
        for (const module of modules) {
            const qname = (0, move_1.moduleQname)(module);
            for (const struct of module.structs) {
                const typeName = qname + move_1.SPLITTER + struct.name;
                // Skip deprecated v2 events
                if (typeName == '0x1::coin::Deposit' || typeName == '0x1::coin::Withdraw') {
                    continue;
                }
                structMap.set(typeName, struct);
                // Check if struct is explicitly marked as event
                if (struct.isEvent) {
                    eventMap.set(typeName, struct);
                    continue;
                }
                if (struct.name.endsWith('Event')) {
                    // this is a hack to support some old events
                    eventMap.set(typeName, struct);
                    continue;
                }
                // Check for native events: structs with EXACTLY drop and store abilities
                if (this.optimisticEventDetection) {
                    const abilities = new Set(struct.abilities);
                    if (abilities.size === 2 && abilities.has('drop') && abilities.has('store')) {
                        eventMap.set(typeName, struct);
                    }
                }
            }
        }
        // Also check for legacy events (in EventHandle fields)
        for (const module of modules) {
            for (const struct of module.structs) {
                for (const field of struct.fields) {
                    const t = field.type;
                    if (t.qname === '0x1::event::EventHandle') {
                        const event = t.typeArgs[0].qname;
                        const eventStruct = structMap.get(event);
                        if (eventStruct) {
                            eventMap.set(event, eventStruct);
                        }
                    }
                }
            }
        }
        return eventMap;
    }
    getType(data) {
        return data.type;
    }
    getData(data) {
        if ('data' in data && 'type' in data) {
            return data.data;
        }
        return data;
    }
    async getChainId() {
        return (await this.client.getChainId()).toString();
    }
}
exports.AptosChainAdapter = AptosChainAdapter;
//# sourceMappingURL=aptos-chain-adapter.js.map