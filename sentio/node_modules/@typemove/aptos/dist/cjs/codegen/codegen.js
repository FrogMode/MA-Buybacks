"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosCodegen = void 0;
exports.codegen = codegen;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const path_1 = require("path");
const aptos_chain_adapter_js_1 = require("../aptos-chain-adapter.js");
const move_1 = require("@typemove/move");
const codegen_1 = require("@typemove/move/codegen");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
async function codegen(abisDir, outDir = (0, path_1.join)('src', 'types', 'aptos'), config, genExample = false, builtin = false) {
    if (!fs.existsSync(abisDir)) {
        console.error(chalk_1.default.red(`ABIs directory ${abisDir} does not exist`));
        return 0;
    }
    const gen = new AptosCodegen(config);
    try {
        const numFiles = await gen.generate(abisDir, outDir, builtin);
        if (numFiles > 0) {
            console.log(chalk_1.default.green(`Generated for ${numFiles} accounts for Aptos to ${outDir}`));
        }
        else {
            console.error(chalk_1.default.red(`No account found`));
        }
        return numFiles;
    }
    catch (e) {
        console.error(chalk_1.default.red(`Failed to generate for ${abisDir}, please check if ABI json files are valid`));
        console.log(e);
        return 0;
    }
}
class AptosCodegen extends codegen_1.AbstractCodegen {
    useViewJson;
    ADDRESS_TYPE = 'MoveAddressType';
    PREFIX = 'Aptos';
    SYSTEM_PACKAGE = '@typemove/aptos';
    constructor(config, useViewJson = false) {
        super(new aptos_chain_adapter_js_1.AptosChainAdapter(new ts_sdk_1.Aptos(config)));
        this.useViewJson = useViewJson;
    }
    generateImports() {
        return `
      ${super.generateImports()}
      import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId, InputViewFunctionData, InputViewFunctionJsonData } from '@aptos-labs/ts-sdk'
    `;
    }
    generateExtra(address, module) {
        const funcs = module.exposedFunctions.map((f) => this.generateEntryForFunction(module, f));
        const viewFuncs = module.exposedFunctions.map((f) => this.generateViewFunction(module, f));
        return `
    export namespace entry {
      ${funcs.join('\n')}
    }
    export namespace view {
      ${viewFuncs.join('\n')}
    }
    `;
    }
    generateStructs(module, struct, events) {
        let content = '';
        switch ((0, move_1.structQname)(module, struct)) {
            case '0x1::object::Object':
                content += `export type ${struct.name}<T> = MoveAddressType`;
                break;
        }
        return content + super.generateStructs(module, struct, events, content !== '');
    }
    generateViewFunction(module, func) {
        if (!func.isView) {
            return '';
        }
        const genericString = this.generateFunctionTypeParameters(func);
        const fields = this.chainAdapter.getMeaningfulFunctionParams(func.params).map((param) => {
            return this.generateTypeForDescriptor(param, module.address);
        });
        const returns = func.return.map((param) => {
            return this.generateTypeForDescriptor(param, module.address);
        });
        const typeParamArg = func.typeParams
            .map((v, idx) => {
            return `TypeDescriptor<T${idx}> | string`;
        })
            .join(',');
        // const args = this.generateArgs(module, func)
        const allEmpty = func.typeParams.length === 0 && func.params.length === 0;
        const requestArg = allEmpty
            ? ''
            : `request: {
      ${func.typeParams.length > 0 ? `typeArguments: [${func.typeParams.map((_) => 'MoveStructId').join(', ')}],` : ''}
      ${func.params.length > 0 ? `functionArguments: [${fields.join(',')}]` : ''}},`;
        if (this.useViewJson) {
            return `export async function ${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}${genericString}(
    client: Aptos,
    ${requestArg}
    version?: bigint): Promise<[${returns.join(',')}]> {
      const coder = ${this.getGetDefaultCoder()}        
      const data: InputViewFunctionJsonData = {
        function: "${module.address}::${module.name}::${func.name}",
        functionArguments: ${func.params.length > 0 ? 'request.functionArguments.map(coder.toMoveValue)' : '[]'},
        typeArguments: ${func.typeParams.length > 0 ? 'request.typeArguments' : '[]'},
      }
      const res = await client.viewJson({payload: data, options: { ledgerVersion: version } });
      const type = await coder.getMoveFunction("${module.address}::${module.name}::${func.name}")
      return await coder.decodeArray(res, type.return) as any
    }`;
        }
        return `export async function ${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}${genericString}(
    client: Aptos,
    ${requestArg}
    version?: bigint): Promise<[${returns.join(',')}]> {
      const coder = ${this.getGetDefaultCoder()}        
      const data: InputViewFunctionData = {
        function: "${module.address}::${module.name}::${func.name}",
        functionArguments: ${func.params.length > 0 ? 'coder.encodeArray(request.functionArguments)' : '[]'},
        typeArguments: ${func.typeParams.length > 0 ? 'request.typeArguments' : '[]'},
      }
      const res = await client.view({payload: data, options: { ledgerVersion: version } });
      const type = await coder.getMoveFunction("${module.address}::${module.name}::${func.name}")
      return await coder.decodeArray(res, type.return) as any
    }`;
    }
    getGetDefaultCoder() {
        return `defaultMoveCoder(client.config)`;
    }
    generateEntryForFunction(module, func) {
        if (!func.isEntry) {
            return '';
        }
        const genericString = this.generateFunctionTypeParameters(func);
        const fields = this.chainAdapter.getMeaningfulFunctionParams(func.params).map((param) => {
            return this.generateTypeForDescriptor(param, module.address);
        });
        // const typeParamArg = func.typeParams
        //     .map((v, idx) => {
        //       return `TypeDescriptor<T${idx}> | string`
        //     })
        //     .join(',')
        //
        // const args = this.generateArgs(module, func)
        return `export async function ${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}${genericString}(
      client: Aptos,
      account: AptosAccount,
      request: {
        typeArguments: [${func.typeParams.map((_) => 'MoveStructId').join(', ')}], 
        functionArguments: [${fields.join(',')}]
      },
      options?: InputGenerateTransactionOptions
    ): Promise<PendingTransactionResponse> {
      const coder = ${this.getGetDefaultCoder()}
      const transaction = await client.transaction.build.simple({
        sender: account.accountAddress,
        data: {
          function: "${module.address}::${module.name}::${func.name}",
          functionArguments: ${func.params.length > 0 ? 'coder.encodeArray(request.functionArguments)' : '[]'},
          typeArguments: ${func.typeParams.length > 0 ? 'request.typeArguments' : '[]'},
        },
        options
      })
      return await client.signAndSubmitTransaction({ signer: account, transaction });
    }`;
    }
}
exports.AptosCodegen = AptosCodegen;
//# sourceMappingURL=codegen.js.map