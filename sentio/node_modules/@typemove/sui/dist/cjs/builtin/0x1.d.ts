import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";
import { TypedDevInspectResults } from "@typemove/sui";
import { Transaction, TransactionArgument, TransactionObjectArgument } from "@mysten/sui/transactions";
import { SuiClient } from "@mysten/sui/client";
export declare namespace address {
    namespace builder {
        function length(tx: Transaction, args: []): TransactionArgument & [];
    }
    namespace view {
        function length(client: SuiClient, args: []): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace ascii {
    type Char = string;
    namespace Char {
        const TYPE_QNAME = "0x1::ascii::Char";
        function type(): TypeDescriptor<Char>;
    }
    type String = string;
    namespace String {
        const TYPE_QNAME = "0x1::ascii::String";
        function type(): TypeDescriptor<String>;
    }
    namespace builder {
        function allCharactersPrintable(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function append(tx: Transaction, args: [
            string | TransactionObjectArgument,
            ascii.String | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function asBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function byte(tx: Transaction, args: [ascii.Char | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function char(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function indexOf(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function insert(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            ascii.String | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function intoBytes(tx: Transaction, args: [ascii.String | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isEmpty(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function isPrintableChar(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isValidChar(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function length(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function popChar(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function pushChar(tx: Transaction, args: [
            string | TransactionObjectArgument,
            ascii.Char | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function string$(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function substring(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function toLowercase(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function toUppercase(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function tryString(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function allCharactersPrintable(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function append(client: SuiClient, args: [string, ascii.String]): Promise<TypedDevInspectResults<[]>>;
        function asBytes(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function byte(client: SuiClient, args: [ascii.Char]): Promise<TypedDevInspectResults<[number]>>;
        function char(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[ascii.Char]>>;
        function indexOf(client: SuiClient, args: [string, string]): Promise<TypedDevInspectResults<[bigint]>>;
        function insert(client: SuiClient, args: [string, bigint, ascii.String]): Promise<TypedDevInspectResults<[]>>;
        function intoBytes(client: SuiClient, args: [ascii.String]): Promise<TypedDevInspectResults<[number[]]>>;
        function isEmpty(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isPrintableChar(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[boolean]>>;
        function isValidChar(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[boolean]>>;
        function length(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function popChar(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.Char]>>;
        function pushChar(client: SuiClient, args: [string, ascii.Char]): Promise<TypedDevInspectResults<[]>>;
        function string$(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function substring(client: SuiClient, args: [string, bigint, bigint]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function toLowercase(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function toUppercase(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function tryString(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[option.Option<ascii.String>]>>;
    }
}
export declare namespace bcs {
    namespace builder {
        function toBytes<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function toBytes<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    type BitVectorInstance = TypedEventInstance<BitVector> & {
        data_decoded: BitVector;
        type_arguments: [];
    };
    namespace builder {
        function isIndexSet(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function length(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function longestSetSequenceStartingAt(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function new$(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function set(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function shiftLeft(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function unset(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function isIndexSet(client: SuiClient, args: [string, bigint]): Promise<TypedDevInspectResults<[boolean]>>;
        function length(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function longestSetSequenceStartingAt(client: SuiClient, args: [string, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bit_vector.BitVector]>>;
        function set(client: SuiClient, args: [string, bigint]): Promise<TypedDevInspectResults<[]>>;
        function shiftLeft(client: SuiClient, args: [string, bigint]): Promise<TypedDevInspectResults<[]>>;
        function unset(client: SuiClient, args: [string, bigint]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace bool {
    namespace builder { }
    namespace view { }
}
export declare namespace debug {
    namespace builder {
        function print<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function printStackTrace(tx: Transaction, args: []): TransactionArgument & [];
    }
    namespace view {
        function print<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function printStackTrace(client: SuiClient, args: []): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    type FixedPoint32Instance = TypedEventInstance<FixedPoint32> & {
        data_decoded: FixedPoint32;
        type_arguments: [];
    };
    namespace builder {
        function createFromRational(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function createFromRawValue(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function divideU64(tx: Transaction, args: [
            bigint | TransactionArgument,
            fixed_point32.FixedPoint32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getRawValue(tx: Transaction, args: [fixed_point32.FixedPoint32 | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isZero(tx: Transaction, args: [fixed_point32.FixedPoint32 | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function multiplyU64(tx: Transaction, args: [
            bigint | TransactionArgument,
            fixed_point32.FixedPoint32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function createFromRational(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>>;
        function createFromRawValue(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>>;
        function divideU64(client: SuiClient, args: [bigint, fixed_point32.FixedPoint32]): Promise<TypedDevInspectResults<[bigint]>>;
        function getRawValue(client: SuiClient, args: [fixed_point32.FixedPoint32]): Promise<TypedDevInspectResults<[bigint]>>;
        function isZero(client: SuiClient, args: [fixed_point32.FixedPoint32]): Promise<TypedDevInspectResults<[boolean]>>;
        function multiplyU64(client: SuiClient, args: [bigint, fixed_point32.FixedPoint32]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace hash {
    namespace builder {
        function sha2256(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function sha3256(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function sha2256(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[number[]]>>;
        function sha3256(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace macros {
    namespace builder { }
    namespace view { }
}
export declare namespace option {
    type Option<T> = T | undefined;
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
    namespace builder {
        function borrow<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function borrowMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function borrowWithDefault<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyNone<T0 = any>(tx: Transaction, args: [option.Option<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroySome<T0 = any>(tx: Transaction, args: [option.Option<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroyWithDefault<T0 = any>(tx: Transaction, args: [option.Option<T0> | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function extract<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function fill<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getWithDefault<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function isNone<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isSome<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function none<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function some<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function swap<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function swapOrFill<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function toVec<T0 = any>(tx: Transaction, args: [option.Option<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function borrow<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowWithDefault<T0 = any>(client: SuiClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any>(client: SuiClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyNone<T0 = any>(client: SuiClient, args: [option.Option<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function destroySome<T0 = any>(client: SuiClient, args: [option.Option<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function destroyWithDefault<T0 = any>(client: SuiClient, args: [option.Option<T0>, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function extract<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function fill<T0 = any>(client: SuiClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function getWithDefault<T0 = any>(client: SuiClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function isNone<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isSome<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function none<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[option.Option<T0>]>>;
        function some<T0 = any>(client: SuiClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[option.Option<T0>]>>;
        function swap<T0 = any>(client: SuiClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function swapOrFill<T0 = any>(client: SuiClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[option.Option<T0>]>>;
        function toVec<T0 = any>(client: SuiClient, args: [option.Option<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
    }
}
export declare namespace string$ {
    interface String {
        bytes: number[];
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    type StringInstance = TypedEventInstance<String> & {
        data_decoded: String;
        type_arguments: [];
    };
    namespace builder {
        function append(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function appendUtf8(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function asBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function bytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function fromAscii(tx: Transaction, args: [ascii.String | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function indexOf(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function insert(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function intoBytes(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isEmpty(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function length(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function subString(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function substring(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function toAscii(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryUtf8(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function utf8(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function append(client: SuiClient, args: [string, string]): Promise<TypedDevInspectResults<[]>>;
        function appendUtf8(client: SuiClient, args: [string, string[]]): Promise<TypedDevInspectResults<[]>>;
        function asBytes(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function bytes(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function fromAscii(client: SuiClient, args: [ascii.String]): Promise<TypedDevInspectResults<[string]>>;
        function indexOf(client: SuiClient, args: [string, string]): Promise<TypedDevInspectResults<[bigint]>>;
        function insert(client: SuiClient, args: [string, bigint, string]): Promise<TypedDevInspectResults<[]>>;
        function intoBytes(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function isEmpty(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function subString(client: SuiClient, args: [string, bigint, bigint]): Promise<TypedDevInspectResults<[string]>>;
        function substring(client: SuiClient, args: [string, bigint, bigint]): Promise<TypedDevInspectResults<[string]>>;
        function toAscii(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function tryUtf8(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[option.Option<string>]>>;
        function utf8(client: SuiClient, args: [string[]]): Promise<TypedDevInspectResults<[string]>>;
    }
}
export declare namespace type_name {
    interface TypeName {
        name: ascii.String;
    }
    namespace TypeName {
        const TYPE_QNAME = "0x1::type_name::TypeName";
        function type(): TypeDescriptor<TypeName>;
    }
    type TypeNameInstance = TypedEventInstance<TypeName> & {
        data_decoded: TypeName;
        type_arguments: [];
    };
    namespace builder {
        function addressString(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function asString(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function borrowString(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function definingId<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function get<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function getAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function getModule(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function getWithOriginalIds<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function intoString(tx: Transaction, args: [type_name.TypeName | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isPrimitive(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function moduleString(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function originalId<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function withDefiningIds<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function withOriginalIds<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
    }
    namespace view {
        function addressString(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function asString(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowString(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function definingId<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function get<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[type_name.TypeName]>>;
        function getAddress(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function getModule(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function getWithOriginalIds<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[type_name.TypeName]>>;
        function intoString(client: SuiClient, args: [type_name.TypeName]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function isPrimitive(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function moduleString(client: SuiClient, args: [string]): Promise<TypedDevInspectResults<[ascii.String]>>;
        function originalId<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function withDefiningIds<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[type_name.TypeName]>>;
        function withOriginalIds<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[type_name.TypeName]>>;
    }
}
export declare namespace u128 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [bigint | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sqrt(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU16(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU32(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU64(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU8(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function diff(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function divideAndRoundUp(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function max(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function min(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function pow(client: SuiClient, args: [bigint, number]): Promise<TypedDevInspectResults<[bigint]>>;
        function sqrt(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function toString(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[string]>>;
        function tryAsU16(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU32(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU64(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<bigint>]>>;
        function tryAsU8(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
    }
}
export declare namespace u16 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sqrt(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU8(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function diff(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function divideAndRoundUp(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function max(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function min(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function pow(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function sqrt(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function toString(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[string]>>;
        function tryAsU8(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
    }
}
export declare namespace u256 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [bigint | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function toString(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU128(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU16(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU32(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU64(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU8(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function diff(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function divideAndRoundUp(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function max(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function min(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function pow(client: SuiClient, args: [bigint, number]): Promise<TypedDevInspectResults<[bigint]>>;
        function toString(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[string]>>;
        function tryAsU128(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<bigint>]>>;
        function tryAsU16(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU32(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU64(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<bigint>]>>;
        function tryAsU8(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
    }
}
export declare namespace u32 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sqrt(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU16(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU8(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function diff(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function divideAndRoundUp(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function max(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function min(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function pow(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function sqrt(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function toString(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[string]>>;
        function tryAsU16(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU8(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
    }
}
export declare namespace u64 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [bigint | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sqrt(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU16(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU32(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function tryAsU8(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function diff(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function divideAndRoundUp(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function max(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function min(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function pow(client: SuiClient, args: [bigint, number]): Promise<TypedDevInspectResults<[bigint]>>;
        function sqrt(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function toString(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[string]>>;
        function tryAsU16(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU32(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
        function tryAsU8(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[option.Option<number>]>>;
    }
}
export declare namespace u8 {
    namespace builder {
        function bitwiseNot(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function diff(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function divideAndRoundUp(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function max(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function min(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pow(tx: Transaction, args: [number | TransactionArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sqrt(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bitwiseNot(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function diff(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function divideAndRoundUp(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function max(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function min(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function pow(client: SuiClient, args: [number, number]): Promise<TypedDevInspectResults<[number]>>;
        function sqrt(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[number]>>;
        function toString(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[string]>>;
    }
}
export declare namespace uq32_32 {
    interface UQ32_32 {
        pos0: bigint;
    }
    namespace UQ32_32 {
        const TYPE_QNAME = "0x1::uq32_32::UQ32_32";
        function type(): TypeDescriptor<UQ32_32>;
    }
    type UQ32_32Instance = TypedEventInstance<UQ32_32> & {
        data_decoded: UQ32_32;
        type_arguments: [];
    };
    namespace builder {
        function add(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function div(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromInt(tx: Transaction, args: [number | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function fromQuotient(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromRaw(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function ge(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gt(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function intDiv(tx: Transaction, args: [
            bigint | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function intMul(tx: Transaction, args: [
            bigint | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function le(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function lt(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mul(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sub(tx: Transaction, args: [
            uq32_32.UQ32_32 | TransactionArgument,
            uq32_32.UQ32_32 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function toInt(tx: Transaction, args: [uq32_32.UQ32_32 | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toRaw(tx: Transaction, args: [uq32_32.UQ32_32 | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function add(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function div(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function fromInt(client: SuiClient, args: [number]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function fromQuotient(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function fromRaw(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function ge(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[boolean]>>;
        function gt(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[boolean]>>;
        function intDiv(client: SuiClient, args: [bigint, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[bigint]>>;
        function intMul(client: SuiClient, args: [bigint, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[bigint]>>;
        function le(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[boolean]>>;
        function lt(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[boolean]>>;
        function mul(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function sub(client: SuiClient, args: [uq32_32.UQ32_32, uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>>;
        function toInt(client: SuiClient, args: [uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[number]>>;
        function toRaw(client: SuiClient, args: [uq32_32.UQ32_32]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace uq64_64 {
    interface UQ64_64 {
        pos0: bigint;
    }
    namespace UQ64_64 {
        const TYPE_QNAME = "0x1::uq64_64::UQ64_64";
        function type(): TypeDescriptor<UQ64_64>;
    }
    type UQ64_64Instance = TypedEventInstance<UQ64_64> & {
        data_decoded: UQ64_64;
        type_arguments: [];
    };
    namespace builder {
        function add(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function div(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromInt(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function fromQuotient(tx: Transaction, args: [bigint | TransactionArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromRaw(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function ge(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gt(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function intDiv(tx: Transaction, args: [
            bigint | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function intMul(tx: Transaction, args: [
            bigint | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function le(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function lt(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mul(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sub(tx: Transaction, args: [
            uq64_64.UQ64_64 | TransactionArgument,
            uq64_64.UQ64_64 | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function toInt(tx: Transaction, args: [uq64_64.UQ64_64 | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toRaw(tx: Transaction, args: [uq64_64.UQ64_64 | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function add(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function div(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function fromInt(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function fromQuotient(client: SuiClient, args: [bigint, bigint]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function fromRaw(client: SuiClient, args: [bigint]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function ge(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[boolean]>>;
        function gt(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[boolean]>>;
        function intDiv(client: SuiClient, args: [bigint, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[bigint]>>;
        function intMul(client: SuiClient, args: [bigint, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[bigint]>>;
        function le(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[boolean]>>;
        function lt(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[boolean]>>;
        function mul(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function sub(client: SuiClient, args: [uq64_64.UQ64_64, uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>>;
        function toInt(client: SuiClient, args: [uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[bigint]>>;
        function toRaw(client: SuiClient, args: [uq64_64.UQ64_64]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace vector {
    namespace builder {
        function append<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrow<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any>(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function empty<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function flatten<T0 = any>(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function indexOf<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function insert<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function isEmpty<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function length<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function popBack<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function pushBack<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function remove<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function reverse<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function singleton<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function skip<T0 = any>(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function swap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function swapRemove<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function take<T0 = any>(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function append<T0 = any>(client: SuiClient, args: [string, string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any>(client: SuiClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any>(client: SuiClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any>(client: SuiClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty<T0 = any>(client: SuiClient, args: [string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function empty<T0 = any>(client: SuiClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function flatten<T0 = any>(client: SuiClient, args: [string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function indexOf<T0 = any>(client: SuiClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean, bigint]>>;
        function insert<T0 = any>(client: SuiClient, args: [string, T0, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function isEmpty<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function popBack<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function pushBack<T0 = any>(client: SuiClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function remove<T0 = any>(client: SuiClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function reverse<T0 = any>(client: SuiClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function singleton<T0 = any>(client: SuiClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function skip<T0 = any>(client: SuiClient, args: [string[], bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function swap<T0 = any>(client: SuiClient, args: [string, bigint, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function swapRemove<T0 = any>(client: SuiClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function take<T0 = any>(client: SuiClient, args: [string[], bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map