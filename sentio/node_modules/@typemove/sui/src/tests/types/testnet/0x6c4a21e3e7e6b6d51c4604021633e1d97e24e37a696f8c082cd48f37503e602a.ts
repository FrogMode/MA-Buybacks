/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a, original address 0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";

import { defaultMoveCoder } from "@typemove/sui";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/sui";
import {
  Transaction,
  TransactionArgument,
  TransactionObjectArgument,
} from "@mysten/sui/transactions";
import { SuiClient } from "@mysten/sui/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrVec,
  transactionArgumentOrPure,
  transactionArgumentOrPureU8,
  transactionArgumentOrPureU16,
  transactionArgumentOrPureU32,
  transactionArgumentOrPureU64,
  transactionArgumentOrPureU128,
  transactionArgumentOrPureU256,
  transactionArgumentOrPureBool,
  transactionArgumentOrPureString,
  transactionArgumentOrPureAddress,
} from "@typemove/sui";

import * as _0x2 from "@typemove/sui/builtin/0x2";
import * as _0x1 from "@typemove/sui/builtin/0x1";

export namespace comparator {
  export interface Result {
    inner: number;
  }

  export namespace Result {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::Result";

    const TYPE = new TypeDescriptor<Result>(Result.TYPE_QNAME);

    export function type(): TypeDescriptor<Result> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function compare<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::compare",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function compareU8Vector(
      tx: Transaction,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::compare_u8_vector",
        arguments: _args,
      });
    }
    export function isEqual(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::is_equal",
        arguments: _args,
      });
    }
    export function isGreaterThan(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::is_greater_than",
        arguments: _args,
      });
    }
    export function isSmallerThan(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::comparator::is_smaller_than",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function compare<T0 = any>(
      client: SuiClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[comparator.Result]>> {
      const tx = new Transaction();
      builder.compare(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [comparator.Result]
      >(inspectRes);
    }
    export async function compareU8Vector(
      client: SuiClient,
      args: [string[], string[]],
    ): Promise<TypedDevInspectResults<[comparator.Result]>> {
      const tx = new Transaction();
      builder.compareU8Vector(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [comparator.Result]
      >(inspectRes);
    }
    export async function isEqual(
      client: SuiClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEqual(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isGreaterThan(
      client: SuiClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isGreaterThan(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isSmallerThan(
      client: SuiClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isSmallerThan(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace math_utils {
  export namespace builder {
    export function max(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::max",
        arguments: _args,
      });
    }
    export function maxU64(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::max_u64",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::sqrt",
        arguments: _args,
      });
    }
    export function sqrtU256(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::math_utils::sqrt_u256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function max(
      client: SuiClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function maxU64(
      client: SuiClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.maxU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function min(
      client: SuiClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pow(
      client: SuiClient,
      args: [bigint, number],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: SuiClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrtU256(
      client: SuiClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sqrtU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace pool {
  export interface ControllerCap {
    id: _0x2.object$.UID;
  }

  export namespace ControllerCap {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::ControllerCap";

    const TYPE = new TypeDescriptor<ControllerCap>(ControllerCap.TYPE_QNAME);

    export function type(): TypeDescriptor<ControllerCap> {
      return TYPE.apply();
    }
  }

  export interface FeeToSet {
    fee_to: string;
    caller: string;
  }

  export namespace FeeToSet {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::FeeToSet";

    const TYPE = new TypeDescriptor<FeeToSet>(FeeToSet.TYPE_QNAME);

    export function type(): TypeDescriptor<FeeToSet> {
      return TYPE.apply();
    }
  }

  export type FeeToSetInstance = TypedEventInstance<FeeToSet> & {
    data_decoded: FeeToSet;
    type_arguments: [];
  };

  export interface LiquidityAdded<T0, T1> {
    user: string;
    first_amount: bigint;
    second_amount: bigint;
    first_reserve: bigint;
    second_reserve: bigint;
    wisp_lp_amount: bigint;
    fee_amount: bigint;
  }

  export namespace LiquidityAdded {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::LiquidityAdded";

    const TYPE = new TypeDescriptor<LiquidityAdded<any, any>>(
      LiquidityAdded.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<LiquidityAdded<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type LiquidityAddedInstance = TypedEventInstance<
    LiquidityAdded<any, any>
  > & {
    data_decoded: LiquidityAdded<any, any>;
    type_arguments: [string, string];
  };

  export interface LiquidityRemoved<T0, T1> {
    user: string;
    first_amount: bigint;
    second_amount: bigint;
    first_reserve: bigint;
    second_reserve: bigint;
    wisp_lp_amount: bigint;
    fee_amount: bigint;
  }

  export namespace LiquidityRemoved {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::LiquidityRemoved";

    const TYPE = new TypeDescriptor<LiquidityRemoved<any, any>>(
      LiquidityRemoved.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<LiquidityRemoved<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type LiquidityRemovedInstance = TypedEventInstance<
    LiquidityRemoved<any, any>
  > & {
    data_decoded: LiquidityRemoved<any, any>;
    type_arguments: [string, string];
  };

  export interface Pool<T0, T1> {
    id: _0x2.object$.UID;
    first_token: _0x2.balance.Balance<T0>;
    second_token: _0x2.balance.Balance<T1>;
    wisp_lp_supply: _0x2.balance.Supply<pool.WISPLP<T0, T1>>;
    k_last: bigint;
  }

  export namespace Pool {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::Pool";

    const TYPE = new TypeDescriptor<Pool<any, any>>(Pool.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Pool<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface PoolCreated<T0, T1> {
    pool: string;
    first_amount: bigint;
    second_amount: bigint;
    wisp_lp_amount: bigint;
  }

  export namespace PoolCreated {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::PoolCreated";

    const TYPE = new TypeDescriptor<PoolCreated<any, any>>(
      PoolCreated.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<PoolCreated<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type PoolCreatedInstance = TypedEventInstance<
    PoolCreated<any, any>
  > & {
    data_decoded: PoolCreated<any, any>;
    type_arguments: [string, string];
  };

  export interface PoolName {
    first_type: _0x1.type_name.TypeName;
    second_type: _0x1.type_name.TypeName;
  }

  export namespace PoolName {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::PoolName";

    const TYPE = new TypeDescriptor<PoolName>(PoolName.TYPE_QNAME);

    export function type(): TypeDescriptor<PoolName> {
      return TYPE.apply();
    }
  }

  export type PoolNameInstance = TypedEventInstance<PoolName> & {
    data_decoded: PoolName;
    type_arguments: [];
  };

  export interface PoolRegistry {
    id: _0x2.object$.UID;
    fee_to: string;
    pools: _0x2.object_bag.ObjectBag;
  }

  export namespace PoolRegistry {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::PoolRegistry";

    const TYPE = new TypeDescriptor<PoolRegistry>(PoolRegistry.TYPE_QNAME);

    export function type(): TypeDescriptor<PoolRegistry> {
      return TYPE.apply();
    }
  }

  export interface TokenSwapped<T0, T1> {
    user: string;
    first_amount_in: bigint;
    second_amount_in: bigint;
    first_amount_out: bigint;
    second_amount_out: bigint;
    first_reserve: bigint;
    second_reserve: bigint;
  }

  export namespace TokenSwapped {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::TokenSwapped";

    const TYPE = new TypeDescriptor<TokenSwapped<any, any>>(
      TokenSwapped.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<TokenSwapped<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type TokenSwappedInstance = TypedEventInstance<
    TokenSwapped<any, any>
  > & {
    data_decoded: TokenSwapped<any, any>;
    type_arguments: [string, string];
  };

  export interface WISPLP<T0, T1> {
    dummy_field: boolean;
  }

  export namespace WISPLP {
    export const TYPE_QNAME =
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::WISPLP";

    const TYPE = new TypeDescriptor<WISPLP<any, any>>(WISPLP.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<WISPLP<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function addLiquidity<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPureU64(args[5], tx));
      _args.push(transactionArgumentOrPureU64(args[6], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::add_liquidity",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMutPool<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::borrow_mut_pool",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowPool<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::borrow_pool",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function createPool<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::create_pool",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function createPoolName(
      tx: Transaction,
      args: [
        _0x1.type_name.TypeName | TransactionArgument,
        _0x1.type_name.TypeName | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::create_pool_name",
        arguments: _args,
      });
    }
    export function getAmounts<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::get_amounts",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getInputAmount<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureBool(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::get_input_amount",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getOutputAmount<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureBool(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::get_output_amount",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getPoolData<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::get_pool_data",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isPoolCreated<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::is_pool_created",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isPoolCreatedSorted<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::is_pool_created_sorted",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function processSwapExactInput<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureBool(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::process_swap_exact_input",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function processSwapExactOutput<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureBool(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::process_swap_exact_output",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeLiquidity<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::remove_liquidity",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function setFeeTo_(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::set_fee_to_",
        arguments: _args,
      });
    }
    export function swapExactFirstToSecond<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::swap_exact_first_to_second",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactSecondToFirst<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::swap_exact_second_to_first",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapFirstToExactSecond<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::swap_first_to_exact_second",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapSecondToExactFirst<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::swap_second_to_exact_first",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function zapInFirst<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::zap_in_first",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function zapInSecond<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool::zap_in_second",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addLiquidity<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, string, bigint, bigint, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<pool.WISPLP<T0, T1>>]>> {
      const tx = new Transaction();
      builder.addLiquidity(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>]
      >(inspectRes);
    }
    export async function borrowMutPool<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMutPool(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowPool<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowPool(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function createPool<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<pool.WISPLP<T0, T1>>]>> {
      const tx = new Transaction();
      builder.createPool(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>]
      >(inspectRes);
    }
    export async function createPoolName(
      client: SuiClient,
      args: [_0x1.type_name.TypeName, _0x1.type_name.TypeName],
    ): Promise<TypedDevInspectResults<[pool.PoolName]>> {
      const tx = new Transaction();
      builder.createPoolName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [pool.PoolName]
      >(inspectRes);
    }
    export async function getAmounts<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint, bigint]>> {
      const tx = new Transaction();
      builder.getAmounts(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, bigint]
      >(inspectRes);
    }
    export async function getInputAmount<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, bigint, boolean],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getInputAmount(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getOutputAmount<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, bigint, boolean],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getOutputAmount(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getPoolData<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[bigint, bigint, bigint, bigint, bigint]>
    > {
      const tx = new Transaction();
      builder.getPoolData(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, bigint, bigint, bigint]
      >(inspectRes);
    }
    export async function isPoolCreated<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPoolCreated(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isPoolCreatedSorted<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPoolCreatedSorted(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function processSwapExactInput<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, string, bigint, boolean],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processSwapExactInput(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function processSwapExactOutput<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, string, bigint, boolean],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processSwapExactOutput(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function removeLiquidity<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]>
    > {
      const tx = new Transaction();
      builder.removeLiquidity(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function setFeeTo_(
      client: SuiClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setFeeTo_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapExactFirstToSecond<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T1>]>> {
      const tx = new Transaction();
      builder.swapExactFirstToSecond(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function swapExactSecondToFirst<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.swapExactSecondToFirst(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
    export async function swapFirstToExactSecond<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T1>]>> {
      const tx = new Transaction();
      builder.swapFirstToExactSecond(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function swapSecondToExactFirst<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.swapSecondToExactFirst(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
    export async function zapInFirst<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>, _0x2.coin.Coin<T1>]
      >
    > {
      const tx = new Transaction();
      builder.zapInFirst(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>, _0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function zapInSecond<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>, _0x2.coin.Coin<T0>]
      >
    > {
      const tx = new Transaction();
      builder.zapInSecond(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<pool.WISPLP<T0, T1>>, _0x2.coin.Coin<T0>]
      >(inspectRes);
    }
  }
}

export namespace pool_utils {
  export namespace builder {
    export function executeReturnToken<T0 = any>(
      tx: Transaction,
      args: [_0x2.coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::execute_return_token",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getInputPrice(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::get_input_price",
        arguments: _args,
      });
    }
    export function getOptimalZapInAmount(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::get_optimal_zap_in_amount",
        arguments: _args,
      });
    }
    export function getOutputPrice(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::get_output_price",
        arguments: _args,
      });
    }
    export function getTripleType<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::get_triple_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function getType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::get_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function quote(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::quote",
        arguments: _args,
      });
    }
    export function sortTokenType(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::pool_utils::sort_token_type",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function executeReturnToken<T0 = any>(
      client: SuiClient,
      args: [_0x2.coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.executeReturnToken(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getInputPrice(
      client: SuiClient,
      args: [bigint, bigint, bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getInputPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getOptimalZapInAmount(
      client: SuiClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getOptimalZapInAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getOutputPrice(
      client: SuiClient,
      args: [bigint, bigint, bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getOutputPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getTripleType<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<
      TypedDevInspectResults<
        [
          _0x1.type_name.TypeName,
          _0x1.type_name.TypeName,
          _0x1.type_name.TypeName,
        ]
      >
    > {
      const tx = new Transaction();
      builder.getTripleType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          _0x1.type_name.TypeName,
          _0x1.type_name.TypeName,
          _0x1.type_name.TypeName,
        ]
      >(inspectRes);
    }
    export async function getType<T0 = any, T1 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x1.type_name.TypeName, _0x1.type_name.TypeName]>
    > {
      const tx = new Transaction();
      builder.getType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.type_name.TypeName, _0x1.type_name.TypeName]
      >(inspectRes);
    }
    export async function quote(
      client: SuiClient,
      args: [bigint, bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.quote(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sortTokenType(
      client: SuiClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[comparator.Result]>> {
      const tx = new Transaction();
      builder.sortTokenType(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [comparator.Result]
      >(inspectRes);
    }
  }
}

export namespace router {
  export namespace builder {
    export function addLiquidity_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPureU64(args[5], tx));
      _args.push(transactionArgumentOrPureU64(args[6], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::add_liquidity_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function createPool_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::create_pool_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeLiquidity_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::remove_liquidity_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactInput_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::swap_exact_input_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactInputDoublehop_<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::swap_exact_input_doublehop_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function swapExactOutput_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::swap_exact_output_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactOutputDoublehop_<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::swap_exact_output_doublehop_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function zapIn_<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a::router::zap_in_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addLiquidity_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], string[], bigint, bigint, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addLiquidity_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function createPool_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], string[], bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.createPool_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function removeLiquidity_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], bigint, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.removeLiquidity_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapExactInput_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swapExactInput_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapExactInputDoublehop_<
      T0 = any,
      T1 = any,
      T2 = any,
    >(
      client: SuiClient,
      args: [string, string[], bigint, bigint],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swapExactInputDoublehop_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapExactOutput_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swapExactOutput_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapExactOutputDoublehop_<
      T0 = any,
      T1 = any,
      T2 = any,
    >(
      client: SuiClient,
      args: [string, string[], bigint, bigint],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swapExactOutputDoublehop_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function zapIn_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string, string[], bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.zapIn_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"comparator":{"fileFormatVersion":6,"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","name":"comparator","friends":[],"structs":{"Result":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"inner","type":"U8"}]}},"exposedFunctions":{"compare":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}},{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}]},"compare_u8_vector":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"},{"Vector":"U8"}],"return":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}]},"is_equal":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}}],"return":["Bool"]},"is_greater_than":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}}],"return":["Bool"]},"is_smaller_than":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}}],"return":["Bool"]}}},"math_utils":{"fileFormatVersion":6,"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","name":"math_utils","friends":[],"structs":{},"exposedFunctions":{"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"max_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U8"],"return":["U128"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U128"]},"sqrt_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":["U256"]}}},"pool":{"fileFormatVersion":6,"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","name":"pool","friends":[],"structs":{"ControllerCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"FeeToSet":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"fee_to","type":"Address"},{"name":"caller","type":"Address"}]},"LiquidityAdded":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"user","type":"Address"},{"name":"first_amount","type":"U64"},{"name":"second_amount","type":"U64"},{"name":"first_reserve","type":"U64"},{"name":"second_reserve","type":"U64"},{"name":"wisp_lp_amount","type":"U64"},{"name":"fee_amount","type":"U64"}]},"LiquidityRemoved":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"user","type":"Address"},{"name":"first_amount","type":"U64"},{"name":"second_amount","type":"U64"},{"name":"first_reserve","type":"U64"},{"name":"second_reserve","type":"U64"},{"name":"wisp_lp_amount","type":"U64"},{"name":"fee_amount","type":"U64"}]},"Pool":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"first_token","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"second_token","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":1}]}}},{"name":"wisp_lp_supply","type":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}}},{"name":"k_last","type":"U128"}]},"PoolCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool","type":"Address"},{"name":"first_amount","type":"U64"},{"name":"second_amount","type":"U64"},{"name":"wisp_lp_amount","type":"U64"}]},"PoolName":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"first_type","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"name":"second_type","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}]},"PoolRegistry":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"fee_to","type":"Address"},{"name":"pools","type":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}}]},"TokenSwapped":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"user","type":"Address"},{"name":"first_amount_in","type":"U64"},{"name":"second_amount_in","type":"U64"},{"name":"first_amount_out","type":"U64"},{"name":"second_amount_out","type":"U64"},{"name":"first_reserve","type":"U64"},{"name":"second_reserve","type":"U64"}]},"WISPLP":{"abilities":{"abilities":["Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"add_liquidity":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}}]},"borrow_mut_pool":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}]},"borrow_pool":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}]},"create_pool":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}}]},"create_pool_name":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}},{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}],"return":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolName","typeArguments":[]}}]},"get_amounts":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64","U64","U64"]},"get_input_amount":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","Bool"],"return":["U64"]},"get_output_amount":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","Bool"],"return":["U64"]},"get_pool_data":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64","U64","U64","U64","U128"]},"is_pool_created":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}}],"return":["Bool"]},"is_pool_created_sorted":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}}],"return":["Bool"]},"process_swap_exact_input":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","Bool",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"process_swap_exact_output":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","Bool",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"remove_liquidity":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}}},"U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"set_fee_to_":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"ControllerCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"swap_exact_first_to_second":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"swap_exact_second_to_first":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"swap_first_to_exact_second":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"swap_second_to_exact_first":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"zap_in_first":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"zap_in_second":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]}}},"pool_utils":{"fileFormatVersion":6,"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","name":"pool_utils","friends":[],"structs":{},"exposedFunctions":{"execute_return_token":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"get_input_price":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64","U64","U64"],"return":["U64"]},"get_optimal_zap_in_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"get_output_price":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64","U64","U64"],"return":["U64"]},"get_triple_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}},{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}},{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"get_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}},{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"quote":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64","U64"],"return":["U64"]},"sort_token_type":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"comparator","name":"Result","typeArguments":[]}}]}}},"router":{"fileFormatVersion":6,"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","name":"router","friends":[],"structs":{},"exposedFunctions":{"add_liquidity_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"create_pool_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"remove_liquidity_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"WISPLP","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]}}},"U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"swap_exact_input_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"swap_exact_input_doublehop_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"swap_exact_output_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"swap_exact_output_doublehop_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"zap_in_":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a","module":"pool","name":"PoolRegistry","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  _0x2.loadAllTypes(coder);
  _0x1.loadAllTypes(coder);
  for (const m of Object.values(MODULES)) {
    coder.load(
      m as any,
      "0x6c4a21e3e7e6b6d51c4604021633e1d97e24e37a696f8c082cd48f37503e602a",
    );
  }
}

loadAllTypes(defaultMoveCoder());
