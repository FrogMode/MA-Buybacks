"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveCoder = void 0;
exports.defaultMoveCoder = defaultMoveCoder;
exports.getMoveCoder = getMoveCoder;
const move_1 = require("@typemove/move");
const client_1 = require("@iota/iota-sdk/client");
const to_internal_js_1 = require("./to-internal.js");
const sui_chain_adapter_js_1 = require("./sui-chain-adapter.js");
const bcs_1 = require("@iota/iota-sdk/bcs");
const utils_1 = require("@iota/iota-sdk/utils");
class MoveCoder extends move_1.AbstractMoveCoder {
    constructor(client) {
        super(new sui_chain_adapter_js_1.IotaChainAdapter(client));
    }
    load(module, address) {
        address = (0, move_1.accountTypeString)(address);
        let m = this.moduleMapping.get(module.address + '::' + module.name);
        const mDeclared = this.moduleMapping.get(address + '::' + module.name);
        if (m && mDeclared) {
            return m;
        }
        this.accounts.add(module.address);
        m = (0, to_internal_js_1.toInternalModule)(module);
        this.loadInternal(m, address);
        return m;
    }
    async decode(data, type) {
        switch (type.qname) {
            case '0x1::ascii::Char':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    const byte = (await super.decode(data, type)).byte;
                    return String.fromCharCode(byte);
                }
            case '0x1::ascii::String':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs verified
                    const bytes = (await super.decode(data, type)).bytes;
                    return new TextDecoder().decode(new Uint8Array(bytes));
                }
            case '0x2::object::ID':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs verified
                    const bytes = (await super.decode(data, type)).bytes;
                    return (0, utils_1.normalizeIotaObjectId)(bytes);
                }
            case '0x2::url::Url':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    return (await super.decode(data, type)).url;
                }
            case '0x2::coin::Coin':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    const bytes = (await super.decode(data, type)).id.id.bytes;
                    return new TextDecoder().decode(new Uint8Array(bytes));
                }
                return data;
            case '0x2::balance::Balance':
                if (data.value) {
                    // bcs verfied
                    const balance = await super.decode(data, type);
                    return balance.value;
                }
                return BigInt(data);
            case '0x1::option::Option':
                if (data === null) {
                    return data;
                }
                if (data.vec) {
                    // bcs verifed
                    let vec = await super.decode(data, type);
                    vec = vec.vec;
                    if (vec.length === 0) {
                        return null;
                    }
                    return vec[0];
                }
                return this.decode(data, type.typeArgs[0]);
            case 'Address':
                const str = data;
                return (0, utils_1.normalizeIotaAddress)(str);
            case '0x1::string::String':
                if (typeof data !== 'string') {
                    // bcs
                    return new TextDecoder().decode(new Uint8Array(data.bytes));
                }
            default:
                return super.decode(data, type);
        }
    }
    decodeEvent(event) {
        return this.decodedStruct(event);
    }
    filterAndDecodeEvents(type, resources) {
        if (typeof type === 'string') {
            type = (0, move_1.parseMoveType)(type);
        }
        return this.filterAndDecodeStruct(type, resources);
    }
    async getDynamicFields(objects, keyType = move_1.ANY_TYPE, valueType = move_1.ANY_TYPE) {
        // const type = dynamic_field.Field.TYPE
        // Not using the code above to avoid cycle initialize failed
        const type = new move_1.TypeDescriptor('0x2::dynamic_field::Field');
        type.typeArgs = [keyType, valueType];
        const res = await this.filterAndDecodeObjects(type, objects);
        return res.map((o) => o.data_decoded);
    }
    filterAndDecodeObjects(type, objects) {
        return this.filterAndDecodeStruct(type, objects);
    }
    async decodeFunctionPayload(payload, inputs) {
        const functionType = [payload.package, payload.module, payload.function].join(move_1.SPLITTER);
        const func = await this.getMoveFunction(functionType);
        const params = this.adapter.getMeaningfulFunctionParams(func.params);
        const args = [];
        for (const value of payload.arguments || []) {
            const argValue = value;
            if ('Input' in argValue) {
                const idx = argValue.Input;
                const arg = inputs[idx];
                if (arg.type === 'pure') {
                    args.push(arg.value);
                }
                else if (arg.type === 'object') {
                    // object is not there
                    args.push(undefined);
                }
                else {
                    console.error('unexpected function arg value');
                    args.push(undefined);
                }
                // args.push(arg) // TODO check why ts not work using arg.push(arg)
            }
            else {
                args.push(undefined);
            }
        }
        const argumentsTyped = await this.decodeArray(args, params, false);
        return {
            ...payload,
            arguments_decoded: argumentsTyped
        };
    }
    bcsRegistered = new Set();
    bcsRegistry = new Map();
    async getBCSTypeWithArgs(type, args = []) {
        const qname = type.qname;
        const sig = type.getNormalizedSignature();
        const cached = this.bcsRegistry.get(sig);
        if (cached) {
            return cached;
        }
        const lowerQname = qname.toLowerCase();
        switch (lowerQname) {
            case 'u8':
            case 'u16':
            case 'u32':
            case 'u64':
            case 'u128':
            case 'u256':
            case 'bool':
                return bcs_1.bcs[lowerQname]();
            case 'address':
                return bcs_1.bcs.Address;
            case 'vector':
                return bcs_1.bcs.vector(args[0]);
            default:
                if (!qname.includes('::')) {
                    throw `Unimplemented builtin type ${qname}`;
                }
        }
        let moveStruct;
        try {
            moveStruct = await this.getMoveStruct(qname);
        }
        catch (e) {
            console.error('Invalid move address', qname);
            throw e;
        }
        const structDef = {};
        for (const field of moveStruct.fields) {
            if (field.type.qname.startsWith('T') && args.length) {
                const index = +field.type.qname.slice(1);
                structDef[field.name] = args[index];
            }
            else if (field.type.typeArgs.length && args.length) {
                structDef[field.name] = await this.getBCSTypeWithArgs(field.type, args);
            }
            else {
                structDef[field.name] = await this.getBCSType(field.type);
            }
        }
        return bcs_1.bcs.struct(qname, structDef);
    }
    async getBCSType(type) {
        const args = await Promise.all(type.typeArgs.map((x) => this.getBCSType(x)));
        const bcsType = await this.getBCSTypeWithArgs(type, args);
        this.bcsRegistry.set(type.getNormalizedSignature(), bcsType);
        return bcsType;
    }
    async registerBCSTypes(type) {
        const sig = type.getNormalizedSignature();
        if (this.bcsRegistered.has(sig)) {
            return;
        }
        this.bcsRegistered.add(sig);
        const bcsType = await this.getBCSType(type);
        this.bcsRegistry.set(type.getNormalizedSignature(), bcsType);
    }
    async decodeBCS(type, data, encoding) {
        await this.registerBCSTypes(type);
        if (typeof data == 'string') {
            const buf = Buffer.from(data, encoding);
            data = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        const bcsType = this.bcsRegistry.get(type.getNormalizedSignature());
        return bcsType?.parse(data);
    }
    async decodeDevInspectResult(inspectRes) {
        const returnValues = [];
        if (inspectRes.results != null) {
            for (const r of inspectRes.results) {
                if (r.returnValues) {
                    for (const returnValue of r.returnValues) {
                        const type = (0, move_1.parseMoveType)(returnValue[1]);
                        const bcsDecoded = await this.decodeBCS(type, new Uint8Array(returnValue[0]));
                        const decoded = await this.decodeType(bcsDecoded, type);
                        returnValues.push(decoded);
                    }
                }
                else {
                    returnValues.push(null);
                }
            }
        }
        return { ...inspectRes, results_decoded: returnValues };
    }
}
exports.MoveCoder = MoveCoder;
const DEFAULT_ENDPOINT = 'https://api.mainnet.iota.cafe/';
const CODER_MAP = new Map();
const CHAIN_ID_CODER_MAP = new Map();
function defaultMoveCoder(endpoint = DEFAULT_ENDPOINT) {
    let coder = CODER_MAP.get(endpoint);
    if (!coder) {
        coder = new MoveCoder(new client_1.IotaClient({ url: endpoint }));
        CODER_MAP.set(endpoint, coder);
    }
    return coder;
}
const PROVIDER_CODER_MAP = new Map();
let DEFAULT_CHAIN_ID;
async function getMoveCoder(client) {
    let coder = PROVIDER_CODER_MAP.get(client);
    if (!coder) {
        coder = new MoveCoder(client);
        // TODO how to dedup
        const id = await client.getChainIdentifier();
        const defaultCoder = defaultMoveCoder();
        if (!DEFAULT_CHAIN_ID) {
            DEFAULT_CHAIN_ID = await defaultCoder.adapter.getChainId();
        }
        if (id === DEFAULT_CHAIN_ID) {
            coder = defaultCoder;
        }
        PROVIDER_CODER_MAP.set(client, coder);
    }
    return coder;
}
//# sourceMappingURL=move-coder.js.map