import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/iota";
import { TypedDevInspectResults } from "@typemove/iota";
import { Transaction, TransactionArgument, TransactionObjectArgument } from "@iota/iota-sdk/transactions";
import { IotaClient } from "@iota/iota-sdk/client";
import * as _0x1 from "./0x1.js";
export declare namespace address {
    namespace builder {
        function fromAsciiBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function fromBytes(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function fromU256(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function length(tx: Transaction, args: []): TransactionArgument & [];
        function max(tx: Transaction, args: []): TransactionArgument & [];
        function toAsciiString(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toBytes(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toString(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function toU256(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function fromAsciiBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function fromBytes(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[string]>>;
        function fromU256(client: IotaClient, args: [bigint]): Promise<TypedDevInspectResults<[string]>>;
        function length(client: IotaClient, args: []): Promise<TypedDevInspectResults<[bigint]>>;
        function max(client: IotaClient, args: []): Promise<TypedDevInspectResults<[bigint]>>;
        function toAsciiString(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.ascii.String]>>;
        function toBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function toString(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function toU256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace authenticator_state {
    interface ActiveJwk {
        jwk_id: authenticator_state.JwkId;
        jwk: authenticator_state.JWK;
        epoch: bigint;
    }
    namespace ActiveJwk {
        const TYPE_QNAME = "0x2::authenticator_state::ActiveJwk";
        function type(): TypeDescriptor<ActiveJwk>;
    }
    type ActiveJwkInstance = TypedEventInstance<ActiveJwk> & {
        data_decoded: ActiveJwk;
        type_arguments: [];
    };
    interface AuthenticatorState {
        id: object$.UID;
        version: bigint;
    }
    namespace AuthenticatorState {
        const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorState";
        function type(): TypeDescriptor<AuthenticatorState>;
    }
    interface AuthenticatorStateInner {
        version: bigint;
        active_jwks: authenticator_state.ActiveJwk[];
    }
    namespace AuthenticatorStateInner {
        const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorStateInner";
        function type(): TypeDescriptor<AuthenticatorStateInner>;
    }
    interface JWK {
        kty: string;
        e: string;
        n: string;
        alg: string;
    }
    namespace JWK {
        const TYPE_QNAME = "0x2::authenticator_state::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    type JWKInstance = TypedEventInstance<JWK> & {
        data_decoded: JWK;
        type_arguments: [];
    };
    interface JwkId {
        iss: string;
        kid: string;
    }
    namespace JwkId {
        const TYPE_QNAME = "0x2::authenticator_state::JwkId";
        function type(): TypeDescriptor<JwkId>;
    }
    type JwkIdInstance = TypedEventInstance<JwkId> & {
        data_decoded: JwkId;
        type_arguments: [];
    };
    namespace builder { }
    namespace view { }
}
export declare namespace bag {
    interface Bag {
        id: object$.UID;
        size: bigint;
    }
    namespace Bag {
        const TYPE_QNAME = "0x2::bag::Bag";
        function type(): TypeDescriptor<Bag>;
    }
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function containsWithType<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty(tx: Transaction, args: [bag.Bag | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isEmpty(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function length(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function new$(tx: Transaction, args: []): TransactionArgument & [];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function containsWithType<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty(client: IotaClient, args: [bag.Bag]): Promise<TypedDevInspectResults<[]>>;
        function isEmpty(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$(client: IotaClient, args: []): Promise<TypedDevInspectResults<[bag.Bag]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
    }
}
export declare namespace balance {
    type Balance<T> = bigint;
    namespace Balance {
        const TYPE_QNAME = "0x2::balance::Balance";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Balance<T0>>;
    }
    interface Supply<T0> {
        value: bigint;
    }
    namespace Supply {
        const TYPE_QNAME = "0x2::balance::Supply";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Supply<T0>>;
    }
    namespace builder {
        function createSupply<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function decreaseSupply<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            balance.Balance<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroySupply<T0 = any>(tx: Transaction, args: [balance.Supply<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroyZero<T0 = any>(tx: Transaction, args: [balance.Balance<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function increaseSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function join<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            balance.Balance<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function split<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function supplyValue<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function value<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function withdrawAll<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function zero<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
    }
    namespace view {
        function createSupply<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Supply<T0>]>>;
        function decreaseSupply<T0 = any>(client: IotaClient, args: [string, balance.Balance<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function destroySupply<T0 = any>(client: IotaClient, args: [balance.Supply<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function destroyZero<T0 = any>(client: IotaClient, args: [balance.Balance<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function increaseSupply<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function join<T0 = any>(client: IotaClient, args: [string, balance.Balance<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function split<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function supplyValue<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function value<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function withdrawAll<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function zero<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
    }
}
export declare namespace bcs {
    interface BCS {
        bytes: number[];
    }
    namespace BCS {
        const TYPE_QNAME = "0x2::bcs::BCS";
        function type(): TypeDescriptor<BCS>;
    }
    type BCSInstance = TypedEventInstance<BCS> & {
        data_decoded: BCS;
        type_arguments: [];
    };
    namespace builder {
        function intoRemainderBytes(tx: Transaction, args: [bcs.BCS | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function new$(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function peelAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelBool(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelEnumTag(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionBool(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU128(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU16(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU32(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU64(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelOptionU8(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU128(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU16(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU32(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU64(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelU8(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecBool(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecLength(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU128(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU16(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU32(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU64(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecU8(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function peelVecVecU8(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function toBytes<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function intoRemainderBytes(client: IotaClient, args: [bcs.BCS]): Promise<TypedDevInspectResults<[number[]]>>;
        function new$(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[bcs.BCS]>>;
        function peelAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function peelBool(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function peelEnumTag(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function peelOptionAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>>;
        function peelOptionBool(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<boolean>]>>;
        function peelOptionU128(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>>;
        function peelOptionU16(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>>;
        function peelOptionU256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>>;
        function peelOptionU32(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>>;
        function peelOptionU64(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>>;
        function peelOptionU8(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>>;
        function peelU128(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function peelU16(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function peelU256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function peelU32(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function peelU64(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function peelU8(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function peelVecAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string[]]>>;
        function peelVecBool(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[boolean[]]>>;
        function peelVecLength(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function peelVecU128(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint[]]>>;
        function peelVecU16(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function peelVecU256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint[]]>>;
        function peelVecU32(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function peelVecU64(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint[]]>>;
        function peelVecU8(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function peelVecVecU8(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[][]]>>;
        function toBytes<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace bls12381 {
    interface G1 {
        dummy_field: boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x2::bls12381::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x2::bls12381::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface GT {
        dummy_field: boolean;
    }
    namespace GT {
        const TYPE_QNAME = "0x2::bls12381::GT";
        function type(): TypeDescriptor<GT>;
    }
    interface Scalar {
        dummy_field: boolean;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x2::bls12381::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
    interface UncompressedG1 {
        dummy_field: boolean;
    }
    namespace UncompressedG1 {
        const TYPE_QNAME = "0x2::bls12381::UncompressedG1";
        function type(): TypeDescriptor<UncompressedG1>;
    }
    namespace builder {
        function bls12381MinPkVerify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function bls12381MinSigVerify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function g1Add(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g1Div(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g1FromBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function g1Generator(tx: Transaction, args: []): TransactionArgument & [];
        function g1Identity(tx: Transaction, args: []): TransactionArgument & [];
        function g1Mul(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g1MultiScalarMultiplication(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g1Neg(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function g1Sub(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g1ToUncompressedG1(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function g2Add(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g2Div(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g2FromBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function g2Generator(tx: Transaction, args: []): TransactionArgument & [];
        function g2Identity(tx: Transaction, args: []): TransactionArgument & [];
        function g2Mul(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g2MultiScalarMultiplication(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function g2Neg(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function g2Sub(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gtAdd(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gtDiv(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gtGenerator(tx: Transaction, args: []): TransactionArgument & [];
        function gtIdentity(tx: Transaction, args: []): TransactionArgument & [];
        function gtMul(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function gtNeg(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function gtSub(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hashToG1(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function hashToG2(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function pairing(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function scalarAdd(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function scalarDiv(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function scalarFromBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function scalarFromU64(tx: Transaction, args: [bigint | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function scalarInv(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function scalarMul(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function scalarNeg(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function scalarOne(tx: Transaction, args: []): TransactionArgument & [];
        function scalarSub(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function scalarZero(tx: Transaction, args: []): TransactionArgument & [];
        function uncompressedG1Sum(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function uncompressedG1ToG1(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function bls12381MinPkVerify(client: IotaClient, args: [string, string, string]): Promise<TypedDevInspectResults<[boolean]>>;
        function bls12381MinSigVerify(client: IotaClient, args: [string, string, string]): Promise<TypedDevInspectResults<[boolean]>>;
        function g1Add(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Div(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1FromBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Generator(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Identity(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Mul(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1MultiScalarMultiplication(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Neg(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1Sub(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function g1ToUncompressedG1(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.UncompressedG1>]>>;
        function g2Add(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Div(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2FromBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Generator(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Identity(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Mul(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2MultiScalarMultiplication(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Neg(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function g2Sub(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function gtAdd(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtDiv(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtGenerator(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtIdentity(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtMul(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtNeg(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function gtSub(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function hashToG1(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
        function hashToG2(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>>;
        function pairing(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>>;
        function scalarAdd(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarDiv(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarFromBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarFromU64(client: IotaClient, args: [bigint]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarInv(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarMul(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarNeg(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarOne(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarSub(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function scalarZero(client: IotaClient, args: []): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>>;
        function uncompressedG1Sum(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.UncompressedG1>]>>;
        function uncompressedG1ToG1(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>>;
    }
}
export declare namespace borrow {
    interface Borrow {
        ref: string;
        obj: object$.ID;
    }
    namespace Borrow {
        const TYPE_QNAME = "0x2::borrow::Borrow";
        function type(): TypeDescriptor<Borrow>;
    }
    interface Referent<T0> {
        id: string;
        value: _0x1.option.Option<T0>;
    }
    namespace Referent {
        const TYPE_QNAME = "0x2::borrow::Referent";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Referent<T0>>;
    }
    namespace builder {
        function borrow<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroy<T0 = any>(tx: Transaction, args: [borrow.Referent<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function putBack<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            borrow.Borrow | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function borrow<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, borrow.Borrow]>>;
        function destroy<T0 = any>(client: IotaClient, args: [borrow.Referent<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function new$<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[borrow.Referent<T0>]>>;
        function putBack<T0 = any>(client: IotaClient, args: [string, T0, borrow.Borrow], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace clock {
    interface Clock {
        id: object$.UID;
        timestamp_ms: bigint;
    }
    namespace Clock {
        const TYPE_QNAME = "0x2::clock::Clock";
        function type(): TypeDescriptor<Clock>;
    }
    namespace builder {
        function timestampMs(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function timestampMs(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace coin {
    type Coin<T> = string;
    namespace Coin {
        const TYPE_QNAME = "0x2::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinMetadata<T0> {
        id: object$.UID;
        decimals: number;
        name: string;
        symbol: _0x1.ascii.String;
        description: string;
        icon_url: _0x1.option.Option<url.Url>;
    }
    namespace CoinMetadata {
        const TYPE_QNAME = "0x2::coin::CoinMetadata";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinMetadata<T0>>;
    }
    interface DenyCapV1<T0> {
        id: object$.UID;
        allow_global_pause: boolean;
    }
    namespace DenyCapV1 {
        const TYPE_QNAME = "0x2::coin::DenyCapV1";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<DenyCapV1<T0>>;
    }
    interface RegulatedCoinMetadata<T0> {
        id: object$.UID;
        coin_metadata_object: object$.ID;
        deny_cap_object: object$.ID;
    }
    namespace RegulatedCoinMetadata {
        const TYPE_QNAME = "0x2::coin::RegulatedCoinMetadata";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RegulatedCoinMetadata<T0>>;
    }
    interface TreasuryCap<T0> {
        id: object$.UID;
        total_supply: balance.Supply<T0>;
    }
    namespace TreasuryCap {
        const TYPE_QNAME = "0x2::coin::TreasuryCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TreasuryCap<T0>>;
    }
    namespace builder {
        function balance<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function balanceMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function burn<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            coin.Coin<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function createCurrency<T0 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            number | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            _0x1.option.Option<url.Url> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function createRegulatedCurrencyV1<T0 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            number | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            _0x1.option.Option<url.Url> | TransactionArgument,
            boolean | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function denyListV1Add<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function denyListV1ContainsCurrentEpoch<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function denyListV1ContainsNextEpoch<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function denyListV1DisableGlobalPause<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function denyListV1EnableGlobalPause<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function denyListV1IsGlobalPauseEnabledCurrentEpoch<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function denyListV1IsGlobalPauseEnabledNextEpoch<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function denyListV1Remove<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function destroyZero<T0 = any>(tx: Transaction, args: [coin.Coin<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function divideIntoN<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromBalance<T0 = any>(tx: Transaction, args: [balance.Balance<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getDecimals<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getDescription<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getIconUrl<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getName<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getSymbol<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function intoBalance<T0 = any>(tx: Transaction, args: [coin.Coin<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function join<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            coin.Coin<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mint<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mintAndTransfer<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function mintBalance<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function put<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            coin.Coin<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function split<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function supplyImmut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function supplyMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function take<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function totalSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function treasuryIntoSupply<T0 = any>(tx: Transaction, args: [coin.TreasuryCap<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function updateDescription<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateIconUrl<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.ascii.String | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateName<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateSymbol<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.ascii.String | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function value<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function zero<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
    }
    namespace view {
        function balance<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function balanceMut<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function burn<T0 = any>(client: IotaClient, args: [string, coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function createCurrency<T0 = any>(client: IotaClient, args: [
            T0,
            number,
            string[],
            string[],
            string[],
            _0x1.option.Option<url.Url>
        ], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.TreasuryCap<T0>, coin.CoinMetadata<T0>]>>;
        function createRegulatedCurrencyV1<T0 = any>(client: IotaClient, args: [
            T0,
            number,
            string[],
            string[],
            string[],
            _0x1.option.Option<url.Url>,
            boolean
        ], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            coin.TreasuryCap<T0>,
            coin.DenyCapV1<T0>,
            coin.CoinMetadata<T0>
        ]>>;
        function denyListV1Add<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function denyListV1ContainsCurrentEpoch<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function denyListV1ContainsNextEpoch<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function denyListV1DisableGlobalPause<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function denyListV1EnableGlobalPause<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function denyListV1IsGlobalPauseEnabledCurrentEpoch<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function denyListV1IsGlobalPauseEnabledNextEpoch<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function denyListV1Remove<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function destroyZero<T0 = any>(client: IotaClient, args: [coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function divideIntoN<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>[]]>>;
        function fromBalance<T0 = any>(client: IotaClient, args: [balance.Balance<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
        function getDecimals<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number]>>;
        function getDescription<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function getIconUrl<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<url.Url>]>>;
        function getName<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function getSymbol<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.ascii.String]>>;
        function intoBalance<T0 = any>(client: IotaClient, args: [coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function join<T0 = any>(client: IotaClient, args: [string, coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function mint<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
        function mintAndTransfer<T0 = any>(client: IotaClient, args: [string, bigint, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function mintBalance<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function put<T0 = any>(client: IotaClient, args: [string, coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function split<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
        function supplyImmut<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function supplyMut<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function take<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
        function totalSupply<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function treasuryIntoSupply<T0 = any>(client: IotaClient, args: [coin.TreasuryCap<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Supply<T0>]>>;
        function updateDescription<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateIconUrl<T0 = any>(client: IotaClient, args: [string, string, _0x1.ascii.String], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateName<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateSymbol<T0 = any>(client: IotaClient, args: [string, string, _0x1.ascii.String], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function value<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function zero<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
    }
}
export declare namespace coin_manager {
    interface CoinManaged {
        coin_name: _0x1.ascii.String;
    }
    namespace CoinManaged {
        const TYPE_QNAME = "0x2::coin_manager::CoinManaged";
        function type(): TypeDescriptor<CoinManaged>;
    }
    type CoinManagedInstance = TypedEventInstance<CoinManaged> & {
        data_decoded: CoinManaged;
        type_arguments: [];
    };
    interface CoinManager<T0> {
        id: object$.UID;
        treasury_cap: coin.TreasuryCap<T0>;
        metadata: _0x1.option.Option<coin.CoinMetadata<T0>>;
        immutable_metadata: _0x1.option.Option<coin_manager.ImmutableCoinMetadata<T0>>;
        maximum_supply: _0x1.option.Option<bigint>;
        supply_immutable: boolean;
        metadata_immutable: boolean;
    }
    namespace CoinManager {
        const TYPE_QNAME = "0x2::coin_manager::CoinManager";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinManager<T0>>;
    }
    interface CoinManagerMetadataCap<T0> {
        id: object$.UID;
    }
    namespace CoinManagerMetadataCap {
        const TYPE_QNAME = "0x2::coin_manager::CoinManagerMetadataCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinManagerMetadataCap<T0>>;
    }
    interface CoinManagerTreasuryCap<T0> {
        id: object$.UID;
    }
    namespace CoinManagerTreasuryCap {
        const TYPE_QNAME = "0x2::coin_manager::CoinManagerTreasuryCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinManagerTreasuryCap<T0>>;
    }
    interface ImmutableCoinMetadata<T0> {
        decimals: number;
        name: string;
        symbol: _0x1.ascii.String;
        description: string;
        icon_url: _0x1.option.Option<url.Url>;
    }
    namespace ImmutableCoinMetadata {
        const TYPE_QNAME = "0x2::coin_manager::ImmutableCoinMetadata";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ImmutableCoinMetadata<T0>>;
    }
    interface MetadataOwnershipRenounced {
        coin_name: _0x1.ascii.String;
    }
    namespace MetadataOwnershipRenounced {
        const TYPE_QNAME = "0x2::coin_manager::MetadataOwnershipRenounced";
        function type(): TypeDescriptor<MetadataOwnershipRenounced>;
    }
    type MetadataOwnershipRenouncedInstance = TypedEventInstance<MetadataOwnershipRenounced> & {
        data_decoded: MetadataOwnershipRenounced;
        type_arguments: [];
    };
    interface TreasuryOwnershipRenounced {
        coin_name: _0x1.ascii.String;
    }
    namespace TreasuryOwnershipRenounced {
        const TYPE_QNAME = "0x2::coin_manager::TreasuryOwnershipRenounced";
        function type(): TypeDescriptor<TreasuryOwnershipRenounced>;
    }
    type TreasuryOwnershipRenouncedInstance = TypedEventInstance<TreasuryOwnershipRenounced> & {
        data_decoded: TreasuryOwnershipRenounced;
        type_arguments: [];
    };
    namespace builder {
        function addAdditionalMetadata<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function additionalMetadata<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function availableSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function burn<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            coin.Coin<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function create<T0 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            number | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            _0x1.option.Option<url.Url> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function decimals<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function description<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function enforceMaximumSupply<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function getAdditionalMetadata<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function hasMaximumSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function iconUrl<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function immutableMetadata<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function maximumSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function metadata<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function metadataIsImmutable<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function mint<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function mintAndTransfer<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function mintBalance<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function name<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any>(tx: Transaction, args: [
            coin.TreasuryCap<T0> | TransactionArgument,
            coin.CoinMetadata<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function newWithImmutableMetadata<T0 = any>(tx: Transaction, args: [
            coin.TreasuryCap<T0> | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function renounceMetadataOwnership<T0 = any>(tx: Transaction, args: [
            coin_manager.CoinManagerMetadataCap<T0> | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function renounceTreasuryOwnership<T0 = any>(tx: Transaction, args: [
            coin_manager.CoinManagerTreasuryCap<T0> | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function replaceAdditionalMetadata<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function supplyImmut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function supplyIsImmutable<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function symbol$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function totalSupply<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function updateDescription<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateIconUrl<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.ascii.String | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateName<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function updateSymbol<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.ascii.String | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function addAdditionalMetadata<T0 = any, T1 = any>(client: IotaClient, args: [string, string, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function additionalMetadata<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function availableSupply<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function burn<T0 = any>(client: IotaClient, args: [string, string, coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function create<T0 = any>(client: IotaClient, args: [
            T0,
            number,
            string[],
            string[],
            string[],
            _0x1.option.Option<url.Url>
        ], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            coin_manager.CoinManagerTreasuryCap<T0>,
            coin_manager.CoinManagerMetadataCap<T0>,
            coin_manager.CoinManager<T0>
        ]>>;
        function decimals<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number]>>;
        function description<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function enforceMaximumSupply<T0 = any>(client: IotaClient, args: [string, string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function getAdditionalMetadata<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function hasMaximumSupply<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function iconUrl<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<url.Url>]>>;
        function immutableMetadata<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function maximumSupply<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function metadata<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function metadataIsImmutable<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function mint<T0 = any>(client: IotaClient, args: [string, string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>]>>;
        function mintAndTransfer<T0 = any>(client: IotaClient, args: [string, string, bigint, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function mintBalance<T0 = any>(client: IotaClient, args: [string, string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[balance.Balance<T0>]>>;
        function name<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function new$<T0 = any>(client: IotaClient, args: [coin.TreasuryCap<T0>, coin.CoinMetadata<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            coin_manager.CoinManagerTreasuryCap<T0>,
            coin_manager.CoinManagerMetadataCap<T0>,
            coin_manager.CoinManager<T0>
        ]>>;
        function newWithImmutableMetadata<T0 = any>(client: IotaClient, args: [coin.TreasuryCap<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            coin_manager.CoinManagerTreasuryCap<T0>,
            coin_manager.CoinManager<T0>
        ]>>;
        function renounceMetadataOwnership<T0 = any>(client: IotaClient, args: [coin_manager.CoinManagerMetadataCap<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function renounceTreasuryOwnership<T0 = any>(client: IotaClient, args: [coin_manager.CoinManagerTreasuryCap<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function replaceAdditionalMetadata<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[T2]>>;
        function supplyImmut<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function supplyIsImmutable<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function symbol$<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.ascii.String]>>;
        function totalSupply<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function updateDescription<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateIconUrl<T0 = any>(client: IotaClient, args: [string, string, _0x1.ascii.String], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateName<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateSymbol<T0 = any>(client: IotaClient, args: [string, string, _0x1.ascii.String], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace config {
    interface Config<T0> {
        id: object$.UID;
    }
    namespace Config {
        const TYPE_QNAME = "0x2::config::Config";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Config<T0>>;
    }
    interface Setting<T0> {
        data: _0x1.option.Option<config.SettingData<T0>>;
    }
    namespace Setting {
        const TYPE_QNAME = "0x2::config::Setting";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Setting<T0>>;
    }
    interface SettingData<T0> {
        newer_value_epoch: bigint;
        newer_value: _0x1.option.Option<T0>;
        older_value_opt: _0x1.option.Option<T0>;
    }
    namespace SettingData {
        const TYPE_QNAME = "0x2::config::SettingData";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SettingData<T0>>;
    }
    namespace builder {
        function addForNextEpoch<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument,
            T2 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrowForNextEpochMut<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function existsWithType<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T1 | TransactionArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function existsWithTypeForNextEpoch<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T1 | TransactionArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function new$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function readSetting<T0 = any, T1 = any>(tx: Transaction, args: [object$.ID | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function readSettingForNextEpoch<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T1 | TransactionArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function removeForNextEpoch<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function share<T0 = any>(tx: Transaction, args: [config.Config<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function transfer<T0 = any>(tx: Transaction, args: [
            config.Config<T0> | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function addForNextEpoch<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string, T1, T2], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>>;
        function borrowForNextEpochMut<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[string]>>;
        function existsWithType<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[boolean]>>;
        function existsWithTypeForNextEpoch<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[boolean]>>;
        function new$<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[config.Config<T0>]>>;
        function readSetting<T0 = any, T1 = any>(client: IotaClient, args: [object$.ID, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>>;
        function readSettingForNextEpoch<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>>;
        function removeForNextEpoch<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string, T1], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>>;
        function share<T0 = any>(client: IotaClient, args: [config.Config<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function transfer<T0 = any>(client: IotaClient, args: [config.Config<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace deny_list {
    interface AddressKey {
        pos0: string;
    }
    namespace AddressKey {
        const TYPE_QNAME = "0x2::deny_list::AddressKey";
        function type(): TypeDescriptor<AddressKey>;
    }
    type AddressKeyInstance = TypedEventInstance<AddressKey> & {
        data_decoded: AddressKey;
        type_arguments: [];
    };
    interface ConfigKey {
        per_type_index: bigint;
        per_type_key: number[];
    }
    namespace ConfigKey {
        const TYPE_QNAME = "0x2::deny_list::ConfigKey";
        function type(): TypeDescriptor<ConfigKey>;
    }
    type ConfigKeyInstance = TypedEventInstance<ConfigKey> & {
        data_decoded: ConfigKey;
        type_arguments: [];
    };
    interface ConfigWriteCap {
        dummy_field: boolean;
    }
    namespace ConfigWriteCap {
        const TYPE_QNAME = "0x2::deny_list::ConfigWriteCap";
        function type(): TypeDescriptor<ConfigWriteCap>;
    }
    interface DenyList {
        id: object$.UID;
        lists: bag.Bag;
    }
    namespace DenyList {
        const TYPE_QNAME = "0x2::deny_list::DenyList";
        function type(): TypeDescriptor<DenyList>;
    }
    interface GlobalPauseKey {
        dummy_field: boolean;
    }
    namespace GlobalPauseKey {
        const TYPE_QNAME = "0x2::deny_list::GlobalPauseKey";
        function type(): TypeDescriptor<GlobalPauseKey>;
    }
    type GlobalPauseKeyInstance = TypedEventInstance<GlobalPauseKey> & {
        data_decoded: GlobalPauseKey;
        type_arguments: [];
    };
    interface PerTypeConfigCreated {
        key: deny_list.ConfigKey;
        config_id: object$.ID;
    }
    namespace PerTypeConfigCreated {
        const TYPE_QNAME = "0x2::deny_list::PerTypeConfigCreated";
        function type(): TypeDescriptor<PerTypeConfigCreated>;
    }
    type PerTypeConfigCreatedInstance = TypedEventInstance<PerTypeConfigCreated> & {
        data_decoded: PerTypeConfigCreated;
        type_arguments: [];
    };
    namespace builder {
        function add(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function containsCurrentEpoch(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function containsNextEpoch(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function disableGlobalPause(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function enableGlobalPause(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function isGlobalPauseEnabledCurrentEpoch(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function isGlobalPauseEnabledNextEpoch(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function remove(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function add(client: IotaClient, args: [string, bigint, string[], string]): Promise<TypedDevInspectResults<[]>>;
        function containsCurrentEpoch(client: IotaClient, args: [string, bigint, string[], string]): Promise<TypedDevInspectResults<[boolean]>>;
        function containsNextEpoch(client: IotaClient, args: [string, bigint, string[], string]): Promise<TypedDevInspectResults<[boolean]>>;
        function disableGlobalPause(client: IotaClient, args: [string, bigint, string[]]): Promise<TypedDevInspectResults<[]>>;
        function enableGlobalPause(client: IotaClient, args: [string, bigint, string[]]): Promise<TypedDevInspectResults<[]>>;
        function isGlobalPauseEnabledCurrentEpoch(client: IotaClient, args: [string, bigint, string[]]): Promise<TypedDevInspectResults<[boolean]>>;
        function isGlobalPauseEnabledNextEpoch(client: IotaClient, args: [string, bigint, string[]]): Promise<TypedDevInspectResults<[boolean]>>;
        function remove(client: IotaClient, args: [string, bigint, string[], string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace display {
    interface Display<T0> {
        id: object$.UID;
        fields: vec_map.VecMap<string, string>;
        version: number;
    }
    namespace Display {
        const TYPE_QNAME = "0x2::display::Display";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Display<T0>>;
    }
    interface DisplayCreated<T0> {
        id: object$.ID;
    }
    namespace DisplayCreated {
        const TYPE_QNAME = "0x2::display::DisplayCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<DisplayCreated<T0>>;
    }
    type DisplayCreatedInstance = TypedEventInstance<DisplayCreated<any>> & {
        data_decoded: DisplayCreated<any>;
        type_arguments: [string];
    };
    interface VersionUpdated<T0> {
        id: object$.ID;
        version: number;
        fields: vec_map.VecMap<string, string>;
    }
    namespace VersionUpdated {
        const TYPE_QNAME = "0x2::display::VersionUpdated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VersionUpdated<T0>>;
    }
    type VersionUpdatedInstance = TypedEventInstance<VersionUpdated<any>> & {
        data_decoded: VersionUpdated<any>;
        type_arguments: [string];
    };
    namespace builder {
        function add<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function addMultiple<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function createAndKeep<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function edit<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function fields<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isAuthorized<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function newWithFields<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function remove<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function updateVersion<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function version<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function add<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function addMultiple<T0 = any>(client: IotaClient, args: [string, string[], string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function createAndKeep<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function edit<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function fields<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function isAuthorized<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function new$<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[display.Display<T0>]>>;
        function newWithFields<T0 = any>(client: IotaClient, args: [string, string[], string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[display.Display<T0>]>>;
        function remove<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function updateVersion<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function version<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number]>>;
    }
}
export declare namespace dynamic_field {
    interface Field<T0, T1> {
        id: object$.UID;
        name: T0;
        value: T1;
    }
    namespace Field {
        const TYPE_QNAME = "0x2::dynamic_field::Field";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Field<T0, T1>>;
    }
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function addChildObject<T0 = any>(tx: Transaction, args: [string | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowChildObject<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowChildObjectMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function exists_<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function existsWithType<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fieldInfo<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fieldInfoMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hasChildObject(tx: Transaction, args: [string | TransactionArgument, string | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hasChildObjectWithTy<T0 = any>(tx: Transaction, args: [string | TransactionArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hashTypeAndKey<T0 = any>(tx: Transaction, args: [string | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function removeChildObject<T0 = any>(tx: Transaction, args: [string | TransactionArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function removeIfExists<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function addChildObject<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowChildObject<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowChildObjectMut<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function exists_<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function existsWithType<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function fieldInfo<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string, string]>>;
        function fieldInfoMut<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string, string]>>;
        function hasChildObject(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[boolean]>>;
        function hasChildObjectWithTy<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function hashTypeAndKey<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
        function removeChildObject<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function removeIfExists<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>>;
    }
}
export declare namespace dynamic_object_field {
    interface Wrapper<T0> {
        name: T0;
    }
    namespace Wrapper {
        const TYPE_QNAME = "0x2::dynamic_object_field::Wrapper";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Wrapper<T0>>;
    }
    type WrapperInstance = TypedEventInstance<Wrapper<any>> & {
        data_decoded: Wrapper<any>;
        type_arguments: [string];
    };
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function exists_<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function existsWithType<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function id<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function internalAdd<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function internalBorrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function internalBorrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function internalExistsWithType<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function internalRemove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function exists_<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function existsWithType<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function id<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>>;
        function internalAdd<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function internalBorrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function internalBorrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function internalExistsWithType<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function internalRemove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
    }
}
export declare namespace ecdsa_k1 {
    namespace builder {
        function decompressPubkey(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function secp256k1Ecrecover(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function secp256k1Verify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function decompressPubkey(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function secp256k1Ecrecover(client: IotaClient, args: [string, string, number]): Promise<TypedDevInspectResults<[number[]]>>;
        function secp256k1Verify(client: IotaClient, args: [string, string, string, number]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace ecdsa_r1 {
    namespace builder {
        function secp256r1Ecrecover(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function secp256r1Verify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function secp256r1Ecrecover(client: IotaClient, args: [string, string, number]): Promise<TypedDevInspectResults<[number[]]>>;
        function secp256r1Verify(client: IotaClient, args: [string, string, string, number]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace ecvrf {
    namespace builder {
        function ecvrfVerify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function ecvrfVerify(client: IotaClient, args: [string, string, string, string]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace ed25519 {
    namespace builder {
        function ed25519Verify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function ed25519Verify(client: IotaClient, args: [string, string, string]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace event {
    namespace builder {
        function emit<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function emit<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace groth16 {
    interface Curve {
        id: number;
    }
    namespace Curve {
        const TYPE_QNAME = "0x2::groth16::Curve";
        function type(): TypeDescriptor<Curve>;
    }
    type CurveInstance = TypedEventInstance<Curve> & {
        data_decoded: Curve;
        type_arguments: [];
    };
    interface PreparedVerifyingKey {
        vk_gamma_abc_g1_bytes: number[];
        alpha_g1_beta_g2_bytes: number[];
        gamma_g2_neg_pc_bytes: number[];
        delta_g2_neg_pc_bytes: number[];
    }
    namespace PreparedVerifyingKey {
        const TYPE_QNAME = "0x2::groth16::PreparedVerifyingKey";
        function type(): TypeDescriptor<PreparedVerifyingKey>;
    }
    type PreparedVerifyingKeyInstance = TypedEventInstance<PreparedVerifyingKey> & {
        data_decoded: PreparedVerifyingKey;
        type_arguments: [];
    };
    interface ProofPoints {
        bytes: number[];
    }
    namespace ProofPoints {
        const TYPE_QNAME = "0x2::groth16::ProofPoints";
        function type(): TypeDescriptor<ProofPoints>;
    }
    type ProofPointsInstance = TypedEventInstance<ProofPoints> & {
        data_decoded: ProofPoints;
        type_arguments: [];
    };
    interface PublicProofInputs {
        bytes: number[];
    }
    namespace PublicProofInputs {
        const TYPE_QNAME = "0x2::groth16::PublicProofInputs";
        function type(): TypeDescriptor<PublicProofInputs>;
    }
    type PublicProofInputsInstance = TypedEventInstance<PublicProofInputs> & {
        data_decoded: PublicProofInputs;
        type_arguments: [];
    };
    namespace builder {
        function bls12381(tx: Transaction, args: []): TransactionArgument & [];
        function bn254(tx: Transaction, args: []): TransactionArgument & [];
        function prepareVerifyingKey(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function proofPointsFromBytes(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function publicProofInputsFromBytes(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function pvkFromBytes(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function pvkToBytes(tx: Transaction, args: [groth16.PreparedVerifyingKey | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function verifyGroth16Proof(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function bls12381(client: IotaClient, args: []): Promise<TypedDevInspectResults<[groth16.Curve]>>;
        function bn254(client: IotaClient, args: []): Promise<TypedDevInspectResults<[groth16.Curve]>>;
        function prepareVerifyingKey(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>>;
        function proofPointsFromBytes(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[groth16.ProofPoints]>>;
        function publicProofInputsFromBytes(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[groth16.PublicProofInputs]>>;
        function pvkFromBytes(client: IotaClient, args: [string[], string[], string[], string[]]): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>>;
        function pvkToBytes(client: IotaClient, args: [groth16.PreparedVerifyingKey]): Promise<TypedDevInspectResults<[number[][]]>>;
        function verifyGroth16Proof(client: IotaClient, args: [string, string, string, string]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace group_ops {
    interface Element<T0> {
        bytes: number[];
    }
    namespace Element {
        const TYPE_QNAME = "0x2::group_ops::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
    type ElementInstance = TypedEventInstance<Element<any>> & {
        data_decoded: Element<any>;
        type_arguments: [string];
    };
    namespace builder {
        function add<T0 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function bytes<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function convert<T0 = any, T1 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            number | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function div<T0 = any, T1 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function equal<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromBytes<T0 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            boolean | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function hashTo<T0 = any>(tx: Transaction, args: [number | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mul<T0 = any, T1 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function multiScalarMultiplication<T0 = any, T1 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function pairing<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function setAsPrefix(tx: Transaction, args: [
            bigint | TransactionArgument,
            boolean | TransactionArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function sub<T0 = any>(tx: Transaction, args: [
            number | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function sum<T0 = any>(tx: Transaction, args: [number | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any>(client: IotaClient, args: [number, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>>;
        function bytes<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function convert<T0 = any, T1 = any>(client: IotaClient, args: [number, number, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>>;
        function div<T0 = any, T1 = any>(client: IotaClient, args: [number, string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>>;
        function equal<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function fromBytes<T0 = any>(client: IotaClient, args: [number, string, boolean], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>>;
        function hashTo<T0 = any>(client: IotaClient, args: [number, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>>;
        function mul<T0 = any, T1 = any>(client: IotaClient, args: [number, string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>>;
        function multiScalarMultiplication<T0 = any, T1 = any>(client: IotaClient, args: [number, string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>>;
        function pairing<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [number, string, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[group_ops.Element<T2>]>>;
        function setAsPrefix(client: IotaClient, args: [bigint, boolean, string]): Promise<TypedDevInspectResults<[]>>;
        function sub<T0 = any>(client: IotaClient, args: [number, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>>;
        function sum<T0 = any>(client: IotaClient, args: [number, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>>;
    }
}
export declare namespace hash {
    namespace builder {
        function blake2b256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function keccak256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function blake2b256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function keccak256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace hex {
    namespace builder {
        function decode(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function encode(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function decode(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[number[]]>>;
        function encode(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace hmac {
    namespace builder {
        function hmacSha3256(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function hmacSha3256(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[number[]]>>;
    }
}
export declare namespace iota {
    interface IOTA {
        dummy_field: boolean;
    }
    namespace IOTA {
        const TYPE_QNAME = "0x2::iota::IOTA";
        function type(): TypeDescriptor<IOTA>;
    }
    interface IotaTreasuryCap {
        inner: coin.TreasuryCap<iota.IOTA>;
    }
    namespace IotaTreasuryCap {
        const TYPE_QNAME = "0x2::iota::IotaTreasuryCap";
        function type(): TypeDescriptor<IotaTreasuryCap>;
    }
    namespace builder {
        function burn(tx: Transaction, args: [
            string | TransactionObjectArgument,
            coin.Coin<iota.IOTA> | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function burnBalance(tx: Transaction, args: [
            string | TransactionObjectArgument,
            balance.Balance<iota.IOTA> | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mint(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function mintBalance(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function totalSupply(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function transfer(tx: Transaction, args: [
            coin.Coin<iota.IOTA> | TransactionArgument,
            string | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function burn(client: IotaClient, args: [string, coin.Coin<iota.IOTA>]): Promise<TypedDevInspectResults<[bigint]>>;
        function burnBalance(client: IotaClient, args: [string, balance.Balance<iota.IOTA>]): Promise<TypedDevInspectResults<[bigint]>>;
        function mint(client: IotaClient, args: [string, bigint]): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>>;
        function mintBalance(client: IotaClient, args: [string, bigint]): Promise<TypedDevInspectResults<[balance.Balance<iota.IOTA>]>>;
        function totalSupply(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function transfer(client: IotaClient, args: [coin.Coin<iota.IOTA>, string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace kiosk {
    interface Borrow {
        kiosk_id: object$.ID;
        item_id: object$.ID;
    }
    namespace Borrow {
        const TYPE_QNAME = "0x2::kiosk::Borrow";
        function type(): TypeDescriptor<Borrow>;
    }
    interface Item {
        id: object$.ID;
    }
    namespace Item {
        const TYPE_QNAME = "0x2::kiosk::Item";
        function type(): TypeDescriptor<Item>;
    }
    type ItemInstance = TypedEventInstance<Item> & {
        data_decoded: Item;
        type_arguments: [];
    };
    interface ItemDelisted<T0> {
        kiosk: object$.ID;
        id: object$.ID;
    }
    namespace ItemDelisted {
        const TYPE_QNAME = "0x2::kiosk::ItemDelisted";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemDelisted<T0>>;
    }
    type ItemDelistedInstance = TypedEventInstance<ItemDelisted<any>> & {
        data_decoded: ItemDelisted<any>;
        type_arguments: [string];
    };
    interface ItemListed<T0> {
        kiosk: object$.ID;
        id: object$.ID;
        price: bigint;
    }
    namespace ItemListed {
        const TYPE_QNAME = "0x2::kiosk::ItemListed";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemListed<T0>>;
    }
    type ItemListedInstance = TypedEventInstance<ItemListed<any>> & {
        data_decoded: ItemListed<any>;
        type_arguments: [string];
    };
    interface ItemPurchased<T0> {
        kiosk: object$.ID;
        id: object$.ID;
        price: bigint;
    }
    namespace ItemPurchased {
        const TYPE_QNAME = "0x2::kiosk::ItemPurchased";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemPurchased<T0>>;
    }
    type ItemPurchasedInstance = TypedEventInstance<ItemPurchased<any>> & {
        data_decoded: ItemPurchased<any>;
        type_arguments: [string];
    };
    interface Kiosk {
        id: object$.UID;
        profits: balance.Balance<iota.IOTA>;
        owner: string;
        item_count: number;
    }
    namespace Kiosk {
        const TYPE_QNAME = "0x2::kiosk::Kiosk";
        function type(): TypeDescriptor<Kiosk>;
    }
    interface KioskOwnerCap {
        id: object$.UID;
        for: object$.ID;
    }
    namespace KioskOwnerCap {
        const TYPE_QNAME = "0x2::kiosk::KioskOwnerCap";
        function type(): TypeDescriptor<KioskOwnerCap>;
    }
    interface Listing {
        id: object$.ID;
        is_exclusive: boolean;
    }
    namespace Listing {
        const TYPE_QNAME = "0x2::kiosk::Listing";
        function type(): TypeDescriptor<Listing>;
    }
    type ListingInstance = TypedEventInstance<Listing> & {
        data_decoded: Listing;
        type_arguments: [];
    };
    interface Lock {
        id: object$.ID;
    }
    namespace Lock {
        const TYPE_QNAME = "0x2::kiosk::Lock";
        function type(): TypeDescriptor<Lock>;
    }
    type LockInstance = TypedEventInstance<Lock> & {
        data_decoded: Lock;
        type_arguments: [];
    };
    interface PurchaseCap<T0> {
        id: object$.UID;
        kiosk_id: object$.ID;
        item_id: object$.ID;
        min_price: bigint;
    }
    namespace PurchaseCap {
        const TYPE_QNAME = "0x2::kiosk::PurchaseCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<PurchaseCap<T0>>;
    }
    namespace builder {
        function borrow<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrowMut<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrowVal<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function closeAndWithdraw(tx: Transaction, args: [
            kiosk.Kiosk | TransactionArgument,
            kiosk.KioskOwnerCap | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function default$(tx: Transaction, args: []): TransactionArgument & [];
        function delist<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function hasAccess(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hasItem(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hasItemWithType<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function isListed(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function isListedExclusively(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function isLocked(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function itemCount(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function kioskOwnerCapFor(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function list<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function listWithPurchaseCap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function lock<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T0 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function lockInternal<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function new$(tx: Transaction, args: []): TransactionArgument & [];
        function owner(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function place<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T0 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function placeAndList<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function placeInternal<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function profitsAmount(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function profitsMut(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function purchase<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument,
            coin.Coin<iota.IOTA> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function purchaseCapItem<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function purchaseCapKiosk<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function purchaseCapMinPrice<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function purchaseWithCap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            kiosk.PurchaseCap<T0> | TransactionArgument,
            coin.Coin<iota.IOTA> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function returnPurchaseCap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            kiosk.PurchaseCap<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function returnVal<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            kiosk.Borrow | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function setOwner(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function setOwnerCustom(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function take<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function uid(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function uidMutAsOwner(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function uidMutInternal(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function withdraw(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.option.Option<bigint> | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function borrow<T0 = any>(client: IotaClient, args: [string, string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any>(client: IotaClient, args: [string, string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowVal<T0 = any>(client: IotaClient, args: [string, string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, kiosk.Borrow]>>;
        function closeAndWithdraw(client: IotaClient, args: [kiosk.Kiosk, kiosk.KioskOwnerCap]): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>>;
        function delist<T0 = any>(client: IotaClient, args: [string, string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function hasAccess(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[boolean]>>;
        function hasItem(client: IotaClient, args: [string, object$.ID]): Promise<TypedDevInspectResults<[boolean]>>;
        function hasItemWithType<T0 = any>(client: IotaClient, args: [string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isListed(client: IotaClient, args: [string, object$.ID]): Promise<TypedDevInspectResults<[boolean]>>;
        function isListedExclusively(client: IotaClient, args: [string, object$.ID]): Promise<TypedDevInspectResults<[boolean]>>;
        function isLocked(client: IotaClient, args: [string, object$.ID]): Promise<TypedDevInspectResults<[boolean]>>;
        function itemCount(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function kioskOwnerCapFor(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function list<T0 = any>(client: IotaClient, args: [string, string, object$.ID, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function listWithPurchaseCap<T0 = any>(client: IotaClient, args: [string, string, object$.ID, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[kiosk.PurchaseCap<T0>]>>;
        function lock<T0 = any>(client: IotaClient, args: [string, string, string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function lockInternal<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function new$(client: IotaClient, args: []): Promise<TypedDevInspectResults<[kiosk.Kiosk, kiosk.KioskOwnerCap]>>;
        function owner(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function place<T0 = any>(client: IotaClient, args: [string, string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function placeAndList<T0 = any>(client: IotaClient, args: [string, string, T0, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function placeInternal<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function profitsAmount(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function profitsMut(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[string]>>;
        function purchase<T0 = any>(client: IotaClient, args: [string, object$.ID, coin.Coin<iota.IOTA>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>>;
        function purchaseCapItem<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function purchaseCapKiosk<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function purchaseCapMinPrice<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function purchaseWithCap<T0 = any>(client: IotaClient, args: [string, kiosk.PurchaseCap<T0>, coin.Coin<iota.IOTA>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>>;
        function returnPurchaseCap<T0 = any>(client: IotaClient, args: [string, kiosk.PurchaseCap<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function returnVal<T0 = any>(client: IotaClient, args: [string, T0, kiosk.Borrow], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function setOwner(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[]>>;
        function setOwnerCustom(client: IotaClient, args: [string, string, string]): Promise<TypedDevInspectResults<[]>>;
        function take<T0 = any>(client: IotaClient, args: [string, string, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function uid(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function uidMutAsOwner(client: IotaClient, args: [string, string]): Promise<TypedDevInspectResults<[string]>>;
        function uidMutInternal(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function withdraw(client: IotaClient, args: [string, string, _0x1.option.Option<bigint>]): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>>;
    }
}
export declare namespace kiosk_extension {
    interface Extension {
        storage: bag.Bag;
        permissions: bigint;
        is_enabled: boolean;
    }
    namespace Extension {
        const TYPE_QNAME = "0x2::kiosk_extension::Extension";
        function type(): TypeDescriptor<Extension>;
    }
    interface ExtensionKey<T0> {
        dummy_field: boolean;
    }
    namespace ExtensionKey {
        const TYPE_QNAME = "0x2::kiosk_extension::ExtensionKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ExtensionKey<T0>>;
    }
    type ExtensionKeyInstance = TypedEventInstance<ExtensionKey<any>> & {
        data_decoded: ExtensionKey<any>;
        type_arguments: [string];
    };
    namespace builder {
        function add<T0 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function canLock<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function canPlace<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function disable<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function enable<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function isEnabled<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isInstalled<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function lock<T0 = any, T1 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function place<T0 = any, T1 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            string | TransactionObjectArgument,
            T1 | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function remove<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function storage<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function storageMut<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any>(client: IotaClient, args: [T0, string, string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function canLock<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function canPlace<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function disable<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function enable<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function isEnabled<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isInstalled<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function lock<T0 = any, T1 = any>(client: IotaClient, args: [T0, string, T1, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function place<T0 = any, T1 = any>(client: IotaClient, args: [T0, string, T1, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function remove<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function storage<T0 = any>(client: IotaClient, args: [T0, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function storageMut<T0 = any>(client: IotaClient, args: [T0, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
    }
}
export declare namespace labeler {
    interface LabelerCap<T0> {
        id: object$.UID;
    }
    namespace LabelerCap {
        const TYPE_QNAME = "0x2::labeler::LabelerCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<LabelerCap<T0>>;
    }
    namespace builder {
        function createLabelerCap<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroyLabelerCap<T0 = any>(tx: Transaction, args: [labeler.LabelerCap<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function createLabelerCap<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[labeler.LabelerCap<T0>]>>;
        function destroyLabelerCap<T0 = any>(client: IotaClient, args: [labeler.LabelerCap<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace linked_table {
    interface LinkedTable<T0, T1> {
        id: object$.UID;
        size: bigint;
        head: _0x1.option.Option<T0>;
        tail: _0x1.option.Option<T0>;
    }
    namespace LinkedTable {
        const TYPE_QNAME = "0x2::linked_table::LinkedTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<LinkedTable<T0, T1>>;
    }
    interface Node<T0, T1> {
        prev: _0x1.option.Option<T0>;
        next: _0x1.option.Option<T0>;
        value: T1;
    }
    namespace Node {
        const TYPE_QNAME = "0x2::linked_table::Node";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Node<T0, T1>>;
    }
    namespace builder {
        function back<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any, T1 = any>(tx: Transaction, args: [linked_table.LinkedTable<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function drop<T0 = any, T1 = any>(tx: Transaction, args: [linked_table.LinkedTable<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function front<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function isEmpty<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function length<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any, T1 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [];
        function next<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function popBack<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function popFront<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function prev<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function pushBack<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function pushFront<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function back<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty<T0 = any, T1 = any>(client: IotaClient, args: [linked_table.LinkedTable<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function drop<T0 = any, T1 = any>(client: IotaClient, args: [linked_table.LinkedTable<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function front<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function isEmpty<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$<T0 = any, T1 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[linked_table.LinkedTable<T0, T1>]>>;
        function next<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function popBack<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0, T1]>>;
        function popFront<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0, T1]>>;
        function prev<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function pushBack<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function pushFront<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
    }
}
export declare namespace object$ {
    type ID = string;
    namespace ID {
        const TYPE_QNAME = "0x2::object::ID";
        function type(): TypeDescriptor<ID>;
    }
    interface UID {
        id: object$.ID;
    }
    namespace UID {
        const TYPE_QNAME = "0x2::object::UID";
        function type(): TypeDescriptor<UID>;
    }
    namespace builder {
        function authenticatorState(tx: Transaction, args: []): TransactionArgument & [];
        function borrowId<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function clock(tx: Transaction, args: []): TransactionArgument & [];
        function delete$(tx: Transaction, args: [object$.UID | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function id<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function idAddress<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function idBytes<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function idFromAddress(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function idFromBytes(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function idToAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function idToBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function iotaDenyListObjectId(tx: Transaction, args: []): TransactionArgument & [];
        function new$(tx: Transaction, args: []): TransactionArgument & [];
        function newUidFromHash(tx: Transaction, args: [string | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function randomnessState(tx: Transaction, args: []): TransactionArgument & [];
        function uidAsInner(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function uidToAddress(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function uidToBytes(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function uidToInner(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function authenticatorState(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object$.UID]>>;
        function borrowId<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function clock(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object$.UID]>>;
        function delete$(client: IotaClient, args: [object$.UID]): Promise<TypedDevInspectResults<[]>>;
        function id<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function idAddress<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function idBytes<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[number[]]>>;
        function idFromAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function idFromBytes(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function idToAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function idToBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function iotaDenyListObjectId(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object$.UID]>>;
        function new$(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object$.UID]>>;
        function newUidFromHash(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.UID]>>;
        function randomnessState(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object$.UID]>>;
        function uidAsInner(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function uidToAddress(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function uidToBytes(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function uidToInner(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
    }
}
export declare namespace object_bag {
    interface ObjectBag {
        id: object$.UID;
        size: bigint;
    }
    namespace ObjectBag {
        const TYPE_QNAME = "0x2::object_bag::ObjectBag";
        function type(): TypeDescriptor<ObjectBag>;
    }
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function containsWithType<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty(tx: Transaction, args: [object_bag.ObjectBag | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function isEmpty(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function length(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function new$(tx: Transaction, args: []): TransactionArgument & [];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function valueId<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function containsWithType<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty(client: IotaClient, args: [object_bag.ObjectBag]): Promise<TypedDevInspectResults<[]>>;
        function isEmpty(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$(client: IotaClient, args: []): Promise<TypedDevInspectResults<[object_bag.ObjectBag]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
        function valueId<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>>;
    }
}
export declare namespace object_table {
    interface ObjectTable<T0, T1> {
        id: object$.UID;
        size: bigint;
    }
    namespace ObjectTable {
        const TYPE_QNAME = "0x2::object_table::ObjectTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<ObjectTable<T0, T1>>;
    }
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any, T1 = any>(tx: Transaction, args: [object_table.ObjectTable<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function isEmpty<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function length<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any, T1 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function valueId<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty<T0 = any, T1 = any>(client: IotaClient, args: [object_table.ObjectTable<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function isEmpty<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$<T0 = any, T1 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[object_table.ObjectTable<T0, T1>]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
        function valueId<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>>;
    }
}
export declare namespace package$ {
    interface Publisher {
        id: object$.UID;
        package: _0x1.ascii.String;
        module_name: _0x1.ascii.String;
    }
    namespace Publisher {
        const TYPE_QNAME = "0x2::package::Publisher";
        function type(): TypeDescriptor<Publisher>;
    }
    interface UpgradeCap {
        id: object$.UID;
        package: object$.ID;
        version: bigint;
        policy: number;
    }
    namespace UpgradeCap {
        const TYPE_QNAME = "0x2::package::UpgradeCap";
        function type(): TypeDescriptor<UpgradeCap>;
    }
    interface UpgradeReceipt {
        cap: object$.ID;
        package: object$.ID;
    }
    namespace UpgradeReceipt {
        const TYPE_QNAME = "0x2::package::UpgradeReceipt";
        function type(): TypeDescriptor<UpgradeReceipt>;
    }
    interface UpgradeTicket {
        cap: object$.ID;
        package: object$.ID;
        policy: number;
        digest: number[];
    }
    namespace UpgradeTicket {
        const TYPE_QNAME = "0x2::package::UpgradeTicket";
        function type(): TypeDescriptor<UpgradeTicket>;
    }
    namespace builder {
        function additivePolicy(tx: Transaction, args: []): TransactionArgument & [];
        function authorizeUpgrade(tx: Transaction, args: [
            string | TransactionObjectArgument,
            number | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function burnPublisher(tx: Transaction, args: [package$.Publisher | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function claim<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function claimAndKeep<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function commitUpgrade(tx: Transaction, args: [
            string | TransactionObjectArgument,
            package$.UpgradeReceipt | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function compatiblePolicy(tx: Transaction, args: []): TransactionArgument & [];
        function depOnlyPolicy(tx: Transaction, args: []): TransactionArgument & [];
        function fromModule<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function fromPackage<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function makeImmutable(tx: Transaction, args: [package$.UpgradeCap | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function onlyAdditiveUpgrades(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function onlyDepUpgrades(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function publishedModule(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function publishedPackage(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function receiptCap(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function receiptPackage(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function ticketDigest(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function ticketPackage(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function ticketPolicy(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function upgradePackage(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function upgradePolicy(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function version(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function additivePolicy(client: IotaClient, args: []): Promise<TypedDevInspectResults<[number]>>;
        function authorizeUpgrade(client: IotaClient, args: [string, number, string[]]): Promise<TypedDevInspectResults<[package$.UpgradeTicket]>>;
        function burnPublisher(client: IotaClient, args: [package$.Publisher]): Promise<TypedDevInspectResults<[]>>;
        function claim<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[package$.Publisher]>>;
        function claimAndKeep<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function commitUpgrade(client: IotaClient, args: [string, package$.UpgradeReceipt]): Promise<TypedDevInspectResults<[]>>;
        function compatiblePolicy(client: IotaClient, args: []): Promise<TypedDevInspectResults<[number]>>;
        function depOnlyPolicy(client: IotaClient, args: []): Promise<TypedDevInspectResults<[number]>>;
        function fromModule<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function fromPackage<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function makeImmutable(client: IotaClient, args: [package$.UpgradeCap]): Promise<TypedDevInspectResults<[]>>;
        function onlyAdditiveUpgrades(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[]>>;
        function onlyDepUpgrades(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[]>>;
        function publishedModule(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function publishedPackage(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function receiptCap(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function receiptPackage(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function ticketDigest(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function ticketPackage(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function ticketPolicy(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function upgradePackage(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function upgradePolicy(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function version(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace pay {
    namespace builder {
        function divideAndKeep<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function joinVec<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function joinVecAndTransfer<T0 = any>(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function keep<T0 = any>(tx: Transaction, args: [coin.Coin<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function split<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function splitAndTransfer<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function splitVec<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function divideAndKeep<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function joinVec<T0 = any>(client: IotaClient, args: [string, string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function joinVecAndTransfer<T0 = any>(client: IotaClient, args: [string[], string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function keep<T0 = any>(client: IotaClient, args: [coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function split<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function splitAndTransfer<T0 = any>(client: IotaClient, args: [string, bigint, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function splitVec<T0 = any>(client: IotaClient, args: [string, string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace poseidon {
    namespace builder {
        function poseidonBn254(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function poseidonBn254(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace priority_queue {
    interface Entry<T0> {
        priority: bigint;
        value: T0;
    }
    namespace Entry {
        const TYPE_QNAME = "0x2::priority_queue::Entry";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Entry<T0>>;
    }
    interface PriorityQueue<T0> {
        entries: priority_queue.Entry<T0>[];
    }
    namespace PriorityQueue {
        const TYPE_QNAME = "0x2::priority_queue::PriorityQueue";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<PriorityQueue<T0>>;
    }
    namespace builder {
        function createEntries<T0 = any>(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function insert<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            T0 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function new$<T0 = any>(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function newEntry<T0 = any>(tx: Transaction, args: [bigint | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function popMax<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function priorities<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function createEntries<T0 = any>(client: IotaClient, args: [string[], string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>[]]>>;
        function insert<T0 = any>(client: IotaClient, args: [string, bigint, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function new$<T0 = any>(client: IotaClient, args: [string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[priority_queue.PriorityQueue<T0>]>>;
        function newEntry<T0 = any>(client: IotaClient, args: [bigint, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>]>>;
        function popMax<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint, T0]>>;
        function priorities<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint[]]>>;
    }
}
export declare namespace prover {
    namespace builder { }
    namespace view { }
}
export declare namespace random {
    interface Random {
        id: object$.UID;
        inner: versioned.Versioned;
    }
    namespace Random {
        const TYPE_QNAME = "0x2::random::Random";
        function type(): TypeDescriptor<Random>;
    }
    interface RandomGenerator {
        seed: number[];
        counter: number;
        buffer: number[];
    }
    namespace RandomGenerator {
        const TYPE_QNAME = "0x2::random::RandomGenerator";
        function type(): TypeDescriptor<RandomGenerator>;
    }
    interface RandomInner {
        version: bigint;
        epoch: bigint;
        randomness_round: bigint;
        random_bytes: number[];
    }
    namespace RandomInner {
        const TYPE_QNAME = "0x2::random::RandomInner";
        function type(): TypeDescriptor<RandomInner>;
    }
    namespace builder {
        function generateBool(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateBytes(tx: Transaction, args: [string | TransactionObjectArgument, number | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function generateU128(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU128InRange(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function generateU16(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU16InRange(tx: Transaction, args: [
            string | TransactionObjectArgument,
            number | TransactionArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function generateU256(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU32(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU32InRange(tx: Transaction, args: [
            string | TransactionObjectArgument,
            number | TransactionArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function generateU64(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU64InRange(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function generateU8(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function generateU8InRange(tx: Transaction, args: [
            string | TransactionObjectArgument,
            number | TransactionArgument,
            number | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function newGenerator(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function shuffle<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function generateBool(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[boolean]>>;
        function generateBytes(client: IotaClient, args: [string, number]): Promise<TypedDevInspectResults<[number[]]>>;
        function generateU128(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function generateU128InRange(client: IotaClient, args: [string, bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function generateU16(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function generateU16InRange(client: IotaClient, args: [string, number, number]): Promise<TypedDevInspectResults<[number]>>;
        function generateU256(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function generateU32(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function generateU32InRange(client: IotaClient, args: [string, number, number]): Promise<TypedDevInspectResults<[number]>>;
        function generateU64(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
        function generateU64InRange(client: IotaClient, args: [string, bigint, bigint]): Promise<TypedDevInspectResults<[bigint]>>;
        function generateU8(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number]>>;
        function generateU8InRange(client: IotaClient, args: [string, number, number]): Promise<TypedDevInspectResults<[number]>>;
        function newGenerator(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[random.RandomGenerator]>>;
        function shuffle<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace system_admin_cap {
    interface IotaSystemAdminCap {
        dummy_field: boolean;
    }
    namespace IotaSystemAdminCap {
        const TYPE_QNAME = "0x2::system_admin_cap::IotaSystemAdminCap";
        function type(): TypeDescriptor<IotaSystemAdminCap>;
    }
    namespace builder { }
    namespace view { }
}
export declare namespace table {
    interface Table<T0, T1> {
        id: object$.UID;
        size: bigint;
    }
    namespace Table {
        const TYPE_QNAME = "0x2::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
    namespace builder {
        function add<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function borrow<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function contains<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any, T1 = any>(tx: Transaction, args: [table.Table<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function drop<T0 = any, T1 = any>(tx: Transaction, args: [table.Table<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function isEmpty<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function length<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any, T1 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function add<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function borrow<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function contains<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty<T0 = any, T1 = any>(client: IotaClient, args: [table.Table<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function drop<T0 = any, T1 = any>(client: IotaClient, args: [table.Table<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function isEmpty<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function new$<T0 = any, T1 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[table.Table<T0, T1>]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T1]>>;
    }
}
export declare namespace table_vec {
    interface TableVec<T0> {
        contents: table.Table<bigint, T0>;
    }
    namespace TableVec {
        const TYPE_QNAME = "0x2::table_vec::TableVec";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TableVec<T0>>;
    }
    namespace builder {
        function borrow<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function borrowMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any>(tx: Transaction, args: [table_vec.TableVec<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function drop<T0 = any>(tx: Transaction, args: [table_vec.TableVec<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function empty<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function isEmpty<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function length<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function popBack<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function pushBack<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function singleton<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function swap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function swapRemove<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function borrow<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function borrowMut<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function destroyEmpty<T0 = any>(client: IotaClient, args: [table_vec.TableVec<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function drop<T0 = any>(client: IotaClient, args: [table_vec.TableVec<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function empty<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>>;
        function isEmpty<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function length<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function popBack<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function pushBack<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function singleton<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>>;
        function swap<T0 = any>(client: IotaClient, args: [string, bigint, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function swapRemove<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
    }
}
export declare namespace timelock {
    interface TimeLock<T0> {
        id: object$.UID;
        locked: T0;
        expiration_timestamp_ms: bigint;
        label: _0x1.option.Option<string>;
    }
    namespace TimeLock {
        const TYPE_QNAME = "0x2::timelock::TimeLock";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TimeLock<T0>>;
    }
    namespace builder {
        function expirationTimestampMs<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isLabeledWith<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function isLocked<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isLockedWithClock<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function join<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            timelock.TimeLock<balance.Balance<T0>> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function joinVec<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function label<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function lock<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function lockAndTransfer<T0 = any>(tx: Transaction, args: [
            T0 | TransactionArgument,
            string | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function lockWithLabel<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function lockWithLabelAndTransfer<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            string | TransactionArgument,
            bigint | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function locked<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function remainingTime<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function remainingTimeWithClock<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function split<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function splitBalance<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function systemPack<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            bigint | TransactionArgument,
            _0x1.option.Option<string> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function systemUnpack<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            timelock.TimeLock<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function transferToSender<T0 = any>(tx: Transaction, args: [timelock.TimeLock<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function typeName<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function unlock<T0 = any>(tx: Transaction, args: [timelock.TimeLock<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function unlockWithClock<T0 = any>(tx: Transaction, args: [
            timelock.TimeLock<T0> | TransactionArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function expirationTimestampMs<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function isLabeledWith<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isLocked<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function isLockedWithClock<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function join<T0 = any>(client: IotaClient, args: [string, timelock.TimeLock<balance.Balance<T0>>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function joinVec<T0 = any>(client: IotaClient, args: [string, string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function label<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>>;
        function lock<T0 = any>(client: IotaClient, args: [T0, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>>;
        function lockAndTransfer<T0 = any>(client: IotaClient, args: [T0, string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function lockWithLabel<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, bigint], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>>;
        function lockWithLabelAndTransfer<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, string, bigint], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function locked<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function remainingTime<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function remainingTimeWithClock<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function split<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[timelock.TimeLock<balance.Balance<T0>>]>>;
        function splitBalance<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function systemPack<T0 = any>(client: IotaClient, args: [string, T0, bigint, _0x1.option.Option<string>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>>;
        function systemUnpack<T0 = any>(client: IotaClient, args: [string, timelock.TimeLock<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, bigint, _0x1.option.Option<string>]>>;
        function transferToSender<T0 = any>(client: IotaClient, args: [timelock.TimeLock<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function typeName<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function unlock<T0 = any>(client: IotaClient, args: [timelock.TimeLock<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function unlockWithClock<T0 = any>(client: IotaClient, args: [timelock.TimeLock<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
    }
}
export declare namespace token {
    interface ActionRequest<T0> {
        name: string;
        amount: bigint;
        sender: string;
        recipient: _0x1.option.Option<string>;
        spent_balance: _0x1.option.Option<balance.Balance<T0>>;
        approvals: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace ActionRequest {
        const TYPE_QNAME = "0x2::token::ActionRequest";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ActionRequest<T0>>;
    }
    interface RuleKey<T0> {
        is_protected: boolean;
    }
    namespace RuleKey {
        const TYPE_QNAME = "0x2::token::RuleKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RuleKey<T0>>;
    }
    type RuleKeyInstance = TypedEventInstance<RuleKey<any>> & {
        data_decoded: RuleKey<any>;
        type_arguments: [string];
    };
    interface Token<T0> {
        id: object$.UID;
        balance: balance.Balance<T0>;
    }
    namespace Token {
        const TYPE_QNAME = "0x2::token::Token";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Token<T0>>;
    }
    interface TokenPolicy<T0> {
        id: object$.UID;
        spent_balance: balance.Balance<T0>;
        rules: vec_map.VecMap<string, vec_set.VecSet<_0x1.type_name.TypeName>>;
    }
    namespace TokenPolicy {
        const TYPE_QNAME = "0x2::token::TokenPolicy";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicy<T0>>;
    }
    interface TokenPolicyCap<T0> {
        id: object$.UID;
        for: object$.ID;
    }
    namespace TokenPolicyCap {
        const TYPE_QNAME = "0x2::token::TokenPolicyCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicyCap<T0>>;
    }
    interface TokenPolicyCreated<T0> {
        id: object$.ID;
        is_mutable: boolean;
    }
    namespace TokenPolicyCreated {
        const TYPE_QNAME = "0x2::token::TokenPolicyCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicyCreated<T0>>;
    }
    type TokenPolicyCreatedInstance = TypedEventInstance<TokenPolicyCreated<any>> & {
        data_decoded: TokenPolicyCreated<any>;
        type_arguments: [string];
    };
    namespace builder {
        function action<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function addApproval<T0 = any, T1 = any>(tx: Transaction, args: [T1 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function addRuleConfig<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            T1 | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T2 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function addRuleForAction<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function allow<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function amount<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function approvals<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function burn<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.Token<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function confirmRequest<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.ActionRequest<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function confirmRequestMut<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.ActionRequest<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function confirmWithPolicyCap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.ActionRequest<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function confirmWithTreasuryCap<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.ActionRequest<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyZero<T0 = any>(tx: Transaction, args: [token.Token<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function disallow<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function flush<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function fromCoin<T0 = any>(tx: Transaction, args: [coin.Coin<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function fromCoinAction(tx: Transaction, args: []): TransactionArgument & [];
        function hasRuleConfig<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument];
        function isAllowed<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function join<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            token.Token<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function keep<T0 = any>(tx: Transaction, args: [token.Token<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function mint<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function newPolicy<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function newRequest<T0 = any>(tx: Transaction, args: [
            string | TransactionArgument,
            bigint | TransactionArgument,
            _0x1.option.Option<string> | TransactionArgument,
            _0x1.option.Option<balance.Balance<T0>> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function recipient<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function removeRuleConfig<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function removeRuleForAction<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function ruleConfig<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [T1 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function ruleConfigMut<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            T1 | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function rules<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function sender<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function sharePolicy<T0 = any>(tx: Transaction, args: [token.TokenPolicy<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function spend<T0 = any>(tx: Transaction, args: [token.Token<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function spendAction(tx: Transaction, args: []): TransactionArgument & [];
        function spent<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function spentBalance<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function split<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function toCoin<T0 = any>(tx: Transaction, args: [token.Token<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function toCoinAction(tx: Transaction, args: []): TransactionArgument & [];
        function transfer<T0 = any>(tx: Transaction, args: [
            token.Token<T0> | TransactionArgument,
            string | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function transferAction(tx: Transaction, args: []): TransactionArgument & [];
        function value<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function zero<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
    }
    namespace view {
        function action<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function addApproval<T0 = any, T1 = any>(client: IotaClient, args: [T1, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function addRuleConfig<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [T1, string, string, T2], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[]>>;
        function addRuleForAction<T0 = any, T1 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function allow<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function amount<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function approvals<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>>;
        function burn<T0 = any>(client: IotaClient, args: [string, token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function confirmRequest<T0 = any>(client: IotaClient, args: [string, token.ActionRequest<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            string,
            bigint,
            string,
            _0x1.option.Option<string>
        ]>>;
        function confirmRequestMut<T0 = any>(client: IotaClient, args: [string, token.ActionRequest<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            string,
            bigint,
            string,
            _0x1.option.Option<string>
        ]>>;
        function confirmWithPolicyCap<T0 = any>(client: IotaClient, args: [string, token.ActionRequest<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            string,
            bigint,
            string,
            _0x1.option.Option<string>
        ]>>;
        function confirmWithTreasuryCap<T0 = any>(client: IotaClient, args: [string, token.ActionRequest<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            string,
            bigint,
            string,
            _0x1.option.Option<string>
        ]>>;
        function destroyZero<T0 = any>(client: IotaClient, args: [token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function disallow<T0 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function flush<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function fromCoin<T0 = any>(client: IotaClient, args: [coin.Coin<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.Token<T0>, token.ActionRequest<T0>]>>;
        function fromCoinAction(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function hasRuleConfig<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[boolean]>>;
        function isAllowed<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function join<T0 = any>(client: IotaClient, args: [string, token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function keep<T0 = any>(client: IotaClient, args: [token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function mint<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.Token<T0>]>>;
        function newPolicy<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.TokenPolicy<T0>, token.TokenPolicyCap<T0>]>>;
        function newRequest<T0 = any>(client: IotaClient, args: [
            string,
            bigint,
            _0x1.option.Option<string>,
            _0x1.option.Option<balance.Balance<T0>>
        ], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>>;
        function recipient<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>>;
        function removeRuleConfig<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[T2]>>;
        function removeRuleForAction<T0 = any, T1 = any>(client: IotaClient, args: [string, string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function ruleConfig<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [T1, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[string]>>;
        function ruleConfigMut<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [T1, string, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[string]>>;
        function rules<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>>;
        function sender<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function sharePolicy<T0 = any>(client: IotaClient, args: [token.TokenPolicy<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function spend<T0 = any>(client: IotaClient, args: [token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>>;
        function spendAction(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function spent<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>>;
        function spentBalance<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function split<T0 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.Token<T0>]>>;
        function toCoin<T0 = any>(client: IotaClient, args: [token.Token<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<T0>, token.ActionRequest<T0>]>>;
        function toCoinAction(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function transfer<T0 = any>(client: IotaClient, args: [token.Token<T0>, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>>;
        function transferAction(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function value<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function zero<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[token.Token<T0>]>>;
    }
}
export declare namespace transfer {
    interface Receiving<T0> {
        id: object$.ID;
        version: bigint;
    }
    namespace Receiving {
        const TYPE_QNAME = "0x2::transfer::Receiving";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Receiving<T0>>;
    }
    namespace builder {
        function freezeObject<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function freezeObjectImpl<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function publicFreezeObject<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function publicReceive<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            transfer.Receiving<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function publicShareObject<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function publicTransfer<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function receive<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            transfer.Receiving<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function receivingObjectId<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function shareObject<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function shareObjectImpl<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function transfer<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function transferImpl<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument, string | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function freezeObject<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function freezeObjectImpl<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function publicFreezeObject<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function publicReceive<T0 = any>(client: IotaClient, args: [string, transfer.Receiving<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function publicShareObject<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function publicTransfer<T0 = any>(client: IotaClient, args: [T0, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function receive<T0 = any>(client: IotaClient, args: [string, transfer.Receiving<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function receivingObjectId<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function shareObject<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function shareObjectImpl<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function transfer<T0 = any>(client: IotaClient, args: [T0, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function transferImpl<T0 = any>(client: IotaClient, args: [T0, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace transfer_policy {
    interface RuleKey<T0> {
        dummy_field: boolean;
    }
    namespace RuleKey {
        const TYPE_QNAME = "0x2::transfer_policy::RuleKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RuleKey<T0>>;
    }
    type RuleKeyInstance = TypedEventInstance<RuleKey<any>> & {
        data_decoded: RuleKey<any>;
        type_arguments: [string];
    };
    interface TransferPolicy<T0> {
        id: object$.UID;
        balance: balance.Balance<iota.IOTA>;
        rules: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace TransferPolicy {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicy";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicy<T0>>;
    }
    interface TransferPolicyCap<T0> {
        id: object$.UID;
        policy_id: object$.ID;
    }
    namespace TransferPolicyCap {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyCap<T0>>;
    }
    interface TransferPolicyCreated<T0> {
        id: object$.ID;
    }
    namespace TransferPolicyCreated {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyCreated<T0>>;
    }
    type TransferPolicyCreatedInstance = TypedEventInstance<TransferPolicyCreated<any>> & {
        data_decoded: TransferPolicyCreated<any>;
        type_arguments: [string];
    };
    interface TransferPolicyDestroyed<T0> {
        id: object$.ID;
    }
    namespace TransferPolicyDestroyed {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyDestroyed";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyDestroyed<T0>>;
    }
    type TransferPolicyDestroyedInstance = TypedEventInstance<TransferPolicyDestroyed<any>> & {
        data_decoded: TransferPolicyDestroyed<any>;
        type_arguments: [string];
    };
    interface TransferRequest<T0> {
        item: object$.ID;
        paid: bigint;
        from: object$.ID;
        receipts: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace TransferRequest {
        const TYPE_QNAME = "0x2::transfer_policy::TransferRequest";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferRequest<T0>>;
    }
    namespace builder {
        function addReceipt<T0 = any, T1 = any>(tx: Transaction, args: [T1 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function addRule<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            T1 | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            T2 | TransactionArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function addToBalance<T0 = any, T1 = any>(tx: Transaction, args: [
            T1 | TransactionArgument,
            string | TransactionObjectArgument,
            coin.Coin<iota.IOTA> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function confirmRequest<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            transfer_policy.TransferRequest<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function default$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function destroyAndWithdraw<T0 = any>(tx: Transaction, args: [
            transfer_policy.TransferPolicy<T0> | TransactionArgument,
            transfer_policy.TransferPolicyCap<T0> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function from$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function getRule<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [T1 | TransactionArgument, string | TransactionObjectArgument], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function hasRule<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function item<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function new$<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function newRequest<T0 = any>(tx: Transaction, args: [
            object$.ID | TransactionArgument,
            bigint | TransactionArgument,
            object$.ID | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function paid<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function removeRule<T0 = any, T1 = any, T2 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function rules<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function uid<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function uidMutAsOwner<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function withdraw<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            _0x1.option.Option<bigint> | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function addReceipt<T0 = any, T1 = any>(client: IotaClient, args: [T1, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function addRule<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [T1, string, string, T2], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[]>>;
        function addToBalance<T0 = any, T1 = any>(client: IotaClient, args: [T1, string, coin.Coin<iota.IOTA>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function confirmRequest<T0 = any>(client: IotaClient, args: [string, transfer_policy.TransferRequest<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID, bigint, object$.ID]>>;
        function destroyAndWithdraw<T0 = any>(client: IotaClient, args: [
            transfer_policy.TransferPolicy<T0>,
            transfer_policy.TransferPolicyCap<T0>
        ], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>>;
        function from$<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function getRule<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [T1, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[string]>>;
        function hasRule<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function item<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[object$.ID]>>;
        function new$<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[
            transfer_policy.TransferPolicy<T0>,
            transfer_policy.TransferPolicyCap<T0>
        ]>>;
        function newRequest<T0 = any>(client: IotaClient, args: [object$.ID, bigint, object$.ID], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[transfer_policy.TransferRequest<T0>]>>;
        function paid<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function removeRule<T0 = any, T1 = any, T2 = any>(client: IotaClient, args: [string, string], typeArguments: [
            TypeDescriptor<T0> | string,
            TypeDescriptor<T1> | string,
            TypeDescriptor<T2> | string
        ]): Promise<TypedDevInspectResults<[]>>;
        function rules<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function uid<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function uidMutAsOwner<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function withdraw<T0 = any>(client: IotaClient, args: [string, string, _0x1.option.Option<bigint>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>>;
    }
}
export declare namespace tx_context {
    interface TxContext {
        sender: string;
        tx_hash: number[];
        epoch: bigint;
        epoch_timestamp_ms: bigint;
        ids_created: bigint;
    }
    namespace TxContext {
        const TYPE_QNAME = "0x2::tx_context::TxContext";
        function type(): TypeDescriptor<TxContext>;
    }
    namespace builder {
        function digest(tx: Transaction, args: []): TransactionArgument & [];
        function epoch(tx: Transaction, args: []): TransactionArgument & [];
        function epochTimestampMs(tx: Transaction, args: []): TransactionArgument & [];
        function freshObjectAddress(tx: Transaction, args: []): TransactionArgument & [];
        function sender(tx: Transaction, args: []): TransactionArgument & [];
    }
    namespace view {
        function digest(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function epoch(client: IotaClient, args: []): Promise<TypedDevInspectResults<[bigint]>>;
        function epochTimestampMs(client: IotaClient, args: []): Promise<TypedDevInspectResults<[bigint]>>;
        function freshObjectAddress(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
        function sender(client: IotaClient, args: []): Promise<TypedDevInspectResults<[string]>>;
    }
}
export declare namespace types {
    namespace builder {
        function isOneTimeWitness<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function isOneTimeWitness<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace url {
    interface Url {
        url: _0x1.ascii.String;
    }
    namespace Url {
        const TYPE_QNAME = "0x2::url::Url";
        function type(): TypeDescriptor<Url>;
    }
    type UrlInstance = TypedEventInstance<Url> & {
        data_decoded: Url;
        type_arguments: [];
    };
    namespace builder {
        function innerUrl(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function newUnsafe(tx: Transaction, args: [_0x1.ascii.String | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function newUnsafeFromBytes(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function update(tx: Transaction, args: [
            string | TransactionObjectArgument,
            _0x1.ascii.String | TransactionArgument
        ]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function innerUrl(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[_0x1.ascii.String]>>;
        function newUnsafe(client: IotaClient, args: [_0x1.ascii.String]): Promise<TypedDevInspectResults<[url.Url]>>;
        function newUnsafeFromBytes(client: IotaClient, args: [string[]]): Promise<TypedDevInspectResults<[url.Url]>>;
        function update(client: IotaClient, args: [string, _0x1.ascii.String]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace vdf {
    namespace builder {
        function hashToInput(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function vdfVerify(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function hashToInput(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[number[]]>>;
        function vdfVerify(client: IotaClient, args: [string, string, string, bigint]): Promise<TypedDevInspectResults<[boolean]>>;
    }
}
export declare namespace vec_map {
    interface Entry<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x2::vec_map::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    type EntryInstance = TypedEventInstance<Entry<any, any>> & {
        data_decoded: Entry<any, any>;
        type_arguments: [string, string];
    };
    interface VecMap<T0, T1> {
        contents: vec_map.Entry<T0, T1>[];
    }
    namespace VecMap {
        const TYPE_QNAME = "0x2::vec_map::VecMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<VecMap<T0, T1>>;
    }
    type VecMapInstance = TypedEventInstance<VecMap<any, any>> & {
        data_decoded: VecMap<any, any>;
        type_arguments: [string, string];
    };
    namespace builder {
        function contains<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroyEmpty<T0 = any, T1 = any>(tx: Transaction, args: [vec_map.VecMap<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function empty<T0 = any, T1 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [];
        function fromKeysValues<T0 = any, T1 = any>(tx: Transaction, args: [
            (string | TransactionObjectArgument)[] | TransactionArgument,
            (string | TransactionObjectArgument)[] | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function get<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getEntryByIdx<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getEntryByIdxMut<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getIdx<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getIdxOpt<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function getMut<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function insert<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            T0 | TransactionArgument,
            T1 | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function intoKeysValues<T0 = any, T1 = any>(tx: Transaction, args: [vec_map.VecMap<T0, T1> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function isEmpty<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function keys<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function pop<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function remove<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function removeEntryByIdx<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument, bigint | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function size<T0 = any, T1 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument];
        function tryGet<T0 = any, T1 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function contains<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function destroyEmpty<T0 = any, T1 = any>(client: IotaClient, args: [vec_map.VecMap<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function empty<T0 = any, T1 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>>;
        function fromKeysValues<T0 = any, T1 = any>(client: IotaClient, args: [string[], string[]], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>>;
        function get<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function getEntryByIdx<T0 = any, T1 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string, string]>>;
        function getEntryByIdxMut<T0 = any, T1 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string, string]>>;
        function getIdx<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function getIdxOpt<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>>;
        function getMut<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[string]>>;
        function insert<T0 = any, T1 = any>(client: IotaClient, args: [string, T0, T1], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[]>>;
        function intoKeysValues<T0 = any, T1 = any>(client: IotaClient, args: [vec_map.VecMap<T0, T1>], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0[], T1[]]>>;
        function isEmpty<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function keys<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function pop<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0, T1]>>;
        function remove<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0, T1]>>;
        function removeEntryByIdx<T0 = any, T1 = any>(client: IotaClient, args: [string, bigint], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[T0, T1]>>;
        function size<T0 = any, T1 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[bigint]>>;
        function tryGet<T0 = any, T1 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string]): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>>;
    }
}
export declare namespace vec_set {
    interface VecSet<T0> {
        contents: T0[];
    }
    namespace VecSet {
        const TYPE_QNAME = "0x2::vec_set::VecSet";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VecSet<T0>>;
    }
    type VecSetInstance = TypedEventInstance<VecSet<any>> & {
        data_decoded: VecSet<any>;
        type_arguments: [string];
    };
    namespace builder {
        function contains<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function empty<T0 = any>(tx: Transaction, args: [], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [];
        function fromKeys<T0 = any>(tx: Transaction, args: [(string | TransactionObjectArgument)[] | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function insert<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function intoKeys<T0 = any>(tx: Transaction, args: [vec_set.VecSet<T0> | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function isEmpty<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function keys<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function remove<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            string | TransactionObjectArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function singleton<T0 = any>(tx: Transaction, args: [T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function size<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function contains<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function empty<T0 = any>(client: IotaClient, args: [], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>>;
        function fromKeys<T0 = any>(client: IotaClient, args: [string[]], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>>;
        function insert<T0 = any>(client: IotaClient, args: [string, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function intoKeys<T0 = any>(client: IotaClient, args: [vec_set.VecSet<T0>], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0[]]>>;
        function isEmpty<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[boolean]>>;
        function keys<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function remove<T0 = any>(client: IotaClient, args: [string, string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function singleton<T0 = any>(client: IotaClient, args: [T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>>;
        function size<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace versioned {
    interface VersionChangeCap {
        versioned_id: object$.ID;
        old_version: bigint;
    }
    namespace VersionChangeCap {
        const TYPE_QNAME = "0x2::versioned::VersionChangeCap";
        function type(): TypeDescriptor<VersionChangeCap>;
    }
    interface Versioned {
        id: object$.UID;
        version: bigint;
    }
    namespace Versioned {
        const TYPE_QNAME = "0x2::versioned::Versioned";
        function type(): TypeDescriptor<Versioned>;
    }
    namespace builder {
        function create<T0 = any>(tx: Transaction, args: [bigint | TransactionArgument, T0 | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument, TransactionArgument];
        function destroy<T0 = any>(tx: Transaction, args: [versioned.Versioned | TransactionArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function loadValue<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function loadValueMut<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function removeValueForUpgrade<T0 = any>(tx: Transaction, args: [string | TransactionObjectArgument], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [TransactionArgument];
        function upgrade<T0 = any>(tx: Transaction, args: [
            string | TransactionObjectArgument,
            bigint | TransactionArgument,
            T0 | TransactionArgument,
            versioned.VersionChangeCap | TransactionArgument
        ], typeArguments: [TypeDescriptor<T0> | string]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function version(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
    }
    namespace view {
        function create<T0 = any>(client: IotaClient, args: [bigint, T0], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[versioned.Versioned]>>;
        function destroy<T0 = any>(client: IotaClient, args: [versioned.Versioned], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0]>>;
        function loadValue<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function loadValueMut<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[string]>>;
        function removeValueForUpgrade<T0 = any>(client: IotaClient, args: [string], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[T0, versioned.VersionChangeCap]>>;
        function upgrade<T0 = any>(client: IotaClient, args: [string, bigint, T0, versioned.VersionChangeCap], typeArguments: [TypeDescriptor<T0> | string]): Promise<TypedDevInspectResults<[]>>;
        function version(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[bigint]>>;
    }
}
export declare namespace zklogin_verified_id {
    interface VerifiedID {
        id: object$.UID;
        owner: string;
        key_claim_name: string;
        key_claim_value: string;
        issuer: string;
        audience: string;
    }
    namespace VerifiedID {
        const TYPE_QNAME = "0x2::zklogin_verified_id::VerifiedID";
        function type(): TypeDescriptor<VerifiedID>;
    }
    namespace builder {
        function audience(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function checkZkloginId(tx: Transaction, args: [
            string | TransactionArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            string | TransactionObjectArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function delete$(tx: Transaction, args: [zklogin_verified_id.VerifiedID | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function issuer(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function keyClaimName(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function keyClaimValue(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function owner(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function verifyZkloginId(tx: Transaction, args: [
            string | TransactionArgument,
            string | TransactionArgument,
            string | TransactionArgument,
            string | TransactionArgument,
            bigint | TransactionArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
    }
    namespace view {
        function audience(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function checkZkloginId(client: IotaClient, args: [string, string, string, string, string, bigint]): Promise<TypedDevInspectResults<[boolean]>>;
        function delete$(client: IotaClient, args: [zklogin_verified_id.VerifiedID]): Promise<TypedDevInspectResults<[]>>;
        function issuer(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function keyClaimName(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function keyClaimValue(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function owner(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function verifyZkloginId(client: IotaClient, args: [string, string, string, string, bigint]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare namespace zklogin_verified_issuer {
    interface VerifiedIssuer {
        id: object$.UID;
        owner: string;
        issuer: string;
    }
    namespace VerifiedIssuer {
        const TYPE_QNAME = "0x2::zklogin_verified_issuer::VerifiedIssuer";
        function type(): TypeDescriptor<VerifiedIssuer>;
    }
    namespace builder {
        function checkZkloginIssuer(tx: Transaction, args: [
            string | TransactionArgument,
            bigint | TransactionArgument,
            string | TransactionObjectArgument
        ]): TransactionArgument & [
            TransactionArgument,
            TransactionArgument,
            TransactionArgument
        ];
        function delete$(tx: Transaction, args: [zklogin_verified_issuer.VerifiedIssuer | TransactionArgument]): TransactionArgument & [TransactionArgument];
        function issuer(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function owner(tx: Transaction, args: [string | TransactionObjectArgument]): TransactionArgument & [TransactionArgument];
        function verifyZkloginIssuer(tx: Transaction, args: [bigint | TransactionArgument, string | TransactionArgument]): TransactionArgument & [TransactionArgument, TransactionArgument];
    }
    namespace view {
        function checkZkloginIssuer(client: IotaClient, args: [string, bigint, string]): Promise<TypedDevInspectResults<[boolean]>>;
        function delete$(client: IotaClient, args: [zklogin_verified_issuer.VerifiedIssuer]): Promise<TypedDevInspectResults<[]>>;
        function issuer(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function owner(client: IotaClient, args: [string]): Promise<TypedDevInspectResults<[string]>>;
        function verifyZkloginIssuer(client: IotaClient, args: [bigint, string]): Promise<TypedDevInspectResults<[]>>;
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x2.d.ts.map