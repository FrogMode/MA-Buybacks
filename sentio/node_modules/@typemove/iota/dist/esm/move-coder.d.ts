import { TypedDevInspectResults, TypedEventInstance } from './models.js';
import { AbstractMoveCoder, DecodedStruct, TypeDescriptor, InternalMoveModule } from '@typemove/move';
import { MoveCallIotaTransaction, IotaCallArg, IotaEvent, IotaMoveNormalizedModule, IotaMoveObject, DevInspectResults, IotaClient } from '@iota/iota-sdk/client';
import { dynamic_field } from './builtin/0x2.js';
import { BcsType } from '@iota/iota-sdk/bcs';
export type Encoding = 'base58' | 'base64' | 'hex';
export declare class MoveCoder extends AbstractMoveCoder<IotaMoveNormalizedModule, IotaEvent | IotaMoveObject> {
    constructor(client: IotaClient);
    load(module: IotaMoveNormalizedModule, address: string): InternalMoveModule;
    protected decode(data: any, type: TypeDescriptor): Promise<any>;
    decodeEvent<T>(event: IotaEvent): Promise<TypedEventInstance<T> | undefined>;
    filterAndDecodeEvents<T>(type: TypeDescriptor<T> | string, resources: IotaEvent[]): Promise<TypedEventInstance<T>[]>;
    getDynamicFields<T1, T2>(objects: IotaMoveObject[], keyType?: TypeDescriptor<T1>, valueType?: TypeDescriptor<T2>): Promise<dynamic_field.Field<T1, T2>[]>;
    filterAndDecodeObjects<T>(type: TypeDescriptor<T>, objects: IotaMoveObject[]): Promise<DecodedStruct<IotaMoveObject, T>[]>;
    decodeFunctionPayload(payload: MoveCallIotaTransaction, inputs: IotaCallArg[]): Promise<MoveCallIotaTransaction>;
    private bcsRegistered;
    private bcsRegistry;
    private getBCSTypeWithArgs;
    getBCSType(type: TypeDescriptor): Promise<BcsType<any>>;
    registerBCSTypes(type: TypeDescriptor): Promise<void>;
    decodeBCS(type: TypeDescriptor, data: Uint8Array | string, encoding?: Encoding): Promise<any>;
    decodeDevInspectResult<T extends any[]>(inspectRes: DevInspectResults): Promise<TypedDevInspectResults<T>>;
}
export declare function defaultMoveCoder(endpoint?: string): MoveCoder;
export declare function getMoveCoder(client: IotaClient): Promise<MoveCoder>;
//# sourceMappingURL=move-coder.d.ts.map