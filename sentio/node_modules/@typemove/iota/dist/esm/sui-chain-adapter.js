import { toInternalModule } from './to-internal.js';
import { ChainAdapter, moduleQname, SPLITTER } from '@typemove/move';
import { IotaClient } from '@iota/iota-sdk/client';
export class IotaChainAdapter extends ChainAdapter {
    async getChainId() {
        return this.client.getChainIdentifier();
    }
    // static INSTANCE = new IotaChainAdapter()
    client;
    constructor(client) {
        super();
        this.client = client;
    }
    async fetchModule(account, module
    // network: IotaNetwork
    ) {
        return await this.client.getNormalizedMoveModule({ package: account, module });
    }
    async fetchModules(account
    // network: IotaNetwork
    ) {
        const modules = await this.client.getNormalizedMoveModulesByPackage({
            package: account
        });
        return Object.values(modules);
    }
    getMeaningfulFunctionParams(params) {
        return params;
        // if (params.length === 0) {
        //   return params
        // }
        // return params.slice(0, params.length - 1)
    }
    toInternalModules(modules) {
        return Object.values(modules).map(toInternalModule);
    }
    getAllEventStructs(modules) {
        const eventMap = new Map();
        for (const module of modules) {
            const qname = moduleQname(module);
            for (const struct of module.structs) {
                const abilities = new Set(struct.abilities);
                if (abilities.has('Drop') && abilities.has('Copy')) {
                    eventMap.set(qname + SPLITTER + struct.name, struct);
                }
            }
        }
        return eventMap;
    }
    getType(base) {
        return base.type;
    }
    getData(val) {
        // if (val.parsedJson) {
        //   return val.parsedJson as any
        // }
        if (val === undefined) {
            throw Error('val is undefined');
        }
        if ('parsedJson' in val) {
            return val.parsedJson;
        }
        // if (IotaParsedData.is(val)) {
        //   return val.fields as any
        // }
        if (val.dataType === 'moveObject') {
            return val.fields;
        }
        // if (IotaMoveObject.is(val)) {
        //   return val.fields as any
        // }
        // This may not be perfect, just think everything has
        if ('fields' in val) {
            if ('type' in val && Object.keys(val).length === 2) {
                return val.fields;
            }
        }
        return val;
    }
}
function getRpcClient(endpoint) {
    return new IotaClient({ url: endpoint });
}
//# sourceMappingURL=sui-chain-adapter.js.map