/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x3, original address 0x3 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/iota";

import { defaultMoveCoder } from "@typemove/iota";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/iota";
import {
  Transaction,
  TransactionArgument,
  TransactionObjectArgument,
} from "@iota/iota-sdk/transactions";
import { IotaClient } from "@iota/iota-sdk/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrVec,
  transactionArgumentOrPure,
  transactionArgumentOrPureU8,
  transactionArgumentOrPureU16,
  transactionArgumentOrPureU32,
  transactionArgumentOrPureU64,
  transactionArgumentOrPureU128,
  transactionArgumentOrPureU256,
  transactionArgumentOrPureBool,
  transactionArgumentOrPureString,
  transactionArgumentOrPureAddress,
} from "@typemove/iota";

import * as _0x1 from "./0x1.js";
import * as _0x2 from "./0x2.js";

export namespace genesis {
  export interface GenesisChainParameters {
    protocol_version: bigint;
    chain_start_timestamp_ms: bigint;
    epoch_duration_ms: bigint;
    max_validator_count: bigint;
    min_validator_joining_stake: bigint;
    validator_low_stake_threshold: bigint;
    validator_very_low_stake_threshold: bigint;
    validator_low_stake_grace_period: bigint;
  }

  export namespace GenesisChainParameters {
    export const TYPE_QNAME = "0x3::genesis::GenesisChainParameters";

    const TYPE = new TypeDescriptor<GenesisChainParameters>(
      GenesisChainParameters.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<GenesisChainParameters> {
      return TYPE.apply();
    }
  }

  export type GenesisChainParametersInstance =
    TypedEventInstance<GenesisChainParameters> & {
      data_decoded: GenesisChainParameters;
      type_arguments: [];
    };

  export interface GenesisValidatorMetadata {
    name: number[];
    description: number[];
    image_url: number[];
    project_url: number[];
    iota_address: string;
    gas_price: bigint;
    commission_rate: bigint;
    authority_public_key: number[];
    proof_of_possession: number[];
    network_public_key: number[];
    protocol_public_key: number[];
    network_address: number[];
    p2p_address: number[];
    primary_address: number[];
  }

  export namespace GenesisValidatorMetadata {
    export const TYPE_QNAME = "0x3::genesis::GenesisValidatorMetadata";

    const TYPE = new TypeDescriptor<GenesisValidatorMetadata>(
      GenesisValidatorMetadata.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<GenesisValidatorMetadata> {
      return TYPE.apply();
    }
  }

  export type GenesisValidatorMetadataInstance =
    TypedEventInstance<GenesisValidatorMetadata> & {
      data_decoded: GenesisValidatorMetadata;
      type_arguments: [];
    };

  export interface TokenAllocation {
    recipient_address: string;
    amount_nanos: bigint;
    staked_with_validator: _0x1.option.Option<string>;
    staked_with_timelock_expiration: _0x1.option.Option<bigint>;
  }

  export namespace TokenAllocation {
    export const TYPE_QNAME = "0x3::genesis::TokenAllocation";

    const TYPE = new TypeDescriptor<TokenAllocation>(
      TokenAllocation.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<TokenAllocation> {
      return TYPE.apply();
    }
  }

  export interface TokenDistributionSchedule {
    pre_minted_supply: bigint;
    allocations: genesis.TokenAllocation[];
  }

  export namespace TokenDistributionSchedule {
    export const TYPE_QNAME = "0x3::genesis::TokenDistributionSchedule";

    const TYPE = new TypeDescriptor<TokenDistributionSchedule>(
      TokenDistributionSchedule.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<TokenDistributionSchedule> {
      return TYPE.apply();
    }
  }

  export namespace builder {}
  export namespace view {}
}

export namespace iota_system {
  export interface IotaSystemState {
    id: _0x2.object$.UID;
    version: bigint;
  }

  export namespace IotaSystemState {
    export const TYPE_QNAME = "0x3::iota_system::IotaSystemState";

    const TYPE = new TypeDescriptor<IotaSystemState>(
      IotaSystemState.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<IotaSystemState> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function activeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::active_validator_addresses",
        arguments: _args,
      });
    }
    export function committeeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::committee_validator_addresses",
        arguments: _args,
      });
    }
    export function create(
      tx: Transaction,
      args: [
        _0x2.object$.UID | TransactionArgument,
        _0x2.iota.IotaTreasuryCap | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        iota_system_state_inner.SystemParametersV1 | TransactionArgument,
        _0x2.system_admin_cap.IotaSystemAdminCap | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPureU64(args[5], tx));
      _args.push(transactionArgumentOrPure(args[6], tx));
      _args.push(transactionArgumentOrPure(args[7], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::create",
        arguments: _args,
      });
    }
    export function getTotalIotaSupply(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::get_total_iota_supply",
        arguments: _args,
      });
    }
    export function loadIotaSystemAdminCap(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::load_iota_system_admin_cap",
        arguments: _args,
      });
    }
    export function poolExchangeRates(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::pool_exchange_rates",
        arguments: _args,
      });
    }
    export function reportValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::report_validator",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.coin.Coin<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_add_stake",
        arguments: _args,
      });
    }
    export function requestAddStakeMulCoin(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_add_stake_mul_coin",
        arguments: _args,
      });
    }
    export function requestAddStakeNonEntry(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.coin.Coin<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_add_stake_non_entry",
        arguments: _args,
      });
    }
    export function requestAddValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_add_validator",
        arguments: _args,
      });
    }
    export function requestAddValidatorCandidate(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrVec(args[5], tx));
      _args.push(transactionArgumentOrVec(args[6], tx));
      _args.push(transactionArgumentOrVec(args[7], tx));
      _args.push(transactionArgumentOrVec(args[8], tx));
      _args.push(transactionArgumentOrVec(args[9], tx));
      _args.push(transactionArgumentOrVec(args[10], tx));
      _args.push(transactionArgumentOrVec(args[11], tx));
      _args.push(transactionArgumentOrPureU64(args[12], tx));
      _args.push(transactionArgumentOrPureU64(args[13], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_add_validator_candidate",
        arguments: _args,
      });
    }
    export function requestRemoveValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_remove_validator",
        arguments: _args,
      });
    }
    export function requestRemoveValidatorCandidate(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_remove_validator_candidate",
        arguments: _args,
      });
    }
    export function requestSetCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_set_commission_rate",
        arguments: _args,
      });
    }
    export function requestSetGasPrice(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_set_gas_price",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function requestWithdrawStakeNonEntry(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::request_withdraw_stake_non_entry",
        arguments: _args,
      });
    }
    export function rotateOperationCap(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::rotate_operation_cap",
        arguments: _args,
      });
    }
    export function setCandidateValidatorCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::set_candidate_validator_commission_rate",
        arguments: _args,
      });
    }
    export function setCandidateValidatorGasPrice(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::set_candidate_validator_gas_price",
        arguments: _args,
      });
    }
    export function undoReportValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::undo_report_validator",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_network_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_network_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_p2p_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorPrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_primary_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_candidate_validator_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorDescription(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_description",
        arguments: _args,
      });
    }
    export function updateValidatorImageUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_image_url",
        arguments: _args,
      });
    }
    export function updateValidatorName(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_name",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system::update_validator_next_epoch_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_next_epoch_network_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_next_epoch_network_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_next_epoch_p2p_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochPrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_next_epoch_primary_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_next_epoch_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorProjectUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::update_validator_project_url",
        arguments: _args,
      });
    }
    export function validatorAddressByPoolId(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system::validator_address_by_pool_id",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function activeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.activeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function committeeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.committeeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function create(
      client: IotaClient,
      args: [
        _0x2.object$.UID,
        _0x2.iota.IotaTreasuryCap,
        string[],
        _0x2.balance.Balance<_0x2.iota.IOTA>,
        bigint,
        bigint,
        iota_system_state_inner.SystemParametersV1,
        _0x2.system_admin_cap.IotaSystemAdminCap,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.create(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getTotalIotaSupply(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getTotalIotaSupply(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function loadIotaSystemAdminCap(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.loadIotaSystemAdminCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function poolExchangeRates(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.poolExchangeRates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function reportValidator(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.reportValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [string, _0x2.coin.Coin<_0x2.iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeMulCoin(
      client: IotaClient,
      args: [string, string[], _0x1.option.Option<bigint>, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStakeMulCoin(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeNonEntry(
      client: IotaClient,
      args: [string, _0x2.coin.Coin<_0x2.iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStakeNonEntry(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestAddValidator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddValidatorCandidate(
      client: IotaClient,
      args: [
        string,
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        bigint,
        bigint,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidatorCandidate(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestSetCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestSetCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestSetGasPrice(
      client: IotaClient,
      args: [string, string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestSetGasPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStakeNonEntry(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.requestWithdrawStakeNonEntry(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function rotateOperationCap(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.rotateOperationCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setCandidateValidatorCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setCandidateValidatorCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setCandidateValidatorGasPrice(
      client: IotaClient,
      args: [string, string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setCandidateValidatorGasPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function undoReportValidator(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.undoReportValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorPrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorDescription(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorDescription(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorImageUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorImageUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorName(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochPrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorProjectUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorProjectUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function validatorAddressByPoolId(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.validatorAddressByPoolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace iota_system_state_inner {
  export interface IotaSystemStateV1 {
    epoch: bigint;
    protocol_version: bigint;
    system_state_version: bigint;
    iota_treasury_cap: _0x2.iota.IotaTreasuryCap;
    validators: validator_set.ValidatorSetV1;
    storage_fund: storage_fund.StorageFundV1;
    parameters: iota_system_state_inner.SystemParametersV1;
    iota_system_admin_cap: _0x2.system_admin_cap.IotaSystemAdminCap;
    reference_gas_price: bigint;
    validator_report_records: _0x2.vec_map.VecMap<
      string,
      _0x2.vec_set.VecSet<string>
    >;
    safe_mode: boolean;
    safe_mode_storage_charges: _0x2.balance.Balance<_0x2.iota.IOTA>;
    safe_mode_computation_rewards: _0x2.balance.Balance<_0x2.iota.IOTA>;
    safe_mode_storage_rebates: bigint;
    safe_mode_non_refundable_storage_fee: bigint;
    epoch_start_timestamp_ms: bigint;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace IotaSystemStateV1 {
    export const TYPE_QNAME = "0x3::iota_system_state_inner::IotaSystemStateV1";

    const TYPE = new TypeDescriptor<IotaSystemStateV1>(
      IotaSystemStateV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<IotaSystemStateV1> {
      return TYPE.apply();
    }
  }

  export interface IotaSystemStateV2 {
    epoch: bigint;
    protocol_version: bigint;
    system_state_version: bigint;
    iota_treasury_cap: _0x2.iota.IotaTreasuryCap;
    validators: validator_set.ValidatorSetV2;
    storage_fund: storage_fund.StorageFundV1;
    parameters: iota_system_state_inner.SystemParametersV1;
    iota_system_admin_cap: _0x2.system_admin_cap.IotaSystemAdminCap;
    reference_gas_price: bigint;
    validator_report_records: _0x2.vec_map.VecMap<
      string,
      _0x2.vec_set.VecSet<string>
    >;
    safe_mode: boolean;
    safe_mode_storage_charges: _0x2.balance.Balance<_0x2.iota.IOTA>;
    safe_mode_computation_charges: _0x2.balance.Balance<_0x2.iota.IOTA>;
    safe_mode_computation_charges_burned: bigint;
    safe_mode_storage_rebates: bigint;
    safe_mode_non_refundable_storage_fee: bigint;
    epoch_start_timestamp_ms: bigint;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace IotaSystemStateV2 {
    export const TYPE_QNAME = "0x3::iota_system_state_inner::IotaSystemStateV2";

    const TYPE = new TypeDescriptor<IotaSystemStateV2>(
      IotaSystemStateV2.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<IotaSystemStateV2> {
      return TYPE.apply();
    }
  }

  export interface SystemEpochInfoEventV1 {
    epoch: bigint;
    protocol_version: bigint;
    reference_gas_price: bigint;
    total_stake: bigint;
    storage_charge: bigint;
    storage_rebate: bigint;
    storage_fund_balance: bigint;
    total_gas_fees: bigint;
    total_stake_rewards_distributed: bigint;
    burnt_tokens_amount: bigint;
    minted_tokens_amount: bigint;
  }

  export namespace SystemEpochInfoEventV1 {
    export const TYPE_QNAME =
      "0x3::iota_system_state_inner::SystemEpochInfoEventV1";

    const TYPE = new TypeDescriptor<SystemEpochInfoEventV1>(
      SystemEpochInfoEventV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<SystemEpochInfoEventV1> {
      return TYPE.apply();
    }
  }

  export type SystemEpochInfoEventV1Instance =
    TypedEventInstance<SystemEpochInfoEventV1> & {
      data_decoded: SystemEpochInfoEventV1;
      type_arguments: [];
    };

  export interface SystemEpochInfoEventV2 {
    epoch: bigint;
    protocol_version: bigint;
    total_stake: bigint;
    storage_charge: bigint;
    storage_rebate: bigint;
    storage_fund_balance: bigint;
    total_gas_fees: bigint;
    total_stake_rewards_distributed: bigint;
    burnt_tokens_amount: bigint;
    minted_tokens_amount: bigint;
    tips_amount: bigint;
  }

  export namespace SystemEpochInfoEventV2 {
    export const TYPE_QNAME =
      "0x3::iota_system_state_inner::SystemEpochInfoEventV2";

    const TYPE = new TypeDescriptor<SystemEpochInfoEventV2>(
      SystemEpochInfoEventV2.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<SystemEpochInfoEventV2> {
      return TYPE.apply();
    }
  }

  export type SystemEpochInfoEventV2Instance =
    TypedEventInstance<SystemEpochInfoEventV2> & {
      data_decoded: SystemEpochInfoEventV2;
      type_arguments: [];
    };

  export interface SystemParametersV1 {
    epoch_duration_ms: bigint;
    min_validator_count: bigint;
    max_validator_count: bigint;
    min_validator_joining_stake: bigint;
    validator_low_stake_threshold: bigint;
    validator_very_low_stake_threshold: bigint;
    validator_low_stake_grace_period: bigint;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace SystemParametersV1 {
    export const TYPE_QNAME =
      "0x3::iota_system_state_inner::SystemParametersV1";

    const TYPE = new TypeDescriptor<SystemParametersV1>(
      SystemParametersV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<SystemParametersV1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function activeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::active_validator_addresses",
        arguments: _args,
      });
    }
    export function advanceEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPureU64(args[6], tx));
      _args.push(transactionArgumentOrPureU64(args[7], tx));
      _args.push(transactionArgumentOrPureU64(args[8], tx));
      _args.push(transactionArgumentOrPureU64(args[9], tx));
      _args.push(transactionArgumentOrPureU64(args[10], tx));
      _args.push(transactionArgumentOrPureU64(args[11], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::advance_epoch",
        arguments: _args,
      });
    }
    export function committeeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::committee_validator_addresses",
        arguments: _args,
      });
    }
    export function committeeValidatorVotingPowers(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::committee_validator_voting_powers",
        arguments: _args,
      });
    }
    export function create(
      tx: Transaction,
      args: [
        _0x2.iota.IotaTreasuryCap | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        iota_system_state_inner.SystemParametersV1 | TransactionArgument,
        _0x2.system_admin_cap.IotaSystemAdminCap | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPure(args[6], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::create",
        arguments: _args,
      });
    }
    export function createSystemParameters(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPureU64(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::create_system_parameters",
        arguments: _args,
      });
    }
    export function epoch(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::epoch",
        arguments: _args,
      });
    }
    export function epochStartTimestampMs(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::epoch_start_timestamp_ms",
        arguments: _args,
      });
    }
    export function genesisSystemStateVersion(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::genesis_system_state_version",
        arguments: _args,
      });
    }
    export function getReportersOf(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::get_reporters_of",
        arguments: _args,
      });
    }
    export function getStorageFundObjectRebates(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::get_storage_fund_object_rebates",
        arguments: _args,
      });
    }
    export function getStorageFundTotalBalance(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::get_storage_fund_total_balance",
        arguments: _args,
      });
    }
    export function getTotalIotaSupply(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::get_total_iota_supply",
        arguments: _args,
      });
    }
    export function iotaSystemAdminCap(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::iota_system_admin_cap",
        arguments: _args,
      });
    }
    export function poolExchangeRates(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::pool_exchange_rates",
        arguments: _args,
      });
    }
    export function protocolVersion(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::protocol_version",
        arguments: _args,
      });
    }
    export function reportValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::report_validator",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.coin.Coin<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_add_stake",
        arguments: _args,
      });
    }
    export function requestAddStakeMulCoin(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_add_stake_mul_coin",
        arguments: _args,
      });
    }
    export function requestAddValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_add_validator",
        arguments: _args,
      });
    }
    export function requestAddValidatorCandidate(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrVec(args[5], tx));
      _args.push(transactionArgumentOrVec(args[6], tx));
      _args.push(transactionArgumentOrVec(args[7], tx));
      _args.push(transactionArgumentOrVec(args[8], tx));
      _args.push(transactionArgumentOrVec(args[9], tx));
      _args.push(transactionArgumentOrVec(args[10], tx));
      _args.push(transactionArgumentOrVec(args[11], tx));
      _args.push(transactionArgumentOrPureU64(args[12], tx));
      _args.push(transactionArgumentOrPureU64(args[13], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_add_validator_candidate",
        arguments: _args,
      });
    }
    export function requestRemoveValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_remove_validator",
        arguments: _args,
      });
    }
    export function requestRemoveValidatorCandidate(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::request_remove_validator_candidate",
        arguments: _args,
      });
    }
    export function requestSetCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_set_commission_rate",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function rotateOperationCap(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::rotate_operation_cap",
        arguments: _args,
      });
    }
    export function setCandidateValidatorCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::set_candidate_validator_commission_rate",
        arguments: _args,
      });
    }
    export function systemStateVersion(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::system_state_version",
        arguments: _args,
      });
    }
    export function undoReportValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::undo_report_validator",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_network_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_network_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_p2p_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorPrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_primary_address",
        arguments: _args,
      });
    }
    export function updateCandidateValidatorProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_candidate_validator_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorDescription(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::update_validator_description",
        arguments: _args,
      });
    }
    export function updateValidatorImageUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::update_validator_image_url",
        arguments: _args,
      });
    }
    export function updateValidatorName(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::update_validator_name",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_network_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_network_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_p2p_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochPrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_primary_address",
        arguments: _args,
      });
    }
    export function updateValidatorNextEpochProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::iota_system_state_inner::update_validator_next_epoch_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateValidatorProjectUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::update_validator_project_url",
        arguments: _args,
      });
    }
    export function v1ToV2(
      tx: Transaction,
      args: [iota_system_state_inner.IotaSystemStateV1 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::v1_to_v2",
        arguments: _args,
      });
    }
    export function validatorAddressByPoolId(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::validator_address_by_pool_id",
        arguments: _args,
      });
    }
    export function validatorStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::validator_stake_amount",
        arguments: _args,
      });
    }
    export function validatorStakingPoolId(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::validator_staking_pool_id",
        arguments: _args,
      });
    }
    export function validatorStakingPoolMappings(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::iota_system_state_inner::validator_staking_pool_mappings",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function activeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.activeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function advanceEpoch(
      client: IotaClient,
      args: [
        string,
        bigint,
        bigint,
        bigint,
        _0x2.balance.Balance<_0x2.iota.IOTA>,
        _0x2.balance.Balance<_0x2.iota.IOTA>,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
      ],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.advanceEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function committeeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.committeeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function committeeValidatorVotingPowers(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x2.vec_map.VecMap<string, bigint>]>> {
      const tx = new Transaction();
      builder.committeeValidatorVotingPowers(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.vec_map.VecMap<string, bigint>]
      >(inspectRes);
    }
    export async function create(
      client: IotaClient,
      args: [
        _0x2.iota.IotaTreasuryCap,
        string[],
        _0x2.balance.Balance<_0x2.iota.IOTA>,
        bigint,
        bigint,
        iota_system_state_inner.SystemParametersV1,
        _0x2.system_admin_cap.IotaSystemAdminCap,
      ],
    ): Promise<
      TypedDevInspectResults<[iota_system_state_inner.IotaSystemStateV1]>
    > {
      const tx = new Transaction();
      builder.create(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [iota_system_state_inner.IotaSystemStateV1]
      >(inspectRes);
    }
    export async function createSystemParameters(
      client: IotaClient,
      args: [bigint, bigint, bigint, bigint, bigint, bigint],
    ): Promise<
      TypedDevInspectResults<[iota_system_state_inner.SystemParametersV1]>
    > {
      const tx = new Transaction();
      builder.createSystemParameters(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [iota_system_state_inner.SystemParametersV1]
      >(inspectRes);
    }
    export async function epoch(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.epoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function epochStartTimestampMs(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.epochStartTimestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function genesisSystemStateVersion(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.genesisSystemStateVersion(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getReportersOf(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[_0x2.vec_set.VecSet<string>]>> {
      const tx = new Transaction();
      builder.getReportersOf(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.vec_set.VecSet<string>]
      >(inspectRes);
    }
    export async function getStorageFundObjectRebates(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getStorageFundObjectRebates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getStorageFundTotalBalance(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getStorageFundTotalBalance(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getTotalIotaSupply(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getTotalIotaSupply(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function iotaSystemAdminCap(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.iotaSystemAdminCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function poolExchangeRates(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.poolExchangeRates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function protocolVersion(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.protocolVersion(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function reportValidator(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.reportValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [string, _0x2.coin.Coin<_0x2.iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestAddStakeMulCoin(
      client: IotaClient,
      args: [string, string[], _0x1.option.Option<bigint>, string],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStakeMulCoin(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestAddValidator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddValidatorCandidate(
      client: IotaClient,
      args: [
        string,
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        bigint,
        bigint,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidatorCandidate(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestSetCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestSetCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function rotateOperationCap(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.rotateOperationCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setCandidateValidatorCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setCandidateValidatorCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function systemStateVersion(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.systemStateVersion(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function undoReportValidator(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.undoReportValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorPrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateValidatorProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateValidatorProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorDescription(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorDescription(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorImageUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorImageUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorName(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochPrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorNextEpochProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorNextEpochProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateValidatorProjectUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateValidatorProjectUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function v1ToV2(
      client: IotaClient,
      args: [iota_system_state_inner.IotaSystemStateV1],
    ): Promise<
      TypedDevInspectResults<[iota_system_state_inner.IotaSystemStateV2]>
    > {
      const tx = new Transaction();
      builder.v1ToV2(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [iota_system_state_inner.IotaSystemStateV2]
      >(inspectRes);
    }
    export async function validatorAddressByPoolId(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.validatorAddressByPoolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function validatorStakeAmount(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorStakingPoolId(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.validatorStakingPoolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function validatorStakingPoolMappings(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.validatorStakingPoolMappings(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace staking_pool {
  export interface PoolTokenExchangeRate {
    iota_amount: bigint;
    pool_token_amount: bigint;
  }

  export namespace PoolTokenExchangeRate {
    export const TYPE_QNAME = "0x3::staking_pool::PoolTokenExchangeRate";

    const TYPE = new TypeDescriptor<PoolTokenExchangeRate>(
      PoolTokenExchangeRate.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PoolTokenExchangeRate> {
      return TYPE.apply();
    }
  }

  export type PoolTokenExchangeRateInstance =
    TypedEventInstance<PoolTokenExchangeRate> & {
      data_decoded: PoolTokenExchangeRate;
      type_arguments: [];
    };

  export interface StakedIota {
    id: _0x2.object$.UID;
    pool_id: _0x2.object$.ID;
    stake_activation_epoch: bigint;
    principal: _0x2.balance.Balance<_0x2.iota.IOTA>;
  }

  export namespace StakedIota {
    export const TYPE_QNAME = "0x3::staking_pool::StakedIota";

    const TYPE = new TypeDescriptor<StakedIota>(StakedIota.TYPE_QNAME);

    export function type(): TypeDescriptor<StakedIota> {
      return TYPE.apply();
    }
  }

  export interface StakingPoolV1 {
    id: _0x2.object$.UID;
    activation_epoch: _0x1.option.Option<bigint>;
    deactivation_epoch: _0x1.option.Option<bigint>;
    iota_balance: bigint;
    rewards_pool: _0x2.balance.Balance<_0x2.iota.IOTA>;
    pool_token_balance: bigint;
    exchange_rates: _0x2.table.Table<
      bigint,
      staking_pool.PoolTokenExchangeRate
    >;
    pending_stake: bigint;
    pending_total_iota_withdraw: bigint;
    pending_pool_token_withdraw: bigint;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace StakingPoolV1 {
    export const TYPE_QNAME = "0x3::staking_pool::StakingPoolV1";

    const TYPE = new TypeDescriptor<StakingPoolV1>(StakingPoolV1.TYPE_QNAME);

    export function type(): TypeDescriptor<StakingPoolV1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function activateStakingPool(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::activate_staking_pool",
        arguments: _args,
      });
    }
    export function deactivateStakingPool(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::deactivate_staking_pool",
        arguments: _args,
      });
    }
    export function depositRewards(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::deposit_rewards",
        arguments: _args,
      });
    }
    export function exchangeRates(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::exchange_rates",
        arguments: _args,
      });
    }
    export function iotaAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::iota_amount",
        arguments: _args,
      });
    }
    export function iotaBalance(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::iota_balance",
        arguments: _args,
      });
    }
    export function isEqualStakingMetadata(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::is_equal_staking_metadata",
        arguments: _args,
      });
    }
    export function isInactive(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::is_inactive",
        arguments: _args,
      });
    }
    export function isPreactive(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::is_preactive",
        arguments: _args,
      });
    }
    export function joinStakedIota(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::join_staked_iota",
        arguments: _args,
      });
    }
    export function new$(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::new",
        arguments: _args,
      });
    }
    export function pendingStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::pending_stake_amount",
        arguments: _args,
      });
    }
    export function pendingStakeWithdrawAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::pending_stake_withdraw_amount",
        arguments: _args,
      });
    }
    export function poolId(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::pool_id",
        arguments: _args,
      });
    }
    export function poolTokenAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::pool_token_amount",
        arguments: _args,
      });
    }
    export function poolTokenExchangeRateAtEpoch(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::pool_token_exchange_rate_at_epoch",
        arguments: _args,
      });
    }
    export function processPendingStake(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::process_pending_stake",
        arguments: _args,
      });
    }
    export function processPendingStakeWithdraw(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::process_pending_stake_withdraw",
        arguments: _args,
      });
    }
    export function processPendingStakesAndWithdraws(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::process_pending_stakes_and_withdraws",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::request_add_stake",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function split(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::split",
        arguments: _args,
      });
    }
    export function splitStakedIota(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::split_staked_iota",
        arguments: _args,
      });
    }
    export function stakeActivationEpoch(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::stake_activation_epoch",
        arguments: _args,
      });
    }
    export function stakedIotaAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::staked_iota_amount",
        arguments: _args,
      });
    }
    export function withdrawFromPrincipal(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::staking_pool::withdraw_from_principal",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function activateStakingPool(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.activateStakingPool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function deactivateStakingPool(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.deactivateStakingPool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositRewards(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.depositRewards(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function exchangeRates(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.exchangeRates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function iotaAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.iotaAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function iotaBalance(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.iotaBalance(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isEqualStakingMetadata(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEqualStakingMetadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isInactive(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isInactive(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isPreactive(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPreactive(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function joinStakedIota(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.joinStakedIota(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[staking_pool.StakingPoolV1]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakingPoolV1]
      >(inspectRes);
    }
    export async function pendingStakeAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pendingStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pendingStakeWithdrawAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pendingStakeWithdrawAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function poolId(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.poolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function poolTokenAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.poolTokenAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function poolTokenExchangeRateAtEpoch(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[staking_pool.PoolTokenExchangeRate]>> {
      const tx = new Transaction();
      builder.poolTokenExchangeRateAtEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.PoolTokenExchangeRate]
      >(inspectRes);
    }
    export async function processPendingStake(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processPendingStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function processPendingStakeWithdraw(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processPendingStakeWithdraw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function processPendingStakesAndWithdraws(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processPendingStakesAndWithdraws(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>, bigint],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function split(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.split(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function splitStakedIota(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.splitStakedIota(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function stakeActivationEpoch(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.stakeActivationEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function stakedIotaAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.stakedIotaAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function withdrawFromPrincipal(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<
      TypedDevInspectResults<[bigint, _0x2.balance.Balance<_0x2.iota.IOTA>]>
    > {
      const tx = new Transaction();
      builder.withdrawFromPrincipal(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, _0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
  }
}

export namespace storage_fund {
  export interface StorageFundV1 {
    total_object_storage_rebates: _0x2.balance.Balance<_0x2.iota.IOTA>;
    non_refundable_balance: _0x2.balance.Balance<_0x2.iota.IOTA>;
  }

  export namespace StorageFundV1 {
    export const TYPE_QNAME = "0x3::storage_fund::StorageFundV1";

    const TYPE = new TypeDescriptor<StorageFundV1>(StorageFundV1.TYPE_QNAME);

    export function type(): TypeDescriptor<StorageFundV1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function advanceEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::storage_fund::advance_epoch",
        arguments: _args,
      });
    }
    export function new$(
      tx: Transaction,
      args: [_0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::storage_fund::new",
        arguments: _args,
      });
    }
    export function totalBalance(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::storage_fund::total_balance",
        arguments: _args,
      });
    }
    export function totalObjectStorageRebates(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::storage_fund::total_object_storage_rebates",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function advanceEpoch(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>, bigint, bigint],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.advanceEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function new$(
      client: IotaClient,
      args: [_0x2.balance.Balance<_0x2.iota.IOTA>],
    ): Promise<TypedDevInspectResults<[storage_fund.StorageFundV1]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [storage_fund.StorageFundV1]
      >(inspectRes);
    }
    export async function totalBalance(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalBalance(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function totalObjectStorageRebates(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalObjectStorageRebates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace timelocked_staking {
  export interface TimelockedStakedIota {
    id: _0x2.object$.UID;
    staked_iota: staking_pool.StakedIota;
    expiration_timestamp_ms: bigint;
    label: _0x1.option.Option<string>;
  }

  export namespace TimelockedStakedIota {
    export const TYPE_QNAME = "0x3::timelocked_staking::TimelockedStakedIota";

    const TYPE = new TypeDescriptor<TimelockedStakedIota>(
      TimelockedStakedIota.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<TimelockedStakedIota> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function expirationTimestampMs(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::expiration_timestamp_ms",
        arguments: _args,
      });
    }
    export function isEqualStakingMetadata(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::is_equal_staking_metadata",
        arguments: _args,
      });
    }
    export function isLabeledWith<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::is_labeled_with",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinStakedIota(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        timelocked_staking.TimelockedStakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::join_staked_iota",
        arguments: _args,
      });
    }
    export function label(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::label",
        arguments: _args,
      });
    }
    export function poolId(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::pool_id",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (
          | _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>
          | TransactionArgument
        ),
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_add_stake",
        arguments: _args,
      });
    }
    export function requestAddStakeAtGenesis(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
        _0x1.option.Option<string> | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_add_stake_at_genesis",
        arguments: _args,
      });
    }
    export function requestAddStakeMulBal(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_add_stake_mul_bal",
        arguments: _args,
      });
    }
    export function requestAddStakeMulBalNonEntry(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_add_stake_mul_bal_non_entry",
        arguments: _args,
      });
    }
    export function requestAddStakeNonEntry(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (
          | _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>
          | TransactionArgument
        ),
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_add_stake_non_entry",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        timelocked_staking.TimelockedStakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function requestWithdrawStakeNonEntry(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        timelocked_staking.TimelockedStakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::request_withdraw_stake_non_entry",
        arguments: _args,
      });
    }
    export function split(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::split",
        arguments: _args,
      });
    }
    export function splitStakedIota(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::split_staked_iota",
        arguments: _args,
      });
    }
    export function stakeActivationEpoch(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::stake_activation_epoch",
        arguments: _args,
      });
    }
    export function stakedIotaAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::staked_iota_amount",
        arguments: _args,
      });
    }
    export function transferToSender(
      tx: Transaction,
      args: [timelocked_staking.TimelockedStakedIota | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::transfer_to_sender",
        arguments: _args,
      });
    }
    export function transferToSenderMultiple(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::transfer_to_sender_multiple",
        arguments: _args,
      });
    }
    export function unlock(
      tx: Transaction,
      args: [timelocked_staking.TimelockedStakedIota | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::unlock",
        arguments: _args,
      });
    }
    export function unlockWithClock(
      tx: Transaction,
      args: [
        timelocked_staking.TimelockedStakedIota | TransactionArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::timelocked_staking::unlock_with_clock",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function expirationTimestampMs(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.expirationTimestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isEqualStakingMetadata(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEqualStakingMetadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isLabeledWith<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isLabeledWith(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function joinStakedIota(
      client: IotaClient,
      args: [string, timelocked_staking.TimelockedStakedIota],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.joinStakedIota(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function label(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new Transaction();
      builder.label(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function poolId(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.poolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [
        string,
        _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>,
        string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeAtGenesis(
      client: IotaClient,
      args: [
        string,
        _0x2.balance.Balance<_0x2.iota.IOTA>,
        string,
        bigint,
        _0x1.option.Option<string>,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStakeAtGenesis(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeMulBal(
      client: IotaClient,
      args: [string, string[], string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStakeMulBal(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeMulBalNonEntry(
      client: IotaClient,
      args: [string, string[], string],
    ): Promise<
      TypedDevInspectResults<[timelocked_staking.TimelockedStakedIota[]]>
    > {
      const tx = new Transaction();
      builder.requestAddStakeMulBalNonEntry(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelocked_staking.TimelockedStakedIota[]]
      >(inspectRes);
    }
    export async function requestAddStakeNonEntry(
      client: IotaClient,
      args: [
        string,
        _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>,
        string,
      ],
    ): Promise<
      TypedDevInspectResults<[timelocked_staking.TimelockedStakedIota]>
    > {
      const tx = new Transaction();
      builder.requestAddStakeNonEntry(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelocked_staking.TimelockedStakedIota]
      >(inspectRes);
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, timelocked_staking.TimelockedStakedIota],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStakeNonEntry(
      client: IotaClient,
      args: [string, timelocked_staking.TimelockedStakedIota],
    ): Promise<
      TypedDevInspectResults<
        [
          _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>,
          _0x2.balance.Balance<_0x2.iota.IOTA>,
        ]
      >
    > {
      const tx = new Transaction();
      builder.requestWithdrawStakeNonEntry(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          _0x2.timelock.TimeLock<_0x2.balance.Balance<_0x2.iota.IOTA>>,
          _0x2.balance.Balance<_0x2.iota.IOTA>,
        ]
      >(inspectRes);
    }
    export async function split(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<
      TypedDevInspectResults<[timelocked_staking.TimelockedStakedIota]>
    > {
      const tx = new Transaction();
      builder.split(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelocked_staking.TimelockedStakedIota]
      >(inspectRes);
    }
    export async function splitStakedIota(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.splitStakedIota(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function stakeActivationEpoch(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.stakeActivationEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function stakedIotaAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.stakedIotaAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function transferToSender(
      client: IotaClient,
      args: [timelocked_staking.TimelockedStakedIota],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transferToSender(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transferToSenderMultiple(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transferToSenderMultiple(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function unlock(
      client: IotaClient,
      args: [timelocked_staking.TimelockedStakedIota],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.unlock(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function unlockWithClock(
      client: IotaClient,
      args: [timelocked_staking.TimelockedStakedIota, string],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.unlockWithClock(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
  }
}

export namespace validator {
  export interface StakingRequestEvent {
    pool_id: _0x2.object$.ID;
    validator_address: string;
    staker_address: string;
    epoch: bigint;
    amount: bigint;
  }

  export namespace StakingRequestEvent {
    export const TYPE_QNAME = "0x3::validator::StakingRequestEvent";

    const TYPE = new TypeDescriptor<StakingRequestEvent>(
      StakingRequestEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<StakingRequestEvent> {
      return TYPE.apply();
    }
  }

  export type StakingRequestEventInstance =
    TypedEventInstance<StakingRequestEvent> & {
      data_decoded: StakingRequestEvent;
      type_arguments: [];
    };

  export interface UnstakingRequestEvent {
    pool_id: _0x2.object$.ID;
    validator_address: string;
    staker_address: string;
    stake_activation_epoch: bigint;
    unstaking_epoch: bigint;
    principal_amount: bigint;
    reward_amount: bigint;
  }

  export namespace UnstakingRequestEvent {
    export const TYPE_QNAME = "0x3::validator::UnstakingRequestEvent";

    const TYPE = new TypeDescriptor<UnstakingRequestEvent>(
      UnstakingRequestEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<UnstakingRequestEvent> {
      return TYPE.apply();
    }
  }

  export type UnstakingRequestEventInstance =
    TypedEventInstance<UnstakingRequestEvent> & {
      data_decoded: UnstakingRequestEvent;
      type_arguments: [];
    };

  export interface ValidatorMetadataV1 {
    iota_address: string;
    authority_pubkey_bytes: number[];
    network_pubkey_bytes: number[];
    protocol_pubkey_bytes: number[];
    proof_of_possession: number[];
    name: string;
    description: string;
    image_url: _0x2.url.Url;
    project_url: _0x2.url.Url;
    net_address: string;
    p2p_address: string;
    primary_address: string;
    next_epoch_authority_pubkey_bytes: _0x1.option.Option<number[]>;
    next_epoch_proof_of_possession: _0x1.option.Option<number[]>;
    next_epoch_network_pubkey_bytes: _0x1.option.Option<number[]>;
    next_epoch_protocol_pubkey_bytes: _0x1.option.Option<number[]>;
    next_epoch_net_address: _0x1.option.Option<string>;
    next_epoch_p2p_address: _0x1.option.Option<string>;
    next_epoch_primary_address: _0x1.option.Option<string>;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace ValidatorMetadataV1 {
    export const TYPE_QNAME = "0x3::validator::ValidatorMetadataV1";

    const TYPE = new TypeDescriptor<ValidatorMetadataV1>(
      ValidatorMetadataV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<ValidatorMetadataV1> {
      return TYPE.apply();
    }
  }

  export interface ValidatorV1 {
    metadata: validator.ValidatorMetadataV1;
    voting_power: bigint;
    operation_cap_id: _0x2.object$.ID;
    gas_price: bigint;
    staking_pool: staking_pool.StakingPoolV1;
    commission_rate: bigint;
    next_epoch_stake: bigint;
    next_epoch_gas_price: bigint;
    next_epoch_commission_rate: bigint;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace ValidatorV1 {
    export const TYPE_QNAME = "0x3::validator::ValidatorV1";

    const TYPE = new TypeDescriptor<ValidatorV1>(ValidatorV1.TYPE_QNAME);

    export function type(): TypeDescriptor<ValidatorV1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function activate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::activate",
        arguments: _args,
      });
    }
    export function adjustNextEpochCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::adjust_next_epoch_commission_rate",
        arguments: _args,
      });
    }
    export function authorityPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::authority_pubkey_bytes",
        arguments: _args,
      });
    }
    export function commissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::commission_rate",
        arguments: _args,
      });
    }
    export function deactivate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::deactivate",
        arguments: _args,
      });
    }
    export function depositStakeRewards(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::deposit_stake_rewards",
        arguments: _args,
      });
    }
    export function description(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::description",
        arguments: _args,
      });
    }
    export function effectuateStagedMetadata(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::effectuate_staged_metadata",
        arguments: _args,
      });
    }
    export function gasPrice(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::gas_price",
        arguments: _args,
      });
    }
    export function getStakingPoolRef(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::get_staking_pool_ref",
        arguments: _args,
      });
    }
    export function imageUrl(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::image_url",
        arguments: _args,
      });
    }
    export function iotaAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::iota_address",
        arguments: _args,
      });
    }
    export function isDuplicate(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::is_duplicate",
        arguments: _args,
      });
    }
    export function isPreactive(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::is_preactive",
        arguments: _args,
      });
    }
    export function metadata(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::metadata",
        arguments: _args,
      });
    }
    export function name(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::name",
        arguments: _args,
      });
    }
    export function networkAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::network_address",
        arguments: _args,
      });
    }
    export function networkPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::network_pubkey_bytes",
        arguments: _args,
      });
    }
    export function new$(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrVec(args[5], tx));
      _args.push(transactionArgumentOrVec(args[6], tx));
      _args.push(transactionArgumentOrVec(args[7], tx));
      _args.push(transactionArgumentOrVec(args[8], tx));
      _args.push(transactionArgumentOrVec(args[9], tx));
      _args.push(transactionArgumentOrVec(args[10], tx));
      _args.push(transactionArgumentOrVec(args[11], tx));
      _args.push(transactionArgumentOrPureU64(args[12], tx));
      _args.push(transactionArgumentOrPureU64(args[13], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::new",
        arguments: _args,
      });
    }
    export function newMetadata(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        _0x2.url.Url | TransactionArgument,
        _0x2.url.Url | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        _0x2.bag.Bag | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPure(args[6], tx));
      _args.push(transactionArgumentOrPure(args[7], tx));
      _args.push(transactionArgumentOrPure(args[8], tx));
      _args.push(transactionArgumentOrPure(args[9], tx));
      _args.push(transactionArgumentOrPure(args[10], tx));
      _args.push(transactionArgumentOrPure(args[11], tx));
      _args.push(transactionArgumentOrPure(args[12], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::new_metadata",
        arguments: _args,
      });
    }
    export function newUnverifiedValidatorOperationCapAndTransfer(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::validator::new_unverified_validator_operation_cap_and_transfer",
        arguments: _args,
      });
    }
    export function nextEpochAuthorityPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_authority_pubkey_bytes",
        arguments: _args,
      });
    }
    export function nextEpochGasPrice(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_gas_price",
        arguments: _args,
      });
    }
    export function nextEpochNetworkAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_network_address",
        arguments: _args,
      });
    }
    export function nextEpochNetworkPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_network_pubkey_bytes",
        arguments: _args,
      });
    }
    export function nextEpochP2pAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_p2p_address",
        arguments: _args,
      });
    }
    export function nextEpochPrimaryAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_primary_address",
        arguments: _args,
      });
    }
    export function nextEpochProofOfPossession(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_proof_of_possession",
        arguments: _args,
      });
    }
    export function nextEpochProtocolPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_protocol_pubkey_bytes",
        arguments: _args,
      });
    }
    export function nextEpochStake(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::next_epoch_stake",
        arguments: _args,
      });
    }
    export function operationCapId(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::operation_cap_id",
        arguments: _args,
      });
    }
    export function p2pAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::p2p_address",
        arguments: _args,
      });
    }
    export function pendingStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::pending_stake_amount",
        arguments: _args,
      });
    }
    export function pendingStakeWithdrawAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::pending_stake_withdraw_amount",
        arguments: _args,
      });
    }
    export function poolTokenExchangeRateAtEpoch(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::pool_token_exchange_rate_at_epoch",
        arguments: _args,
      });
    }
    export function primaryAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::primary_address",
        arguments: _args,
      });
    }
    export function processPendingStakesAndWithdraws(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::process_pending_stakes_and_withdraws",
        arguments: _args,
      });
    }
    export function projectUrl(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::project_url",
        arguments: _args,
      });
    }
    export function proofOfPossession(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::proof_of_possession",
        arguments: _args,
      });
    }
    export function protocolPubkeyBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::protocol_pubkey_bytes",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::request_add_stake",
        arguments: _args,
      });
    }
    export function requestAddStakeAtGenesis(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::request_add_stake_at_genesis",
        arguments: _args,
      });
    }
    export function requestAddStakeAtGenesisWithReceipt(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::request_add_stake_at_genesis_with_receipt",
        arguments: _args,
      });
    }
    export function requestSetCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::request_set_commission_rate",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function setCandidateCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::set_candidate_commission_rate",
        arguments: _args,
      });
    }
    export function setVotingPower(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::set_voting_power",
        arguments: _args,
      });
    }
    export function smallerThan(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::smaller_than",
        arguments: _args,
      });
    }
    export function stakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::stake_amount",
        arguments: _args,
      });
    }
    export function stakingPoolId(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::staking_pool_id",
        arguments: _args,
      });
    }
    export function totalStake(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::total_stake",
        arguments: _args,
      });
    }
    export function totalStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::total_stake_amount",
        arguments: _args,
      });
    }
    export function updateCandidateAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_network_address",
        arguments: _args,
      });
    }
    export function updateCandidateNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_network_pubkey",
        arguments: _args,
      });
    }
    export function updateCandidateP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_p2p_address",
        arguments: _args,
      });
    }
    export function updateCandidatePrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_primary_address",
        arguments: _args,
      });
    }
    export function updateCandidateProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_candidate_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateDescription(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_description",
        arguments: _args,
      });
    }
    export function updateImageUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_image_url",
        arguments: _args,
      });
    }
    export function updateName(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_name",
        arguments: _args,
      });
    }
    export function updateNextEpochAuthorityPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_authority_pubkey",
        arguments: _args,
      });
    }
    export function updateNextEpochNetworkAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_network_address",
        arguments: _args,
      });
    }
    export function updateNextEpochNetworkPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_network_pubkey",
        arguments: _args,
      });
    }
    export function updateNextEpochP2pAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_p2p_address",
        arguments: _args,
      });
    }
    export function updateNextEpochPrimaryAddress(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_primary_address",
        arguments: _args,
      });
    }
    export function updateNextEpochProtocolPubkey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_next_epoch_protocol_pubkey",
        arguments: _args,
      });
    }
    export function updateProjectUrl(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::update_project_url",
        arguments: _args,
      });
    }
    export function validateMetadata(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::validate_metadata",
        arguments: _args,
      });
    }
    export function validateMetadataBcs(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::validate_metadata_bcs",
        arguments: _args,
      });
    }
    export function votingPower(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator::voting_power",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function activate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.activate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function adjustNextEpochCommissionRate(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.adjustNextEpochCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function authorityPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.authorityPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function commissionRate(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.commissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function deactivate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.deactivate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositStakeRewards(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.depositStakeRewards(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function description(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.description(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function effectuateStagedMetadata(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.effectuateStagedMetadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function gasPrice(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.gasPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getStakingPoolRef(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getStakingPoolRef(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function imageUrl(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.imageUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function iotaAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.iotaAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isDuplicate(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isDuplicate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isPreactive(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPreactive(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function metadata(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.metadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function name(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.name(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function networkAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.networkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function networkPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.networkPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [
        string,
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        string[],
        bigint,
        bigint,
      ],
    ): Promise<TypedDevInspectResults<[validator.ValidatorV1]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator.ValidatorV1]
      >(inspectRes);
    }
    export async function newMetadata(
      client: IotaClient,
      args: [
        string,
        string[],
        string[],
        string[],
        string[],
        string,
        string,
        _0x2.url.Url,
        _0x2.url.Url,
        string,
        string,
        string,
        _0x2.bag.Bag,
      ],
    ): Promise<TypedDevInspectResults<[validator.ValidatorMetadataV1]>> {
      const tx = new Transaction();
      builder.newMetadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator.ValidatorMetadataV1]
      >(inspectRes);
    }
    export async function newUnverifiedValidatorOperationCapAndTransfer(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.newUnverifiedValidatorOperationCapAndTransfer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function nextEpochAuthorityPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochAuthorityPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochGasPrice(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.nextEpochGasPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function nextEpochNetworkAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochNetworkPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochNetworkPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochP2pAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochPrimaryAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochProofOfPossession(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochProofOfPossession(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochProtocolPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.nextEpochProtocolPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function nextEpochStake(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.nextEpochStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function operationCapId(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.operationCapId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function p2pAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.p2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function pendingStakeAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pendingStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pendingStakeWithdrawAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pendingStakeWithdrawAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function poolTokenExchangeRateAtEpoch(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[staking_pool.PoolTokenExchangeRate]>> {
      const tx = new Transaction();
      builder.poolTokenExchangeRateAtEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.PoolTokenExchangeRate]
      >(inspectRes);
    }
    export async function primaryAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.primaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function processPendingStakesAndWithdraws(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processPendingStakesAndWithdraws(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function projectUrl(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.projectUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function proofOfPossession(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.proofOfPossession(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function protocolPubkeyBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.protocolPubkeyBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestAddStakeAtGenesis(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddStakeAtGenesis(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStakeAtGenesisWithReceipt(
      client: IotaClient,
      args: [string, _0x2.balance.Balance<_0x2.iota.IOTA>],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStakeAtGenesisWithReceipt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestSetCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestSetCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function setCandidateCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setCandidateCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setVotingPower(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setVotingPower(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function smallerThan(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.smallerThan(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function stakeAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.stakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function stakingPoolId(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.stakingPoolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function totalStake(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function totalStakeAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function updateCandidateAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidatePrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidatePrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateCandidateProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateCandidateProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateDescription(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateDescription(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateImageUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateImageUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateName(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochAuthorityPubkey(
      client: IotaClient,
      args: [string, string[], string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochAuthorityPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochNetworkAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochNetworkAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochNetworkPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochNetworkPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochP2pAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochP2pAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochPrimaryAddress(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochPrimaryAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateNextEpochProtocolPubkey(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateNextEpochProtocolPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateProjectUrl(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateProjectUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function validateMetadata(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.validateMetadata(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function validateMetadataBcs(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.validateMetadataBcs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function votingPower(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.votingPower(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace validator_cap {
  export interface UnverifiedValidatorOperationCap {
    id: _0x2.object$.UID;
    authorizer_validator_address: string;
  }

  export namespace UnverifiedValidatorOperationCap {
    export const TYPE_QNAME =
      "0x3::validator_cap::UnverifiedValidatorOperationCap";

    const TYPE = new TypeDescriptor<UnverifiedValidatorOperationCap>(
      UnverifiedValidatorOperationCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<UnverifiedValidatorOperationCap> {
      return TYPE.apply();
    }
  }

  export interface ValidatorOperationCap {
    authorizer_validator_address: string;
  }

  export namespace ValidatorOperationCap {
    export const TYPE_QNAME = "0x3::validator_cap::ValidatorOperationCap";

    const TYPE = new TypeDescriptor<ValidatorOperationCap>(
      ValidatorOperationCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<ValidatorOperationCap> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function newFromUnverified(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_cap::new_from_unverified",
        arguments: _args,
      });
    }
    export function newUnverifiedValidatorOperationCapAndTransfer(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::validator_cap::new_unverified_validator_operation_cap_and_transfer",
        arguments: _args,
      });
    }
    export function unverifiedOperationCapAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_cap::unverified_operation_cap_address",
        arguments: _args,
      });
    }
    export function verifiedOperationCapAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_cap::verified_operation_cap_address",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function newFromUnverified(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[validator_cap.ValidatorOperationCap]>> {
      const tx = new Transaction();
      builder.newFromUnverified(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator_cap.ValidatorOperationCap]
      >(inspectRes);
    }
    export async function newUnverifiedValidatorOperationCapAndTransfer(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.newUnverifiedValidatorOperationCapAndTransfer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function unverifiedOperationCapAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.unverifiedOperationCapAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function verifiedOperationCapAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.verifiedOperationCapAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace validator_set {
  export interface CommitteeValidatorJoinEvent {
    epoch: bigint;
    validator_address: string;
    staking_pool_id: _0x2.object$.ID;
  }

  export namespace CommitteeValidatorJoinEvent {
    export const TYPE_QNAME = "0x3::validator_set::CommitteeValidatorJoinEvent";

    const TYPE = new TypeDescriptor<CommitteeValidatorJoinEvent>(
      CommitteeValidatorJoinEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<CommitteeValidatorJoinEvent> {
      return TYPE.apply();
    }
  }

  export type CommitteeValidatorJoinEventInstance =
    TypedEventInstance<CommitteeValidatorJoinEvent> & {
      data_decoded: CommitteeValidatorJoinEvent;
      type_arguments: [];
    };

  export interface CommitteeValidatorLeaveEvent {
    epoch: bigint;
    validator_address: string;
    staking_pool_id: _0x2.object$.ID;
  }

  export namespace CommitteeValidatorLeaveEvent {
    export const TYPE_QNAME =
      "0x3::validator_set::CommitteeValidatorLeaveEvent";

    const TYPE = new TypeDescriptor<CommitteeValidatorLeaveEvent>(
      CommitteeValidatorLeaveEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<CommitteeValidatorLeaveEvent> {
      return TYPE.apply();
    }
  }

  export type CommitteeValidatorLeaveEventInstance =
    TypedEventInstance<CommitteeValidatorLeaveEvent> & {
      data_decoded: CommitteeValidatorLeaveEvent;
      type_arguments: [];
    };

  export interface ValidatorEpochInfoEventV1 {
    epoch: bigint;
    validator_address: string;
    reference_gas_survey_quote: bigint;
    stake: bigint;
    voting_power: bigint;
    commission_rate: bigint;
    pool_staking_reward: bigint;
    pool_token_exchange_rate: staking_pool.PoolTokenExchangeRate;
    tallying_rule_reporters: string[];
    tallying_rule_global_score: bigint;
  }

  export namespace ValidatorEpochInfoEventV1 {
    export const TYPE_QNAME = "0x3::validator_set::ValidatorEpochInfoEventV1";

    const TYPE = new TypeDescriptor<ValidatorEpochInfoEventV1>(
      ValidatorEpochInfoEventV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<ValidatorEpochInfoEventV1> {
      return TYPE.apply();
    }
  }

  export type ValidatorEpochInfoEventV1Instance =
    TypedEventInstance<ValidatorEpochInfoEventV1> & {
      data_decoded: ValidatorEpochInfoEventV1;
      type_arguments: [];
    };

  export interface ValidatorJoinEvent {
    epoch: bigint;
    validator_address: string;
    staking_pool_id: _0x2.object$.ID;
  }

  export namespace ValidatorJoinEvent {
    export const TYPE_QNAME = "0x3::validator_set::ValidatorJoinEvent";

    const TYPE = new TypeDescriptor<ValidatorJoinEvent>(
      ValidatorJoinEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<ValidatorJoinEvent> {
      return TYPE.apply();
    }
  }

  export type ValidatorJoinEventInstance =
    TypedEventInstance<ValidatorJoinEvent> & {
      data_decoded: ValidatorJoinEvent;
      type_arguments: [];
    };

  export interface ValidatorLeaveEvent {
    epoch: bigint;
    validator_address: string;
    staking_pool_id: _0x2.object$.ID;
    is_voluntary: boolean;
  }

  export namespace ValidatorLeaveEvent {
    export const TYPE_QNAME = "0x3::validator_set::ValidatorLeaveEvent";

    const TYPE = new TypeDescriptor<ValidatorLeaveEvent>(
      ValidatorLeaveEvent.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<ValidatorLeaveEvent> {
      return TYPE.apply();
    }
  }

  export type ValidatorLeaveEventInstance =
    TypedEventInstance<ValidatorLeaveEvent> & {
      data_decoded: ValidatorLeaveEvent;
      type_arguments: [];
    };

  export interface ValidatorSetV1 {
    total_stake: bigint;
    active_validators: validator.ValidatorV1[];
    pending_active_validators: _0x2.table_vec.TableVec<validator.ValidatorV1>;
    pending_removals: bigint[];
    staking_pool_mappings: _0x2.table.Table<_0x2.object$.ID, string>;
    inactive_validators: _0x2.table.Table<
      _0x2.object$.ID,
      validator_wrapper.Validator
    >;
    validator_candidates: _0x2.table.Table<string, validator_wrapper.Validator>;
    at_risk_validators: _0x2.vec_map.VecMap<string, bigint>;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace ValidatorSetV1 {
    export const TYPE_QNAME = "0x3::validator_set::ValidatorSetV1";

    const TYPE = new TypeDescriptor<ValidatorSetV1>(ValidatorSetV1.TYPE_QNAME);

    export function type(): TypeDescriptor<ValidatorSetV1> {
      return TYPE.apply();
    }
  }

  export interface ValidatorSetV2 {
    total_stake: bigint;
    active_validators: validator.ValidatorV1[];
    committee_members: bigint[];
    pending_active_validators: _0x2.table_vec.TableVec<validator.ValidatorV1>;
    pending_removals: bigint[];
    staking_pool_mappings: _0x2.table.Table<_0x2.object$.ID, string>;
    inactive_validators: _0x2.table.Table<
      _0x2.object$.ID,
      validator_wrapper.Validator
    >;
    validator_candidates: _0x2.table.Table<string, validator_wrapper.Validator>;
    at_risk_validators: _0x2.vec_map.VecMap<string, bigint>;
    extra_fields: _0x2.bag.Bag;
  }

  export namespace ValidatorSetV2 {
    export const TYPE_QNAME = "0x3::validator_set::ValidatorSetV2";

    const TYPE = new TypeDescriptor<ValidatorSetV2>(ValidatorSetV2.TYPE_QNAME);

    export function type(): TypeDescriptor<ValidatorSetV2> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function activeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::active_validator_addresses",
        arguments: _args,
      });
    }
    export function activeValidators(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::active_validators",
        arguments: _args,
      });
    }
    export function activeValidatorsInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::active_validators_inner",
        arguments: _args,
      });
    }
    export function advanceEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));
      _args.push(transactionArgumentOrPureU64(args[4], tx));
      _args.push(transactionArgumentOrPureU64(args[5], tx));
      _args.push(transactionArgumentOrPureU64(args[6], tx));
      _args.push(transactionArgumentOrPureU64(args[7], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::advance_epoch",
        arguments: _args,
      });
    }
    export function assertNoPendingOrActiveDuplicates(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::assert_no_pending_or_active_duplicates",
        arguments: _args,
      });
    }
    export function committeeValidatorAddresses(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::committee_validator_addresses",
        arguments: _args,
      });
    }
    export function deriveReferenceGasPrice(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::derive_reference_gas_price",
        arguments: _args,
      });
    }
    export function getActiveOrPendingOrCandidateValidatorRef(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));
      _args.push(transactionArgumentOrPureU8(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::validator_set::get_active_or_pending_or_candidate_validator_ref",
        arguments: _args,
      });
    }
    export function getActiveValidatorRef(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_active_validator_ref",
        arguments: _args,
      });
    }
    export function getActiveValidatorRefInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_active_validator_ref_inner",
        arguments: _args,
      });
    }
    export function getCommitteeValidatorRefInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_committee_validator_ref_inner",
        arguments: _args,
      });
    }
    export function getPendingValidatorRef(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_pending_validator_ref",
        arguments: _args,
      });
    }
    export function getPendingValidatorRefInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_pending_validator_ref_inner",
        arguments: _args,
      });
    }
    export function getValidatorMut(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_validator_mut",
        arguments: _args,
      });
    }
    export function getValidatorMutWithCtx(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_validator_mut_with_ctx",
        arguments: _args,
      });
    }
    export function getValidatorMutWithCtxIncludingCandidates(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target:
          "0x3::validator_set::get_validator_mut_with_ctx_including_candidates",
        arguments: _args,
      });
    }
    export function getValidatorMutWithVerifiedCap(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        boolean | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureBool(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::get_validator_mut_with_verified_cap",
        arguments: _args,
      });
    }
    export function isActiveValidatorByIotaAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_active_validator_by_iota_address",
        arguments: _args,
      });
    }
    export function isCommitteeValidatorByIotaAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_committee_validator_by_iota_address",
        arguments: _args,
      });
    }
    export function isDuplicateValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_duplicate_validator",
        arguments: _args,
      });
    }
    export function isInactiveValidator(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_inactive_validator",
        arguments: _args,
      });
    }
    export function isInactiveValidatorInner(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x2.object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_inactive_validator_inner",
        arguments: _args,
      });
    }
    export function isValidatorCandidate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_validator_candidate",
        arguments: _args,
      });
    }
    export function isValidatorCandidateInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::is_validator_candidate_inner",
        arguments: _args,
      });
    }
    export function newV1(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::new_v1",
        arguments: _args,
      });
    }
    export function nextEpochValidatorCount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::next_epoch_validator_count",
        arguments: _args,
      });
    }
    export function poolExchangeRates(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::pool_exchange_rates",
        arguments: _args,
      });
    }
    export function processNewCommittee(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::process_new_committee",
        arguments: _args,
      });
    }
    export function requestAddStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionArgument,
        _0x2.balance.Balance<_0x2.iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_add_stake",
        arguments: _args,
      });
    }
    export function requestAddValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_add_validator",
        arguments: _args,
      });
    }
    export function requestAddValidatorCandidate(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        validator.ValidatorV1 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_add_validator_candidate",
        arguments: _args,
      });
    }
    export function requestRemoveValidator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_remove_validator",
        arguments: _args,
      });
    }
    export function requestRemoveValidatorCandidate(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_remove_validator_candidate",
        arguments: _args,
      });
    }
    export function requestSetCommissionRate(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_set_commission_rate",
        arguments: _args,
      });
    }
    export function requestWithdrawStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        staking_pool.StakedIota | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::request_withdraw_stake",
        arguments: _args,
      });
    }
    export function selectCommitteeMembersTopNStakers(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::select_committee_members_top_n_stakers",
        arguments: _args,
      });
    }
    export function stakingPoolMappings(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::staking_pool_mappings",
        arguments: _args,
      });
    }
    export function stakingPoolMappingsInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::staking_pool_mappings_inner",
        arguments: _args,
      });
    }
    export function sumCommitteeVotingPowerByAddresses(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::sum_committee_voting_power_by_addresses",
        arguments: _args,
      });
    }
    export function sumVotingPowerByAddresses(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::sum_voting_power_by_addresses",
        arguments: _args,
      });
    }
    export function totalStake(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::total_stake",
        arguments: _args,
      });
    }
    export function totalStakeInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::total_stake_inner",
        arguments: _args,
      });
    }
    export function v1ToV2(
      tx: Transaction,
      args: [validator_set.ValidatorSetV1 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::v1_to_v2",
        arguments: _args,
      });
    }
    export function validatorAddressByPoolIdInner(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_address_by_pool_id_inner",
        arguments: _args,
      });
    }
    export function validatorStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_stake_amount",
        arguments: _args,
      });
    }
    export function validatorStakeAmountInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_stake_amount_inner",
        arguments: _args,
      });
    }
    export function validatorStakingPoolId(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_staking_pool_id",
        arguments: _args,
      });
    }
    export function validatorStakingPoolIdInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_staking_pool_id_inner",
        arguments: _args,
      });
    }
    export function validatorTotalStakeAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_total_stake_amount",
        arguments: _args,
      });
    }
    export function validatorTotalStakeAmountInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_total_stake_amount_inner",
        arguments: _args,
      });
    }
    export function validatorVotingPower(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_voting_power",
        arguments: _args,
      });
    }
    export function validatorVotingPowerInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::validator_voting_power_inner",
        arguments: _args,
      });
    }
    export function verifyCap(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU8(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_set::verify_cap",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function activeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.activeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function activeValidators(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.activeValidators(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function activeValidatorsInner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.activeValidatorsInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function advanceEpoch(
      client: IotaClient,
      args: [string, string, string, bigint, bigint, bigint, bigint, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.advanceEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function assertNoPendingOrActiveDuplicates(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.assertNoPendingOrActiveDuplicates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function committeeValidatorAddresses(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.committeeValidatorAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function deriveReferenceGasPrice(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.deriveReferenceGasPrice(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getActiveOrPendingOrCandidateValidatorRef(
      client: IotaClient,
      args: [string, string, number],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getActiveOrPendingOrCandidateValidatorRef(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getActiveValidatorRef(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getActiveValidatorRef(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getActiveValidatorRefInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getActiveValidatorRefInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getCommitteeValidatorRefInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getCommitteeValidatorRefInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getPendingValidatorRef(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getPendingValidatorRef(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getPendingValidatorRefInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getPendingValidatorRefInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getValidatorMut(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getValidatorMut(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getValidatorMutWithCtx(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getValidatorMutWithCtx(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getValidatorMutWithCtxIncludingCandidates(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getValidatorMutWithCtxIncludingCandidates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getValidatorMutWithVerifiedCap(
      client: IotaClient,
      args: [string, string, boolean],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getValidatorMutWithVerifiedCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isActiveValidatorByIotaAddress(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isActiveValidatorByIotaAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isCommitteeValidatorByIotaAddress(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isCommitteeValidatorByIotaAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isDuplicateValidator(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isDuplicateValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isInactiveValidator(
      client: IotaClient,
      args: [string, _0x2.object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isInactiveValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isInactiveValidatorInner(
      client: IotaClient,
      args: [string, _0x2.object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isInactiveValidatorInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isValidatorCandidate(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isValidatorCandidateInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isValidatorCandidateInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function newV1(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[validator_set.ValidatorSetV1]>> {
      const tx = new Transaction();
      builder.newV1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator_set.ValidatorSetV1]
      >(inspectRes);
    }
    export async function nextEpochValidatorCount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.nextEpochValidatorCount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function poolExchangeRates(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.poolExchangeRates(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function processNewCommittee(
      client: IotaClient,
      args: [string, bigint, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.processNewCommittee(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddStake(
      client: IotaClient,
      args: [string, string, _0x2.balance.Balance<_0x2.iota.IOTA>],
    ): Promise<TypedDevInspectResults<[staking_pool.StakedIota]>> {
      const tx = new Transaction();
      builder.requestAddStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [staking_pool.StakedIota]
      >(inspectRes);
    }
    export async function requestAddValidator(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestAddValidatorCandidate(
      client: IotaClient,
      args: [string, validator.ValidatorV1],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestAddValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestRemoveValidatorCandidate(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestRemoveValidatorCandidate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestSetCommissionRate(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.requestSetCommissionRate(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function requestWithdrawStake(
      client: IotaClient,
      args: [string, staking_pool.StakedIota],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<_0x2.iota.IOTA>]>> {
      const tx = new Transaction();
      builder.requestWithdrawStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<_0x2.iota.IOTA>]
      >(inspectRes);
    }
    export async function selectCommitteeMembersTopNStakers(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new Transaction();
      builder.selectCommitteeMembersTopNStakers(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function stakingPoolMappings(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.stakingPoolMappings(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function stakingPoolMappingsInner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.stakingPoolMappingsInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function sumCommitteeVotingPowerByAddresses(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sumCommitteeVotingPowerByAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sumVotingPowerByAddresses(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sumVotingPowerByAddresses(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function totalStake(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function totalStakeInner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalStakeInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function v1ToV2(
      client: IotaClient,
      args: [validator_set.ValidatorSetV1],
    ): Promise<TypedDevInspectResults<[validator_set.ValidatorSetV2]>> {
      const tx = new Transaction();
      builder.v1ToV2(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator_set.ValidatorSetV2]
      >(inspectRes);
    }
    export async function validatorAddressByPoolIdInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.validatorAddressByPoolIdInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function validatorStakeAmount(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorStakeAmountInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorStakeAmountInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorStakingPoolId(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.validatorStakingPoolId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function validatorStakingPoolIdInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[_0x2.object$.ID]>> {
      const tx = new Transaction();
      builder.validatorStakingPoolIdInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.object$.ID]
      >(inspectRes);
    }
    export async function validatorTotalStakeAmount(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorTotalStakeAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorTotalStakeAmountInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorTotalStakeAmountInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorVotingPower(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorVotingPower(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function validatorVotingPowerInner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.validatorVotingPowerInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function verifyCap(
      client: IotaClient,
      args: [string, string, number],
    ): Promise<TypedDevInspectResults<[validator_cap.ValidatorOperationCap]>> {
      const tx = new Transaction();
      builder.verifyCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator_cap.ValidatorOperationCap]
      >(inspectRes);
    }
  }
}

export namespace validator_wrapper {
  export interface Validator {
    inner: _0x2.versioned.Versioned;
  }

  export namespace Validator {
    export const TYPE_QNAME = "0x3::validator_wrapper::Validator";

    const TYPE = new TypeDescriptor<Validator>(Validator.TYPE_QNAME);

    export function type(): TypeDescriptor<Validator> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function createV1(
      tx: Transaction,
      args: [validator.ValidatorV1 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_wrapper::create_v1",
        arguments: _args,
      });
    }
    export function destroy(
      tx: Transaction,
      args: [validator_wrapper.Validator | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_wrapper::destroy",
        arguments: _args,
      });
    }
    export function loadValidatorMaybeUpgrade(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::validator_wrapper::load_validator_maybe_upgrade",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function createV1(
      client: IotaClient,
      args: [validator.ValidatorV1],
    ): Promise<TypedDevInspectResults<[validator_wrapper.Validator]>> {
      const tx = new Transaction();
      builder.createV1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator_wrapper.Validator]
      >(inspectRes);
    }
    export async function destroy(
      client: IotaClient,
      args: [validator_wrapper.Validator],
    ): Promise<TypedDevInspectResults<[validator.ValidatorV1]>> {
      const tx = new Transaction();
      builder.destroy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [validator.ValidatorV1]
      >(inspectRes);
    }
    export async function loadValidatorMaybeUpgrade(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.loadValidatorMaybeUpgrade(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace voting_power {
  export interface VotingPowerInfoV1 {
    validator_index: bigint;
    voting_power: bigint;
    stake: bigint;
  }

  export namespace VotingPowerInfoV1 {
    export const TYPE_QNAME = "0x3::voting_power::VotingPowerInfoV1";

    const TYPE = new TypeDescriptor<VotingPowerInfoV1>(
      VotingPowerInfoV1.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<VotingPowerInfoV1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function quorumThreshold(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::voting_power::quorum_threshold",
        arguments: _args,
      });
    }
    export function setVotingPower(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::voting_power::set_voting_power",
        arguments: _args,
      });
    }
    export function totalCommitteeStake(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::voting_power::total_committee_stake",
        arguments: _args,
      });
    }
    export function totalVotingPower(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x3::voting_power::total_voting_power",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function quorumThreshold(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.quorumThreshold(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function setVotingPower(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setVotingPower(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function totalCommitteeStake(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalCommitteeStake(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function totalVotingPower(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalVotingPower(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"genesis":{"fileFormatVersion":6,"address":"0x3","name":"genesis","friends":[],"structs":{"GenesisChainParameters":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"protocol_version","type":"U64"},{"name":"chain_start_timestamp_ms","type":"U64"},{"name":"epoch_duration_ms","type":"U64"},{"name":"max_validator_count","type":"U64"},{"name":"min_validator_joining_stake","type":"U64"},{"name":"validator_low_stake_threshold","type":"U64"},{"name":"validator_very_low_stake_threshold","type":"U64"},{"name":"validator_low_stake_grace_period","type":"U64"}]},"GenesisValidatorMetadata":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"name","type":{"Vector":"U8"}},{"name":"description","type":{"Vector":"U8"}},{"name":"image_url","type":{"Vector":"U8"}},{"name":"project_url","type":{"Vector":"U8"}},{"name":"iota_address","type":"Address"},{"name":"gas_price","type":"U64"},{"name":"commission_rate","type":"U64"},{"name":"authority_public_key","type":{"Vector":"U8"}},{"name":"proof_of_possession","type":{"Vector":"U8"}},{"name":"network_public_key","type":{"Vector":"U8"}},{"name":"protocol_public_key","type":{"Vector":"U8"}},{"name":"network_address","type":{"Vector":"U8"}},{"name":"p2p_address","type":{"Vector":"U8"}},{"name":"primary_address","type":{"Vector":"U8"}}]},"TokenAllocation":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"recipient_address","type":"Address"},{"name":"amount_nanos","type":"U64"},{"name":"staked_with_validator","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}},{"name":"staked_with_timelock_expiration","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}}]},"TokenDistributionSchedule":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"pre_minted_supply","type":"U64"},{"name":"allocations","type":{"Vector":{"Struct":{"address":"0x3","module":"genesis","name":"TokenAllocation","typeArguments":[]}}}}]}},"exposedFunctions":{}},"iota_system":{"fileFormatVersion":6,"address":"0x3","name":"iota_system","friends":[{"address":"0x3","name":"genesis"},{"address":"0x3","name":"timelocked_staking"}],"structs":{"IotaSystemState":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"version","type":"U64"}]}},"exposedFunctions":{"active_validator_addresses":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"committee_validator_addresses":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"create":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}},{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}},{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"U64","U64",{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"SystemParametersV1","typeArguments":[]}},{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"get_total_iota_supply":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}}],"return":["U64"]},"load_iota_system_admin_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}}]},"pool_exchange_rates":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]}}}]},"report_validator":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"Address"],"return":[]},"request_add_stake":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_mul_coin":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_non_entry":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_add_validator":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_validator_candidate":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator_candidate":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_set_commission_rate":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_set_gas_price":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"U64"],"return":[]},"request_withdraw_stake":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_withdraw_stake_non_entry":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"rotate_operation_cap":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"set_candidate_validator_commission_rate":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"set_candidate_validator_gas_price":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"U64"],"return":[]},"undo_report_validator":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"Address"],"return":[]},"update_candidate_validator_authority_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_network_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_network_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_p2p_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_primary_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_protocol_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_description":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_image_url":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_name":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_authority_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_network_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_network_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_p2p_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_primary_address":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_protocol_pubkey":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_project_url":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"validator_address_by_pool_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":["Address"]}}},"iota_system_state_inner":{"fileFormatVersion":6,"address":"0x3","name":"iota_system_state_inner","friends":[{"address":"0x3","name":"genesis"},{"address":"0x3","name":"iota_system"}],"structs":{"IotaSystemStateV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"protocol_version","type":"U64"},{"name":"system_state_version","type":"U64"},{"name":"iota_treasury_cap","type":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},{"name":"validators","type":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},{"name":"storage_fund","type":{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}},{"name":"parameters","type":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"SystemParametersV1","typeArguments":[]}}},{"name":"iota_system_admin_cap","type":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}},{"name":"reference_gas_price","type":"U64"},{"name":"validator_report_records","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address",{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":["Address"]}}]}}},{"name":"safe_mode","type":"Bool"},{"name":"safe_mode_storage_charges","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"safe_mode_computation_rewards","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"safe_mode_storage_rebates","type":"U64"},{"name":"safe_mode_non_refundable_storage_fee","type":"U64"},{"name":"epoch_start_timestamp_ms","type":"U64"},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"IotaSystemStateV2":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"protocol_version","type":"U64"},{"name":"system_state_version","type":"U64"},{"name":"iota_treasury_cap","type":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},{"name":"validators","type":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"name":"storage_fund","type":{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}},{"name":"parameters","type":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"SystemParametersV1","typeArguments":[]}}},{"name":"iota_system_admin_cap","type":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}},{"name":"reference_gas_price","type":"U64"},{"name":"validator_report_records","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address",{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":["Address"]}}]}}},{"name":"safe_mode","type":"Bool"},{"name":"safe_mode_storage_charges","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"safe_mode_computation_charges","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"safe_mode_computation_charges_burned","type":"U64"},{"name":"safe_mode_storage_rebates","type":"U64"},{"name":"safe_mode_non_refundable_storage_fee","type":"U64"},{"name":"epoch_start_timestamp_ms","type":"U64"},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"SystemEpochInfoEventV1":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"protocol_version","type":"U64"},{"name":"reference_gas_price","type":"U64"},{"name":"total_stake","type":"U64"},{"name":"storage_charge","type":"U64"},{"name":"storage_rebate","type":"U64"},{"name":"storage_fund_balance","type":"U64"},{"name":"total_gas_fees","type":"U64"},{"name":"total_stake_rewards_distributed","type":"U64"},{"name":"burnt_tokens_amount","type":"U64"},{"name":"minted_tokens_amount","type":"U64"}]},"SystemEpochInfoEventV2":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"protocol_version","type":"U64"},{"name":"total_stake","type":"U64"},{"name":"storage_charge","type":"U64"},{"name":"storage_rebate","type":"U64"},{"name":"storage_fund_balance","type":"U64"},{"name":"total_gas_fees","type":"U64"},{"name":"total_stake_rewards_distributed","type":"U64"},{"name":"burnt_tokens_amount","type":"U64"},{"name":"minted_tokens_amount","type":"U64"},{"name":"tips_amount","type":"U64"}]},"SystemParametersV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"epoch_duration_ms","type":"U64"},{"name":"min_validator_count","type":"U64"},{"name":"max_validator_count","type":"U64"},{"name":"min_validator_joining_stake","type":"U64"},{"name":"validator_low_stake_threshold","type":"U64"},{"name":"validator_very_low_stake_threshold","type":"U64"},{"name":"validator_low_stake_grace_period","type":"U64"},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}},"exposedFunctions":{"active_validator_addresses":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"advance_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"U64","U64","U64",{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"U64","U64","U64","U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"committee_validator_addresses":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"committee_validator_voting_powers":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address","U64"]}}]},"create":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}},{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"U64","U64",{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"SystemParametersV1","typeArguments":[]}},{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV1","typeArguments":[]}}]},"create_system_parameters":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","U64","U64","U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"SystemParametersV1","typeArguments":[]}}]},"epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"epoch_start_timestamp_ms":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"genesis_system_state_version":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]},"get_reporters_of":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"Address"],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":["Address"]}}]},"get_storage_fund_object_rebates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"get_storage_fund_total_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"get_total_iota_supply":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"iota_system_admin_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}}]},"pool_exchange_rates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]}}}]},"protocol_version":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"report_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"Address"],"return":[]},"request_add_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_add_stake_mul_coin":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_add_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_validator_candidate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator_candidate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_set_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_withdraw_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"rotate_operation_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"set_candidate_validator_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"system_state_version":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":["U64"]},"undo_report_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"Address"],"return":[]},"update_candidate_validator_authority_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_network_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_network_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_p2p_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_primary_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_candidate_validator_protocol_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_description":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_image_url":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_name":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_authority_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_network_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_network_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_p2p_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_primary_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_next_epoch_protocol_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"update_validator_project_url":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"v1_to_v2":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV1","typeArguments":[]}}],"return":[{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}]},"validator_address_by_pool_id":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":["Address"]},"validator_stake_amount":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_staking_pool_id":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}},"Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"validator_staking_pool_mappings":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"iota_system_state_inner","name":"IotaSystemStateV2","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"Address"]}}}]}}},"staking_pool":{"fileFormatVersion":6,"address":"0x3","name":"staking_pool","friends":[{"address":"0x3","name":"validator"},{"address":"0x3","name":"validator_set"}],"structs":{"PoolTokenExchangeRate":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"iota_amount","type":"U64"},{"name":"pool_token_amount","type":"U64"}]},"StakedIota":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"stake_activation_epoch","type":"U64"},{"name":"principal","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}}]},"StakingPoolV1":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"activation_epoch","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}},{"name":"deactivation_epoch","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}},{"name":"iota_balance","type":"U64"},{"name":"rewards_pool","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"pool_token_balance","type":"U64"},{"name":"exchange_rates","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]}}},{"name":"pending_stake","type":"U64"},{"name":"pending_total_iota_withdraw","type":"U64"},{"name":"pending_pool_token_withdraw","type":"U64"},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}},"exposedFunctions":{"activate_staking_pool":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},"U64"],"return":[]},"deactivate_staking_pool":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},"U64"],"return":[]},"deposit_rewards":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[]},"exchange_rates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]}}}]},"iota_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}}],"return":["U64"]},"iota_balance":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":["U64"]},"is_equal_staking_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}}],"return":["Bool"]},"is_inactive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":["Bool"]},"is_preactive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":["Bool"]},"join_staked_iota":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}],"return":[]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}]},"pending_stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":["U64"]},"pending_stake_withdraw_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":["U64"]},"pool_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"pool_token_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}}],"return":["U64"]},"pool_token_exchange_rate_at_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},"U64"],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]},"process_pending_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":[]},"process_pending_stake_withdraw":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}],"return":[]},"process_pending_stakes_and_withdraws":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_withdraw_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"split_staked_iota":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"stake_activation_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}}],"return":["U64"]},"staked_iota_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}}],"return":["U64"]},"withdraw_from_principal":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}],"return":["U64",{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}}},"storage_fund":{"fileFormatVersion":6,"address":"0x3","name":"storage_fund","friends":[{"address":"0x3","name":"iota_system_state_inner"}],"structs":{"StorageFundV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"total_object_storage_rebates","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"non_refundable_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}}]}},"exposedFunctions":{"advance_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"U64","U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}]},"total_balance":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}}],"return":["U64"]},"total_object_storage_rebates":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"storage_fund","name":"StorageFundV1","typeArguments":[]}}}],"return":["U64"]}}},"timelocked_staking":{"fileFormatVersion":6,"address":"0x3","name":"timelocked_staking","friends":[{"address":"0x3","name":"genesis"}],"structs":{"TimelockedStakedIota":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"staked_iota","type":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}},{"name":"expiration_timestamp_ms","type":"U64"},{"name":"label","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]}},"exposedFunctions":{"expiration_timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":["U64"]},"is_equal_staking_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":["Bool"]},"is_labeled_with":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":["Bool"]},"join_staked_iota":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}],"return":[]},"label":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"pool_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"request_add_stake":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_at_genesis":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address","U64",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_mul_bal":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_mul_bal_non_entry":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Vector":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}]},"request_add_stake_non_entry":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}]},"request_withdraw_stake":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_withdraw_stake_non_entry":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"iota_system","name":"IotaSystemState","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}]},"split_staked_iota":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"stake_activation_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":["U64"]},"staked_iota_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}}],"return":["U64"]},"transfer_to_sender":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"transfer_to_sender_multiple":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"unlock":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"unlock_with_clock":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"timelocked_staking","name":"TimelockedStakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]}}},"validator":{"fileFormatVersion":6,"address":"0x3","name":"validator","friends":[{"address":"0x3","name":"genesis"},{"address":"0x3","name":"iota_system_state_inner"},{"address":"0x3","name":"timelocked_staking"},{"address":"0x3","name":"validator_set"},{"address":"0x3","name":"voting_power"}],"structs":{"StakingRequestEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"validator_address","type":"Address"},{"name":"staker_address","type":"Address"},{"name":"epoch","type":"U64"},{"name":"amount","type":"U64"}]},"UnstakingRequestEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"validator_address","type":"Address"},{"name":"staker_address","type":"Address"},{"name":"stake_activation_epoch","type":"U64"},{"name":"unstaking_epoch","type":"U64"},{"name":"principal_amount","type":"U64"},{"name":"reward_amount","type":"U64"}]},"ValidatorMetadataV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"iota_address","type":"Address"},{"name":"authority_pubkey_bytes","type":{"Vector":"U8"}},{"name":"network_pubkey_bytes","type":{"Vector":"U8"}},{"name":"protocol_pubkey_bytes","type":{"Vector":"U8"}},{"name":"proof_of_possession","type":{"Vector":"U8"}},{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"description","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"image_url","type":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}},{"name":"project_url","type":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}},{"name":"net_address","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"p2p_address","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"primary_address","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"next_epoch_authority_pubkey_bytes","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}},{"name":"next_epoch_proof_of_possession","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}},{"name":"next_epoch_network_pubkey_bytes","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}},{"name":"next_epoch_protocol_pubkey_bytes","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}},{"name":"next_epoch_net_address","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},{"name":"next_epoch_p2p_address","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},{"name":"next_epoch_primary_address","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"ValidatorV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"metadata","type":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorMetadataV1","typeArguments":[]}}},{"name":"voting_power","type":"U64"},{"name":"operation_cap_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"gas_price","type":"U64"},{"name":"staking_pool","type":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}},{"name":"commission_rate","type":"U64"},{"name":"next_epoch_stake","type":"U64"},{"name":"next_epoch_gas_price","type":"U64"},{"name":"next_epoch_commission_rate","type":"U64"},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}},"exposedFunctions":{"activate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[]},"adjust_next_epoch_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[]},"authority_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"commission_rate":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"deactivate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[]},"deposit_stake_rewards":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[]},"description":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"effectuate_staged_metadata":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[]},"gas_price":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"get_staking_pool_ref":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x3","module":"staking_pool","name":"StakingPoolV1","typeArguments":[]}}}]},"image_url":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}}]},"iota_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["Address"]},"is_duplicate":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["Bool"]},"is_preactive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["Bool"]},"metadata":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorMetadataV1","typeArguments":[]}}}]},"name":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"network_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"network_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},"U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}]},"new_metadata":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}},{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}],"return":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorMetadataV1","typeArguments":[]}}]},"new_unverified_validator_operation_cap_and_transfer":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"next_epoch_authority_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}}]},"next_epoch_gas_price":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"next_epoch_network_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]},"next_epoch_network_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}}]},"next_epoch_p2p_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]},"next_epoch_primary_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]},"next_epoch_proof_of_possession":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}}]},"next_epoch_protocol_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Vector":"U8"}]}}}]},"next_epoch_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"operation_cap_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"p2p_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"pending_stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"pending_stake_withdraw_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"pool_token_exchange_rate_at_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]},"primary_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"process_pending_stakes_and_withdraws":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"project_url":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}}]},"proof_of_possession":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"protocol_pubkey_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"request_add_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_add_stake_at_genesis":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake_at_genesis_with_receipt":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_set_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[]},"request_withdraw_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"set_candidate_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[]},"set_voting_power":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},"U64"],"return":[]},"smaller_than":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["Bool"]},"stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"staking_pool_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"total_stake":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"total_stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]},"update_candidate_authority_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"}],"return":[]},"update_candidate_network_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_candidate_network_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_candidate_p2p_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_candidate_primary_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_candidate_protocol_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_description":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_image_url":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_name":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_next_epoch_authority_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"},{"Vector":"U8"}],"return":[]},"update_next_epoch_network_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_next_epoch_network_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_next_epoch_p2p_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_next_epoch_primary_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_next_epoch_protocol_pubkey":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"update_project_url":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"validate_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorMetadataV1","typeArguments":[]}}}],"return":[]},"validate_metadata_bcs":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[]},"voting_power":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["U64"]}}},"validator_cap":{"fileFormatVersion":6,"address":"0x3","name":"validator_cap","friends":[{"address":"0x3","name":"iota_system_state_inner"},{"address":"0x3","name":"validator"},{"address":"0x3","name":"validator_set"}],"structs":{"UnverifiedValidatorOperationCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"authorizer_validator_address","type":"Address"}]},"ValidatorOperationCap":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"authorizer_validator_address","type":"Address"}]}},"exposedFunctions":{"new_from_unverified":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"validator_cap","name":"ValidatorOperationCap","typeArguments":[]}}]},"new_unverified_validator_operation_cap_and_transfer":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"unverified_operation_cap_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}}],"return":[{"Reference":"Address"}]},"verified_operation_cap_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"ValidatorOperationCap","typeArguments":[]}}}],"return":[{"Reference":"Address"}]}}},"validator_set":{"fileFormatVersion":6,"address":"0x3","name":"validator_set","friends":[{"address":"0x3","name":"genesis"},{"address":"0x3","name":"iota_system_state_inner"}],"structs":{"CommitteeValidatorJoinEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"validator_address","type":"Address"},{"name":"staking_pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"CommitteeValidatorLeaveEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"validator_address","type":"Address"},{"name":"staking_pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ValidatorEpochInfoEventV1":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"validator_address","type":"Address"},{"name":"reference_gas_survey_quote","type":"U64"},{"name":"stake","type":"U64"},{"name":"voting_power","type":"U64"},{"name":"commission_rate","type":"U64"},{"name":"pool_staking_reward","type":"U64"},{"name":"pool_token_exchange_rate","type":{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}},{"name":"tallying_rule_reporters","type":{"Vector":"Address"}},{"name":"tallying_rule_global_score","type":"U64"}]},"ValidatorJoinEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"validator_address","type":"Address"},{"name":"staking_pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ValidatorLeaveEvent":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"epoch","type":"U64"},{"name":"validator_address","type":"Address"},{"name":"staking_pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"is_voluntary","type":"Bool"}]},"ValidatorSetV1":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"total_stake","type":"U64"},{"name":"active_validators","type":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},{"name":"pending_active_validators","type":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}]}}},{"name":"pending_removals","type":{"Vector":"U64"}},{"name":"staking_pool_mappings","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"Address"]}}},{"name":"inactive_validators","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}]}}},{"name":"validator_candidates","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["Address",{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}]}}},{"name":"at_risk_validators","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address","U64"]}}},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"ValidatorSetV2":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"total_stake","type":"U64"},{"name":"active_validators","type":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},{"name":"committee_members","type":{"Vector":"U64"}},{"name":"pending_active_validators","type":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}]}}},{"name":"pending_removals","type":{"Vector":"U64"}},{"name":"staking_pool_mappings","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"Address"]}}},{"name":"inactive_validators","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}]}}},{"name":"validator_candidates","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["Address",{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}]}}},{"name":"at_risk_validators","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address","U64"]}}},{"name":"extra_fields","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}},"exposedFunctions":{"active_validator_addresses":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"active_validators":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}}],"return":[{"Reference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}}]},"active_validators_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":[{"Reference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}}]},"advance_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":["Address",{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":["Address"]}}]}}},"U64","U64","U64","U64","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"assert_no_pending_or_active_duplicates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":[]},"committee_validator_addresses":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"derive_reference_gas_price":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}}],"return":["U64"]},"get_active_or_pending_or_candidate_validator_ref":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address","U8"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_active_validator_ref":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_active_validator_ref_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_committee_validator_ref_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_pending_validator_ref":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_pending_validator_ref_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":[{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_validator_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},"Address"],"return":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_validator_mut_with_ctx":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_validator_mut_with_ctx_including_candidates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"get_validator_mut_with_verified_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"ValidatorOperationCap","typeArguments":[]}}},"Bool"],"return":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]},"is_active_validator_by_iota_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["Bool"]},"is_committee_validator_by_iota_address":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["Bool"]},"is_duplicate_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},{"Reference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}],"return":["Bool"]},"is_inactive_validator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_inactive_validator_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_validator_candidate":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":["Bool"]},"is_validator_candidate_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["Bool"]},"new_v1":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}]},"next_epoch_validator_count":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":["U64"]},"pool_exchange_rates":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0x3","module":"staking_pool","name":"PoolTokenExchangeRate","typeArguments":[]}}]}}}]},"process_new_committee":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"U64",{"Vector":"Address"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address",{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}}]},"request_add_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_add_validator_candidate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_remove_validator_candidate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_set_commission_rate":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"request_withdraw_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Struct":{"address":"0x3","module":"staking_pool","name":"StakedIota","typeArguments":[]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"select_committee_members_top_n_stakers":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"U64"],"return":[{"Vector":"U64"}]},"staking_pool_mappings":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"Address"]}}}]},"staking_pool_mappings_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"Address"]}}}]},"sum_committee_voting_power_by_addresses":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Vector":"Address"}}],"return":["U64"]},"sum_voting_power_by_addresses":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},{"Reference":{"Vector":"Address"}}],"return":["U64"]},"total_stake":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}}],"return":["U64"]},"total_stake_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}}],"return":["U64"]},"v1_to_v2":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}],"return":[{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}]},"validator_address_by_pool_id_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":["Address"]},"validator_stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_stake_amount_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_staking_pool_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"validator_staking_pool_id_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"validator_total_stake_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_total_stake_amount_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_voting_power":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV1","typeArguments":[]}}},"Address"],"return":["U64"]},"validator_voting_power_inner":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},"Address"],"return":["U64"]},"verify_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_set","name":"ValidatorSetV2","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x3","module":"validator_cap","name":"UnverifiedValidatorOperationCap","typeArguments":[]}}},"U8"],"return":[{"Struct":{"address":"0x3","module":"validator_cap","name":"ValidatorOperationCap","typeArguments":[]}}]}}},"validator_wrapper":{"fileFormatVersion":6,"address":"0x3","name":"validator_wrapper","friends":[{"address":"0x3","name":"validator_set"}],"structs":{"Validator":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"inner","type":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}]}},"exposedFunctions":{"create_v1":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}]},"destroy":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}],"return":[{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}]},"load_validator_maybe_upgrade":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator_wrapper","name":"Validator","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}]}}},"voting_power":{"fileFormatVersion":6,"address":"0x3","name":"voting_power","friends":[{"address":"0x3","name":"validator_set"}],"structs":{"VotingPowerInfoV1":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"validator_index","type":"U64"},{"name":"voting_power","type":"U64"},{"name":"stake","type":"U64"}]}},"exposedFunctions":{"quorum_threshold":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]},"set_voting_power":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U64"}},{"MutableReference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}}],"return":[]},"total_committee_stake":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x3","module":"validator","name":"ValidatorV1","typeArguments":[]}}}},{"Reference":{"Vector":"U64"}}],"return":["U64"]},"total_voting_power":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  _0x1.loadAllTypes(coder);
  _0x2.loadAllTypes(coder);
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0x3");
  }
}

loadAllTypes(defaultMoveCoder());
