var Rw = Object.defineProperty;
var tA = (r) => {
  throw TypeError(r);
};
var Sw = (r, t, e) => t in r ? Rw(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var Q = (r, t, e) => Sw(r, typeof t != "symbol" ? t + "" : t, e), bc = (r, t, e) => t.has(r) || tA("Cannot " + e);
var _t = (r, t, e) => (bc(r, t, "read from private field"), e ? e.call(r) : t.get(r)), Ce = (r, t, e) => t.has(r) ? tA("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, e), Gt = (r, t, e, n) => (bc(r, t, "write to private field"), n ? n.call(r, e) : t.set(r, e), e), un = (r, t, e) => (bc(r, t, "access private method"), e);
function Tw(r, t) {
  for (var e = 0; e < t.length; e++) {
    const n = t[e];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const s in n)
        if (s !== "default" && !(s in r)) {
          const i = Object.getOwnPropertyDescriptor(n, s);
          i && Object.defineProperty(r, s, i.get ? i : {
            enumerable: !0,
            get: () => n[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }));
}
let c;
const C_ = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && C_.decode();
let Wi = null;
function E_() {
  return (Wi === null || Wi.byteLength === 0) && (Wi = new Uint8Array(c.memory.buffer)), Wi;
}
function Fw(r, t) {
  return r = r >>> 0, C_.decode(E_().subarray(r, r + t));
}
function w(r, t) {
  if (!(r instanceof t))
    throw new Error(`expected instance of ${t.name}`);
}
function Nw(r, t) {
  const e = c.gm_args(r, t);
  return V.__wrap(e);
}
function Qw(r, t, e) {
  const n = c.gtf_args(r, t, e);
  return V.__wrap(n);
}
function Dw(r, t, e, n) {
  w(n, Qi);
  var s = n.__destroy_into_raw();
  const i = c.niop_args(r, t, e, s);
  return V.__wrap(i);
}
function Ow(r, t, e, n) {
  w(n, sn);
  var s = n.__destroy_into_raw();
  const i = c.wdcm_args(r, t, e, s);
  return V.__wrap(i);
}
function Mw(r, t, e, n) {
  w(n, sn);
  var s = n.__destroy_into_raw();
  const i = c.wqcm_args(r, t, e, s);
  return V.__wrap(i);
}
function Pw(r, t, e, n) {
  w(n, ha);
  var s = n.__destroy_into_raw();
  const i = c.wdop_args(r, t, e, s);
  return V.__wrap(i);
}
function Lw(r, t, e, n) {
  w(n, ha);
  var s = n.__destroy_into_raw();
  const i = c.wqop_args(r, t, e, s);
  return V.__wrap(i);
}
function kw(r, t, e, n) {
  w(n, _a);
  var s = n.__destroy_into_raw();
  const i = c.wdml_args(r, t, e, s);
  return V.__wrap(i);
}
function Uw(r, t, e, n) {
  w(n, _a);
  var s = n.__destroy_into_raw();
  const i = c.wqml_args(r, t, e, s);
  return V.__wrap(i);
}
function Gw(r, t, e, n) {
  w(n, la);
  var s = n.__destroy_into_raw();
  const i = c.wddv_args(r, t, e, s);
  return V.__wrap(i);
}
function zw(r, t, e, n) {
  w(n, la);
  var s = n.__destroy_into_raw();
  const i = c.wqdv_args(r, t, e, s);
  return V.__wrap(i);
}
function Xw(r, t, e) {
  const n = c.add(r, t, e);
  return V.__wrap(n);
}
function Hw(r, t, e) {
  const n = c.and(r, t, e);
  return V.__wrap(n);
}
function Vw(r, t, e) {
  const n = c.div(r, t, e);
  return V.__wrap(n);
}
function Ww(r, t, e) {
  const n = c.eq(r, t, e);
  return V.__wrap(n);
}
function Yw(r, t, e) {
  const n = c.exp(r, t, e);
  return V.__wrap(n);
}
function Zw(r, t, e) {
  const n = c.gt(r, t, e);
  return V.__wrap(n);
}
function Jw(r, t, e) {
  const n = c.lt(r, t, e);
  return V.__wrap(n);
}
function jw(r, t, e) {
  const n = c.mlog(r, t, e);
  return V.__wrap(n);
}
function qw(r, t, e) {
  const n = c.mroo(r, t, e);
  return V.__wrap(n);
}
function $w(r, t, e) {
  const n = c.mod_(r, t, e);
  return V.__wrap(n);
}
function gn(r, t) {
  const e = c.move_(r, t);
  return V.__wrap(e);
}
function Kw(r, t, e) {
  const n = c.mul(r, t, e);
  return V.__wrap(n);
}
function t0(r, t) {
  const e = c.not(r, t);
  return V.__wrap(e);
}
function e0(r, t, e) {
  const n = c.or(r, t, e);
  return V.__wrap(n);
}
function r0(r, t, e) {
  const n = c.sll(r, t, e);
  return V.__wrap(n);
}
function n0(r, t, e) {
  const n = c.srl(r, t, e);
  return V.__wrap(n);
}
function Wa(r, t, e) {
  const n = c.sub(r, t, e);
  return V.__wrap(n);
}
function s0(r, t, e) {
  const n = c.xor(r, t, e);
  return V.__wrap(n);
}
function i0(r, t, e, n) {
  const s = c.mldv(r, t, e, n);
  return V.__wrap(s);
}
function a0(r, t, e, n) {
  const s = c.niop(r, t, e, n);
  return V.__wrap(s);
}
function Pd(r) {
  const t = c.ret(r);
  return V.__wrap(t);
}
function o0(r, t) {
  const e = c.retd(r, t);
  return V.__wrap(e);
}
function c0(r) {
  const t = c.aloc(r);
  return V.__wrap(t);
}
function d0(r, t) {
  const e = c.mcl(r, t);
  return V.__wrap(e);
}
function u0(r, t, e) {
  const n = c.mcp(r, t, e);
  return V.__wrap(n);
}
function A0(r, t, e, n) {
  const s = c.meq(r, t, e, n);
  return V.__wrap(s);
}
function l0(r, t) {
  const e = c.bhsh(r, t);
  return V.__wrap(e);
}
function h0(r) {
  const t = c.bhei(r);
  return V.__wrap(t);
}
function _0(r, t) {
  const e = c.burn(r, t);
  return V.__wrap(e);
}
function Kc(r, t, e, n) {
  const s = c.call(r, t, e, n);
  return V.__wrap(s);
}
function p0(r, t, e, n) {
  const s = c.ccp(r, t, e, n);
  return V.__wrap(s);
}
function f0(r, t) {
  const e = c.croo(r, t);
  return V.__wrap(e);
}
function g0(r, t) {
  const e = c.csiz(r, t);
  return V.__wrap(e);
}
function w0(r) {
  const t = c.cb(r);
  return V.__wrap(t);
}
function qi(r, t, e, n) {
  const s = c.ldc(r, t, e, n);
  return V.__wrap(s);
}
function m0(r, t, e, n) {
  const s = c.log(r, t, e, n);
  return V.__wrap(s);
}
function y0(r, t, e, n) {
  const s = c.logd(r, t, e, n);
  return V.__wrap(s);
}
function b0(r, t) {
  const e = c.mint(r, t);
  return V.__wrap(e);
}
function I0(r) {
  const t = c.rvrt(r);
  return V.__wrap(t);
}
function C0(r, t, e) {
  const n = c.scwq(r, t, e);
  return V.__wrap(n);
}
function E0(r, t, e) {
  const n = c.srw(r, t, e);
  return V.__wrap(n);
}
function B0(r, t, e, n) {
  const s = c.srwq(r, t, e, n);
  return V.__wrap(s);
}
function v0(r, t, e) {
  const n = c.sww(r, t, e);
  return V.__wrap(n);
}
function x0(r, t, e, n) {
  const s = c.swwq(r, t, e, n);
  return V.__wrap(s);
}
function B_(r, t, e) {
  const n = c.tr(r, t, e);
  return V.__wrap(n);
}
function R0(r, t, e, n) {
  const s = c.tro(r, t, e, n);
  return V.__wrap(s);
}
function S0(r, t, e) {
  const n = c.eck1(r, t, e);
  return V.__wrap(n);
}
function T0(r, t, e) {
  const n = c.ecr1(r, t, e);
  return V.__wrap(n);
}
function F0(r, t, e, n) {
  const s = c.ed19(r, t, e, n);
  return V.__wrap(s);
}
function N0(r, t, e) {
  const n = c.k256(r, t, e);
  return V.__wrap(n);
}
function Q0(r, t, e) {
  const n = c.s256(r, t, e);
  return V.__wrap(n);
}
function D0(r, t) {
  const e = c.time(r, t);
  return V.__wrap(e);
}
function O0() {
  const r = c.noop();
  return V.__wrap(r);
}
function M0(r) {
  const t = c.flag(r);
  return V.__wrap(t);
}
function P0(r, t, e) {
  const n = c.bal(r, t, e);
  return V.__wrap(n);
}
function Ya(r) {
  const t = c.jmp(r);
  return V.__wrap(t);
}
function L0(r, t, e) {
  const n = c.jne(r, t, e);
  return V.__wrap(n);
}
function k0(r, t, e, n) {
  const s = c.smo(r, t, e, n);
  return V.__wrap(s);
}
function Er(r, t, e) {
  const n = c.addi(r, t, e);
  return V.__wrap(n);
}
function U0(r, t, e) {
  const n = c.andi(r, t, e);
  return V.__wrap(n);
}
function Za(r, t, e) {
  const n = c.divi(r, t, e);
  return V.__wrap(n);
}
function G0(r, t, e) {
  const n = c.expi(r, t, e);
  return V.__wrap(n);
}
function z0(r, t, e) {
  const n = c.modi(r, t, e);
  return V.__wrap(n);
}
function X0(r, t, e) {
  const n = c.muli(r, t, e);
  return V.__wrap(n);
}
function H0(r, t, e) {
  const n = c.ori(r, t, e);
  return V.__wrap(n);
}
function V0(r, t, e) {
  const n = c.slli(r, t, e);
  return V.__wrap(n);
}
function W0(r, t, e) {
  const n = c.srli(r, t, e);
  return V.__wrap(n);
}
function v_(r, t, e) {
  const n = c.subi(r, t, e);
  return V.__wrap(n);
}
function Y0(r, t, e) {
  const n = c.xori(r, t, e);
  return V.__wrap(n);
}
function Z0(r, t, e) {
  const n = c.jnei(r, t, e);
  return V.__wrap(n);
}
function J0(r, t, e) {
  const n = c.lb(r, t, e);
  return V.__wrap(n);
}
function ea(r, t, e) {
  const n = c.lw(r, t, e);
  return V.__wrap(n);
}
function j0(r, t, e) {
  const n = c.sb(r, t, e);
  return V.__wrap(n);
}
function q0(r, t, e) {
  const n = c.sw(r, t, e);
  return V.__wrap(n);
}
function $0(r, t, e) {
  const n = c.mcpi(r, t, e);
  return V.__wrap(n);
}
function x_(r, t, e) {
  const n = c.gtf(r, t, e);
  return V.__wrap(n);
}
function K0(r, t, e) {
  const n = c.lqw(r, t, e);
  return V.__wrap(n);
}
function tm(r, t, e) {
  const n = c.lhw(r, t, e);
  return V.__wrap(n);
}
function em(r, t, e) {
  const n = c.sqw(r, t, e);
  return V.__wrap(n);
}
function rm(r, t, e) {
  const n = c.shw(r, t, e);
  return V.__wrap(n);
}
function nm(r, t) {
  const e = c.mcli(r, t);
  return V.__wrap(e);
}
function sm(r, t) {
  const e = c.gm(r, t);
  return V.__wrap(e);
}
function rs(r, t) {
  const e = c.movi(r, t);
  return V.__wrap(e);
}
function im(r, t) {
  const e = c.jnzi(r, t);
  return V.__wrap(e);
}
function am(r, t) {
  const e = c.jmpf(r, t);
  return V.__wrap(e);
}
function om(r, t) {
  const e = c.jmpb(r, t);
  return V.__wrap(e);
}
function cm(r, t, e) {
  const n = c.jnzf(r, t, e);
  return V.__wrap(n);
}
function R_(r, t, e) {
  const n = c.jnzb(r, t, e);
  return V.__wrap(n);
}
function dm(r, t, e, n) {
  const s = c.jnef(r, t, e, n);
  return V.__wrap(s);
}
function um(r, t, e, n) {
  const s = c.jneb(r, t, e, n);
  return V.__wrap(s);
}
function Am(r) {
  const t = c.ji(r);
  return V.__wrap(t);
}
function lm(r) {
  const t = c.cfei(r);
  return V.__wrap(t);
}
function hm(r) {
  const t = c.cfsi(r);
  return V.__wrap(t);
}
function _m(r) {
  const t = c.cfe(r);
  return V.__wrap(t);
}
function pm(r) {
  const t = c.cfs(r);
  return V.__wrap(t);
}
function fm(r) {
  const t = c.pshl(r);
  return V.__wrap(t);
}
function gm(r) {
  const t = c.pshh(r);
  return V.__wrap(t);
}
function wm(r) {
  const t = c.popl(r);
  return V.__wrap(t);
}
function mm(r) {
  const t = c.poph(r);
  return V.__wrap(t);
}
function ym(r, t, e) {
  const n = c.jal(r, t, e);
  return V.__wrap(n);
}
function bm(r, t, e, n) {
  const s = c.wdcm(r, t, e, n);
  return V.__wrap(s);
}
function Im(r, t, e, n) {
  const s = c.wqcm(r, t, e, n);
  return V.__wrap(s);
}
function Cm(r, t, e, n) {
  const s = c.wdop(r, t, e, n);
  return V.__wrap(s);
}
function Em(r, t, e, n) {
  const s = c.wqop(r, t, e, n);
  return V.__wrap(s);
}
function Bm(r, t, e, n) {
  const s = c.wdml(r, t, e, n);
  return V.__wrap(s);
}
function vm(r, t, e, n) {
  const s = c.wqml(r, t, e, n);
  return V.__wrap(s);
}
function xm(r, t, e, n) {
  const s = c.wddv(r, t, e, n);
  return V.__wrap(s);
}
function Rm(r, t, e, n) {
  const s = c.wqdv(r, t, e, n);
  return V.__wrap(s);
}
function Sm(r, t, e, n) {
  const s = c.wdmd(r, t, e, n);
  return V.__wrap(s);
}
function Tm(r, t, e, n) {
  const s = c.wqmd(r, t, e, n);
  return V.__wrap(s);
}
function Fm(r, t, e, n) {
  const s = c.wdam(r, t, e, n);
  return V.__wrap(s);
}
function Nm(r, t, e, n) {
  const s = c.wqam(r, t, e, n);
  return V.__wrap(s);
}
function Qm(r, t, e, n) {
  const s = c.wdmm(r, t, e, n);
  return V.__wrap(s);
}
function Dm(r, t, e, n) {
  const s = c.wqmm(r, t, e, n);
  return V.__wrap(s);
}
function Om(r, t, e, n) {
  const s = c.ecal(r, t, e, n);
  return V.__wrap(s);
}
function Ja(r, t) {
  const e = c.bsiz(r, t);
  return V.__wrap(e);
}
function Mm(r, t, e, n) {
  const s = c.bldd(r, t, e, n);
  return V.__wrap(s);
}
function Pm(r, t, e, n) {
  const s = c.ecop(r, t, e, n);
  return V.__wrap(s);
}
function Lm(r, t, e, n) {
  const s = c.epar(r, t, e, n);
  return V.__wrap(s);
}
let ln = null;
function eA() {
  return (ln === null || ln.buffer.detached === !0 || ln.buffer.detached === void 0 && ln.buffer !== c.memory.buffer) && (ln = new DataView(c.memory.buffer)), ln;
}
function km(r, t) {
  return r = r >>> 0, E_().subarray(r / 1, r / 1 + t);
}
const Um = Object.freeze({
  /**
   * Equality (`==`)
   */
  EQ: 0,
  0: "EQ",
  /**
   * Inequality (`!=`)
   */
  NE: 1,
  1: "NE",
  /**
   * Less than (`<`)
   */
  LT: 2,
  2: "LT",
  /**
   * Greater than (`>`)
   */
  GT: 3,
  3: "GT",
  /**
   * Less than or equals (`>=`)
   */
  LTE: 4,
  4: "LTE",
  /**
   * Greater than or equals (`>=`)
   */
  GTE: 5,
  5: "GTE",
  /**
   * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
   */
  LZC: 6,
  6: "LZC"
}), Gm = Object.freeze({
  /**
   * r" Get if caller is external.
   */
  IsCallerExternal: 1,
  1: "IsCallerExternal",
  /**
   * r" Get caller's contract ID.
   */
  GetCaller: 2,
  2: "GetCaller",
  /**
   * r" Get index of current predicate.
   */
  GetVerifyingPredicate: 3,
  3: "GetVerifyingPredicate",
  /**
   * r" Get the Chain ID this VM is operating within
   */
  GetChainId: 4,
  4: "GetChainId",
  /**
   * r" Get memory address where the transaction is located
   */
  TxStart: 5,
  5: "TxStart",
  /**
   * r" Get memory address of base asset ID
   */
  BaseAssetId: 6,
  6: "BaseAssetId",
  /**
   * r" Get gas price for block
   */
  GetGasPrice: 7,
  7: "GetGasPrice"
}), S_ = Object.freeze({
  /**
   * r" Set `$rA` to `tx.type`
   */
  Type: 1,
  1: "Type",
  /**
   * r" Set `$rA` to `tx.scriptGasLimit`
   */
  ScriptGasLimit: 2,
  2: "ScriptGasLimit",
  /**
   * r" Set `$rA` to `tx.scriptLength`
   */
  ScriptLength: 3,
  3: "ScriptLength",
  /**
   * r" Set `$rA` to `tx.scriptDataLength`
   */
  ScriptDataLength: 4,
  4: "ScriptDataLength",
  /**
   * r" Set `$rA` to `tx.inputsCount`
   */
  ScriptInputsCount: 5,
  5: "ScriptInputsCount",
  /**
   * r" Set `$rA` to `tx.outputsCount`
   */
  ScriptOutputsCount: 6,
  6: "ScriptOutputsCount",
  /**
   * r" Set `$rA` to `tx.witnessesCount`
   */
  ScriptWitnessesCount: 7,
  7: "ScriptWitnessesCount",
  /**
   * r" Set `$rA` to `Memory address of tx.script`
   */
  Script: 9,
  9: "Script",
  /**
   * r" Set `$rA` to `Memory address of tx.scriptData`
   */
  ScriptData: 10,
  10: "ScriptData",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
   */
  ScriptInputAtIndex: 11,
  11: "ScriptInputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of t.outputs[$rB]`
   */
  ScriptOutputAtIndex: 12,
  12: "ScriptOutputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
   */
  ScriptWitnessAtIndex: 13,
  13: "ScriptWitnessAtIndex",
  /**
   * r" Set `$rA` to size of the transaction in memory, in bytes
   */
  TxLength: 14,
  14: "TxLength",
  /**
   * r" Set `$rA` to `tx.bytecodeWitnessIndex`
   */
  CreateBytecodeWitnessIndex: 257,
  257: "CreateBytecodeWitnessIndex",
  /**
   * r" Set `$rA` to `tx.storageSlotsCount`
   */
  CreateStorageSlotsCount: 258,
  258: "CreateStorageSlotsCount",
  /**
   * r" Set `$rA` to `tx.inputsCount`
   */
  CreateInputsCount: 259,
  259: "CreateInputsCount",
  /**
   * r" Set `$rA` to `tx.outputsCount`
   */
  CreateOutputsCount: 260,
  260: "CreateOutputsCount",
  /**
   * r" Set `$rA` to `tx.witnessesCount`
   */
  CreateWitnessesCount: 261,
  261: "CreateWitnessesCount",
  /**
   * r" Set `$rA` to `Memory address of tx.salt`
   */
  CreateSalt: 262,
  262: "CreateSalt",
  /**
   * r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
   */
  CreateStorageSlotAtIndex: 263,
  263: "CreateStorageSlotAtIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
   */
  CreateInputAtIndex: 264,
  264: "CreateInputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of t.outputs[$rB]`
   */
  CreateOutputAtIndex: 265,
  265: "CreateOutputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
   */
  CreateWitnessAtIndex: 266,
  266: "CreateWitnessAtIndex",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].type`
   */
  InputType: 512,
  512: "InputType",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
   */
  InputCoinTxId: 513,
  513: "InputCoinTxId",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
   */
  InputCoinOutputIndex: 514,
  514: "InputCoinOutputIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
   */
  InputCoinOwner: 515,
  515: "InputCoinOwner",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].amount`
   */
  InputCoinAmount: 516,
  516: "InputCoinAmount",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
   */
  InputCoinAssetId: 517,
  517: "InputCoinAssetId",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
   */
  InputCoinTxPointer: 518,
  518: "InputCoinTxPointer",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
   */
  InputCoinWitnessIndex: 519,
  519: "InputCoinWitnessIndex",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
   */
  InputCoinPredicateLength: 521,
  521: "InputCoinPredicateLength",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
   */
  InputCoinPredicateDataLength: 522,
  522: "InputCoinPredicateDataLength",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
   */
  InputCoinPredicate: 523,
  523: "InputCoinPredicate",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
   */
  InputCoinPredicateData: 524,
  524: "InputCoinPredicateData",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
   */
  InputCoinPredicateGasUsed: 525,
  525: "InputCoinPredicateGasUsed",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
   */
  InputContractTxId: 544,
  544: "InputContractTxId",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].outputIndex`
   */
  InputContractOutputIndex: 545,
  545: "InputContractOutputIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
   */
  InputContractId: 549,
  549: "InputContractId",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
   */
  InputMessageSender: 576,
  576: "InputMessageSender",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
   */
  InputMessageRecipient: 577,
  577: "InputMessageRecipient",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].amount`
   */
  InputMessageAmount: 578,
  578: "InputMessageAmount",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
   */
  InputMessageNonce: 579,
  579: "InputMessageNonce",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
   */
  InputMessageWitnessIndex: 580,
  580: "InputMessageWitnessIndex",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].dataLength`
   */
  InputMessageDataLength: 581,
  581: "InputMessageDataLength",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].predicateLength`
   */
  InputMessagePredicateLength: 582,
  582: "InputMessagePredicateLength",
  /**
   * r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
   */
  InputMessagePredicateDataLength: 583,
  583: "InputMessagePredicateDataLength",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
   */
  InputMessageData: 584,
  584: "InputMessageData",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
   */
  InputMessagePredicate: 585,
  585: "InputMessagePredicate",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
   */
  InputMessagePredicateData: 586,
  586: "InputMessagePredicateData",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
   */
  InputMessagePredicateGasUsed: 587,
  587: "InputMessagePredicateGasUsed",
  /**
   * r" Set `$rA` to `tx.outputs[$rB].type`
   */
  OutputType: 768,
  768: "OutputType",
  /**
   * r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
   */
  OutputCoinTo: 769,
  769: "OutputCoinTo",
  /**
   * r" Set `$rA` to `tx.outputs[$rB].amount`
   */
  OutputCoinAmount: 770,
  770: "OutputCoinAmount",
  /**
   * r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
   */
  OutputCoinAssetId: 771,
  771: "OutputCoinAssetId",
  /**
   * r" Set `$rA` to `tx.outputs[$rB].inputIndex`
   */
  OutputContractInputIndex: 772,
  772: "OutputContractInputIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
   */
  OutputContractCreatedContractId: 775,
  775: "OutputContractCreatedContractId",
  /**
   * r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
   */
  OutputContractCreatedStateRoot: 776,
  776: "OutputContractCreatedStateRoot",
  /**
   * r" Set `$rA` to `tx.witnesses[$rB].dataLength`
   */
  WitnessDataLength: 1024,
  1024: "WitnessDataLength",
  /**
   * r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
   */
  WitnessData: 1025,
  1025: "WitnessData",
  /**
   * r" Set `$rA` to `tx.policyTypes`
   */
  PolicyTypes: 1280,
  1280: "PolicyTypes",
  /**
   * r" Set `$rA` to `tx.policies[0x00].gasPrice`
   */
  PolicyTip: 1281,
  1281: "PolicyTip",
  /**
   * r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
   */
  PolicyWitnessLimit: 1282,
  1282: "PolicyWitnessLimit",
  /**
   * r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
   */
  PolicyMaturity: 1283,
  1283: "PolicyMaturity",
  /**
   * r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
   */
  PolicyMaxFee: 1284,
  1284: "PolicyMaxFee",
  /**
   * r" Set `$rA` to `tx.policies[count_ones(0b11111 & tx.policyTypes) - 1].expiration`
   */
  PolicyExpiration: 1285,
  1285: "PolicyExpiration",
  /**
   * r" Set `$rA` to `Memory address of tx.root`
   */
  UploadRoot: 1536,
  1536: "UploadRoot",
  /**
   * r" Set `$rA` to `tx.witnessIndex`
   */
  UploadWitnessIndex: 1537,
  1537: "UploadWitnessIndex",
  /**
   * r" Set `$rA` to `tx.subsectionIndex`
   */
  UploadSubsectionIndex: 1538,
  1538: "UploadSubsectionIndex",
  /**
   * r" Set `$rA` to `tx.subsectionsNumber`
   */
  UploadSubsectionsCount: 1539,
  1539: "UploadSubsectionsCount",
  /**
   * r" Set `$rA` to `tx.proofSetCount`
   */
  UploadProofSetCount: 1540,
  1540: "UploadProofSetCount",
  /**
   * r" Set `$rA` to `Memory address of tx.proofSet[$rB]`
   */
  UploadProofSetAtIndex: 1541,
  1541: "UploadProofSetAtIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.id`
   */
  BlobId: 1792,
  1792: "BlobId",
  /**
   * r" Set `$rA` to `tx.witnessIndex`
   */
  BlobWitnessIndex: 1793,
  1793: "BlobWitnessIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.purpose`
   */
  UpgradePurpose: 2048,
  2048: "UpgradePurpose",
  /**
   * r" Set `$rA` to `tx.inputsCount`
   */
  TxInputsCount: 2304,
  2304: "TxInputsCount",
  /**
   * r" Set `$rA` to `tx.outputsCount`
   */
  TxOutputsCount: 2305,
  2305: "TxOutputsCount",
  /**
   * r" Set `$rA` to `tx.witnessesCount`
   */
  TxWitnessesCount: 2306,
  2306: "TxWitnessesCount",
  /**
   * r" Set `$rA` to `Memory address of tx.inputs[$rB]`
   */
  TxInputAtIndex: 2307,
  2307: "TxInputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of t.outputs[$rB]`
   */
  TxOutputAtIndex: 2308,
  2308: "TxOutputAtIndex",
  /**
   * r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
   */
  TxWitnessAtIndex: 2309,
  2309: "TxWitnessAtIndex"
}), zm = Object.freeze({
  /**
   * Add
   */
  ADD: 0,
  0: "ADD",
  /**
   * Subtract
   */
  SUB: 1,
  1: "SUB",
  /**
   * Invert bits (discards rhs)
   */
  NOT: 2,
  2: "NOT",
  /**
   * Bitwise or
   */
  OR: 3,
  3: "OR",
  /**
   * Bitwise exclusive or
   */
  XOR: 4,
  4: "XOR",
  /**
   * Bitwise and
   */
  AND: 5,
  5: "AND",
  /**
   * Shift left
   */
  SHL: 6,
  6: "SHL",
  /**
   * Shift right
   */
  SHR: 7,
  7: "SHR"
}), Xm = Object.freeze({
  /**
   * Add
   */
  ADD: 0,
  0: "ADD",
  /**
   * Subtract
   */
  SUB: 1,
  1: "SUB",
  /**
   * Multiply
   */
  MUL: 2,
  2: "MUL",
  /**
   * Exponentiate
   */
  EXP: 3,
  3: "EXP",
  /**
   * Bit shift left
   */
  SLL: 4,
  4: "SLL",
  /**
   * XNOR
   */
  XNOR: 5,
  5: "XNOR"
}), Hm = Object.freeze({
  /**
   * 8-bit
   */
  U8: 0,
  0: "U8",
  /**
   * 16-bit
   */
  U16: 1,
  1: "U16",
  /**
   * 32-bit
   */
  U32: 2,
  2: "U32"
}), Vm = Object.freeze({
  /**
   * r" The byte can't be mapped to any known `PanicReason`.
   */
  UnknownPanicReason: 0,
  0: "UnknownPanicReason",
  /**
   * r" Found `RVRT` instruction.
   */
  Revert: 1,
  1: "Revert",
  /**
   * r" Execution ran out of gas.
   */
  OutOfGas: 2,
  2: "OutOfGas",
  /**
   * r" The transaction validity is violated.
   */
  TransactionValidity: 3,
  3: "TransactionValidity",
  /**
   * r" Attempt to write outside interpreter memory boundaries.
   */
  MemoryOverflow: 4,
  4: "MemoryOverflow",
  /**
   * r" Overflow while executing arithmetic operation.
   * r" These errors are ignored using the WRAPPING flag.
   */
  ArithmeticOverflow: 5,
  5: "ArithmeticOverflow",
  /**
   * r" Designed contract was not found in the storage.
   */
  ContractNotFound: 6,
  6: "ContractNotFound",
  /**
   * r" Memory ownership rules are violated.
   */
  MemoryOwnership: 7,
  7: "MemoryOwnership",
  /**
   * r" The asset ID balance isn't enough for the instruction.
   */
  NotEnoughBalance: 8,
  8: "NotEnoughBalance",
  /**
   * r" The interpreter is expected to be in internal context.
   */
  ExpectedInternalContext: 9,
  9: "ExpectedInternalContext",
  /**
   * r" The queried asset ID was not found in the state.
   */
  AssetIdNotFound: 10,
  10: "AssetIdNotFound",
  /**
   * r" The provided input is not found in the transaction.
   */
  InputNotFound: 11,
  11: "InputNotFound",
  /**
   * r" The provided output is not found in the transaction.
   */
  OutputNotFound: 12,
  12: "OutputNotFound",
  /**
   * r" The provided witness is not found in the transaction.
   */
  WitnessNotFound: 13,
  13: "WitnessNotFound",
  /**
   * r" The transaction maturity is not valid for this request.
   */
  TransactionMaturity: 14,
  14: "TransactionMaturity",
  /**
   * r" The metadata identifier is invalid.
   */
  InvalidMetadataIdentifier: 15,
  15: "InvalidMetadataIdentifier",
  /**
   * r" The call structure is not valid.
   */
  MalformedCallStructure: 16,
  16: "MalformedCallStructure",
  /**
   * r" The provided register does not allow write operations.
   */
  ReservedRegisterNotWritable: 17,
  17: "ReservedRegisterNotWritable",
  /**
   * r" The execution resulted in an erroneous state of the interpreter.
   */
  InvalidFlags: 18,
  18: "InvalidFlags",
  /**
   * r" The provided immediate value is not valid for this instruction.
   */
  InvalidImmediateValue: 19,
  19: "InvalidImmediateValue",
  /**
   * r" The provided transaction input is not of type `Coin`.
   */
  ExpectedCoinInput: 20,
  20: "ExpectedCoinInput",
  /**
   * r" `ECAL` instruction failed.
   */
  EcalError: 21,
  21: "EcalError",
  /**
   * r" Two segments of the interpreter memory should not intersect for write operations.
   */
  MemoryWriteOverlap: 22,
  22: "MemoryWriteOverlap",
  /**
   * r" The requested contract is not listed in the transaction inputs.
   */
  ContractNotInInputs: 23,
  23: "ContractNotInInputs",
  /**
   * r" The internal asset ID balance overflowed with the provided instruction.
   */
  InternalBalanceOverflow: 24,
  24: "InternalBalanceOverflow",
  /**
   * r" The maximum allowed contract size is violated.
   */
  ContractMaxSize: 25,
  25: "ContractMaxSize",
  /**
   * r" This instruction expects the stack area to be unallocated for this call.
   */
  ExpectedUnallocatedStack: 26,
  26: "ExpectedUnallocatedStack",
  /**
   * r" The maximum allowed number of static contracts was reached for this transaction.
   */
  MaxStaticContractsReached: 27,
  27: "MaxStaticContractsReached",
  /**
   * r" The requested transfer amount cannot be zero.
   */
  TransferAmountCannotBeZero: 28,
  28: "TransferAmountCannotBeZero",
  /**
   * r" The provided transaction output should be of type `Variable`.
   */
  ExpectedOutputVariable: 29,
  29: "ExpectedOutputVariable",
  /**
   * r" The expected context of the stack parent is internal.
   */
  ExpectedParentInternalContext: 30,
  30: "ExpectedParentInternalContext",
  /**
   * r" The predicate returned non `1`. The `1` means successful verification
   * r" of the predicate, all other values means unsuccessful.
   */
  PredicateReturnedNonOne: 31,
  31: "PredicateReturnedNonOne",
  /**
   * r" The contract ID is already deployed and can't be overwritten.
   */
  ContractIdAlreadyDeployed: 32,
  32: "ContractIdAlreadyDeployed",
  /**
   * r" The loaded contract mismatch expectations.
   */
  ContractMismatch: 33,
  33: "ContractMismatch",
  /**
   * r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
   */
  MessageDataTooLong: 34,
  34: "MessageDataTooLong",
  /**
   * r" Mathematically invalid arguments where given to an arithmetic instruction.
   * r" For instance, division by zero produces this.
   * r" These errors are ignored using the UNSAFEMATH flag.
   */
  ArithmeticError: 35,
  35: "ArithmeticError",
  /**
   * r" The contract instruction is not allowed in predicates.
   */
  ContractInstructionNotAllowed: 36,
  36: "ContractInstructionNotAllowed",
  /**
   * r" Transfer of zero coins is not allowed.
   */
  TransferZeroCoins: 37,
  37: "TransferZeroCoins",
  /**
   * r" Attempted to execute an invalid instruction
   */
  InvalidInstruction: 38,
  38: "InvalidInstruction",
  /**
   * r" Memory outside $is..$ssp range is not executable
   */
  MemoryNotExecutable: 39,
  39: "MemoryNotExecutable",
  /**
   * r" The policy is not set.
   */
  PolicyIsNotSet: 40,
  40: "PolicyIsNotSet",
  /**
   * r" The policy is not found across policies.
   */
  PolicyNotFound: 41,
  41: "PolicyNotFound",
  /**
   * r" Receipt context is full
   */
  TooManyReceipts: 42,
  42: "TooManyReceipts",
  /**
   * r" Balance of a contract overflowed
   */
  BalanceOverflow: 43,
  43: "BalanceOverflow",
  /**
   * r" Block height value is invalid, typically because it is too large
   */
  InvalidBlockHeight: 44,
  44: "InvalidBlockHeight",
  /**
   * r" Attempt to use sequential memory instructions with too large slot count,
   * r" typically because it cannot fit into usize
   */
  TooManySlots: 45,
  45: "TooManySlots",
  /**
   * r" Caller of this internal context is also expected to be internal,
   * r" i.e. $fp->$fp must be non-zero.
   */
  ExpectedNestedCaller: 46,
  46: "ExpectedNestedCaller",
  /**
   * r" During memory growth, the stack overlapped with the heap
   */
  MemoryGrowthOverlap: 47,
  47: "MemoryGrowthOverlap",
  /**
   * r" Attempting to read or write uninitialized memory.
   * r" Also occurs when boundary crosses from stack to heap.
   */
  UninitalizedMemoryAccess: 48,
  48: "UninitalizedMemoryAccess",
  /**
   * r" Overriding consensus parameters is not allowed.
   */
  OverridingConsensusParameters: 49,
  49: "OverridingConsensusParameters",
  /**
   * r" The storage doesn't know about the hash of the state transition bytecode.
   */
  UnknownStateTransactionBytecodeRoot: 50,
  50: "UnknownStateTransactionBytecodeRoot",
  /**
   * r" Overriding the state transition bytecode is not allowed.
   */
  OverridingStateTransactionBytecode: 51,
  51: "OverridingStateTransactionBytecode",
  /**
   * r" The bytecode is already uploaded and cannot be uploaded again.
   */
  BytecodeAlreadyUploaded: 52,
  52: "BytecodeAlreadyUploaded",
  /**
   * r" The part of the bytecode is not sequentially connected to the previous parts.
   */
  ThePartIsNotSequentiallyConnected: 53,
  53: "ThePartIsNotSequentiallyConnected",
  /**
   * r" The requested blob is not found.
   */
  BlobNotFound: 54,
  54: "BlobNotFound",
  /**
   * r" The blob was already
   */
  BlobIdAlreadyUploaded: 55,
  55: "BlobIdAlreadyUploaded",
  /**
   * r" Active gas costs do not define the cost for this instruction.
   */
  GasCostNotDefined: 56,
  56: "GasCostNotDefined",
  /**
   * r" The curve id is not supported.
   */
  UnsupportedCurveId: 57,
  57: "UnsupportedCurveId",
  /**
   * r" The operation type is not supported.
   */
  UnsupportedOperationType: 58,
  58: "UnsupportedOperationType",
  /**
   * r" Read alt_bn_128 curve point is invalid.
   */
  InvalidEllipticCurvePoint: 59,
  59: "InvalidEllipticCurvePoint",
  /**
   * r" Given input contract does not exist.
   */
  InputContractDoesNotExist: 60,
  60: "InputContractDoesNotExist",
  /**
   * r" Storage slot in Create not found
   */
  StorageSlotsNotFound: 61,
  61: "StorageSlotsNotFound",
  /**
   * r" Proof in Upload not found
   */
  ProofInUploadNotFound: 62,
  62: "ProofInUploadNotFound",
  /**
   * r" Invalid purpose type in Upgrade
   */
  InvalidUpgradePurposeType: 63,
  63: "InvalidUpgradePurposeType",
  /**
   * r" Cannot get gas price in predicate
   */
  CanNotGetGasPriceInPredicate: 64,
  64: "CanNotGetGasPriceInPredicate"
}), rA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_add_free(r >>> 0, 1));
class Wm {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, rA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_add_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, rA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const nA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_addi_free(r >>> 0, 1));
class Ym {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_addi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, nA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const sA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_aloc_free(r >>> 0, 1));
class Zm {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_aloc_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} bytes
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, sA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const iA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_and_free(r >>> 0, 1));
class Jm {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, iA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_and_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, iA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const aA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_andi_free(r >>> 0, 1));
class jm {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, aA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_andi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, aA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const oA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_bal_free(r >>> 0, 1));
class qm {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, oA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_bal_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} asset_id_addr
   * @param {RegId} contract_id_addr
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, oA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const cA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_bhei_free(r >>> 0, 1));
class $m {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_bhei_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, cA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const dA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_bhsh_free(r >>> 0, 1));
class Km {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_bhsh_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} heigth
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, dA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const uA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_bldd_free(r >>> 0, 1));
class ty {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, uA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_bldd_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_ptr
   * @param {RegId} blob_id_ptr
   * @param {RegId} offset
   * @param {RegId} len
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, uA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const AA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_bsiz_free(r >>> 0, 1));
class ey {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, AA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_bsiz_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} blob_id_ptr
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, AA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const lA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_burn_free(r >>> 0, 1));
class ry {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, lA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_burn_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} amount
   * @param {RegId} sub_id_addr
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, lA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const hA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_call_free(r >>> 0, 1));
class ny {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_call_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} target_struct
   * @param {RegId} fwd_coins
   * @param {RegId} asset_id_addr
   * @param {RegId} fwd_gas
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, hA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const _A = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_cb_free(r >>> 0, 1));
class sy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _A.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_cb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, _A.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const pA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ccp_free(r >>> 0, 1));
class iy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ccp_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} contract_id_addr
   * @param {RegId} offset
   * @param {RegId} len
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, pA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const fA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_cfe_free(r >>> 0, 1));
class ay {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_cfe_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} amount
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, fA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const gA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_cfei_free(r >>> 0, 1));
class oy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_cfei_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} amount
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, gA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const wA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_cfs_free(r >>> 0, 1));
class cy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_cfs_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} amount
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, wA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const mA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_cfsi_free(r >>> 0, 1));
class dy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, mA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_cfsi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} amount
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, mA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const yA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_croo_free(r >>> 0, 1));
class uy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_croo_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} contract_id_addr
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, yA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const bA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_csiz_free(r >>> 0, 1));
class Ay {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_csiz_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} contract_id_addr
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, bA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const IA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_compareargs_free(r >>> 0, 1));
class sn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(sn.prototype);
    return e.__wbg_ptr = t, IA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, IA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_compareargs_free(t, 0);
  }
  /**
   * Comparison mode
   * @returns {CompareMode}
   */
  get mode() {
    return c.__wbg_get_compareargs_mode(this.__wbg_ptr);
  }
  /**
   * Comparison mode
   * @param {CompareMode} arg0
   */
  set mode(t) {
    c.__wbg_set_compareargs_mode(this.__wbg_ptr, t);
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @returns {boolean}
   */
  get indirect_rhs() {
    return c.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr) !== 0;
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @param {boolean} arg0
   */
  set indirect_rhs(t) {
    c.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, t);
  }
  /**
   * Convert to immediate value.
   * @returns {Imm06}
   */
  to_imm() {
    const t = this.__destroy_into_raw(), e = c.compareargs_to_imm(t);
    return Nt.__wrap(e);
  }
  /**
   * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
   * @param {Imm06} bits
   * @returns {CompareArgs | undefined}
   */
  static from_imm(t) {
    w(t, Nt);
    var e = t.__destroy_into_raw();
    const n = c.compareargs_from_imm(e);
    return n === 0 ? void 0 : sn.__wrap(n);
  }
}
const CA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_div_free(r >>> 0, 1));
class ly {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, CA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_div_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, CA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const EA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_divi_free(r >>> 0, 1));
class hy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, EA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_divi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, EA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const _y = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_divargs_free(r >>> 0, 1));
class la {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _y.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_divargs_free(t, 0);
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @returns {boolean}
   */
  get indirect_rhs() {
    return c.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr) !== 0;
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @param {boolean} arg0
   */
  set indirect_rhs(t) {
    c.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, t);
  }
}
const BA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ecal_free(r >>> 0, 1));
class py {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, BA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ecal_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} a
   * @param {RegId} b
   * @param {RegId} c
   * @param {RegId} d
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, BA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const vA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_eck1_free(r >>> 0, 1));
class fy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_eck1_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} sig_addr
   * @param {RegId} msg_hash_addr
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, vA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const xA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ecop_free(r >>> 0, 1));
class gy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ecop_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} curve_id
   * @param {RegId} operation_type
   * @param {RegId} points_ptr
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, xA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const RA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ecr1_free(r >>> 0, 1));
class wy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, RA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ecr1_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} sig_addr
   * @param {RegId} msg_hash_addr
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, RA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const SA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ed19_free(r >>> 0, 1));
class my {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, SA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ed19_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} pub_key_addr
   * @param {RegId} sig_addr
   * @param {RegId} msg_addr
   * @param {RegId} msg_len
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, SA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const TA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_epar_free(r >>> 0, 1));
class yy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, TA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_epar_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} success
   * @param {RegId} curve_id
   * @param {RegId} number_elements
   * @param {RegId} points_ptr
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, TA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const FA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_eq_free(r >>> 0, 1));
class by {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, FA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_eq_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, FA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const NA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_exp_free(r >>> 0, 1));
class Iy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, NA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_exp_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, NA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const QA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_expi_free(r >>> 0, 1));
class Cy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, QA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_expi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, QA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const DA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_flag_free(r >>> 0, 1));
class Ey {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, DA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_flag_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} value
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, DA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Ic = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_gm_free(r >>> 0, 1));
class ja {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ja.prototype);
    return e.__wbg_ptr = t, Ic.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ic.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_gm_free(t, 0);
  }
  /**
   * Construct a `GM` instruction from its arguments.
   * @param {RegId} ra
   * @param {GMArgs} args
   * @returns {GM}
   */
  static from_args(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    const s = c.gm_from_args(n, e);
    return ja.__wrap(s);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {Imm18} selector
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.gm_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, Ic.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const OA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_gt_free(r >>> 0, 1));
class By {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, OA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_gt_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, OA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Cc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_gtf_free(r >>> 0, 1));
class qa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qa.prototype);
    return e.__wbg_ptr = t, Cc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_gtf_free(t, 0);
  }
  /**
   * Construct a `GTF` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {GTFArgs} args
   * @returns {GTF}
   */
  static from_args(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    const a = c.gtf_from_args(s, i, n);
    return qa.__wrap(a);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   * @param {Imm12} selector
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.gtf_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Cc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const MA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_imm06_free(r >>> 0, 1));
class Nt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Nt.prototype);
    return e.__wbg_ptr = t, MA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, MA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_imm06_free(t, 0);
  }
}
const PA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_imm12_free(r >>> 0, 1));
class dt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(dt.prototype);
    return e.__wbg_ptr = t, PA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, PA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_imm12_free(t, 0);
  }
}
const LA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_imm18_free(r >>> 0, 1));
class ke {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ke.prototype);
    return e.__wbg_ptr = t, LA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, LA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_imm18_free(t, 0);
  }
}
const kA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_imm24_free(r >>> 0, 1));
class Fe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fe.prototype);
    return e.__wbg_ptr = t, kA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, kA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_imm24_free(t, 0);
  }
}
const UA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_instruction_free(r >>> 0, 1));
class V {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(V.prototype);
    return e.__wbg_ptr = t, UA.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, UA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_instruction_free(t, 0);
  }
  /**
   * Convenience method for converting to bytes
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const s = c.__wbindgen_add_to_stack_pointer(-16);
      c.instruction_to_bytes(s, this.__wbg_ptr);
      var t = eA().getInt32(s + 4 * 0, !0), e = eA().getInt32(s + 4 * 1, !0), n = km(t, e).slice();
      return c.__wbindgen_export_0(t, e * 1, 1), n;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Size of an instruction in bytes
   * @returns {number}
   */
  static size() {
    return c.instruction_size() >>> 0;
  }
}
const GA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jal_free(r >>> 0, 1));
class vy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, GA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jal_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} ret_addr
   * @param {RegId} target
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, GA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const zA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ji_free(r >>> 0, 1));
class xy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ji_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} abs_target
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, zA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const XA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jmp_free(r >>> 0, 1));
class Ry {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, XA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jmp_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} abs_target
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, XA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const HA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jmpb_free(r >>> 0, 1));
class Sy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, HA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jmpb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dynamic
   * @param {Imm18} fixed
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.jmpb_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, HA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const VA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jmpf_free(r >>> 0, 1));
class Ty {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, VA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jmpf_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dynamic
   * @param {Imm18} fixed
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.jmpb_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, VA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const WA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jne_free(r >>> 0, 1));
class Fy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, WA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jne_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} abs_target
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, WA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const YA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jneb_free(r >>> 0, 1));
class Ny {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, YA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jneb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_lhs
   * @param {RegId} cond_rhs
   * @param {RegId} dynamic
   * @param {Imm06} fixed
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, YA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const ZA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jnef_free(r >>> 0, 1));
class Qy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ZA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jnef_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_lhs
   * @param {RegId} cond_rhs
   * @param {RegId} dynamic
   * @param {Imm06} fixed
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, ZA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const JA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jnei_free(r >>> 0, 1));
class Dy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, JA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jnei_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_lhs
   * @param {RegId} cond_rhs
   * @param {Imm12} abs_target
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, JA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const jA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jnzb_free(r >>> 0, 1));
class Oy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jnzb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_nz
   * @param {RegId} dynamic
   * @param {Imm12} fixed
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, jA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const qA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jnzf_free(r >>> 0, 1));
class My {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, qA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jnzf_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_nz
   * @param {RegId} dynamic
   * @param {Imm12} fixed
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, qA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const $A = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_jnzi_free(r >>> 0, 1));
class Py {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $A.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_jnzi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} cond_nz
   * @param {Imm18} abs_target
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.jmpb_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, $A.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const KA = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_k256_free(r >>> 0, 1));
class Ly {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, KA.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_k256_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} src_addr
   * @param {RegId} len
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, KA.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const tl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_lb_free(r >>> 0, 1));
class ky {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, tl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_lb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} addr
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, tl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const el = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ldc_free(r >>> 0, 1));
class Uy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, el.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ldc_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} src_addr
   * @param {RegId} offset
   * @param {RegId} len
   * @param {Imm06} mode
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, el.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const rl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_lhw_free(r >>> 0, 1));
class Gy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, rl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_lhw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, rl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const nl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_log_free(r >>> 0, 1));
class zy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_log_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} a
   * @param {RegId} b
   * @param {RegId} c
   * @param {RegId} d
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, nl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const sl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_logd_free(r >>> 0, 1));
class Xy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_logd_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} a
   * @param {RegId} b
   * @param {RegId} addr
   * @param {RegId} len
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, sl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const il = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_lqw_free(r >>> 0, 1));
class Hy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, il.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_lqw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, il.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const al = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_lt_free(r >>> 0, 1));
class Vy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, al.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_lt_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, al.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const ol = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_lw_free(r >>> 0, 1));
class Wy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ol.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_lw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} addr
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, ol.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const cl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mcl_free(r >>> 0, 1));
class Yy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mcl_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} len
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, cl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const dl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mcli_free(r >>> 0, 1));
class Zy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mcli_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} addr
   * @param {Imm18} count
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.jmpb_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, dl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const ul = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mcp_free(r >>> 0, 1));
class Jy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ul.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mcp_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} src_addr
   * @param {RegId} len
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, ul.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Al = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mcpi_free(r >>> 0, 1));
class jy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Al.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mcpi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} src_addr
   * @param {Imm12} len
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Al.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const ll = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_meq_free(r >>> 0, 1));
class qy {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ll.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_meq_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} result
   * @param {RegId} lhs_addr
   * @param {RegId} rhs_addr
   * @param {RegId} len
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, ll.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const hl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mint_free(r >>> 0, 1));
class $y {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mint_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} amount
   * @param {RegId} sub_id_addr
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, hl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const _l = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mldv_free(r >>> 0, 1));
class Ky {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _l.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mldv_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} mul_lhs
   * @param {RegId} mul_rhs
   * @param {RegId} divisor
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, _l.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const pl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mlog_free(r >>> 0, 1));
class tb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mlog_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, pl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const fl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mod_free(r >>> 0, 1));
class eb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mod_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, fl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const gl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_modi_free(r >>> 0, 1));
class rb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_modi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, gl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const wl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_move_free(r >>> 0, 1));
class nb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_move_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} src
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, wl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const ml = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_movi_free(r >>> 0, 1));
class sb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ml.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_movi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {Imm18} val
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, ke);
    var s = e.__destroy_into_raw();
    const i = c.jmpb_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, ml.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 18-bit immediate value.
   * @returns {Imm18}
   */
  imm18() {
    const t = c.gm_imm18(this.__wbg_ptr);
    return ke.__wrap(t);
  }
}
const yl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mroo_free(r >>> 0, 1));
class ib {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mroo_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, yl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const bl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mul_free(r >>> 0, 1));
class ab {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mul_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, bl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Il = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_muli_free(r >>> 0, 1));
class ob {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Il.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_muli_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Il.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const cb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mathargs_free(r >>> 0, 1));
class ha {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mathargs_free(t, 0);
  }
  /**
   * Create a new `MathArgs` instance from operation and width.
   * @param {NarrowMathOp} op
   * @param {OpWidth} width
   */
  constructor(t, e) {
    const n = c.mathargs_new(t, e);
    return Qi.__wrap(n);
  }
  /**
   * The operation to perform
   * @returns {MathOp}
   */
  get op() {
    return c.__wbg_get_mathargs_op(this.__wbg_ptr);
  }
  /**
   * The operation to perform
   * @param {MathOp} arg0
   */
  set op(t) {
    c.__wbg_set_mathargs_op(this.__wbg_ptr, t);
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @returns {boolean}
   */
  get indirect_rhs() {
    return c.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr) !== 0;
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @param {boolean} arg0
   */
  set indirect_rhs(t) {
    c.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, t);
  }
}
const db = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_mulargs_free(r >>> 0, 1));
class _a {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, db.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_mulargs_free(t, 0);
  }
  /**
   * Load LHSS from register if true, otherwise zero-extend register value
   * @returns {boolean}
   */
  get indirect_lhs() {
    return c.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr) !== 0;
  }
  /**
   * Load LHSS from register if true, otherwise zero-extend register value
   * @param {boolean} arg0
   */
  set indirect_lhs(t) {
    c.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, t);
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @returns {boolean}
   */
  get indirect_rhs() {
    return c.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr) !== 0;
  }
  /**
   * Load RHS from register if true, otherwise zero-extend register value
   * @param {boolean} arg0
   */
  set indirect_rhs(t) {
    c.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, t);
  }
}
const Ec = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_niop_free(r >>> 0, 1));
class $a {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($a.prototype);
    return e.__wbg_ptr = t, Ec.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ec.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_niop_free(t, 0);
  }
  /**
   * Construct a `NIOP` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {NarrowMathArgs} args
   * @returns {NIOP}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Qi);
    var d = s.__destroy_into_raw();
    const A = c.niop_from_args(i, a, o, d);
    return $a.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Ec.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const Cl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_noop_free(r >>> 0, 1));
class ub {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_noop_free(t, 0);
  }
  /**
   * Construct the instruction.
   */
  constructor() {
    const t = c.noop_new_typescript();
    return this.__wbg_ptr = t >>> 0, Cl.register(this, this.__wbg_ptr, this), this;
  }
}
const El = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_not_free(r >>> 0, 1));
class Ab {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, El.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_not_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, El.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Bl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_narrowmathargs_free(r >>> 0, 1));
class Qi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qi.prototype);
    return e.__wbg_ptr = t, Bl.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Bl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_narrowmathargs_free(t, 0);
  }
  /**
   * The operation to perform
   * @returns {NarrowMathOp}
   */
  get op() {
    return c.__wbg_get_narrowmathargs_op(this.__wbg_ptr);
  }
  /**
   * The operation to perform
   * @param {NarrowMathOp} arg0
   */
  set op(t) {
    c.__wbg_set_narrowmathargs_op(this.__wbg_ptr, t);
  }
  /**
   * Width of the operation
   * @returns {OpWidth}
   */
  get width() {
    return c.__wbg_get_narrowmathargs_width(this.__wbg_ptr);
  }
  /**
   * Width of the operation
   * @param {OpWidth} arg0
   */
  set width(t) {
    c.__wbg_set_narrowmathargs_width(this.__wbg_ptr, t);
  }
}
const vl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_or_free(r >>> 0, 1));
class lb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_or_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, vl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const xl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ori_free(r >>> 0, 1));
class hb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ori_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, xl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const Rl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_poph_free(r >>> 0, 1));
class _b {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_poph_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} bitmask
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Rl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const Sl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_popl_free(r >>> 0, 1));
class pb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_popl_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} bitmask
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Sl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const Tl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_pshh_free(r >>> 0, 1));
class fb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Tl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_pshh_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} bitmask
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Tl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const Fl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_pshl_free(r >>> 0, 1));
class gb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_pshl_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {Imm24} bitmask
   */
  constructor(t) {
    w(t, Fe);
    var e = t.__destroy_into_raw();
    const n = c.cfei_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Fl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the 24-bit immediate value.
   * @returns {Imm24}
   */
  imm24() {
    const t = c.cfei_imm24(this.__wbg_ptr);
    return Fe.__wrap(t);
  }
}
const Nl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_panicinstruction_free(r >>> 0, 1));
class wb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_panicinstruction_free(t, 0);
  }
  /**
   * Represents an error described by a reason and an instruction.
   * @param {PanicReason} reason
   * @param {number} instruction
   */
  constructor(t, e) {
    const n = c.panicinstruction_error_typescript(t, e);
    return this.__wbg_ptr = n >>> 0, Nl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Underlying panic reason
   * @returns {PanicReason}
   */
  reason() {
    return c.panicinstruction_reason(this.__wbg_ptr);
  }
  /**
   * Underlying instruction
   * @returns {number}
   */
  instruction() {
    return c.panicinstruction_instruction(this.__wbg_ptr) >>> 0;
  }
}
const Ql = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_ret_free(r >>> 0, 1));
class mb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ql.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_ret_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} value
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Ql.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Dl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_retd_free(r >>> 0, 1));
class yb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Dl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_retd_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} addr
   * @param {RegId} len
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, Dl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Ol = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_rvrt_free(r >>> 0, 1));
class bb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ol.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_rvrt_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} value
   */
  constructor(t) {
    w(t, h);
    var e = t.__destroy_into_raw();
    const n = c.aloc_new_typescript(e);
    return this.__wbg_ptr = n >>> 0, Ol.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.aloc_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Bc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_regid_free(r >>> 0, 1));
class h {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(h.prototype);
    return e.__wbg_ptr = t, Bc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Bc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_regid_free(t, 0);
  }
  /**
   * Construct a register ID from the given value.
   *
   * Returns `None` if the value is outside the 6-bit value range.
   * @param {number} u
   * @returns {RegId | undefined}
   */
  static new_checked(t) {
    const e = c.regid_new_checked(t);
    return e === 0 ? void 0 : h.__wrap(e);
  }
  /**
   * Received balance for this context.
   * @returns {RegId}
   */
  static bal() {
    const t = c.regid_bal();
    return h.__wrap(t);
  }
  /**
   * Remaining gas in the context.
   * @returns {RegId}
   */
  static cgas() {
    const t = c.regid_cgas();
    return h.__wrap(t);
  }
  /**
   * Error codes for particular operations.
   * @returns {RegId}
   */
  static err() {
    const t = c.regid_err();
    return h.__wrap(t);
  }
  /**
   * Flags register.
   * @returns {RegId}
   */
  static flag() {
    const t = c.regid_flag();
    return h.__wrap(t);
  }
  /**
   * Frame pointer. Memory address of beginning of current call frame.
   * @returns {RegId}
   */
  static fp() {
    const t = c.regid_fp();
    return h.__wrap(t);
  }
  /**
   * Remaining gas globally.
   * @returns {RegId}
   */
  static ggas() {
    const t = c.regid_ggas();
    return h.__wrap(t);
  }
  /**
   * Heap pointer. Memory address below the current bottom of the heap (points to free
   * memory).
   * @returns {RegId}
   */
  static hp() {
    const t = c.regid_hp();
    return h.__wrap(t);
  }
  /**
   * Instructions start. Pointer to the start of the currently-executing code.
   * @returns {RegId}
   */
  static is() {
    const t = c.regid_is();
    return h.__wrap(t);
  }
  /**
   * Contains overflow/underflow of addition, subtraction, and multiplication.
   * @returns {RegId}
   */
  static of() {
    const t = c.regid_of();
    return h.__wrap(t);
  }
  /**
   * Contains one (1), for convenience.
   * @returns {RegId}
   */
  static one() {
    const t = c.regid_one();
    return h.__wrap(t);
  }
  /**
   * The program counter. Memory address of the current instruction.
   * @returns {RegId}
   */
  static pc() {
    const t = c.regid_pc();
    return h.__wrap(t);
  }
  /**
   * Return value or pointer.
   * @returns {RegId}
   */
  static ret() {
    const t = c.regid_ret();
    return h.__wrap(t);
  }
  /**
   * Return value length in bytes.
   * @returns {RegId}
   */
  static retl() {
    const t = c.regid_retl();
    return h.__wrap(t);
  }
  /**
   * Stack pointer. Memory address on top of current writable stack area (points to
   * free memory).
   * @returns {RegId}
   */
  static sp() {
    const t = c.regid_sp();
    return h.__wrap(t);
  }
  /**
   * Stack start pointer. Memory address of bottom of current writable stack area.
   * @returns {RegId}
   */
  static spp() {
    const t = c.regid_spp();
    return h.__wrap(t);
  }
  /**
   * Smallest writable register.
   * @returns {RegId}
   */
  static writable() {
    const t = c.regid_writable();
    return h.__wrap(t);
  }
  /**
   * Contains zero (0), for convenience.
   * @returns {RegId}
   */
  static zero() {
    const t = c.regid_zero();
    return h.__wrap(t);
  }
  /**
   * Construct a register ID from the given value.
   *
   * The given value will be masked to 6 bits.
   * @param {number} u
   */
  constructor(t) {
    const e = c.regid_new_typescript(t);
    return this.__wbg_ptr = e >>> 0, Bc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * A const alternative to the `Into<u8>` implementation.
   * @returns {number}
   */
  to_u8() {
    const t = this.__destroy_into_raw();
    return c.regid_to_u8(t);
  }
}
const Ml = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_s256_free(r >>> 0, 1));
class Ib {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ml.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_s256_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} src_addr
   * @param {RegId} len
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Ml.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Pl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sb_free(r >>> 0, 1));
class Cb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Pl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sb_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} addr
   * @param {RegId} value
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Pl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const Ll = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_scwq_free(r >>> 0, 1));
class Eb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ll.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_scwq_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} key_addr
   * @param {RegId} status
   * @param {RegId} lenq
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Ll.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const kl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_shw_free(r >>> 0, 1));
class Bb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, kl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_shw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, kl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const Ul = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sll_free(r >>> 0, 1));
class vb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ul.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sll_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Ul.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Gl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_slli_free(r >>> 0, 1));
class xb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Gl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_slli_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Gl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const zl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_smo_free(r >>> 0, 1));
class Rb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_smo_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} recipient_addr
   * @param {RegId} data_addr
   * @param {RegId} data_len
   * @param {RegId} coins
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, zl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Xl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sqw_free(r >>> 0, 1));
class Sb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Xl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sqw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} arg
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Xl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const Hl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_srl_free(r >>> 0, 1));
class Tb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Hl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_srl_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Hl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Vl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_srli_free(r >>> 0, 1));
class Fb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Vl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_srli_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Vl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const Wl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_srw_free(r >>> 0, 1));
class Nb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Wl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_srw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} status
   * @param {RegId} key_addr
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Wl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Yl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_srwq_free(r >>> 0, 1));
class Qb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Yl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_srwq_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst_addr
   * @param {RegId} status
   * @param {RegId} key_addr
   * @param {RegId} lenq
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Yl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Zl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sub_free(r >>> 0, 1));
class Db {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Zl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sub_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Zl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Jl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_subi_free(r >>> 0, 1));
class Ob {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Jl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_subi_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, Jl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const jl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sw_free(r >>> 0, 1));
class Mb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sw_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} addr
   * @param {RegId} value
   * @param {Imm12} offset
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, jl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
const ql = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_sww_free(r >>> 0, 1));
class Pb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ql.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_sww_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} key_addr
   * @param {RegId} status
   * @param {RegId} value
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, ql.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const $l = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_swwq_free(r >>> 0, 1));
class Lb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $l.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_swwq_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} key_addr
   * @param {RegId} status
   * @param {RegId} src_addr
   * @param {RegId} lenq
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, $l.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Kl = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_time_free(r >>> 0, 1));
class kb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Kl.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_time_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} heigth
   */
  constructor(t, e) {
    w(t, h);
    var n = t.__destroy_into_raw();
    w(e, h);
    var s = e.__destroy_into_raw();
    const i = c.bhsh_new_typescript(n, s);
    return this.__wbg_ptr = i >>> 0, Kl.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const th = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_tr_free(r >>> 0, 1));
class Ub {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, th.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_tr_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} contract_id_addr
   * @param {RegId} amount
   * @param {RegId} asset_id_addr
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, th.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const eh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_tro_free(r >>> 0, 1));
class Gb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, eh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_tro_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} contract_id_addr
   * @param {RegId} output_index
   * @param {RegId} amount
   * @param {RegId} asset_id_addr
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, eh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const rh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdam_free(r >>> 0, 1));
class zb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, rh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdam_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} add_lhs
   * @param {RegId} add_rhs
   * @param {RegId} modulo
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, rh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const vc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdcm_free(r >>> 0, 1));
class Ka {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ka.prototype);
    return e.__wbg_ptr = t, vc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdcm_free(t, 0);
  }
  /**
   * Construct a `WDCM` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {CompareArgs} args
   * @returns {WDCM}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, sn);
    var d = s.__destroy_into_raw();
    const A = c.wdcm_from_args(i, a, o, d);
    return Ka.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, vc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const xc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wddv_free(r >>> 0, 1));
class to {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(to.prototype);
    return e.__wbg_ptr = t, xc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wddv_free(t, 0);
  }
  /**
   * Construct a `WDDV` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {DivArgs} args
   * @returns {WDDV}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, la);
    var d = s.__destroy_into_raw();
    const A = c.wddv_from_args(i, a, o, d);
    return to.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, xc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const nh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdmd_free(r >>> 0, 1));
class Xb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdmd_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} mul_lhs
   * @param {RegId} mul_rhs
   * @param {RegId} divisor
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, nh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Rc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdml_free(r >>> 0, 1));
class eo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(eo.prototype);
    return e.__wbg_ptr = t, Rc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdml_free(t, 0);
  }
  /**
   * Construct a `WDML` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {MulArgs} args
   * @returns {WDML}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, _a);
    var d = s.__destroy_into_raw();
    const A = c.wdml_from_args(i, a, o, d);
    return eo.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Rc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const sh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdmm_free(r >>> 0, 1));
class Hb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdmm_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} mul_lhs
   * @param {RegId} mul_rhs
   * @param {RegId} modulo
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, sh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Sc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wdop_free(r >>> 0, 1));
class ro {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ro.prototype);
    return e.__wbg_ptr = t, Sc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wdop_free(t, 0);
  }
  /**
   * Construct a `WDOP` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {MathArgs} args
   * @returns {WDOP}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, ha);
    var d = s.__destroy_into_raw();
    const A = c.wdop_from_args(i, a, o, d);
    return ro.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Sc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const ih = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqam_free(r >>> 0, 1));
class Vb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ih.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqam_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} add_lhs
   * @param {RegId} add_rhs
   * @param {RegId} modulo
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, ih.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Tc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqcm_free(r >>> 0, 1));
class no {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(no.prototype);
    return e.__wbg_ptr = t, Tc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Tc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqcm_free(t, 0);
  }
  /**
   * Construct a `WQCM` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {CompareArgs} args
   * @returns {WQCM}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, sn);
    var d = s.__destroy_into_raw();
    const A = c.wdcm_from_args(i, a, o, d);
    return no.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Tc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const Fc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqdv_free(r >>> 0, 1));
class so {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(so.prototype);
    return e.__wbg_ptr = t, Fc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqdv_free(t, 0);
  }
  /**
   * Construct a `WQDV` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {DivArgs} args
   * @returns {WQDV}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, la);
    var d = s.__destroy_into_raw();
    const A = c.wddv_from_args(i, a, o, d);
    return so.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Fc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const ah = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqmd_free(r >>> 0, 1));
class Wb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ah.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqmd_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} mul_lhs
   * @param {RegId} mul_rhs
   * @param {RegId} divisor
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, ah.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Nc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqml_free(r >>> 0, 1));
class io {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(io.prototype);
    return e.__wbg_ptr = t, Nc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqml_free(t, 0);
  }
  /**
   * Construct a `WQML` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {MulArgs} args
   * @returns {WQML}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, _a);
    var d = s.__destroy_into_raw();
    const A = c.wdml_from_args(i, a, o, d);
    return io.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Nc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const oh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqmm_free(r >>> 0, 1));
class Yb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, oh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqmm_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} mul_lhs
   * @param {RegId} mul_rhs
   * @param {RegId} modulo
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, h);
    var d = s.__destroy_into_raw();
    const A = c.bldd_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, oh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register D.
   * @returns {RegId}
   */
  rd() {
    const t = c.bldd_rd(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const Qc = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_wqop_free(r >>> 0, 1));
class ao {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ao.prototype);
    return e.__wbg_ptr = t, Qc.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Qc.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_wqop_free(t, 0);
  }
  /**
   * Construct a `WQOP` instruction from its arguments.
   * @param {RegId} ra
   * @param {RegId} rb
   * @param {RegId} rc
   * @param {MathArgs} args
   * @returns {WQOP}
   */
  static from_args(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, ha);
    var d = s.__destroy_into_raw();
    const A = c.wdop_from_args(i, a, o, d);
    return ao.__wrap(A);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   * @param {Imm06} flags
   */
  constructor(t, e, n, s) {
    w(t, h);
    var i = t.__destroy_into_raw();
    w(e, h);
    var a = e.__destroy_into_raw();
    w(n, h);
    var o = n.__destroy_into_raw();
    w(s, Nt);
    var d = s.__destroy_into_raw();
    const A = c.niop_new_typescript(i, a, o, d);
    return this.__wbg_ptr = A >>> 0, Qc.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 6-bit immediate value.
   * @returns {Imm06}
   */
  imm06() {
    const t = c.jneb_imm06(this.__wbg_ptr);
    return Nt.__wrap(t);
  }
}
const ch = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_xor_free(r >>> 0, 1));
class Zb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ch.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_xor_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {RegId} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, h);
    var a = n.__destroy_into_raw();
    const o = c.add_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, ch.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register C.
   * @returns {RegId}
   */
  rc() {
    const t = c.add_rc(this.__wbg_ptr);
    return h.__wrap(t);
  }
}
const dh = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((r) => c.__wbg_xori_free(r >>> 0, 1));
class Jb {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dh.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    c.__wbg_xori_free(t, 0);
  }
  /**
   * Construct the instruction from its parts.
   * @param {RegId} dst
   * @param {RegId} lhs
   * @param {Imm12} rhs
   */
  constructor(t, e, n) {
    w(t, h);
    var s = t.__destroy_into_raw();
    w(e, h);
    var i = e.__destroy_into_raw();
    w(n, dt);
    var a = n.__destroy_into_raw();
    const o = c.addi_new_typescript(s, i, a);
    return this.__wbg_ptr = o >>> 0, dh.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * Access the ID for register A.
   * @returns {RegId}
   */
  ra() {
    const t = c.add_ra(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the ID for register B.
   * @returns {RegId}
   */
  rb() {
    const t = c.add_rb(this.__wbg_ptr);
    return h.__wrap(t);
  }
  /**
   * Access the 12-bit immediate value.
   * @returns {Imm12}
   */
  imm12() {
    const t = c.addi_imm12(this.__wbg_ptr);
    return dt.__wrap(t);
  }
}
async function jb(r, t) {
  if (typeof Response == "function" && r instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(r, t);
      } catch (n) {
        if (r.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", n);
        else
          throw n;
      }
    const e = await r.arrayBuffer();
    return await WebAssembly.instantiate(e, t);
  } else {
    const e = await WebAssembly.instantiate(r, t);
    return e instanceof WebAssembly.Instance ? { instance: e, module: r } : e;
  }
}
function T_() {
  const r = {};
  return r.wbg = {}, r.wbg.__wbindgen_throw = function(t, e) {
    throw new Error(Fw(t, e));
  }, r;
}
function F_(r, t) {
  return c = r.exports, N_.__wbindgen_wasm_module = t, ln = null, Wi = null, c;
}
function qb(r) {
  if (c !== void 0) return c;
  typeof r < "u" && (Object.getPrototypeOf(r) === Object.prototype ? { module: r } = r : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const t = T_();
  r instanceof WebAssembly.Module || (r = new WebAssembly.Module(r));
  const e = new WebAssembly.Instance(r, t);
  return F_(e, r);
}
async function N_(r) {
  if (c !== void 0) return c;
  typeof r < "u" && (Object.getPrototypeOf(r) === Object.prototype ? { module_or_path: r } = r : console.warn("using deprecated parameters for the initialization function; pass a single object instead"));
  const t = T_(), { instance: e, module: n } = await jb(await r, t);
  return F_(e, n);
}
function $b(r, t, e, n) {
  var s = null, i = typeof process < "u" && process.versions != null && process.versions.node != null;
  if (i)
    s = Buffer.from(e, "base64");
  else {
    var a = globalThis.atob(e), o = a.length;
    s = new Uint8Array(new ArrayBuffer(o));
    for (var d = 0; d < o; d++)
      s[d] = a.charCodeAt(d);
  }
  {
    var A = new WebAssembly.Module(s);
    return A;
  }
}
function Kb(r) {
  return $b(1, null, "AGFzbQEAAAABQQtgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38Bf2ACf38AYAABf2AFf39/f38Bf2ABfwBgA39/fwBgBH9/f38AYAAAAhgBA3diZxBfX3diaW5kZ2VuX3Rocm93AAQDnAKaAgEDAQAEBAMEAwQDBAEBBAQEBAEJAQEBAQEDAQQEAQEEAgICAgICAgEBAQQDAgEBAQMDAwMDAwMDAQQEBAQEAAICAgMDAwMDAwMDAwMEBAADAQEEBAQDAgEAAAIEAQEEBAQEAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAQEBAQEBAQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcBAAEBAQMEAwYBBwcHAQEBAQEBBQEBAQEDAQEDAQYCAgYHBAQAAgAHAQgBAwEKBAEBBAcBBQQFBQUFBQUFBQUFBQUFBQUFBQUGBgYDAgIDAgYGAAAIAAQFAXABCAgFAwEAEQYJAX8BQYCAwAALB+NSigYGbWVtb3J5AgAZX193YmdfbmFycm93bWF0aGFyZ3NfZnJlZQA6G19fd2JnX2dldF9uYXJyb3dtYXRoYXJnc19vcABRG19fd2JnX3NldF9uYXJyb3dtYXRoYXJnc19vcABNHl9fd2JnX2dldF9uYXJyb3dtYXRoYXJnc193aWR0aABSHl9fd2JnX3NldF9uYXJyb3dtYXRoYXJnc193aWR0aABODG1hdGhhcmdzX25ldwBQFl9fd2JnX2NvbXBhcmVhcmdzX2ZyZWUAOxpfX3diZ19nZXRfY29tcGFyZWFyZ3NfbW9kZQBRGl9fd2JnX3NldF9jb21wYXJlYXJnc19tb2RlADwiX193YmdfZ2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwBSIl9fd2JnX3NldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMAVBJjb21wYXJlYXJnc190b19pbW0AWBRjb21wYXJlYXJnc19mcm9tX2ltbQAuFV9fd2JnX2dldF9tYXRoYXJnc19vcABRFV9fd2JnX3NldF9tYXRoYXJnc19vcAA9El9fd2JnX211bGFyZ3NfZnJlZQA+Hl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X3JocwBRHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwBVEl9fd2JnX2RpdmFyZ3NfZnJlZQBcHl9fd2JnX2dldF9kaXZhcmdzX2luZGlyZWN0X3JocwDSAR5fX3diZ19zZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAywEbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlABwhcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AFYXcGFuaWNpbnN0cnVjdGlvbl9yZWFzb24AXRxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAF4MZ21fZnJvbV9hcmdzAPABDWd0Zl9mcm9tX2FyZ3MA6QEHZ21fYXJncwDKAQhndGZfYXJncwCPAQ5uaW9wX2Zyb21fYXJncwBACW5pb3BfYXJncwAhDndkY21fZnJvbV9hcmdzAEEOd2RvcF9mcm9tX2FyZ3MAQQ53ZG1sX2Zyb21fYXJncwBCDndkZHZfZnJvbV9hcmdzAOMBCXdkY21fYXJncwAiCXdxY21fYXJncwAjCXdkb3BfYXJncwAkCXdxb3BfYXJncwAlCXdkbWxfYXJncwAmCXdxbWxfYXJncwAnCXdkZHZfYXJncwBjCXdxZHZfYXJncwBkEF9fd2JnX2ltbTA2X2ZyZWUAXxBfX3diZ19pbW0xMl9mcmVlAGAQX193YmdfaW1tMThfZnJlZQBhDl9fd2JnX2FkZF9mcmVlAB0PX193Ymdfbm9vcF9mcmVlABASYWRkX25ld190eXBlc2NyaXB0AFkGYWRkX3JhAC8GYWRkX3JiABcGYWRkX3JjAB4DYWRkAMYBA2FuZACQAQNkaXYAkQECZXEAkgEDZXhwAJMBAmd0AJQBAmx0AJUBBG1sb2cAlgEEbXJvbwCXAQRtb2RfAJgBBW1vdmVfAEMDbXVsAJkBA25vdABEAm9yAJoBA3NsbACbAQNzcmwAnAEDc3ViAJ0BA3hvcgCeAQRtbGR2AGUTbmlvcF9uZXdfdHlwZXNjcmlwdADkAQRuaW9wAGYDcmV0ANMBBHJldGQAMRNhbG9jX25ld190eXBlc2NyaXB0AIYBB2Fsb2NfcmEAKgRhbG9jANQBA21jbABFA21jcACfAQNtZXEAZxNiaHNoX25ld190eXBlc2NyaXB0ACwEYmhzaABGBGJoZWkA1QEEYnVybgBHBGNhbGwAaANjY3AAaQRjcm9vAEgEY3NpegBJAmNiANYBA2xkYwBqA2xvZwBrBGxvZ2QAbARtaW50ADIEcnZydADXAQRzY3dxAKABA3NydwChAQRzcndxAG0Dc3d3AKIBBHN3d3EAbgJ0cgCjAQN0cm8AbwRlY2sxAKQBBGVjcjEApQEEZWQxOQBwBGsyNTYApgEEczI1NgCnAQR0aW1lAEoTbm9vcF9uZXdfdHlwZXNjcmlwdADYAQRub29wAPkBBGZsYWcA2QEDYmFsAKgBA2ptcADaAQNqbmUAqQEDc21vAHETYWRkaV9uZXdfdHlwZXNjcmlwdABaCmFkZGlfaW1tMTIADQRhZGRpAKoBBGFuZGkAqwEEZGl2aQCsAQRleHBpAK0BBG1vZGkArgEEbXVsaQCvAQNvcmkAsAEEc2xsaQCxAQRzcmxpALIBBHN1YmkAswEEeG9yaQC0AQRqbmVpALUBAmxiALYBAmx3ALcBAnNiALgBAnN3ALkBBG1jcGkAugESZ3RmX25ld190eXBlc2NyaXB0AOsBA2d0ZgC7AQNscXcAvAEDbGh3AL0BA3NxdwC+AQNzaHcAvwEEbWNsaQAzEWdtX25ld190eXBlc2NyaXB0AEsIZ21faW1tMTgAEwJnbQA0BG1vdmkANQRqbnppADYEam1wZgA3E2ptcGJfbmV3X3R5cGVzY3JpcHQAGgRqbXBiADgEam56ZgDAAQRqbnpiAMEBBGpuZWYAcgpqbmViX2ltbTA2ADAEam5lYgBzAmppAIcBE2NmZWlfbmV3X3R5cGVzY3JpcHQAOQpjZmVpX2ltbTI0AA4EY2ZlaQCIAQRjZnNpAIkBA2NmZQDbAQNjZnMA3AEEcHNobACKAQRwc2hoAIsBBHBvcGwAjAEEcG9waACNAQNqYWwAwgEEd2RjbQB0BHdxY20AdQR3ZG9wAHYEd3FvcAB3BHdkbWwAeAR3cW1sAHkEd2RkdgB6BHdxZHYAewR3ZG1kAHwEd3FtZAB9BHdkYW0AfgR3cWFtAH8Ed2RtbQCAAQR3cW1tAIEBBGVjYWwAggEEYnNpegBME2JsZGRfbmV3X3R5cGVzY3JpcHQAVwdibGRkX3JkADAEYmxkZACDAQRlY29wAIQBBGVwYXIAhQEWX193YmdfaW5zdHJ1Y3Rpb25fZnJlZQASFGluc3RydWN0aW9uX3RvX2J5dGVzAAoQaW5zdHJ1Y3Rpb25fc2l6ZQCMAhFyZWdpZF9uZXdfY2hlY2tlZADOAQlyZWdpZF9iYWwA+wEKcmVnaWRfY2dhcwD8AQlyZWdpZF9lcnIA/QEKcmVnaWRfZmxhZwD+AQhyZWdpZF9mcAD/AQpyZWdpZF9nZ2FzAIACCHJlZ2lkX2hwAIECCHJlZ2lkX2lzAIICCHJlZ2lkX29mAIMCCXJlZ2lkX29uZQCEAghyZWdpZF9wYwCFAglyZWdpZF9yZXQAhgIKcmVnaWRfcmV0bACHAghyZWdpZF9zcACIAglyZWdpZF9zcHAAiQIOcmVnaWRfd3JpdGFibGUAigIKcmVnaWRfemVybwCLAhRyZWdpZF9uZXdfdHlwZXNjcmlwdAD0AQtyZWdpZF90b191OAD1ARJhbmRfbmV3X3R5cGVzY3JpcHQAWRJkaXZfbmV3X3R5cGVzY3JpcHQAWRFlcV9uZXdfdHlwZXNjcmlwdABZEmV4cF9uZXdfdHlwZXNjcmlwdABZEWd0X25ld190eXBlc2NyaXB0AFkRbHRfbmV3X3R5cGVzY3JpcHQAWRNtbG9nX25ld190eXBlc2NyaXB0AFkTbXJvb19uZXdfdHlwZXNjcmlwdABZEm1vZF9uZXdfdHlwZXNjcmlwdABZEm11bF9uZXdfdHlwZXNjcmlwdABZEW9yX25ld190eXBlc2NyaXB0AFkSc2xsX25ld190eXBlc2NyaXB0AFkSc3JsX25ld190eXBlc2NyaXB0AFkSc3ViX25ld190eXBlc2NyaXB0AFkSeG9yX25ld190eXBlc2NyaXB0AFkSbWNwX25ld190eXBlc2NyaXB0AFkTc2N3cV9uZXdfdHlwZXNjcmlwdABZEnNyd19uZXdfdHlwZXNjcmlwdABZEnN3d19uZXdfdHlwZXNjcmlwdABZEXRyX25ld190eXBlc2NyaXB0AFkTZWNrMV9uZXdfdHlwZXNjcmlwdABZE2VjcjFfbmV3X3R5cGVzY3JpcHQAWRNrMjU2X25ld190eXBlc2NyaXB0AFkTczI1Nl9uZXdfdHlwZXNjcmlwdABZEmJhbF9uZXdfdHlwZXNjcmlwdABZEmpuZV9uZXdfdHlwZXNjcmlwdABZE2FuZGlfbmV3X3R5cGVzY3JpcHQAWhNkaXZpX25ld190eXBlc2NyaXB0AFoTZXhwaV9uZXdfdHlwZXNjcmlwdABaE21vZGlfbmV3X3R5cGVzY3JpcHQAWhNtdWxpX25ld190eXBlc2NyaXB0AFoSb3JpX25ld190eXBlc2NyaXB0AFoTc2xsaV9uZXdfdHlwZXNjcmlwdABaE3NybGlfbmV3X3R5cGVzY3JpcHQAWhNzdWJpX25ld190eXBlc2NyaXB0AFoTeG9yaV9uZXdfdHlwZXNjcmlwdABaE2puZWlfbmV3X3R5cGVzY3JpcHQAWhFsYl9uZXdfdHlwZXNjcmlwdABaEWx3X25ld190eXBlc2NyaXB0AFoRc2JfbmV3X3R5cGVzY3JpcHQAWhFzd19uZXdfdHlwZXNjcmlwdABaE21jcGlfbmV3X3R5cGVzY3JpcHQAWhJscXdfbmV3X3R5cGVzY3JpcHQAWhJsaHdfbmV3X3R5cGVzY3JpcHQAWhJzcXdfbmV3X3R5cGVzY3JpcHQAWhJzaHdfbmV3X3R5cGVzY3JpcHQAWhNqbnpmX25ld190eXBlc2NyaXB0AFoTam56Yl9uZXdfdHlwZXNjcmlwdABaEmphbF9uZXdfdHlwZXNjcmlwdABaEWppX25ld190eXBlc2NyaXB0ADkTY2ZzaV9uZXdfdHlwZXNjcmlwdAA5E3BzaGxfbmV3X3R5cGVzY3JpcHQAORNwc2hoX25ld190eXBlc2NyaXB0ADkTcG9wbF9uZXdfdHlwZXNjcmlwdAA5E3BvcGhfbmV3X3R5cGVzY3JpcHQAORNtb3ZpX25ld190eXBlc2NyaXB0ABoTbWNsaV9uZXdfdHlwZXNjcmlwdAAaE2puemlfbmV3X3R5cGVzY3JpcHQAGhNqbXBmX25ld190eXBlc2NyaXB0ABoSbm90X25ld190eXBlc2NyaXB0ACwTcmV0ZF9uZXdfdHlwZXNjcmlwdAAsE21vdmVfbmV3X3R5cGVzY3JpcHQALBJtY2xfbmV3X3R5cGVzY3JpcHQALBNidXJuX25ld190eXBlc2NyaXB0ACwTY3Jvb19uZXdfdHlwZXNjcmlwdAAsE2NzaXpfbmV3X3R5cGVzY3JpcHQALBNtaW50X25ld190eXBlc2NyaXB0ACwTdGltZV9uZXdfdHlwZXNjcmlwdAAsE2JzaXpfbmV3X3R5cGVzY3JpcHQALBNtbGR2X25ld190eXBlc2NyaXB0AFcSbWVxX25ld190eXBlc2NyaXB0AFcSY2NwX25ld190eXBlc2NyaXB0AFcSbG9nX25ld190eXBlc2NyaXB0AFcTbG9nZF9uZXdfdHlwZXNjcmlwdABXE3Nyd3FfbmV3X3R5cGVzY3JpcHQAVxNzd3dxX25ld190eXBlc2NyaXB0AFcSdHJvX25ld190eXBlc2NyaXB0AFcTZWQxOV9uZXdfdHlwZXNjcmlwdABXEnNtb19uZXdfdHlwZXNjcmlwdABXEmxkY19uZXdfdHlwZXNjcmlwdABXE2puZWZfbmV3X3R5cGVzY3JpcHQAVxN3ZG1kX25ld190eXBlc2NyaXB0AFcTd3FtZF9uZXdfdHlwZXNjcmlwdABXE3dkYW1fbmV3X3R5cGVzY3JpcHQAVxN3cWFtX25ld190eXBlc2NyaXB0AFcTd2RtbV9uZXdfdHlwZXNjcmlwdABXE3dxbW1fbmV3X3R5cGVzY3JpcHQAVxNlY2FsX25ld190eXBlc2NyaXB0AFcTY2FsbF9uZXdfdHlwZXNjcmlwdABXE2Vjb3BfbmV3X3R5cGVzY3JpcHQAVxNlcGFyX25ld190eXBlc2NyaXB0AFcfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwBUHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X2xocwBUEnJldF9uZXdfdHlwZXNjcmlwdACGARNiaGVpX25ld190eXBlc2NyaXB0AIYBEWNiX25ld190eXBlc2NyaXB0AIYBE3J2cnRfbmV3X3R5cGVzY3JpcHQAhgETZmxhZ19uZXdfdHlwZXNjcmlwdACGARJqbXBfbmV3X3R5cGVzY3JpcHQAhgESY2ZlX25ld190eXBlc2NyaXB0AIYBEmNmc19uZXdfdHlwZXNjcmlwdACGAR5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9saHMAUh9fX3diZ19nZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAFITd3Fkdl9uZXdfdHlwZXNjcmlwdADkARN3cW1sX25ld190eXBlc2NyaXB0AOQBE3dkbWxfbmV3X3R5cGVzY3JpcHQA5AETd3FvcF9uZXdfdHlwZXNjcmlwdADkARN3ZG9wX25ld190eXBlc2NyaXB0AOQBE3dxY21fbmV3X3R5cGVzY3JpcHQA5AETd2Rkdl9uZXdfdHlwZXNjcmlwdADkARN3ZGNtX25ld190eXBlc2NyaXB0AOQBDndxb3BfZnJvbV9hcmdzAEEOd3FtbF9mcm9tX2FyZ3MAQg53cWR2X2Zyb21fYXJncwDjAQ53cWNtX2Zyb21fYXJncwBBE2puZWJfbmV3X3R5cGVzY3JpcHQAVxBfX3diZ19yZWdpZF9mcmVlAF8QX193YmdfaW1tMjRfZnJlZQBhE19fd2JnX21hdGhhcmdzX2ZyZWUAOw9fX3diZ19tb3ZpX2ZyZWUAHQ5fX3diZ190cm9fZnJlZQAdD19fd2JnX2xvZ2RfZnJlZQAdDl9fd2JnX2ptcF9mcmVlAB0PX193YmdfYW5kaV9mcmVlAB0OX193YmdfYmFsX2ZyZWUAHQ5fX3diZ19scXdfZnJlZQAdDl9fd2JnX2phbF9mcmVlAB0Gam1wX3JhACoPX193YmdfYmhlaV9mcmVlAB0PX193Ymdfc3JsaV9mcmVlAB0FY2JfcmEAKg1fX3diZ19jYl9mcmVlAB0OX193Ymdfc3JsX2ZyZWUAHQ9fX3diZ19tbG9nX2ZyZWUAHQ5fX3diZ19saHdfZnJlZQAdDl9fd2JnX2puZV9mcmVlAB0PX193YmdfbW9kaV9mcmVlAB0HcnZydF9yYQAqD19fd2JnX3J2cnRfZnJlZQAdD19fd2JnX2syNTZfZnJlZQAdDV9fd2JnX2VxX2ZyZWUAHQ1fX3diZ19sYl9mcmVlAB0PX193YmdfbW92ZV9mcmVlAB0NX193YmdfbHRfZnJlZQAdB2JoZWlfcmEAKg9fX3diZ19hbG9jX2ZyZWUAHQZyZXRfcmEAKg5fX3diZ19yZXRfZnJlZQAdDl9fd2JnX2d0Zl9mcmVlAB0PX193YmdfYnNpel9mcmVlAB0PX193YmdfZWNhbF9mcmVlAB0OX193YmdfbWVxX2ZyZWUAHQ9fX3diZ193cW1kX2ZyZWUAHQ5fX3diZ19zbGxfZnJlZQAdD19fd2JnX2JsZGRfZnJlZQAdDl9fd2JnX21jcF9mcmVlAB0PX193Ymdfam5lZl9mcmVlAB0OX193YmdfY2NwX2ZyZWUAHQ9fX3diZ19wb3BsX2ZyZWUAHQ9fX3diZ193cWFtX2ZyZWUAHQ1fX3diZ19nbV9mcmVlAB0PX193Ymdfd2RhbV9mcmVlAB0PX193YmdfY2FsbF9mcmVlAB0OX193Ymdfc21vX2ZyZWUAHQpwb3BsX2ltbTI0AA4NX193YmdfamlfZnJlZQAdDl9fd2JnX2FuZF9mcmVlAB0OX193YmdfZXhwX2ZyZWUAHQ1fX3diZ19sd19mcmVlAB0NX193Ymdfc2JfZnJlZQAdD19fd2JnX3MyNTZfZnJlZQAdDl9fd2JnX29yaV9mcmVlAB0NX193YmdfZ3RfZnJlZQAdD19fd2JnX21yb29fZnJlZQAdD19fd2JnX3dxZHZfZnJlZQAdD19fd2JnX3dkZHZfZnJlZQAdD19fd2JnX2puemJfZnJlZQAdDl9fd2JnX3hvcl9mcmVlAB0PX193YmdfZWQxOV9mcmVlAB0IamlfaW1tMjQADg9fX3diZ19jZnNpX2ZyZWUAHQ9fX3diZ19qbXBiX2ZyZWUAHQ5fX3diZ19zcXdfZnJlZQAdDl9fd2JnX3Nod19mcmVlAB0OX193YmdfbWNsX2ZyZWUAHQ9fX3diZ19lY29wX2ZyZWUAHQ9fX3diZ19qbmVpX2ZyZWUAHQ9fX3diZ19zd3dxX2ZyZWUAHQ5fX3diZ19zcndfZnJlZQAdDl9fd2JnX21vZF9mcmVlAB0PX193Ymdfd2RtbV9mcmVlAB0NX193YmdfdHJfZnJlZQAdDV9fd2JnX3N3X2ZyZWUAHQ5fX3diZ19sZGNfZnJlZQAdDl9fd2JnX3N3d19mcmVlAB0KY2ZzaV9pbW0yNAAOD19fd2JnX2NmZWlfZnJlZQAdD19fd2JnX3Nyd3FfZnJlZQAdD19fd2JnX2Nyb29fZnJlZQAdDV9fd2JnX29yX2ZyZWUAHQ5fX3diZ19sb2dfZnJlZQAdD19fd2JnX21sZHZfZnJlZQAdD19fd2JnX2J1cm5fZnJlZQAdD19fd2JnX211bGlfZnJlZQAdD19fd2JnX3dxbW1fZnJlZQAdB2ZsYWdfcmEAKg9fX3diZ19mbGFnX2ZyZWUAHQ9fX3diZ19qbnppX2ZyZWUAHQpwb3BoX2ltbTI0AA4PX193YmdfcG9waF9mcmVlAB0GY2ZzX3JhACoOX193YmdfY2ZzX2ZyZWUAHQ5fX3diZ19kaXZfZnJlZQAdCnBzaGxfaW1tMjQADg9fX3diZ19wc2hsX2ZyZWUAHQ5fX3diZ19zdWJfZnJlZQAdD19fd2JnX3N1YmlfZnJlZQAdD19fd2JnX2VwYXJfZnJlZQAdD19fd2JnX2NzaXpfZnJlZQAdD19fd2JnX25pb3BfZnJlZQAdCnBzaGhfaW1tMjQADg9fX3diZ19wc2hoX2ZyZWUAHQ5fX3diZ19ub3RfZnJlZQAdD19fd2JnX2puZWJfZnJlZQAdBmNmZV9yYQAqDl9fd2JnX2NmZV9mcmVlAB0PX193YmdfbWNsaV9mcmVlAB0PX193Ymdfd3FtbF9mcmVlAB0PX193YmdfYWRkaV9mcmVlAB0PX193YmdfYmhzaF9mcmVlAB0PX193YmdfZXhwaV9mcmVlAB0PX193Ymdfc2N3cV9mcmVlAB0PX193YmdfbWludF9mcmVlAB0PX193YmdfdGltZV9mcmVlAB0PX193YmdfeG9yaV9mcmVlAB0PX193Ymdfd2RvcF9mcmVlAB0PX193YmdfcmV0ZF9mcmVlAB0PX193Ymdfd3FvcF9mcmVlAB0PX193YmdfZWNrMV9mcmVlAB0PX193Ymdfc2xsaV9mcmVlAB0PX193Ymdfd2RtZF9mcmVlAB0PX193YmdfbWNwaV9mcmVlAB0PX193Ymdfam1wZl9mcmVlAB0PX193Ymdfd2RjbV9mcmVlAB0PX193Ymdfd2RtbF9mcmVlAB0PX193Ymdfam56Zl9mcmVlAB0PX193YmdfZWNyMV9mcmVlAB0OX193YmdfbXVsX2ZyZWUAHQ9fX3diZ193cWNtX2ZyZWUAHQ9fX3diZ19kaXZpX2ZyZWUAHQdtb3ZpX3JhAC8FZXFfcmIAFwVlcV9yYQAvB2xvZ2RfcmMAHgdsb2dkX3JiABcHbG9nZF9yYQAvCmFuZGlfaW1tMTIADQdhbmRpX3JiABcHYW5kaV9yYQAvBnRyb19yZAAwBnRyb19yYwAeBnRyb19yYgAXBnRyb19yYQAvCWxxd19pbW0xMgANBmxxd19yYgAXBmxxd19yYQAvCWphbF9pbW0xMgANBmphbF9yYgAXBmphbF9yYQAvCnNybGlfaW1tMTIADQdzcmxpX3JiABcHc3JsaV9yYQAvBnNybF9yYwAeBnNybF9yYgAXBnNybF9yYQAvB21sb2dfcmMAHgdtbG9nX3JiABcHbWxvZ19yYQAvCWxod19pbW0xMgANBmxod19yYgAXBmxod19yYQAvBmpuZV9yYwAeBmpuZV9yYgAXBmpuZV9yYQAvCm1vZGlfaW1tMTIADQdtb2RpX3JiABcHbW9kaV9yYQAvB2syNTZfcmMAHgdrMjU2X3JiABcHazI1Nl9yYQAvBWVxX3JjAB4GYmFsX3JiABcGYmFsX3JhAC8IbGJfaW1tMTIADQVsYl9yYgAXBWxiX3JhAC8HbW92ZV9yYgAXB21vdmVfcmEALwVsdF9yYwAeBWx0X3JiABcFbHRfcmEALwlndGZfaW1tMTIADQZndGZfcmIAFwZndGZfcmEALwdic2l6X3JiABcHYnNpel9yYQAvB2xvZ2RfcmQAMAdlY2FsX3JjAB4HZWNhbF9yYgAXB2VjYWxfcmEALwZtZXFfcmQAMAZtZXFfcmMAHgZtZXFfcmIAFwZtZXFfcmEALwd3cW1kX3JkADAHd3FtZF9yYwAeB3dxbWRfcmIAFwd3cW1kX3JhAC8Gc2xsX3JjAB4Gc2xsX3JiABcGc2xsX3JhAC8HZWNhbF9yZAAwB2JsZGRfcmMAHgdibGRkX3JiABcHYmxkZF9yYQAvBm1jcF9yYwAeBm1jcF9yYgAXBm1jcF9yYQAvB2puZWZfcmMAHgdqbmVmX3JiABcHam5lZl9yYQAvBmNjcF9yZAAwBmNjcF9yYwAeBmNjcF9yYgAXBmNjcF9yYQAvB3dxYW1fcmQAMAd3cWFtX3JjAB4Hd3FhbV9yYgAXB3dxYW1fcmEALwptb3ZpX2ltbTE4ABMFZ21fcmEALwd3ZGFtX3JkADAHd2RhbV9yYwAeB3dkYW1fcmIAFwd3ZGFtX3JhAC8HY2FsbF9yZAAwB2NhbGxfcmMAHgdjYWxsX3JiABcHY2FsbF9yYQAvBnNtb19yZAAwBnNtb19yYwAeBnNtb19yYgAXBnNtb19yYQAvBmJhbF9yYwAeBmFuZF9yYgAXBmFuZF9yYQAvBmV4cF9yYwAeBmV4cF9yYgAXBmV4cF9yYQAvCGx3X2ltbTEyAA0FbHdfcmIAFwVsd19yYQAvCHNiX2ltbTEyAA0Fc2JfcmIAFwVzYl9yYQAvB3MyNTZfcmMAHgdzMjU2X3JiABcHczI1Nl9yYQAvCW9yaV9pbW0xMgANBm9yaV9yYgAXBm9yaV9yYQAvBWd0X3JjAB4FZ3RfcmIAFwVndF9yYQAvB21yb29fcmMAHgdtcm9vX3JiABcHbXJvb19yYQAvCndxZHZfaW1tMDYAMAd3cWR2X3JjAB4Hd3Fkdl9yYgAXB3dxZHZfcmEALwp3ZGR2X2ltbTA2ADAHd2Rkdl9yYwAeB3dkZHZfcmIAFwd3ZGR2X3JhAC8Kam56Yl9pbW0xMgANB2puemJfcmIAFwdqbnpiX3JhAC8GeG9yX3JjAB4GeG9yX3JiABcGeG9yX3JhAC8HZWQxOV9yZAAwB2VkMTlfcmMAHgdlZDE5X3JiABcHZWQxOV9yYQAvCmptcGJfaW1tMTgAEwdqbXBiX3JhAC8Jc3F3X2ltbTEyAA0Gc3F3X3JiABcGc3F3X3JhAC8Jc2h3X2ltbTEyAA0Gc2h3X3JiABcGc2h3X3JhAC8GbWNsX3JiABcGbWNsX3JhAC8HZWNvcF9yZAAwB2Vjb3BfcmMAHgdlY29wX3JiABcHZWNvcF9yYQAvCmpuZWlfaW1tMTIADQdqbmVpX3JiABcHam5laV9yYQAvB3N3d3FfcmQAMAdzd3dxX3JjAB4Hc3d3cV9yYgAXB3N3d3FfcmEALwZzcndfcmMAHgZzcndfcmIAFwZzcndfcmEALwZtb2RfcmMAHgZtb2RfcmIAFwZtb2RfcmEALwd3ZG1tX3JkADAHd2RtbV9yYwAeB3dkbW1fcmIAFwd3ZG1tX3JhAC8FdHJfcmMAHgV0cl9yYgAXBXRyX3JhAC8Ic3dfaW1tMTIADQVzd19yYgAXBXN3X3JhAC8JbGRjX2ltbTA2ADAGbGRjX3JjAB4GbGRjX3JiABcGbGRjX3JhAC8Gc3d3X3JjAB4Gc3d3X3JiABcGc3d3X3JhAC8Hc3J3cV9yZAAwB3Nyd3FfcmMAHgdzcndxX3JiABcHc3J3cV9yYQAvB2Nyb29fcmIAFwdjcm9vX3JhAC8Fb3JfcmMAHgVvcl9yYgAXBW9yX3JhAC8GbG9nX3JkADAGbG9nX3JjAB4GbG9nX3JiABcGbG9nX3JhAC8HbWxkdl9yZAAwB21sZHZfcmMAHgdtbGR2X3JiABcHbWxkdl9yYQAvB2J1cm5fcmIAFwdidXJuX3JhAC8KbXVsaV9pbW0xMgANB211bGlfcmIAFwdtdWxpX3JhAC8Hd3FtbV9yZAAwB3dxbW1fcmMAHgd3cW1tX3JiABcHd3FtbV9yYQAvCmpuemlfaW1tMTgAEwdqbnppX3JhAC8GZGl2X3JjAB4GZGl2X3JiABcGZGl2X3JhAC8Gc3ViX3JjAB4Gc3ViX3JiABcGc3ViX3JhAC8Kc3ViaV9pbW0xMgANB3N1YmlfcmIAFwdzdWJpX3JhAC8HZXBhcl9yZAAwB2VwYXJfcmMAHgdlcGFyX3JiABcHZXBhcl9yYQAvB2NzaXpfcmIAFwdjc2l6X3JhAC8KbmlvcF9pbW0wNgAwB25pb3BfcmMAHgduaW9wX3JiABcHbmlvcF9yYQAvBm5vdF9yYgAXBm5vdF9yYQAvCmpuZWZfaW1tMDYAMAdqbmViX3JjAB4Ham5lYl9yYgAXB2puZWJfcmEALwptY2xpX2ltbTE4ABMHbWNsaV9yYQAvCndxbWxfaW1tMDYAMAd3cW1sX3JjAB4Hd3FtbF9yYgAXB3dxbWxfcmEALwZhbmRfcmMAHgdhZGRpX3JiABcHYWRkaV9yYQAvB2Joc2hfcmIAFwdiaHNoX3JhAC8KZXhwaV9pbW0xMgANB2V4cGlfcmIAFwdleHBpX3JhAC8Hc2N3cV9yYwAeB3Njd3FfcmIAFwdzY3dxX3JhAC8HbWludF9yYgAXB21pbnRfcmEALwd0aW1lX3JiABcHdGltZV9yYQAvCnhvcmlfaW1tMTIADQd4b3JpX3JiABcHeG9yaV9yYQAvCndkb3BfaW1tMDYAMAd3ZG9wX3JjAB4Hd2RvcF9yYgAXB3dkb3BfcmEALwdyZXRkX3JiABcHcmV0ZF9yYQAvCndxb3BfaW1tMDYAMAd3cW9wX3JjAB4Hd3FvcF9yYgAXB3dxb3BfcmEALwdlY2sxX3JjAB4HZWNrMV9yYgAXB2VjazFfcmEALwpzbGxpX2ltbTEyAA0Hc2xsaV9yYgAXB3NsbGlfcmEALwd3ZG1kX3JkADAHd2RtZF9yYwAeB3dkbWRfcmIAFwd3ZG1kX3JhAC8KbWNwaV9pbW0xMgANB21jcGlfcmIAFwdtY3BpX3JhAC8Kam1wZl9pbW0xOAATB2ptcGZfcmEALwp3ZGNtX2ltbTA2ADAHd2RjbV9yYwAeB3dkY21fcmIAFwd3ZGNtX3JhAC8Kd2RtbF9pbW0wNgAwB3dkbWxfcmMAHgd3ZG1sX3JiABcHd2RtbF9yYQAvCmpuemZfaW1tMTIADQdqbnpmX3JiABcHam56Zl9yYQAvB2VjcjFfcmMAHgdlY3IxX3JiABcHZWNyMV9yYQAvBm11bF9yYwAeBm11bF9yYgAXBm11bF9yYQAvCndxY21faW1tMDYAMAd3cWNtX3JjAB4Hd3FjbV9yYgAXB3dxY21fcmEALwpkaXZpX2ltbTEyAA0HZGl2aV9yYgAXB2RpdmlfcmEALx9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAPEBE19fd2JpbmRnZW5fZXhwb3J0XzAA7gEJEAEAQQELBwILCQf6AfYB5gEK2JgBmgL0IgIIfwF+AkACQAJAAkACQAJAAkAgAEH1AU8EQCAAQc3/e08NBSAAQQtqIgFBeHEhBUH8kMAAKAIAIghFDQRBHyEHQQAgBWshBCAAQfT//wdNBEAgBUEGIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEHCyAHQQJ0QeCNwABqKAIAIgJFBEBBACEAQQAhAQwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQNBACEBA0ACQCACKAIEQXhxIgYgBUkNACAGIAVrIgYgBE8NACACIQEgBiIEDQBBACEEIAEhAAwECyACKAIUIgYgACAGIAIgA0EddkEEcWpBEGooAgAiAkcbIAAgBhshACADQQF0IQMgAg0ACwwBC0H4kMAAKAIAIgJBECAAQQtqQfgDcSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiBUEDdCIAQfCOwABqIgMgAEH4jsAAaigCACIBKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H4kMAAIAJBfiAFd3E2AgALIAEgAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBCABQQhqDwsgBUGAkcAAKAIATQ0DAkACQCABRQRAQfyQwAAoAgAiAEUNBiAAaEECdEHgjcAAaigCACIBKAIEQXhxIAVrIQQgASECA0ACQCABKAIQIgANACABKAIUIgANACACKAIYIQcCQAJAIAIgAigCDCIARgRAIAJBFEEQIAIoAhQiABtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAJBFGogAkEQaiAAGyEDA0AgAyEGIAEiAEEUaiAAQRBqIAAoAhQiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQQgAiACKAIcQQJ0QeCNwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNBQwECyABIAA2AgAgAA0DQfyQwABB/JDAACgCAEF+IAIoAhx3cTYCAAwECyAAKAIEQXhxIAVrIgEgBCABIARJIgEbIQQgACACIAEbIQIgACEBDAALAAsCQEECIAB0IgNBACADa3IgASAAdHFoIgZBA3QiAEHwjsAAaiIDIABB+I7AAGooAgAiASgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtB+JDAACACQX4gBndxNgIACyABIAVBA3I2AgQgASAFaiIGIAAgBWsiBEEBcjYCBCAAIAFqIAQ2AgBBgJHAACgCACICBEAgAkF4cUHwjsAAaiEAQYiRwAAoAgAhAwJ/QfiQwAAoAgAiBUEBIAJBA3Z0IgJxRQRAQfiQwAAgAiAFcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIC0GIkcAAIAY2AgBBgJHAACAENgIAIAFBCGoPCyAAIAc2AhggAigCECIBBEAgACABNgIQIAEgADYCGAsgAigCFCIBRQ0AIAAgATYCFCABIAA2AhgLAkACQCAEQRBPBEAgAiAFQQNyNgIEIAIgBWoiBSAEQQFyNgIEIAQgBWogBDYCAEGAkcAAKAIAIgNFDQEgA0F4cUHwjsAAaiEAQYiRwAAoAgAhAQJ/QfiQwAAoAgAiBkEBIANBA3Z0IgNxRQRAQfiQwAAgAyAGcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELQYiRwAAgBTYCAEGAkcAAIAQ2AgALIAJBCGoPCyAAIAFyRQRAQQAhAUECIAd0IgBBACAAa3IgCHEiAEUNAyAAaEECdEHgjcAAaigCACEACyAARQ0BCwNAIAAgASAAKAIEQXhxIgMgBWsiBiAESSIHGyEIIAAoAhAiAkUEQCAAKAIUIQILIAEgCCADIAVJIgAbIQEgBCAGIAQgBxsgABshBCACIgANAAsLIAFFDQAgBUGAkcAAKAIAIgBNIAQgACAFa09xDQAgASgCGCEHAkACQCABIAEoAgwiAEYEQCABQRRBECABKAIUIgAbaigCACICDQFBACEADAILIAEoAggiAiAANgIMIAAgAjYCCAwBCyABQRRqIAFBEGogABshAwNAIAMhBiACIgBBFGogAEEQaiAAKAIUIgIbIQMgAEEUQRAgAhtqKAIAIgINAAsgBkEANgIACyAHRQ0DIAEgASgCHEECdEHgjcAAaiICKAIARwRAIAdBEEEUIAcoAhAgAUYbaiAANgIAIABFDQQMAwsgAiAANgIAIAANAkH8kMAAQfyQwAAoAgBBfiABKAIcd3E2AgAMAwsCQAJAAkACQAJAIAVBgJHAACgCACIBSwRAIAVBhJHAACgCACIATwRAQQAhBCAFQa+ABGoiAEEQdkAAIgFBf0YiAw0HIAFBEHQiAkUNB0GQkcAAQQAgAEGAgHxxIAMbIgRBkJHAACgCAGoiADYCAEGUkcAAQZSRwAAoAgAiASAAIAAgAUkbNgIAAkACQEGMkcAAKAIAIgMEQEHgjsAAIQADQCAAKAIAIgEgACgCBCIGaiACRg0CIAAoAggiAA0ACwwCC0GckcAAKAIAIgBBACAAIAJNG0UEQEGckcAAIAI2AgALQaCRwABB/x82AgBB5I7AACAENgIAQeCOwAAgAjYCAEH8jsAAQfCOwAA2AgBBhI/AAEH4jsAANgIAQfiOwABB8I7AADYCAEGMj8AAQYCPwAA2AgBBgI/AAEH4jsAANgIAQZSPwABBiI/AADYCAEGIj8AAQYCPwAA2AgBBnI/AAEGQj8AANgIAQZCPwABBiI/AADYCAEGkj8AAQZiPwAA2AgBBmI/AAEGQj8AANgIAQayPwABBoI/AADYCAEGgj8AAQZiPwAA2AgBBtI/AAEGoj8AANgIAQaiPwABBoI/AADYCAEHsjsAAQQA2AgBBvI/AAEGwj8AANgIAQbCPwABBqI/AADYCAEG4j8AAQbCPwAA2AgBBxI/AAEG4j8AANgIAQcCPwABBuI/AADYCAEHMj8AAQcCPwAA2AgBByI/AAEHAj8AANgIAQdSPwABByI/AADYCAEHQj8AAQciPwAA2AgBB3I/AAEHQj8AANgIAQdiPwABB0I/AADYCAEHkj8AAQdiPwAA2AgBB4I/AAEHYj8AANgIAQeyPwABB4I/AADYCAEHoj8AAQeCPwAA2AgBB9I/AAEHoj8AANgIAQfCPwABB6I/AADYCAEH8j8AAQfCPwAA2AgBBhJDAAEH4j8AANgIAQfiPwABB8I/AADYCAEGMkMAAQYCQwAA2AgBBgJDAAEH4j8AANgIAQZSQwABBiJDAADYCAEGIkMAAQYCQwAA2AgBBnJDAAEGQkMAANgIAQZCQwABBiJDAADYCAEGkkMAAQZiQwAA2AgBBmJDAAEGQkMAANgIAQayQwABBoJDAADYCAEGgkMAAQZiQwAA2AgBBtJDAAEGokMAANgIAQaiQwABBoJDAADYCAEG8kMAAQbCQwAA2AgBBsJDAAEGokMAANgIAQcSQwABBuJDAADYCAEG4kMAAQbCQwAA2AgBBzJDAAEHAkMAANgIAQcCQwABBuJDAADYCAEHUkMAAQciQwAA2AgBByJDAAEHAkMAANgIAQdyQwABB0JDAADYCAEHQkMAAQciQwAA2AgBB5JDAAEHYkMAANgIAQdiQwABB0JDAADYCAEHskMAAQeCQwAA2AgBB4JDAAEHYkMAANgIAQfSQwABB6JDAADYCAEHokMAAQeCQwAA2AgBBjJHAACACNgIAQfCQwABB6JDAADYCAEGEkcAAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQZiRwABBgICAATYCAAwICyACIANNIAEgA0tyDQAgACgCDEUNAwtBnJHAAEGckcAAKAIAIgAgAiAAIAJJGzYCACACIARqIQFB4I7AACEAAkACQANAIAEgACgCACIGRwRAIAAoAggiAA0BDAILCyAAKAIMRQ0BC0HgjsAAIQADQAJAIAMgACgCACIBTwRAIAMgASAAKAIEaiIGSQ0BCyAAKAIIIQAMAQsLQYyRwAAgAjYCAEGEkcAAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQZiRwABBgICAATYCACADIAZBIGtBeHFBCGsiACAAIANBEGpJGyIBQRs2AgRB4I7AACkCACEJIAFBEGpB6I7AACkCADcCACABIAk3AghB5I7AACAENgIAQeCOwAAgAjYCAEHojsAAIAFBCGo2AgBB7I7AAEEANgIAIAFBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgASADRg0HIAEgASgCBEF+cTYCBCADIAEgA2siAEEBcjYCBCABIAA2AgAgAEGAAk8EQCADIAAQCAwICyAAQfgBcUHwjsAAaiEBAn9B+JDAACgCACICQQEgAEEDdnQiAHFFBEBB+JDAACAAIAJyNgIAIAEMAQsgASgCCAshACABIAM2AgggACADNgIMIAMgATYCDCADIAA2AggMBwsgACACNgIAIAAgACgCBCAEajYCBCACIAVBA3I2AgQgBkEPakF4cUEIayIEIAIgBWoiA2shBSAEQYyRwAAoAgBGDQMgBEGIkcAAKAIARg0EIAQoAgQiAUEDcUEBRgRAIAQgAUF4cSIAEAYgACAFaiEFIAAgBGoiBCgCBCEBCyAEIAFBfnE2AgQgAyAFQQFyNgIEIAMgBWogBTYCACAFQYACTwRAIAMgBRAIDAYLIAVB+AFxQfCOwABqIQACf0H4kMAAKAIAIgFBASAFQQN2dCIEcUUEQEH4kMAAIAEgBHI2AgAgAAwBCyAAKAIICyEFIAAgAzYCCCAFIAM2AgwgAyAANgIMIAMgBTYCCAwFC0GEkcAAIAAgBWsiATYCAEGMkcAAQYyRwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEEDAYLQYiRwAAoAgAhAAJAIAEgBWsiAkEPTQRAQYiRwABBADYCAEGAkcAAQQA2AgAgACABQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELQYCRwAAgAjYCAEGIkcAAIAAgBWoiAzYCACADIAJBAXI2AgQgACABaiACNgIAIAAgBUEDcjYCBAsgAEEIag8LIAAgBCAGajYCBEGMkcAAQYyRwAAoAgAiAEEPakF4cSIBQQhrIgI2AgBBhJHAAEGEkcAAKAIAIARqIgMgACABa2pBCGoiATYCACACIAFBAXI2AgQgACADakEoNgIEQZiRwABBgICAATYCAAwDC0GMkcAAIAM2AgBBhJHAAEGEkcAAKAIAIAVqIgA2AgAgAyAAQQFyNgIEDAELQYiRwAAgAzYCAEGAkcAAQYCRwAAoAgAgBWoiADYCACADIABBAXI2AgQgACADaiAANgIACyACQQhqDwtBACEEQYSRwAAoAgAiACAFTQ0AQYSRwAAgACAFayIBNgIAQYyRwABBjJHAACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqDwsgBA8LIAAgBzYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQAgACACNgIUIAIgADYCGAsCQCAEQRBPBEAgASAFQQNyNgIEIAEgBWoiAiAEQQFyNgIEIAIgBGogBDYCACAEQYACTwRAIAIgBBAIDAILIARB+AFxQfCOwABqIQACf0H4kMAAKAIAIgNBASAEQQN2dCIEcUUEQEH4kMAAIAMgBHI2AgAgAAwBCyAAKAIICyEEIAAgAjYCCCAEIAI2AgwgAiAANgIMIAIgBDYCCAwBCyABIAQgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsgAUEIagueCgELfyAAKAIEIQggACgCACEGAkACQAJAIAEoAgAiAyABKAIIIgByBEACQCAAQQFxRQ0AIAYgCGohBAJAIAEoAgwiCUUEQCAGIQIMAQsgBiECA0AgAiIAIARGDQICfyAAQQFqIAAsAAAiAkEATg0AGiAAQQJqIAJBYEkNABogAEEDaiACQXBJDQAaIABBBGoLIgIgAGsgBWohBSAJIAdBAWoiB0cNAAsLIAIgBEYNACACLAAAGiAFIAgCfwJAIAVFDQAgBSAITwRAIAUgCEYNAUEADAILIAUgBmosAABBQE4NAEEADAELIAYLIgAbIQggACAGIAAbIQYLIANFDQMgASgCBCELIAhBEE8EQCAIIAYgBkEDakF8cSIFayIHaiIKQQNxIQlBACEDQQAhACAFIAZHBEAgB0F8TQRAQQAhBANAIAAgBCAGaiICLAAAQb9/SmogAkEBaiwAAEG/f0pqIAJBAmosAABBv39KaiACQQNqLAAAQb9/SmohACAEQQRqIgQNAAsLIAYhAgNAIAAgAiwAAEG/f0pqIQAgAkEBaiECIAdBAWoiBw0ACwsCQCAJRQ0AIAUgCkF8cWoiAiwAAEG/f0ohAyAJQQFGDQAgAyACLAABQb9/SmohAyAJQQJGDQAgAyACLAACQb9/SmohAwsgCkECdiEEIAAgA2ohAwNAIAUhByAERQ0EQcABIAQgBEHAAU8bIglBA3EhCiAJQQJ0IQVBACECIARBBE8EQCAHIAVB8AdxaiEMIAchAANAIAIgACgCACICQX9zQQd2IAJBBnZyQYGChAhxaiAAKAIEIgJBf3NBB3YgAkEGdnJBgYKECHFqIAAoAggiAkF/c0EHdiACQQZ2ckGBgoQIcWogACgCDCICQX9zQQd2IAJBBnZyQYGChAhxaiECIABBEGoiACAMRw0ACwsgBCAJayEEIAUgB2ohBSACQQh2Qf+B/AdxIAJB/4H8B3FqQYGABGxBEHYgA2ohAyAKRQ0ACyAHIAlB/AFxQQJ0aiICKAIAIgBBf3NBB3YgAEEGdnJBgYKECHEhACAKQQFGDQIgACACKAIEIgBBf3NBB3YgAEEGdnJBgYKECHFqIQAgCkECRg0CIAAgAigCCCIAQX9zQQd2IABBBnZyQYGChAhxaiEADAILIAhFBEBBACEDDAMLIAhBA3EhAgJAIAhBBEkEQEEAIQNBACEHDAELQQAhAyAGIQAgCEEMcSIHIQUDQCADIAAsAABBv39KaiAAQQFqLAAAQb9/SmogAEECaiwAAEG/f0pqIABBA2osAABBv39KaiEDIABBBGohACAFQQRrIgUNAAsLIAJFDQIgBiAHaiEAA0AgAyAALAAAQb9/SmohAyAAQQFqIQAgAkEBayICDQALDAILDAILIABBCHZB/4EccSAAQf+B/AdxakGBgARsQRB2IANqIQMLAkAgAyALSQRAIAsgA2shBAJAAkACQCABLQAYIgBBACAAQQNHGyIAQQFrDgIAAQILIAQhAEEAIQQMAQsgBEEBdiEAIARBAWpBAXYhBAsgAEEBaiEAIAEoAhAhByABKAIgIQIgASgCHCEBA0AgAEEBayIARQ0CIAEgByACKAIQEQMARQ0AC0EBDwsMAQsgASAGIAggAigCDBEAAARAQQEPC0EAIQADQCAAIARGBEBBAA8LIABBAWohACABIAcgAigCEBEDAEUNAAsgAEEBayAESQ8LIAEoAhwgBiAIIAEoAiAoAgwRAAALqAYBAX8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQYAEaw4mAQIDBAUGBwg7CQoLDA07Ozs7Ozs7Ozs7Ozs7Ozs7OzsODzs7OxAAC0EBIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBAWsODlIBAgMEBQZRBwgJCgsMAAsCQCAAQcAEaw4MJygpKissLS4vMDEyAAsCQCAAQYECaw4KDQ4PEBESExQVFgALAkAgAEGABmsOCTM0NTY3UVE4OQALAkAgAEGACmsOBjw9Pj9AQQALAkAgAEGADGsOBkJDREVGRwALAkAgAEGAEmsOBkpLTE1OTwALAkAgAEGACGsOAjo7AAsgAEGADmsOAkdITwtBAg8LQQMPC0EEDwtBBQ8LQQYPC0EHDwtBCQ8LQQoPC0ELDwtBDA8LQQ0PC0EODwtBgQIPC0GCAg8LQYMCDwtBhAIPC0GFAg8LQYYCDwtBhwIPC0GIAg8LQYkCDwtBigIPC0GABA8LQYEEDwtBggQPC0GDBA8LQYQEDwtBhQQPC0GGBA8LQYcEDwtBiQQPC0GKBA8LQYsEDwtBjAQPC0GNBA8LQaAEDwtBoQQPC0GlBA8LQcAEDwtBwQQPC0HCBA8LQcMEDwtBxAQPC0HFBA8LQcYEDwtBxwQPC0HIBA8LQckEDwtBygQPC0HLBA8LQYAGDwtBgQYPC0GCBg8LQYMGDwtBhAYPC0GHBg8LQYgGDwtBgAgPC0GBCA8LQYAKDwtBgQoPC0GCCg8LQYMKDwtBhAoPC0GFCg8LQYAMDwtBgQwPC0GCDA8LQYMMDwtBhAwPC0GFDA8LQYAODwtBgQ4PC0GAEg8LQYESDwtBghIPC0GDEg8LQYQSDwtBhRIhAQwCC0GAECEBIABBgBBGDQELQbyDwABBGRDzAQALIAEL5wMBCX9BASEHQStBgIDEACAAKAIUIgVBAXEiBBshCCAFQQRxQQJ2IQkCQAJAIAAoAgBFBEAgACgCHCIEIAAoAiAiACAIIAkQWw0BDAILIAAoAgQiCiACIARqIgNNBEAgACgCHCIEIAAoAiAiACAIIAkQWw0BDAILIAVBCHEEQCAAKAIQIQUgAEEwNgIQIAAtABghBCAAQQE6ABggACgCHCILIAAoAiAiBiAIIAkQWw0BIAogA2tBAWohAwJAA0AgA0EBayIDRQ0BIAtBMCAGKAIQEQMARQ0AC0EBDwsgCyABIAIgBigCDBEAAARAQQEPCyAAIAQ6ABggACAFNgIQQQAhBwwBCyAKIANrIQQCQAJAAkBBASAALQAYIgMgA0EDRhsiA0EBaw4CAAECCyAEIQNBACEEDAELIARBAXYhAyAEQQFqQQF2IQQLIANBAWohAyAAKAIQIQUgACgCICEGIAAoAhwhAAJAA0AgA0EBayIDRQ0BIAAgBSAGKAIQEQMARQ0AC0EBDwsgACAGIAggCRBbDQAgACABIAIgBigCDBEAAA0AQQAhAwNAIAMgBEYEQEEADwsgA0EBaiEDIAAgBSAGKAIQEQMARQ0ACyADQQFrIARJDwsgBw8LIAQgASACIAAoAgwRAAAL+QMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEGIkcAAKAIARgRAIAIoAgRBA3FBA0cNAUGAkcAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEAYLAkACQAJAIAIoAgQiA0ECcUUEQCACQYyRwAAoAgBGDQIgAkGIkcAAKAIARg0DIAIgA0F4cSICEAYgACABIAJqIgFBAXI2AgQgACABaiABNgIAIABBiJHAACgCAEcNAUGAkcAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQCA8LIAFB+AFxQfCOwABqIQICf0H4kMAAKAIAIgNBASABQQN2dCIBcUUEQEH4kMAAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQYyRwAAgADYCAEGEkcAAQYSRwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGIkcAAKAIARw0BQYCRwABBADYCAEGIkcAAQQA2AgAPC0GIkcAAIAA2AgBBgJHAAEGAkcAAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsL8QIBBH8gACgCDCECAkACQCABQYACTwRAIAAoAhghAwJAAkAgACACRgRAIABBFEEQIAAoAhQiAhtqKAIAIgENAUEAIQIMAgsgACgCCCIBIAI2AgwgAiABNgIIDAELIABBFGogAEEQaiACGyEEA0AgBCEFIAEiAkEUaiACQRBqIAIoAhQiARshBCACQRRBECABG2ooAgAiAQ0ACyAFQQA2AgALIANFDQIgACAAKAIcQQJ0QeCNwABqIgEoAgBHBEAgA0EQQRQgAygCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQfyQwABB/JDAACgCAEF+IAAoAhx3cTYCAAwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB+JDAAEH4kMAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYCwu8AgEGfyMAQRBrIgMkAEEKIQICQCAAKAIAIgBBkM4ASQRAIAAhBAwBCwNAIANBBmogAmoiBUEEayAAQZDOAG4iBEHwsQNsIABqIgZB//8DcUHkAG4iB0EBdEGUiMAAai8AADsAACAFQQJrIAdBnH9sIAZqQf//A3FBAXRBlIjAAGovAAA7AAAgAkEEayECIABB/8HXL0sgBCEADQALCwJAIARB4wBNBEAgBCEADAELIAJBAmsiAiADQQZqaiAEQf//A3FB5ABuIgBBnH9sIARqQf//A3FBAXRBlIjAAGovAAA7AAALAkAgAEEKTwRAIAJBAmsiAiADQQZqaiAAQQF0QZSIwABqLwAAOwAADAELIAJBAWsiAiADQQZqaiAAQTByOgAACyABIANBBmogAmpBCiACaxAEIANBEGokAAu6AgEEf0EfIQIgAEIANwIQIAFB////B00EQCABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQILIAAgAjYCHCACQQJ0QeCNwABqIQRBASACdCIDQfyQwAAoAgBxRQRAIAQgADYCACAAIAQ2AhggACAANgIMIAAgADYCCEH8kMAAQfyQwAAoAgAgA3I2AgAPCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEFA0AgAyAFQR12QQRxakEQaiIEKAIAIgJFDQIgBUEBdCEFIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAEIAA2AgAgACADNgIYIAAgADYCDCAAIAA2AggLgAIBBH8jAEEQayIDJAACQAJAIAAvAQAiAkGQzgBPBEBBASEEIAMgAiACQZDOAG4iAkHwsX9saiIFQf//A3FB5ABuIgBBAXRBlIjAAGovAAA7AAwgAyAAQZx/bCAFakH//wNxQQF0QZSIwABqLwAAOwAODAELQQUhBCACQeQATwRAIAMgAiACQeQAbiICQZx/bGpB//8DcUEBdEGUiMAAai8AADsADkEDIQQLIAJBCkkNACAEQQJrIgAgA0ELamogAkEBdEGUiMAAai8AADsAAAwBCyAEQQFrIgAgA0ELamogAkEwcjoAAAsgASADQQtqIABqQQUgAGsQBCADQRBqJAALyQEBBX8jAEEQayIEJAAgARDsASABQQhrIgUgBSgCAEEBaiICNgIAAkACQCACBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAhAkGpkcAALQAAGkEEQQEQ3QEhAyAEQQhqIgZBBDYCBCAGIAM2AgAgBCgCCCIDRQ0CIAMgAsBBAnRBlITAAGooAgAgAkGAfnFyNgAAIAEgASgCAEEBazYCACAFENABIABBBDYCBCAAIAM2AgAgBEEQaiQADwsACxDyAQALAAuaAQECfyMAQRBrIgMkAAJAAkACQCAALQAAIgJB5ABPBEAgAyACIAJB5ABuIgJBnH9sakH/AXFBAXRBlIjAAGovAAA7AA5BACEADAELQQIhACACQQpPDQELIANBDWogAGogAkEwcjoAAAwBC0EBIQAgAyACQQF0QZSIwABqLwAAOwAOCyABIANBDWogAGogAEEDcxAEIANBEGokAAt3AgF/AX4gARDsASABQQhrIgIoAgBBAUYEQCABKQIAIQMgAkEANgIAAkAgAkF/Rg0AIAFBBGsiASABKAIAQQFrIgE2AgAgAQ0AIAJBEBArCyAAIANCKIhCAYM8AAEgACADQiCIQgGDPAAADwtB1YPAAEE/EPMBAAt3AQJ/IwBBEGsiASQAIAFBBGogABAgIAEoAgQiAC8AACAAQQJqLQAAQRB0chD4ASECIAEoAgggASgCDBDnAUEQQQQQzAEiACACQQh2QYAecSACQRh2cjsBDCAAQQA2AgggAEKBgICAEDcCACABQRBqJAAgAEEIagtuAQJ/IAAQ7AEgAEEIayIBIAEoAgBBAWoiAjYCAAJAIAIEQCAAKAIAQX9GDQEgAC8ABCAAQQZqLQAAQRB0chD4ASEAIAEQzwEgAEEIdkGA/gNxIABBGHZyIABBgP4DcUEIdHIQyAEPCwALEPIBAAt0AgF/AX4gARDsASABQQhrIgIoAgBBAUYEQCABKQIAIQMgAkEANgIAAkAgAkF/Rg0AIAFBBGsiASABKAIAQQFrIgE2AgAgAQ0AIAJBEBArCyAAIANCKIg8AAEgACADQiCIQgGDPAAADwtB1YPAAEE/EPMBAAtzAQJ/IAAQ7AEgAEEIayICKAIAIQMCQCABRQRAIANBAUYEQCACQQA2AgAgAkF/Rg0CIABBBGsiACAAKAIAQQFrIgA2AgAgAA0CIAJBEBArDwtB1YPAAEE/EPMBAAsgAiADQQFrIgA2AgAgAA0AIAIQxAELC3ECAX8BfiABEOwBIAFBCGsiAigCAEEBRgRAIAEpAgAhAyACQQA2AgACQCACQX9GDQAgAUEEayIBIAEoAgBBAWsiATYCACABDQAgAkEQECsLIAAgA0IoiDwAASAAIANCIIg8AAAPC0HVg8AAQT8Q8wEAC2wBAX8gABDsASAAQQhrIQICQCABRQRAIAIoAgBBAUcNASAAKAIEIAJBADYCAAJAIAJBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACACQRAQKwsQ9wEPCyACENABDwtB1YPAAEE/EPMBAAtiAQF/IwBBEGsiASQAIAFBBGogABAgIAEoAgQiAC8AACAAQQJqLQAAQRB0chD4ASEAIAEoAgggASgCDBDnASAAQQh2QYD+A3EgAEEYdnIgAEGABnFBCHRyEMgBIAFBEGokAAt7AQF/IwBBEGsiAyQAQdyNwABB3I3AACgCACIEQQFqNgIAAkAgBEEASA0AAkBBqJHAAC0AAEUEQEGkkcAAQaSRwAAoAgBBAWo2AgBB2I3AACgCAEEATg0BDAILIANBCGogACABEQQAAAtBqJHAAEEAOgAAIAJFDQAACwALawEBfyMAQTBrIgEkACABIAA6AA8gAEH/AXFBwABPBEAgAUECNgIUIAFB0IHAADYCECABQgE3AhwgAUECNgIsIAEgAUEoajYCGCABIAFBD2o2AiggAUEQakHggcAAEI4BAAsgAUEwaiQAIAALbAEBfyMAQTBrIgEkACABIAA7AQ4gAEH//wNxQYAgTwRAIAFBAjYCFCABQZSCwAA2AhAgAUIBNwIcIAFBAzYCLCABIAFBKGo2AhggASABQQ5qNgIoIAFBEGpBpILAABCOAQALIAFBMGokACAAC18BAX8jAEEQayIBJAAgAUEEaiAAECAgASgCBCIALwAAIABBAmotAABBEHRyEPgBIQAgASgCCCABKAIMEOcBIABBCHZBgOADcSAAQYAGcUEIdHJBDHYQyQEgAUEQaiQACxUAIABB6ILAAEHYgsAAQYCAEBCUAgsWACAAQayDwABBnIPAAEGAgIAIEJQCC2ABAX8gABAfIQIgARApIQBBEEEEEMwBIgFCgYCAgBA3AgAgASAAQRB0QYCA/AdxIAAgAkH/AXFBEnRyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2cq1CIIY3AgggAUEIagtcAQJ/IAAQ7AEgAEEIayIBKAIAQQFGBEAgAC0ABCABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQECsLQQFxDwtB1YPAAEE/EPMBAAthAQF/IAAQ7AEgAEEIayECAkAgAUUEQCACKAIAQQFGBEAgAkEANgIAIAJBf0YNAiAAQQRrIgAgACgCAEEBayIANgIAIAANAiACQRQQKw8LQdWDwABBPxDzAQALIAIQ0QELC2EBAX8gABDsASAAQQhrIQICQCABRQRAIAIoAgBBAUYEQCACQQA2AgAgAkF/Rg0CIABBBGsiACAAKAIAQQFrIgA2AgAgAA0CIAJBEBArDwtB1YPAAEE/EPMBAAsgAhDPAQsLVgEBfyMAQRBrIgEkACABQQRqIAAQICABKAIEIgAvAAAgAEECai0AAEEQdHIQ+AEhACABKAIIIAEoAgwQ5wEgAEEOdkE8cSAAQR52chDJASABQRBqJAALWQECfyAAEOwBIABBCGsiASgCAEEBRgRAIAAtAAQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBArCw8LQdWDwABBPxDzAQALWQECfyABEOwBIAFBCGsiAyADKAIAQQFqIgI2AgACQCACBEAgASgCACICQX9GDQEgACADNgIIIAAgATYCBCAAIAFBBGo2AgAgASACQQFqNgIADwsACxDyAQALWQECfyMAQRBrIgQkACAEQQhqIAMQESAELQAJIQMgBC0ACCEFIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQ4QFB/wFxIAUgAxDlAUEIdEETchDtARDIASAEQRBqJAALEAAgACABIAIgA0HkABCVAgsQACAAIAEgAiADQeUAEJUCCxAAIAAgASACIANB5gAQlQILEAAgACABIAIgA0HnABCVAgsQACAAIAEgAiADQegAEJYCCxAAIAAgASACIANB6QAQlgILWQECfyAAEOwBIABBCGsiASgCAEEBRgRAIAAvAQQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBArCw8LQdWDwABBPxDzAQALWQECfyAAEOwBIABBCGsiASgCAEEBRgRAIAAoAgQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBArCw8LQdWDwABBPxDzAQALVQECfyAAEOwBIABBCGsiASABKAIAQQFqIgI2AgACQCACBEAgACgCAEF/Rg0BIAAvAAQgAEEGai0AAEEQdHIQ7wEgARDPAUH/AXEQyQEPCwALEPIBAAvOBgEEfwJAIABBBGsoAgAiBCICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgAEEIayIBIAQiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFBiJHAACgCAEYEQCACKAIEQQNxQQNHDQFBgJHAACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADAILIAEgAxAGCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJBjJHAACgCAEYNAiACQYiRwAAoAgBGDQMgAiADQXhxIgIQBiABIAAgAmoiAEEBcjYCBCAAIAFqIAA2AgAgAUGIkcAAKAIARw0BQYCRwAAgADYCAAwGCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQCEEAIQFBoJHAAEGgkcAAKAIAQQFrIgA2AgAgAA0EQeiOwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtBoJHAAEH/HyABIAFB/x9NGzYCAAwEC0GMkcAAIAE2AgBBhJHAAEGEkcAAKAIAIABqIgA2AgAgASAAQQFyNgIEQYiRwAAoAgAgAUYEQEGAkcAAQQA2AgBBiJHAAEEANgIACyAAQZiRwAAoAgAiA00NA0GMkcAAKAIAIgJFDQNBACEAQYSRwAAoAgAiBEEpSQ0CQeCOwAAhAQNAIAIgASgCACIFTwRAIAIgBSABKAIEakkNBAsgASgCCCEBDAALAAtBiJHAACABNgIAQYCRwABBgJHAACgCACAAaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMAgsgAEH4AXFB8I7AAGohAgJ/QfiQwAAoAgAiA0EBIABBA3Z0IgBxRQRAQfiQwAAgACADcjYCACACDAELIAIoAggLIQAgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDAELQeiOwAAoAgAiAQRAA0AgAEEBaiEAIAEoAggiAQ0ACwtBoJHAAEH/HyAAIABB/x9NGzYCACADIARPDQBBmJHAAEF/NgIACw8LQYWKwABBtIrAABBTAAtBxIrAAEH0isAAEFMAC1cBAX8gABAfIQIgARAfIQFBEEEEEMwBIgBCgYCAgBA3AgAgACABQf8BcUEMdCACQRJ0ciIBQYDgA3FBCHQgAUEIdkGA/gNxckEIdq1CIIY3AgggAEEIagtMACADQf8BcSABQf8BcUEMdCAAQf8BcUESdHIiACACQf8BcUEGdHJyIgFBEHRBgID8B3EgAEEIdkGA/gNxIAFBgP4DcUEIdHJBCHZyC04BAn8CQCAAEB8iAEEYcQ0AIABBB3EiAkEHRg0AQRBBBBDMASIBQoGAgIAQNwIAIAEgAq1CKIYgAK1CIINCG4aENwIIIAFBCGohAQsgAQtKAQF/IwBBEGsiASQAIAFBBGogABAgIAEoAgQiAC8AACAAQQJqLQAAQRB0chDvASABKAIIIAEoAgwQ5wFB/wFxEMkBIAFBEGokAAtMAQF/IwBBEGsiASQAIAFBBGogABAgIAEoAgQiAC8AACAAQQJqLQAAQRB0chD4AUEYdkE/cSABKAIIIAEoAgwQ5wEQyQEgAUEQaiQACw8AIAAgAUGAgICoARCXAgsPACAAIAFBgICAqAIQlwILDAAgACABQdAAEJgCCwwAIAAgAUHRABCYAgsMACAAIAFB0gAQmAILDAAgACABQdMAEJgCCwwAIAAgAUHUABCYAgsMACAAIAFB1QAQmAILTgEBfyAAECkhAEEQQQQQzAEiAUKBgICAEDcCACABIABBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyrUIghjcCCCABQQhqC0oBAX8jAEEQayICJAACQCABRQRAIAJBCGogABARDAELIAAQ7AEgAEEIayIAIAAoAgBBAWsiATYCACABDQAgABDEAQsgAkEQaiQAC0oBAX8jAEEQayICJAACQCABRQRAIAJBCGogABAPDAELIAAQ7AEgAEEIayIAIAAoAgBBAWsiATYCACABDQAgABDEAQsgAkEQaiQACwsAIAAgAUEHEJkCCwsAIAAgAUEIEJkCC0oBAX8jAEEQayICJAACQCABRQRAIAJBCGogABAMDAELIAAQ7AEgAEEIayIAIAAoAgBBAWsiATYCACABDQAgABDEAQsgAkEQaiQACz8AIAJBFnRBgICABnEgAUH/AXFBDHQiASACQfwBcUEGdHJBgP4DcUEIdCABIABBEnRyQQh2QYD+A3FyQQh2cgs5AQF/IwBBEGsiBCQAIAAQHyABEB8gAhAfIARBCGogAxARIAQtAAggBC0ACRDlARDFASAEQRBqJAALOQEBfyMAQRBrIgQkACAAEB8gARAfIAIQHyAEQQhqIAMQDyAELQAIIAQtAAkQ4gEQxQEgBEEQaiQACzkBAX8jAEEQayIEJAAgABAfIAEQHyACEB8gBEEIaiADEAwgBC0ACCAELQAJEM0BEMUBIARBEGokAAsLACAAIAFBChCaAgsLACAAIAFBDBCaAgsLACAAIAFBFxCaAgsLACAAIAFBGhCaAgsLACAAIAFBHBCaAgsLACAAIAFBHxCaAgsLACAAIAFBIBCaAgsLACAAIAFBMxCaAgs/ACAAEB8hACABECkiAUEQdEGAgPwHcSAAQf8BcUESdCABciIAQYD+A3FBCHQgAEEIdkGA/gNxckEIdnIQxQELDAAgACABQfMAEJoCCz4BAX8jAEEQayICJAAgABDsASABEN4BIQEgAkEIaiAAEMMBIAIoAgwgAigCCCABOgABQQA2AgAgAkEQaiQACz4BAX8jAEEQayICJAAgABDsASABEN8BIQEgAkEIaiAAEMMBIAIoAgwgAigCCCABOgAAQQA2AgAgAkEQaiQACzgAIAJBEHRBgID8B3EgAUH/AXFBDHQiASACckGA/gNxQQh0IAEgAEESdHJBCHZBgP4DcXJBCHZyC0MBAX8gABDeASECIAEQ3wEhAUEQQQQQzAEiAEKBgICAEDcCACAAIAFB/wFxrUIghiACQf8Bca1CKIaENwIIIABBCGoLPAECfyMAQRBrIgEkACAAEOwBIAFBCGogABBiIAEoAggtAAEgASgCDCICIAIoAgBBAWs2AgAgAUEQaiQACzwBAn8jAEEQayIBJAAgABDsASABQQhqIAAQYiABKAIILQAAIAEoAgwiAiACKAIAQQFrNgIAIAFBEGokAAtCAQF/IwBBIGsiAiQAIAJBADYCECACQQE2AgQgAkIENwIIIAJBLjYCHCACIAA2AhggAiACQRhqNgIAIAIgARCOAQALOgEBfyMAQRBrIgIkACAAEOwBIAJBCGogABDDASACKAIMIAIoAgggAUEARzoAAEEANgIAIAJBEGokAAs6AQF/IwBBEGsiAiQAIAAQ7AEgAkEIaiAAEMMBIAIoAgwgAigCCCABQQBHOgABQQA2AgAgAkEQaiQAC0QBAX8gAEHBAE8EQEG8g8AAQRkQ8wEAC0EUQQQQzAEiAiAAOgAQIAIgATYCDCACQQA2AgggAkKBgICAEDcCACACQQhqCz4AIAAQHyABEB8gAhAfIAMQHxAtIQFBEEEEEMwBIgBCgYCAgBA3AgAgACABrUL///8Hg0IghjcCCCAAQQhqCzABAX8jAEEQayIBJAAgAUEIaiAAEA8gAS0ACUEgQQAgAS0ACBtyEMkBIAFBEGokAAs6ACAAEB8gARAfIAIQHxA/IQFBEEEEEMwBIgBCgYCAgBA3AgAgACABrUL///8Hg0IghjcCCCAAQQhqCzoAIAAQHyABEB8gAhAoEE8hAUEQQQQQzAEiAEKBgICAEDcCACAAIAGtQv///weDQiCGNwIIIABBCGoLOAACQCACQYCAxABGDQAgACACIAEoAhARAwBFDQBBAQ8LIANFBEBBAA8LIAAgA0EAIAEoAgwRAAALMgAgAUUEQCAAEBsaDwsgABDsASAAQQhrIgAgACgCAEEBayIBNgIAIAFFBEAgABDEAQsLMgEBfyMAQRBrIgEkACABQQRqIAAQICABKAIELQAEIAEoAgggASgCDBDoASABQRBqJAALMgEBfyMAQRBrIgEkACABQQRqIAAQICABKAIEKAIAIAEoAgggASgCDBDoASABQRBqJAALMgAgAUUEQCAAEB8aDwsgABDsASAAQQhrIgAgACgCAEEBayIBNgIAIAFFBEAgABDEAQsLMgAgAUUEQCAAECgaDwsgABDsASAAQQhrIgAgACgCAEEBayIBNgIAIAFFBEAgABDEAQsLMgAgAUUEQCAAECkaDwsgABDsASAAQQhrIgAgACgCAEEBayIBNgIAIAFFBEAgABDEAQsLMQEBfyABKAIAIgJBf0cEQCABIAJBAWo2AgAgACABNgIEIAAgAUEEajYCAA8LEPIBAAsQACAAIAEgAiADQeoAEI0CCxAAIAAgASACIANB6wAQjQILDwAgACABIAIgA0ESEI4CCw8AIAAgASACIANBExCPAgsPACAAIAEgAiADQRkQjgILDwAgACABIAIgA0EdEI4CCw8AIAAgASACIANBHhCOAgsPACAAIAEgAiADQSIQjwILDwAgACABIAIgA0EjEI4CCw8AIAAgASACIANBJBCOAgsPACAAIAEgAiADQSkQjgILDwAgACABIAIgA0ErEI4CCw8AIAAgASACIANBLRCOAgsPACAAIAEgAiADQTAQjgILDwAgACABIAIgA0E5EI4CCxAAIAAgASACIANB2AAQjwILEAAgACABIAIgA0HZABCPAgsQACAAIAEgAiADQeQAEI8CCxAAIAAgASACIANB5QAQjwILEAAgACABIAIgA0HmABCPAgsQACAAIAEgAiADQecAEI8CCxAAIAAgASACIANB6AAQjwILEAAgACABIAIgA0HpABCPAgsQACAAIAEgAiADQeoAEI8CCxAAIAAgASACIANB6wAQjwILEAAgACABIAIgA0HsABCOAgsQACAAIAEgAiADQe0AEI4CCxAAIAAgASACIANB7gAQjgILEAAgACABIAIgA0HvABCOAgsQACAAIAEgAiADQfAAEI4CCxAAIAAgASACIANB8QAQjgILEAAgACABIAIgA0HyABCOAgsQACAAIAEgAiADQfQAEI4CCxAAIAAgASACIANB9QAQjgILEAAgACABIAIgA0H2ABCOAgszAQF/IAAQHyEBQRBBBBDMASIAQoGAgIAQNwIAIAAgAUECdEH8AXGtQiCGNwIIIABBCGoLCgAgAEHaABCQAgsKACAAQdsAEJACCwoAIABB3AAQkAILCgAgAEHfABCQAgsKACAAQeAAEJACCwoAIABB4QAQkAILCgAgAEHiABCQAgvqAQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQQUgASgCCCIALQAIIAAtAAkQFAALIAAgAzYCBCAAIAI2AgAgAEEGIAEoAggiAC0ACCAALQAJEBQACysAIAIQAyECIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQT0EIdEHLAHIQ7QEQyAELDQAgACABIAJBARCRAgsNACAAIAEgAkECEJECCw0AIAAgASACQQMQkQILDQAgACABIAJBBBCRAgsNACAAIAEgAkEFEJECCw0AIAAgASACQQYQkQILDQAgACABIAJBBxCRAgsNACAAIAEgAkEIEJECCw0AIAAgASACQQkQkQILDQAgACABIAJBCxCRAgsNACAAIAEgAkENEJECCw0AIAAgASACQQ4QkQILDQAgACABIAJBDxCRAgsNACAAIAEgAkEQEJECCw0AIAAgASACQREQkQILDQAgACABIAJBGBCRAgsNACAAIAEgAkEnEJECCw0AIAAgASACQSgQkQILDQAgACABIAJBKhCRAgsNACAAIAEgAkEsEJECCw0AIAAgASACQS4QkQILDQAgACABIAJBLxCRAgsNACAAIAEgAkExEJECCw0AIAAgASACQTIQkQILDQAgACABIAJBNhCRAgsNACAAIAEgAkE4EJECCw0AIAAgASACQToQkgILDQAgACABIAJBOxCSAgsNACAAIAEgAkE8EJICCw0AIAAgASACQT0QkgILDQAgACABIAJBPhCSAgsNACAAIAEgAkE/EJICCw4AIAAgASACQcAAEJICCw4AIAAgASACQcEAEJICCw4AIAAgASACQcIAEJICCw4AIAAgASACQcMAEJICCw4AIAAgASACQcQAEJICCw4AIAAgASACQcUAEJICCw4AIAAgASACQcYAEJICCw4AIAAgASACQccAEJICCw4AIAAgASACQcgAEJICCw4AIAAgASACQckAEJICCw4AIAAgASACQcoAEJICCw4AIAAgASACQcsAEJICCw4AIAAgASACQcwAEJICCw4AIAAgASACQc0AEJICCw4AIAAgASACQc4AEJICCw4AIAAgASACQc8AEJICCw4AIAAgASACQdYAEJICCw4AIAAgASACQdcAEJICCw4AIAAgASACQeMAEJICCygAIAEoAgBFBEAgAUF/NgIAIAAgATYCBCAAIAFBBGo2AgAPCxDyAQALJwEBfwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEEQECsLCywBAX9BEEEEEMwBIgFCgYCAgBA3AgAgASAArUL///8Hg0IghjcCCCABQQhqCygAIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQ4QFB/wFxED9BCHQQ7QEQyAELIAAgAEEBayIAQQZNBEAgAEEBag8LQbyDwABBGRDzAQALKQEBf0EQQQQQzAEiASAANgIMIAFBADYCCCABQoGAgIAQNwIAIAFBCGoLKQEBf0EQQQQQzAEiASAAOgAMIAFBADYCCCABQoGAgIAQNwIAIAFBCGoLJAAgARDHASEBIAAQ4QFB/wFxIAEQ4AFBCHRB0QByEO0BEMgBCx0AIAAQ7AEgACgCAARAEPIBAAsgACABQQBHOgAECxsAQamRwAAtAAAaIAAgARDdASIABEAgAA8LAAsZACAAIAEgAkEgQQAgBBtBEEEAIAMbchAtCxgBAX8gAEH/AXFBP00EfyAAEMkBBUEACwseAQF/IAAgACgCAEEBayIBNgIAIAFFBEAgABDEAQsLRAEBfyAAIAAoAgBBAWsiATYCACABRQRAIAAoAgwQ9wECQCAAQX9GDQAgACAAKAIEQQFrIgE2AgQgAQ0AIABBEBArCwsLPAEBfyAAIAAoAgBBAWsiATYCACABRQRAAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQRQQKwsLCxsAIAAQ7AEgACgCAEF/RgRAEPIBAAsgAC0ABAsJACAAQRQQkwILCQAgAEEWEJMCCwkAIABBGxCTAgsJACAAQSEQkwILCQAgAEEmEJMCCyIBAX9BEEEEEMwBIgBCADcCCCAAQoGAgIAQNwIAIABBCGoLCQAgAEE1EJMCCwkAIABBNxCTAgsKACAAQd0AEJMCCwoAIABB3gAQkwIL9AIBBX8gAUEJTwRAAkBBzf97QRAgASABQRBNGyICayAATQ0AIAJBECAAQQtqQXhxIABBC0kbIgRqQQxqEAEiAEUNACAAQQhrIQECQCACQQFrIgMgAHFFBEAgASEADAELIABBBGsiBSgCACIGQXhxIAAgA2pBACACa3FBCGsiACACQQAgACABa0EQTRtqIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQBQwBCyABKAIAIQEgACADNgIEIAAgASACajYCAAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFyQQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEAULIABBCGohAwsgAw8LIAAQAQsYACAAQQVNBEAgAA8LQbyDwABBGRDzAQALGAAgAEECTQRAIAAPC0G8g8AAQRkQ8wEACxYAIAFBEHRBgIAccSAAQQJ0QfwBcXILbQAgAEH/AXFBwABPBEAjAEEwayIAJAAgAEEiNgIMIABB3IDAADYCCCAAQQE2AhQgAEGMiMAANgIQIABCATcCHCAAIABBCGqtQoCAgIAQhDcDKCAAIABBKGo2AhggAEEQakGUgcAAEI4BAAsgAAsUACAAIAEgAkEgQQAgAxsgBHIQLQsYACAAEB8gARAfIAIQHyADEBsQ6gEQxQELFwAgABAfIAEQHyACEB8gAxAfEC0QxQELEgAgACABIAIgA0EEdCAEchAtCxwAIABBADYCECAAQgA3AgggAEKAgICAwAA3AgALFAAgACAAKAIAQQFrNgIAIAEQzwELFAAgACAAKAIAQQFrNgIAIAEQ0QELEwAgABAfIAEQHyACEAMQTxDFAQsRACAAIAEgAkEgQQAgAxsQLQsTACAAEB8gARAfIAIQKBBPEMUBCxMAIAAEQA8LQdCMwABBGxDzAQALFAEBf0EEQQEQzAEiASAANgAAIAELDQAgAQRAIAAgARArCwsNACAAEPgBQQp2QT9xCxEAIAAQHyABEMcBEOABEMUBCwsAIAAjAGokACMACw4AQeuMwABBzwAQ8wEACwkAIAAgARAAAAsKACAAQT9xEMkBCwoAIAAQH0H/AXELDAAgACABKQIANwMACwgAIABBBBArCwcAIABBCHQLCgBBNBDtARDIAQsJACAAQQA2AgALBwBBCxDJAQsHAEEKEMkBCwcAQQgQyQELBwBBDxDJAQsHAEEGEMkBCwcAQQkQyQELBwBBBxDJAQsHAEEMEMkBCwcAQQIQyQELBwBBARDJAQsHAEEDEMkBCwcAQQ0QyQELBwBBDhDJAQsHAEEFEMkBCwcAQQQQyQELBwBBEBDJAQsHAEEAEMkBCwQAQQQLNAAgAxAbIQMgABDhAUH/AXEgARDhAUH/AXEgAhDhAUH/AXEgAxDqAUEIdCAEchDtARDIAQs0ACAAEOEBQf8BcSABEOEBQf8BcSACEOEBQf8BcSADEOEBQf8BcRAtQQh0IARyEO0BEMgBCzMAIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQ4QFB/wFxIAMQFUH/AXEQLUEIdCAEchDtARDIAQsrACAAEBkiAEEQdEGAgPwHcSAAQYD+A3EgAEEQdnJyQQh0IAFyEO0BEMgBCysAIAAQ4QFB/wFxIAEQ4QFB/wFxIAIQ4QFB/wFxED9BCHQgA3IQ7QEQyAELKwAgABDhAUH/AXEgARDhAUH/AXEgAhAWQf//A3EQT0EIdCADchDtARDIAQsbACAAEOEBGiAAQQp0QYD4A3EgAXIQ7QEQyAELYAEBfyMAQTBrIgQkACAEIAA2AgwgACADTwRAIARBAjYCFCAEIAI2AhAgBEIBNwIcIARBBDYCLCAEIARBKGo2AhggBCAEQQxqNgIoIARBEGogARCOAQALIARBMGokACAAC1kBAn8jAEEQayIFJAAgBUEIaiADEA8gBS0ACSEDIAUtAAghBiAAEOEBQf8BcSABEOEBQf8BcSACEOEBQf8BcSAGIAMQ4gFBCHQgBHIQ7QEQyAEgBUEQaiQAC1kBAn8jAEEQayIFJAAgBUEIaiADEAwgBS0ACSEDIAUtAAghBiAAEOEBQf8BcSABEOEBQf8BcSACEOEBQf8BcSAGIAMQzQFBCHQgBHIQ7QEQyAEgBUEQaiQAC0oAIAAQ4QEaIAEQ4QEaIABBEnRBgIDwF3EiACABQQx0QYDgP3FyIgFBgOADcUEIdCABQQh2QYD+A3EgACACckEYdnJyEO0BEMgBC0oAIAAQ4QEaIAEQGCIBQRB0QYCA/AdxIABBEnRBgIDwH3EgAXIiAEGA/gNxQQh0IABBCHZBgP4DcXJBCHZyQQh0IAJyEO0BEMgBC0oBAX8jAEEQayIDJAAgABDsASABIAJPBEBBvIPAAEEZEPMBAAsgA0EIaiAAEMMBIAMoAgwgAygCCCABOgABQQA2AgAgA0EQaiQAC0IAIAAQ4QEaIAEQ4QEaIABBEnRBgIDwB3EgAUEMdEGA4D9xciIAQQh2QYD+A3EgAEGA4ANxQQh0ciACchDtARDIAQsLzQ0CAEGAgMAAC7oNL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAAAAEABKAAAAoQAAABkAAABDaGVja1JlZ0lkIHdhcyBnaXZlbiBpbnZhbGlkIFJlZ0lkZnVlbC1hc20vc3JjL2xpYi5ycwAAAH4AEAATAAAAbwAAACIAAABWYWx1ZSBgYCBvdXQgb2YgcmFuZ2UgZm9yIDYtYml0IGltbWVkaWF0ZQAAAKQAEAAHAAAAqwAQACIAAAB+ABAAEwAAAMADAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDEyLWJpdCBpbW1lZGlhdGUApAAQAAcAAADwABAAIwAAAH4AEAATAAAAxQMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTgtYml0IGltbWVkaWF0ZQCkABAABwAAADQBEAAjAAAAfgAQABMAAADKAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAyNC1iaXQgaW1tZWRpYXRlAKQAEAAHAAAAeAEQACMAAAB+ABAAEwAAAM8DAAAcAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZGF0dGVtcHRlZCB0byB0YWtlIG93bmVyc2hpcCBvZiBSdXN0IHZhbHVlIHdoaWxlIGl0IHdhcyBib3Jyb3dlZBAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAABHAAAASAAAAEkAAABKAAAASwAAAEwAAABQAAAAUQAAAFIAAABTAAAAVAAAAFUAAABWAAAAVwAAAFgAAABZAAAAWgAAAFsAAABcAAAAXQAAAF4AAABfAAAAYAAAAGEAAABiAAAAYwAAAGQAAABlAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAJkAAACgAAAAoQAAAKIAAACjAAAApAAAAKUAAACmAAAApwAAAKgAAACpAAAAqgAAAKsAAACsAAAArQAAALAAAAC6AAAAuwAAALwAAAC+AAAAY2FwYWNpdHkgb3ZlcmZsb3cAAADwAxAAEQAAAAEAAAAAAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi43L3NyYy9kbG1hbGxvYy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQA3AQQACkAAACoBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAANwEEAApAAAArgQAAA0AAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAIQFEAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAuAUQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AAAoBhAADgAAALgFEABdAAAAegIAAA0AAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0AEHUjcAACwEHADwJcHJvZHVjZXJzAQxwcm9jZXNzZWQtYnkCBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuBzAuMi4xMDA=");
}
async function Io() {
  return await N_({ module_or_path: Kb() });
}
Io();
const Q_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ADD: Wm,
  ADDI: Ym,
  ALOC: Zm,
  AND: Jm,
  ANDI: jm,
  BAL: qm,
  BHEI: $m,
  BHSH: Km,
  BLDD: ty,
  BSIZ: ey,
  BURN: ry,
  CALL: ny,
  CB: sy,
  CCP: iy,
  CFE: ay,
  CFEI: oy,
  CFS: cy,
  CFSI: dy,
  CROO: uy,
  CSIZ: Ay,
  CompareArgs: sn,
  CompareMode: Um,
  DIV: ly,
  DIVI: hy,
  DivArgs: la,
  ECAL: py,
  ECK1: fy,
  ECOP: gy,
  ECR1: wy,
  ED19: my,
  EPAR: yy,
  EQ: by,
  EXP: Iy,
  EXPI: Cy,
  FLAG: Ey,
  GM: ja,
  GMArgs: Gm,
  GT: By,
  GTF: qa,
  GTFArgs: S_,
  Imm06: Nt,
  Imm12: dt,
  Imm18: ke,
  Imm24: Fe,
  Instruction: V,
  JAL: vy,
  JI: xy,
  JMP: Ry,
  JMPB: Sy,
  JMPF: Ty,
  JNE: Fy,
  JNEB: Ny,
  JNEF: Qy,
  JNEI: Dy,
  JNZB: Oy,
  JNZF: My,
  JNZI: Py,
  K256: Ly,
  LB: ky,
  LDC: Uy,
  LHW: Gy,
  LOG: zy,
  LOGD: Xy,
  LQW: Hy,
  LT: Vy,
  LW: Wy,
  MCL: Yy,
  MCLI: Zy,
  MCP: Jy,
  MCPI: jy,
  MEQ: qy,
  MINT: $y,
  MLDV: Ky,
  MLOG: tb,
  MOD: eb,
  MODI: rb,
  MOVE: nb,
  MOVI: sb,
  MROO: ib,
  MUL: ab,
  MULI: ob,
  MathArgs: ha,
  MathOp: zm,
  MulArgs: _a,
  NIOP: $a,
  NOOP: ub,
  NOT: Ab,
  NarrowMathArgs: Qi,
  NarrowMathOp: Xm,
  OR: lb,
  ORI: hb,
  OpWidth: Hm,
  POPH: _b,
  POPL: pb,
  PSHH: fb,
  PSHL: gb,
  PanicInstruction: wb,
  PanicReason: Vm,
  RET: mb,
  RETD: yb,
  RVRT: bb,
  RegId: h,
  S256: Ib,
  SB: Cb,
  SCWQ: Eb,
  SHW: Bb,
  SLL: vb,
  SLLI: xb,
  SMO: Rb,
  SQW: Sb,
  SRL: Tb,
  SRLI: Fb,
  SRW: Nb,
  SRWQ: Qb,
  SUB: Db,
  SUBI: Ob,
  SW: Mb,
  SWW: Pb,
  SWWQ: Lb,
  TIME: kb,
  TR: Ub,
  TRO: Gb,
  WDAM: zb,
  WDCM: Ka,
  WDDV: to,
  WDMD: Xb,
  WDML: eo,
  WDMM: Hb,
  WDOP: ro,
  WQAM: Vb,
  WQCM: no,
  WQDV: so,
  WQMD: Wb,
  WQML: io,
  WQMM: Yb,
  WQOP: ao,
  XOR: Zb,
  XORI: Jb,
  add: Xw,
  addi: Er,
  aloc: c0,
  and: Hw,
  andi: U0,
  bal: P0,
  bhei: h0,
  bhsh: l0,
  bldd: Mm,
  bsiz: Ja,
  burn: _0,
  call: Kc,
  cb: w0,
  ccp: p0,
  cfe: _m,
  cfei: lm,
  cfs: pm,
  cfsi: hm,
  croo: f0,
  csiz: g0,
  div: Vw,
  divi: Za,
  ecal: Om,
  eck1: S0,
  ecop: Pm,
  ecr1: T0,
  ed19: F0,
  epar: Lm,
  eq: Ww,
  exp: Yw,
  expi: G0,
  flag: M0,
  gm: sm,
  gm_args: Nw,
  gt: Zw,
  gtf: x_,
  gtf_args: Qw,
  initSync: qb,
  initWasm: Io,
  jal: ym,
  ji: Am,
  jmp: Ya,
  jmpb: om,
  jmpf: am,
  jne: L0,
  jneb: um,
  jnef: dm,
  jnei: Z0,
  jnzb: R_,
  jnzf: cm,
  jnzi: im,
  k256: N0,
  lb: J0,
  ldc: qi,
  lhw: tm,
  log: m0,
  logd: y0,
  lqw: K0,
  lt: Jw,
  lw: ea,
  mcl: d0,
  mcli: nm,
  mcp: u0,
  mcpi: $0,
  meq: A0,
  mint: b0,
  mldv: i0,
  mlog: jw,
  mod_: $w,
  modi: z0,
  move_: gn,
  movi: rs,
  mroo: qw,
  mul: Kw,
  muli: X0,
  niop: a0,
  niop_args: Dw,
  noop: O0,
  not: t0,
  or: e0,
  ori: H0,
  poph: mm,
  popl: wm,
  pshh: gm,
  pshl: fm,
  ret: Pd,
  retd: o0,
  rvrt: I0,
  s256: Q0,
  sb: j0,
  scwq: C0,
  shw: rm,
  sll: r0,
  slli: V0,
  smo: k0,
  sqw: em,
  srl: n0,
  srli: W0,
  srw: E0,
  srwq: B0,
  sub: Wa,
  subi: v_,
  sw: q0,
  sww: v0,
  swwq: x0,
  time: D0,
  tr: B_,
  tro: R0,
  wdam: Fm,
  wdcm: bm,
  wdcm_args: Ow,
  wddv: xm,
  wddv_args: Gw,
  wdmd: Sm,
  wdml: Bm,
  wdml_args: kw,
  wdmm: Qm,
  wdop: Cm,
  wdop_args: Pw,
  wqam: Nm,
  wqcm: Im,
  wqcm_args: Mw,
  wqdv: Rm,
  wqdv_args: zw,
  wqmd: Tm,
  wqml: vm,
  wqml_args: Uw,
  wqmm: Dm,
  wqop: Em,
  wqop_args: Lw,
  xor: s0,
  xori: Y0
}, Symbol.toStringTag, { value: "Module" }));
function MR(r) {
  return r;
}
var tI = /* @__PURE__ */ ((r) => (r.build = "build", r.deploy = "deploy", r.dev = "dev", r.init = "init", r.versions = "versions", r.node = "node", r))(tI || {}), eI = Object.defineProperty, Nr = (r, t) => eI(r, "name", { value: t, configurable: !0 });
function Ld() {
  return {
    FUEL_CORE: "0.47.1",
    FORC: "0.68.7",
    FUELS: "0.102.0"
  };
}
Nr(Ld, "getBuiltinVersions");
function td(r) {
  const [t, e, n] = r.split(".").map((s) => parseInt(s, 10));
  return { major: t, minor: e, patch: n };
}
Nr(td, "parseVersion");
function Yn(r, t) {
  const e = td(r), n = td(t), s = e.major - n.major, i = e.minor - n.minor, a = e.patch - n.patch;
  return {
    major: s,
    minor: i,
    patch: a,
    fullVersionDiff: s || i || a
  };
}
Nr(Yn, "versionDiffs");
function rI(r, t) {
  const { fullVersionDiff: e } = Yn(r, t);
  return e > 0;
}
Nr(rI, "gt");
function nI(r, t) {
  const { fullVersionDiff: e } = Yn(r, t);
  return e === 0;
}
Nr(nI, "eq");
function sI(r, t) {
  const { fullVersionDiff: e } = Yn(r, t);
  return e >= 0;
}
Nr(sI, "gte");
function D_(r, t) {
  const { major: e } = Yn(r, t);
  return e === 0;
}
Nr(D_, "majorEq");
function O_(r, t) {
  const { minor: e } = Yn(r, t);
  return e === 0;
}
Nr(O_, "minorEq");
function M_(r, t) {
  const { patch: e } = Yn(r, t);
  return e === 0;
}
Nr(M_, "patchEq");
function P_(r) {
  const { FUEL_CORE: t } = Ld();
  return /^\d+\.\d+\.\d+\D+/m.test(r) && console.warn(`You're running against an unreleased fuel-core version: ${r}. Things may work as expected, but it's not guaranteed. Please use a released version.      
This unreleased fuel-core build may include features and updates not yet supported by this version of the TS-SDK.`), {
    supportedVersion: t,
    isMajorSupported: D_(r, t),
    isMinorSupported: O_(r, t),
    isPatchSupported: M_(r, t)
  };
}
Nr(P_, "checkFuelCoreVersionCompatibility");
var L_ = Ld(), iI = Object.defineProperty, aI = (r, t) => iI(r, "name", { value: t, configurable: !0 }), L = /* @__PURE__ */ ((r) => (r.NO_ABIS_FOUND = "no-abis-found", r.ABI_TYPES_AND_VALUES_MISMATCH = "abi-types-and-values-mismatch", r.ABI_MAIN_METHOD_MISSING = "abi-main-method-missing", r.INVALID_COMPONENT = "invalid-component", r.CONFIGURABLE_NOT_FOUND = "configurable-not-found", r.TYPE_NOT_FOUND = "type-not-found", r.LOG_TYPE_NOT_FOUND = "log-type-not-found", r.TYPE_NOT_SUPPORTED = "type-not-supported", r.INVALID_DECODE_VALUE = "invalid-decode-value", r.JSON_ABI_ERROR = "json-abi-error", r.TYPE_ID_NOT_FOUND = "type-id-not-found", r.BIN_FILE_NOT_FOUND = "bin-file-not-found", r.CODER_NOT_FOUND = "coder-not-found", r.INVALID_DATA = "invalid-data", r.FUNCTION_NOT_FOUND = "function-not-found", r.UNSUPPORTED_ENCODING_VERSION = "unsupported-encoding-version", r.TIMEOUT_EXCEEDED = "timeout-exceeded", r.CONFIG_FILE_NOT_FOUND = "config-file-not-found", r.CONFIG_FILE_ALREADY_EXISTS = "config-file-already-exists", r.WORKSPACE_NOT_DETECTED = "workspace-not-detected", r.INVALID_ADDRESS = "invalid-address", r.INVALID_EVM_ADDRESS = "invalid-evm-address", r.INVALID_B256_ADDRESS = "invalid-b256-address", r.CHAIN_INFO_CACHE_EMPTY = "chain-info-cache-empty", r.NODE_INFO_CACHE_EMPTY = "node-info-cache-empty", r.MISSING_PROVIDER = "missing-provider", r.INVALID_PROVIDER = "invalid-provider", r.CONNECTION_REFUSED = "connection-refused", r.INVALID_URL = "invalid-url", r.UNSUPPORTED_FEATURE = "unsupported-feature", r.RESPONSE_BODY_EMPTY = "response-body-empty", r.INVALID_PUBLIC_KEY = "invalid-public-key", r.WALLET_MANAGER_ERROR = "wallet-manager-error", r.HD_WALLET_ERROR = "hd-wallet-error", r.MISSING_CONNECTOR = "missing-connector", r.PARSE_FAILED = "parse-failed", r.ENCODE_ERROR = "encode-error", r.DECODE_ERROR = "decode-error", r.ENV_DEPENDENCY_MISSING = "env-dependency-missing", r.INVALID_TTL = "invalid-ttl", r.INVALID_INPUT_PARAMETERS = "invalid-input-parameters", r.NOT_IMPLEMENTED = "not-implemented", r.NOT_SUPPORTED = "not-supported", r.CONVERTING_FAILED = "converting-error", r.ELEMENT_NOT_FOUND = "element-not-found", r.MISSING_REQUIRED_PARAMETER = "missing-required-parameter", r.INVALID_REQUEST = "invalid-request", r.INVALID_TRANSFER_AMOUNT = "invalid-transfer-amount", r.INSUFFICIENT_FUNDS_OR_MAX_COINS = "not-enough-funds-or-max-coins-reached", r.INSUFFICIENT_FUNDS = "not-enough-funds", r.MAX_COINS_REACHED = "max-coins-reached", r.INVALID_CREDENTIALS = "invalid-credentials", r.HASHER_LOCKED = "hasher-locked", r.GAS_PRICE_TOO_LOW = "gas-price-too-low", r.GAS_LIMIT_TOO_LOW = "gas-limit-too-low", r.MAX_FEE_TOO_LOW = "max-fee-too-low", r.TRANSACTION_NOT_FOUND = "transaction-not-found", r.TRANSACTION_FAILED = "transaction-failed", r.INVALID_CONFIGURABLE_CONSTANTS = "invalid-configurable-constants", r.INVALID_TRANSACTION_INPUT = "invalid-transaction-input", r.INVALID_TRANSACTION_OUTPUT = "invalid-transaction-output", r.INVALID_TRANSACTION_STATUS = "invalid-transaction-status", r.UNSUPPORTED_TRANSACTION_TYPE = "unsupported-transaction-type", r.TRANSACTION_ERROR = "transaction-error", r.INVALID_POLICY_TYPE = "invalid-policy-type", r.DUPLICATED_POLICY = "duplicated-policy", r.TRANSACTION_SQUEEZED_OUT = "transaction-squeezed-out", r.CONTRACT_SIZE_EXCEEDS_LIMIT = "contract-size-exceeds-limit", r.INVALID_CHUNK_SIZE_MULTIPLIER = "invalid-chunk-size-multiplier", r.MAX_INPUTS_EXCEEDED = "max-inputs-exceeded", r.FUNDS_TOO_LOW = "funds-too-low", r.MAX_OUTPUTS_EXCEEDED = "max-outputs-exceeded", r.ASSET_BURN_DETECTED = "asset-burn-detected", r.CHANGE_OUTPUT_COLLISION = "change-output-collision", r.DUPLICATE_CHANGE_OUTPUT_ACCOUNT = "duplicate-change-output-account", r.INVALID_RECEIPT_TYPE = "invalid-receipt-type", r.INVALID_WORD_LIST = "invalid-word-list", r.INVALID_MNEMONIC = "invalid-mnemonic", r.INVALID_ENTROPY = "invalid-entropy", r.INVALID_SEED = "invalid-seed", r.INVALID_CHECKSUM = "invalid-checksum", r.INVALID_PASSWORD = "invalid-password", r.ACCOUNT_REQUIRED = "account-required", r.UNLOCKED_WALLET_REQUIRED = "unlocked-wallet-required", r.UNABLE_TO_CONSOLIDATE_COINS = "unable-to-consolidate-coins", r.NO_COINS_TO_CONSOLIDATE = "no-coins-to-consolidate", r.COINS_ASSET_ID_MISMATCH = "coins-asset-id-mismatch", r.ASSET_NOT_FOUND = "asset-not-found", r.NUMBER_TOO_BIG = "number-too-big", r.ERROR_BUILDING_BLOCK_EXPLORER_URL = "error-building-block-explorer-url", r.RPC_CONSISTENCY = "rpc-consistency", r.VITEPRESS_PLUGIN_ERROR = "vitepress-plugin-error", r.SCRIPT_REVERTED = "script-reverted", r.SCRIPT_RETURN_INVALID_TYPE = "script-return-invalid-type", r.STREAM_PARSING_ERROR = "stream-parsing-error", r.NODE_LAUNCH_FAILED = "node-launch-failed", r.UNKNOWN = "unknown", r))(L || {}), Br, x = (Br = class extends Error {
  constructor(e, n, s = {}, i = null) {
    super(n);
    Q(this, "VERSIONS", L_);
    Q(this, "metadata");
    Q(this, "rawError");
    Q(this, "code");
    this.code = e, this.name = "FuelError", this.metadata = s, this.rawError = i;
  }
  static parse(e) {
    const n = e;
    if (n.code === void 0)
      throw new Br(
        "parse-failed",
        "Failed to parse the error object. The required 'code' property is missing."
      );
    const s = Object.values(L);
    if (!s.includes(n.code))
      throw new Br(
        "parse-failed",
        `Unknown error code: ${n.code}. Accepted codes: ${s.join(", ")}.`
      );
    return new Br(n.code, n.message, n.metadata, n.rawError);
  }
  toObject() {
    const { code: e, name: n, message: s, metadata: i, VERSIONS: a, rawError: o } = this;
    return { code: e, name: n, message: s, metadata: i, VERSIONS: a, rawError: o };
  }
}, aI(Br, "FuelError"), Q(Br, "CODES", L), Br), uh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function k_(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function oI(r) {
  if (r.__esModule) return r;
  var t = r.default;
  if (typeof t == "function") {
    var e = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(e, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), e;
}
var Fa = { exports: {} };
const cI = {}, dI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cI
}, Symbol.toStringTag, { value: "Module" })), uI = /* @__PURE__ */ oI(dI);
var AI = Fa.exports, Ah;
function lI() {
  return Ah || (Ah = 1, function(r) {
    (function(t, e) {
      function n(R, u) {
        if (!R) throw new Error(u || "Assertion failed");
      }
      function s(R, u) {
        R.super_ = u;
        var l = function() {
        };
        l.prototype = u.prototype, R.prototype = new l(), R.prototype.constructor = R;
      }
      function i(R, u, l) {
        if (i.isBN(R))
          return R;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, R !== null && ((u === "le" || u === "be") && (l = u, u = 10), this._init(R || 0, u || 10, l || "be"));
      }
      typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
      var a;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = uI.Buffer;
      } catch {
      }
      i.isBN = function(u) {
        return u instanceof i ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
      }, i.max = function(u, l) {
        return u.cmp(l) > 0 ? u : l;
      }, i.min = function(u, l) {
        return u.cmp(l) < 0 ? u : l;
      }, i.prototype._init = function(u, l, f) {
        if (typeof u == "number")
          return this._initNumber(u, l, f);
        if (typeof u == "object")
          return this._initArray(u, l, f);
        l === "hex" && (l = 16), n(l === (l | 0) && l >= 2 && l <= 36), u = u.toString().replace(/\s+/g, "");
        var m = 0;
        u[0] === "-" && (m++, this.negative = 1), m < u.length && (l === 16 ? this._parseHex(u, m, f) : (this._parseBase(u, l, m), f === "le" && this._initArray(this.toArray(), l, f)));
      }, i.prototype._initNumber = function(u, l, f) {
        u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
          u & 67108863,
          u / 67108864 & 67108863
        ], this.length = 2) : (n(u < 9007199254740992), this.words = [
          u & 67108863,
          u / 67108864 & 67108863,
          1
        ], this.length = 3), f === "le" && this._initArray(this.toArray(), l, f);
      }, i.prototype._initArray = function(u, l, f) {
        if (n(typeof u.length == "number"), u.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
        for (var m = 0; m < this.length; m++)
          this.words[m] = 0;
        var b, T, O = 0;
        if (f === "be")
          for (m = u.length - 1, b = 0; m >= 0; m -= 3)
            T = u[m] | u[m - 1] << 8 | u[m - 2] << 16, this.words[b] |= T << O & 67108863, this.words[b + 1] = T >>> 26 - O & 67108863, O += 24, O >= 26 && (O -= 26, b++);
        else if (f === "le")
          for (m = 0, b = 0; m < u.length; m += 3)
            T = u[m] | u[m + 1] << 8 | u[m + 2] << 16, this.words[b] |= T << O & 67108863, this.words[b + 1] = T >>> 26 - O & 67108863, O += 24, O >= 26 && (O -= 26, b++);
        return this._strip();
      };
      function o(R, u) {
        var l = R.charCodeAt(u);
        if (l >= 48 && l <= 57)
          return l - 48;
        if (l >= 65 && l <= 70)
          return l - 55;
        if (l >= 97 && l <= 102)
          return l - 87;
        n(!1, "Invalid character in " + R);
      }
      function d(R, u, l) {
        var f = o(R, l);
        return l - 1 >= u && (f |= o(R, l - 1) << 4), f;
      }
      i.prototype._parseHex = function(u, l, f) {
        this.length = Math.ceil((u.length - l) / 6), this.words = new Array(this.length);
        for (var m = 0; m < this.length; m++)
          this.words[m] = 0;
        var b = 0, T = 0, O;
        if (f === "be")
          for (m = u.length - 1; m >= l; m -= 2)
            O = d(u, l, m) << b, this.words[T] |= O & 67108863, b >= 18 ? (b -= 18, T += 1, this.words[T] |= O >>> 26) : b += 8;
        else {
          var C = u.length - l;
          for (m = C % 2 === 0 ? l + 1 : l; m < u.length; m += 2)
            O = d(u, l, m) << b, this.words[T] |= O & 67108863, b >= 18 ? (b -= 18, T += 1, this.words[T] |= O >>> 26) : b += 8;
        }
        this._strip();
      };
      function A(R, u, l, f) {
        for (var m = 0, b = 0, T = Math.min(R.length, l), O = u; O < T; O++) {
          var C = R.charCodeAt(O) - 48;
          m *= f, C >= 49 ? b = C - 49 + 10 : C >= 17 ? b = C - 17 + 10 : b = C, n(C >= 0 && b < f, "Invalid character"), m += b;
        }
        return m;
      }
      i.prototype._parseBase = function(u, l, f) {
        this.words = [0], this.length = 1;
        for (var m = 0, b = 1; b <= 67108863; b *= l)
          m++;
        m--, b = b / l | 0;
        for (var T = u.length - f, O = T % m, C = Math.min(T, T - O) + f, _ = 0, B = f; B < C; B += m)
          _ = A(u, B, B + m, l), this.imuln(b), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
        if (O !== 0) {
          var tt = 1;
          for (_ = A(u, B, u.length, l), B = 0; B < O; B++)
            tt *= l;
          this.imuln(tt), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
        }
        this._strip();
      }, i.prototype.copy = function(u) {
        u.words = new Array(this.length);
        for (var l = 0; l < this.length; l++)
          u.words[l] = this.words[l];
        u.length = this.length, u.negative = this.negative, u.red = this.red;
      };
      function p(R, u) {
        R.words = u.words, R.length = u.length, R.negative = u.negative, R.red = u.red;
      }
      if (i.prototype._move = function(u) {
        p(u, this);
      }, i.prototype.clone = function() {
        var u = new i(null);
        return this.copy(u), u;
      }, i.prototype._expand = function(u) {
        for (; this.length < u; )
          this.words[this.length++] = 0;
        return this;
      }, i.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, i.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          i.prototype[Symbol.for("nodejs.util.inspect.custom")] = g;
        } catch {
          i.prototype.inspect = g;
        }
      else
        i.prototype.inspect = g;
      function g() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var y = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], v = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], N = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      i.prototype.toString = function(u, l) {
        u = u || 10, l = l | 0 || 1;
        var f;
        if (u === 16 || u === "hex") {
          f = "";
          for (var m = 0, b = 0, T = 0; T < this.length; T++) {
            var O = this.words[T], C = ((O << m | b) & 16777215).toString(16);
            b = O >>> 24 - m & 16777215, m += 2, m >= 26 && (m -= 26, T--), b !== 0 || T !== this.length - 1 ? f = y[6 - C.length] + C + f : f = C + f;
          }
          for (b !== 0 && (f = b.toString(16) + f); f.length % l !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        if (u === (u | 0) && u >= 2 && u <= 36) {
          var _ = v[u], B = N[u];
          f = "";
          var tt = this.clone();
          for (tt.negative = 0; !tt.isZero(); ) {
            var et = tt.modrn(B).toString(u);
            tt = tt.idivn(B), tt.isZero() ? f = et + f : f = y[_ - et.length] + et + f;
          }
          for (this.isZero() && (f = "0" + f); f.length % l !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        n(!1, "Base should be between 2 and 36");
      }, i.prototype.toNumber = function() {
        var u = this.words[0];
        return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
      }, i.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, a && (i.prototype.toBuffer = function(u, l) {
        return this.toArrayLike(a, u, l);
      }), i.prototype.toArray = function(u, l) {
        return this.toArrayLike(Array, u, l);
      };
      var E = function(u, l) {
        return u.allocUnsafe ? u.allocUnsafe(l) : new u(l);
      };
      i.prototype.toArrayLike = function(u, l, f) {
        this._strip();
        var m = this.byteLength(), b = f || Math.max(1, m);
        n(m <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0");
        var T = E(u, b), O = l === "le" ? "LE" : "BE";
        return this["_toArrayLike" + O](T, m), T;
      }, i.prototype._toArrayLikeLE = function(u, l) {
        for (var f = 0, m = 0, b = 0, T = 0; b < this.length; b++) {
          var O = this.words[b] << T | m;
          u[f++] = O & 255, f < u.length && (u[f++] = O >> 8 & 255), f < u.length && (u[f++] = O >> 16 & 255), T === 6 ? (f < u.length && (u[f++] = O >> 24 & 255), m = 0, T = 0) : (m = O >>> 24, T += 2);
        }
        if (f < u.length)
          for (u[f++] = m; f < u.length; )
            u[f++] = 0;
      }, i.prototype._toArrayLikeBE = function(u, l) {
        for (var f = u.length - 1, m = 0, b = 0, T = 0; b < this.length; b++) {
          var O = this.words[b] << T | m;
          u[f--] = O & 255, f >= 0 && (u[f--] = O >> 8 & 255), f >= 0 && (u[f--] = O >> 16 & 255), T === 6 ? (f >= 0 && (u[f--] = O >> 24 & 255), m = 0, T = 0) : (m = O >>> 24, T += 2);
        }
        if (f >= 0)
          for (u[f--] = m; f >= 0; )
            u[f--] = 0;
      }, Math.clz32 ? i.prototype._countBits = function(u) {
        return 32 - Math.clz32(u);
      } : i.prototype._countBits = function(u) {
        var l = u, f = 0;
        return l >= 4096 && (f += 13, l >>>= 13), l >= 64 && (f += 7, l >>>= 7), l >= 8 && (f += 4, l >>>= 4), l >= 2 && (f += 2, l >>>= 2), f + l;
      }, i.prototype._zeroBits = function(u) {
        if (u === 0) return 26;
        var l = u, f = 0;
        return l & 8191 || (f += 13, l >>>= 13), l & 127 || (f += 7, l >>>= 7), l & 15 || (f += 4, l >>>= 4), l & 3 || (f += 2, l >>>= 2), l & 1 || f++, f;
      }, i.prototype.bitLength = function() {
        var u = this.words[this.length - 1], l = this._countBits(u);
        return (this.length - 1) * 26 + l;
      };
      function F(R) {
        for (var u = new Array(R.bitLength()), l = 0; l < u.length; l++) {
          var f = l / 26 | 0, m = l % 26;
          u[l] = R.words[f] >>> m & 1;
        }
        return u;
      }
      i.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var u = 0, l = 0; l < this.length; l++) {
          var f = this._zeroBits(this.words[l]);
          if (u += f, f !== 26) break;
        }
        return u;
      }, i.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, i.prototype.toTwos = function(u) {
        return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
      }, i.prototype.fromTwos = function(u) {
        return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
      }, i.prototype.isNeg = function() {
        return this.negative !== 0;
      }, i.prototype.neg = function() {
        return this.clone().ineg();
      }, i.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, i.prototype.iuor = function(u) {
        for (; this.length < u.length; )
          this.words[this.length++] = 0;
        for (var l = 0; l < u.length; l++)
          this.words[l] = this.words[l] | u.words[l];
        return this._strip();
      }, i.prototype.ior = function(u) {
        return n((this.negative | u.negative) === 0), this.iuor(u);
      }, i.prototype.or = function(u) {
        return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
      }, i.prototype.uor = function(u) {
        return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
      }, i.prototype.iuand = function(u) {
        var l;
        this.length > u.length ? l = u : l = this;
        for (var f = 0; f < l.length; f++)
          this.words[f] = this.words[f] & u.words[f];
        return this.length = l.length, this._strip();
      }, i.prototype.iand = function(u) {
        return n((this.negative | u.negative) === 0), this.iuand(u);
      }, i.prototype.and = function(u) {
        return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
      }, i.prototype.uand = function(u) {
        return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
      }, i.prototype.iuxor = function(u) {
        var l, f;
        this.length > u.length ? (l = this, f = u) : (l = u, f = this);
        for (var m = 0; m < f.length; m++)
          this.words[m] = l.words[m] ^ f.words[m];
        if (this !== l)
          for (; m < l.length; m++)
            this.words[m] = l.words[m];
        return this.length = l.length, this._strip();
      }, i.prototype.ixor = function(u) {
        return n((this.negative | u.negative) === 0), this.iuxor(u);
      }, i.prototype.xor = function(u) {
        return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
      }, i.prototype.uxor = function(u) {
        return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
      }, i.prototype.inotn = function(u) {
        n(typeof u == "number" && u >= 0);
        var l = Math.ceil(u / 26) | 0, f = u % 26;
        this._expand(l), f > 0 && l--;
        for (var m = 0; m < l; m++)
          this.words[m] = ~this.words[m] & 67108863;
        return f > 0 && (this.words[m] = ~this.words[m] & 67108863 >> 26 - f), this._strip();
      }, i.prototype.notn = function(u) {
        return this.clone().inotn(u);
      }, i.prototype.setn = function(u, l) {
        n(typeof u == "number" && u >= 0);
        var f = u / 26 | 0, m = u % 26;
        return this._expand(f + 1), l ? this.words[f] = this.words[f] | 1 << m : this.words[f] = this.words[f] & ~(1 << m), this._strip();
      }, i.prototype.iadd = function(u) {
        var l;
        if (this.negative !== 0 && u.negative === 0)
          return this.negative = 0, l = this.isub(u), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && u.negative !== 0)
          return u.negative = 0, l = this.isub(u), u.negative = 1, l._normSign();
        var f, m;
        this.length > u.length ? (f = this, m = u) : (f = u, m = this);
        for (var b = 0, T = 0; T < m.length; T++)
          l = (f.words[T] | 0) + (m.words[T] | 0) + b, this.words[T] = l & 67108863, b = l >>> 26;
        for (; b !== 0 && T < f.length; T++)
          l = (f.words[T] | 0) + b, this.words[T] = l & 67108863, b = l >>> 26;
        if (this.length = f.length, b !== 0)
          this.words[this.length] = b, this.length++;
        else if (f !== this)
          for (; T < f.length; T++)
            this.words[T] = f.words[T];
        return this;
      }, i.prototype.add = function(u) {
        var l;
        return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, l = this.sub(u), u.negative ^= 1, l) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, l = u.sub(this), this.negative = 1, l) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
      }, i.prototype.isub = function(u) {
        if (u.negative !== 0) {
          u.negative = 0;
          var l = this.iadd(u);
          return u.negative = 1, l._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
        var f = this.cmp(u);
        if (f === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var m, b;
        f > 0 ? (m = this, b = u) : (m = u, b = this);
        for (var T = 0, O = 0; O < b.length; O++)
          l = (m.words[O] | 0) - (b.words[O] | 0) + T, T = l >> 26, this.words[O] = l & 67108863;
        for (; T !== 0 && O < m.length; O++)
          l = (m.words[O] | 0) + T, T = l >> 26, this.words[O] = l & 67108863;
        if (T === 0 && O < m.length && m !== this)
          for (; O < m.length; O++)
            this.words[O] = m.words[O];
        return this.length = Math.max(this.length, O), m !== this && (this.negative = 1), this._strip();
      }, i.prototype.sub = function(u) {
        return this.clone().isub(u);
      };
      function k(R, u, l) {
        l.negative = u.negative ^ R.negative;
        var f = R.length + u.length | 0;
        l.length = f, f = f - 1 | 0;
        var m = R.words[0] | 0, b = u.words[0] | 0, T = m * b, O = T & 67108863, C = T / 67108864 | 0;
        l.words[0] = O;
        for (var _ = 1; _ < f; _++) {
          for (var B = C >>> 26, tt = C & 67108863, et = Math.min(_, u.length - 1), nt = Math.max(0, _ - R.length + 1); nt <= et; nt++) {
            var Dt = _ - nt | 0;
            m = R.words[Dt] | 0, b = u.words[nt] | 0, T = m * b + tt, B += T / 67108864 | 0, tt = T & 67108863;
          }
          l.words[_] = tt | 0, C = B | 0;
        }
        return C !== 0 ? l.words[_] = C | 0 : l.length--, l._strip();
      }
      var H = function(u, l, f) {
        var m = u.words, b = l.words, T = f.words, O = 0, C, _, B, tt = m[0] | 0, et = tt & 8191, nt = tt >>> 13, Dt = m[1] | 0, ft = Dt & 8191, Bt = Dt >>> 13, ar = m[2] | 0, Rt = ar & 8191, vt = ar >>> 13, Me = m[3] | 0, Tt = Me & 8191, Ot = Me >>> 13, Lu = m[4] | 0, Ht = Lu & 8191, Vt = Lu >>> 13, ku = m[5] | 0, Wt = ku & 8191, Yt = ku >>> 13, Uu = m[6] | 0, Zt = Uu & 8191, Jt = Uu >>> 13, Gu = m[7] | 0, jt = Gu & 8191, qt = Gu >>> 13, zu = m[8] | 0, $t = zu & 8191, Kt = zu >>> 13, Xu = m[9] | 0, te = Xu & 8191, ee = Xu >>> 13, Hu = b[0] | 0, re = Hu & 8191, ne = Hu >>> 13, Vu = b[1] | 0, se = Vu & 8191, ie = Vu >>> 13, Wu = b[2] | 0, ae = Wu & 8191, oe = Wu >>> 13, Yu = b[3] | 0, ce = Yu & 8191, de = Yu >>> 13, Zu = b[4] | 0, ue = Zu & 8191, Ae = Zu >>> 13, Ju = b[5] | 0, le = Ju & 8191, he = Ju >>> 13, ju = b[6] | 0, _e = ju & 8191, pe = ju >>> 13, qu = b[7] | 0, fe = qu & 8191, ge = qu >>> 13, $u = b[8] | 0, we = $u & 8191, me = $u >>> 13, Ku = b[9] | 0, ye = Ku & 8191, be = Ku >>> 13;
        f.negative = u.negative ^ l.negative, f.length = 19, C = Math.imul(et, re), _ = Math.imul(et, ne), _ = _ + Math.imul(nt, re) | 0, B = Math.imul(nt, ne);
        var rc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (rc >>> 26) | 0, rc &= 67108863, C = Math.imul(ft, re), _ = Math.imul(ft, ne), _ = _ + Math.imul(Bt, re) | 0, B = Math.imul(Bt, ne), C = C + Math.imul(et, se) | 0, _ = _ + Math.imul(et, ie) | 0, _ = _ + Math.imul(nt, se) | 0, B = B + Math.imul(nt, ie) | 0;
        var nc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (nc >>> 26) | 0, nc &= 67108863, C = Math.imul(Rt, re), _ = Math.imul(Rt, ne), _ = _ + Math.imul(vt, re) | 0, B = Math.imul(vt, ne), C = C + Math.imul(ft, se) | 0, _ = _ + Math.imul(ft, ie) | 0, _ = _ + Math.imul(Bt, se) | 0, B = B + Math.imul(Bt, ie) | 0, C = C + Math.imul(et, ae) | 0, _ = _ + Math.imul(et, oe) | 0, _ = _ + Math.imul(nt, ae) | 0, B = B + Math.imul(nt, oe) | 0;
        var sc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (sc >>> 26) | 0, sc &= 67108863, C = Math.imul(Tt, re), _ = Math.imul(Tt, ne), _ = _ + Math.imul(Ot, re) | 0, B = Math.imul(Ot, ne), C = C + Math.imul(Rt, se) | 0, _ = _ + Math.imul(Rt, ie) | 0, _ = _ + Math.imul(vt, se) | 0, B = B + Math.imul(vt, ie) | 0, C = C + Math.imul(ft, ae) | 0, _ = _ + Math.imul(ft, oe) | 0, _ = _ + Math.imul(Bt, ae) | 0, B = B + Math.imul(Bt, oe) | 0, C = C + Math.imul(et, ce) | 0, _ = _ + Math.imul(et, de) | 0, _ = _ + Math.imul(nt, ce) | 0, B = B + Math.imul(nt, de) | 0;
        var ic = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (ic >>> 26) | 0, ic &= 67108863, C = Math.imul(Ht, re), _ = Math.imul(Ht, ne), _ = _ + Math.imul(Vt, re) | 0, B = Math.imul(Vt, ne), C = C + Math.imul(Tt, se) | 0, _ = _ + Math.imul(Tt, ie) | 0, _ = _ + Math.imul(Ot, se) | 0, B = B + Math.imul(Ot, ie) | 0, C = C + Math.imul(Rt, ae) | 0, _ = _ + Math.imul(Rt, oe) | 0, _ = _ + Math.imul(vt, ae) | 0, B = B + Math.imul(vt, oe) | 0, C = C + Math.imul(ft, ce) | 0, _ = _ + Math.imul(ft, de) | 0, _ = _ + Math.imul(Bt, ce) | 0, B = B + Math.imul(Bt, de) | 0, C = C + Math.imul(et, ue) | 0, _ = _ + Math.imul(et, Ae) | 0, _ = _ + Math.imul(nt, ue) | 0, B = B + Math.imul(nt, Ae) | 0;
        var ac = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (ac >>> 26) | 0, ac &= 67108863, C = Math.imul(Wt, re), _ = Math.imul(Wt, ne), _ = _ + Math.imul(Yt, re) | 0, B = Math.imul(Yt, ne), C = C + Math.imul(Ht, se) | 0, _ = _ + Math.imul(Ht, ie) | 0, _ = _ + Math.imul(Vt, se) | 0, B = B + Math.imul(Vt, ie) | 0, C = C + Math.imul(Tt, ae) | 0, _ = _ + Math.imul(Tt, oe) | 0, _ = _ + Math.imul(Ot, ae) | 0, B = B + Math.imul(Ot, oe) | 0, C = C + Math.imul(Rt, ce) | 0, _ = _ + Math.imul(Rt, de) | 0, _ = _ + Math.imul(vt, ce) | 0, B = B + Math.imul(vt, de) | 0, C = C + Math.imul(ft, ue) | 0, _ = _ + Math.imul(ft, Ae) | 0, _ = _ + Math.imul(Bt, ue) | 0, B = B + Math.imul(Bt, Ae) | 0, C = C + Math.imul(et, le) | 0, _ = _ + Math.imul(et, he) | 0, _ = _ + Math.imul(nt, le) | 0, B = B + Math.imul(nt, he) | 0;
        var oc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (oc >>> 26) | 0, oc &= 67108863, C = Math.imul(Zt, re), _ = Math.imul(Zt, ne), _ = _ + Math.imul(Jt, re) | 0, B = Math.imul(Jt, ne), C = C + Math.imul(Wt, se) | 0, _ = _ + Math.imul(Wt, ie) | 0, _ = _ + Math.imul(Yt, se) | 0, B = B + Math.imul(Yt, ie) | 0, C = C + Math.imul(Ht, ae) | 0, _ = _ + Math.imul(Ht, oe) | 0, _ = _ + Math.imul(Vt, ae) | 0, B = B + Math.imul(Vt, oe) | 0, C = C + Math.imul(Tt, ce) | 0, _ = _ + Math.imul(Tt, de) | 0, _ = _ + Math.imul(Ot, ce) | 0, B = B + Math.imul(Ot, de) | 0, C = C + Math.imul(Rt, ue) | 0, _ = _ + Math.imul(Rt, Ae) | 0, _ = _ + Math.imul(vt, ue) | 0, B = B + Math.imul(vt, Ae) | 0, C = C + Math.imul(ft, le) | 0, _ = _ + Math.imul(ft, he) | 0, _ = _ + Math.imul(Bt, le) | 0, B = B + Math.imul(Bt, he) | 0, C = C + Math.imul(et, _e) | 0, _ = _ + Math.imul(et, pe) | 0, _ = _ + Math.imul(nt, _e) | 0, B = B + Math.imul(nt, pe) | 0;
        var cc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (cc >>> 26) | 0, cc &= 67108863, C = Math.imul(jt, re), _ = Math.imul(jt, ne), _ = _ + Math.imul(qt, re) | 0, B = Math.imul(qt, ne), C = C + Math.imul(Zt, se) | 0, _ = _ + Math.imul(Zt, ie) | 0, _ = _ + Math.imul(Jt, se) | 0, B = B + Math.imul(Jt, ie) | 0, C = C + Math.imul(Wt, ae) | 0, _ = _ + Math.imul(Wt, oe) | 0, _ = _ + Math.imul(Yt, ae) | 0, B = B + Math.imul(Yt, oe) | 0, C = C + Math.imul(Ht, ce) | 0, _ = _ + Math.imul(Ht, de) | 0, _ = _ + Math.imul(Vt, ce) | 0, B = B + Math.imul(Vt, de) | 0, C = C + Math.imul(Tt, ue) | 0, _ = _ + Math.imul(Tt, Ae) | 0, _ = _ + Math.imul(Ot, ue) | 0, B = B + Math.imul(Ot, Ae) | 0, C = C + Math.imul(Rt, le) | 0, _ = _ + Math.imul(Rt, he) | 0, _ = _ + Math.imul(vt, le) | 0, B = B + Math.imul(vt, he) | 0, C = C + Math.imul(ft, _e) | 0, _ = _ + Math.imul(ft, pe) | 0, _ = _ + Math.imul(Bt, _e) | 0, B = B + Math.imul(Bt, pe) | 0, C = C + Math.imul(et, fe) | 0, _ = _ + Math.imul(et, ge) | 0, _ = _ + Math.imul(nt, fe) | 0, B = B + Math.imul(nt, ge) | 0;
        var dc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (dc >>> 26) | 0, dc &= 67108863, C = Math.imul($t, re), _ = Math.imul($t, ne), _ = _ + Math.imul(Kt, re) | 0, B = Math.imul(Kt, ne), C = C + Math.imul(jt, se) | 0, _ = _ + Math.imul(jt, ie) | 0, _ = _ + Math.imul(qt, se) | 0, B = B + Math.imul(qt, ie) | 0, C = C + Math.imul(Zt, ae) | 0, _ = _ + Math.imul(Zt, oe) | 0, _ = _ + Math.imul(Jt, ae) | 0, B = B + Math.imul(Jt, oe) | 0, C = C + Math.imul(Wt, ce) | 0, _ = _ + Math.imul(Wt, de) | 0, _ = _ + Math.imul(Yt, ce) | 0, B = B + Math.imul(Yt, de) | 0, C = C + Math.imul(Ht, ue) | 0, _ = _ + Math.imul(Ht, Ae) | 0, _ = _ + Math.imul(Vt, ue) | 0, B = B + Math.imul(Vt, Ae) | 0, C = C + Math.imul(Tt, le) | 0, _ = _ + Math.imul(Tt, he) | 0, _ = _ + Math.imul(Ot, le) | 0, B = B + Math.imul(Ot, he) | 0, C = C + Math.imul(Rt, _e) | 0, _ = _ + Math.imul(Rt, pe) | 0, _ = _ + Math.imul(vt, _e) | 0, B = B + Math.imul(vt, pe) | 0, C = C + Math.imul(ft, fe) | 0, _ = _ + Math.imul(ft, ge) | 0, _ = _ + Math.imul(Bt, fe) | 0, B = B + Math.imul(Bt, ge) | 0, C = C + Math.imul(et, we) | 0, _ = _ + Math.imul(et, me) | 0, _ = _ + Math.imul(nt, we) | 0, B = B + Math.imul(nt, me) | 0;
        var uc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (uc >>> 26) | 0, uc &= 67108863, C = Math.imul(te, re), _ = Math.imul(te, ne), _ = _ + Math.imul(ee, re) | 0, B = Math.imul(ee, ne), C = C + Math.imul($t, se) | 0, _ = _ + Math.imul($t, ie) | 0, _ = _ + Math.imul(Kt, se) | 0, B = B + Math.imul(Kt, ie) | 0, C = C + Math.imul(jt, ae) | 0, _ = _ + Math.imul(jt, oe) | 0, _ = _ + Math.imul(qt, ae) | 0, B = B + Math.imul(qt, oe) | 0, C = C + Math.imul(Zt, ce) | 0, _ = _ + Math.imul(Zt, de) | 0, _ = _ + Math.imul(Jt, ce) | 0, B = B + Math.imul(Jt, de) | 0, C = C + Math.imul(Wt, ue) | 0, _ = _ + Math.imul(Wt, Ae) | 0, _ = _ + Math.imul(Yt, ue) | 0, B = B + Math.imul(Yt, Ae) | 0, C = C + Math.imul(Ht, le) | 0, _ = _ + Math.imul(Ht, he) | 0, _ = _ + Math.imul(Vt, le) | 0, B = B + Math.imul(Vt, he) | 0, C = C + Math.imul(Tt, _e) | 0, _ = _ + Math.imul(Tt, pe) | 0, _ = _ + Math.imul(Ot, _e) | 0, B = B + Math.imul(Ot, pe) | 0, C = C + Math.imul(Rt, fe) | 0, _ = _ + Math.imul(Rt, ge) | 0, _ = _ + Math.imul(vt, fe) | 0, B = B + Math.imul(vt, ge) | 0, C = C + Math.imul(ft, we) | 0, _ = _ + Math.imul(ft, me) | 0, _ = _ + Math.imul(Bt, we) | 0, B = B + Math.imul(Bt, me) | 0, C = C + Math.imul(et, ye) | 0, _ = _ + Math.imul(et, be) | 0, _ = _ + Math.imul(nt, ye) | 0, B = B + Math.imul(nt, be) | 0;
        var Ac = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (Ac >>> 26) | 0, Ac &= 67108863, C = Math.imul(te, se), _ = Math.imul(te, ie), _ = _ + Math.imul(ee, se) | 0, B = Math.imul(ee, ie), C = C + Math.imul($t, ae) | 0, _ = _ + Math.imul($t, oe) | 0, _ = _ + Math.imul(Kt, ae) | 0, B = B + Math.imul(Kt, oe) | 0, C = C + Math.imul(jt, ce) | 0, _ = _ + Math.imul(jt, de) | 0, _ = _ + Math.imul(qt, ce) | 0, B = B + Math.imul(qt, de) | 0, C = C + Math.imul(Zt, ue) | 0, _ = _ + Math.imul(Zt, Ae) | 0, _ = _ + Math.imul(Jt, ue) | 0, B = B + Math.imul(Jt, Ae) | 0, C = C + Math.imul(Wt, le) | 0, _ = _ + Math.imul(Wt, he) | 0, _ = _ + Math.imul(Yt, le) | 0, B = B + Math.imul(Yt, he) | 0, C = C + Math.imul(Ht, _e) | 0, _ = _ + Math.imul(Ht, pe) | 0, _ = _ + Math.imul(Vt, _e) | 0, B = B + Math.imul(Vt, pe) | 0, C = C + Math.imul(Tt, fe) | 0, _ = _ + Math.imul(Tt, ge) | 0, _ = _ + Math.imul(Ot, fe) | 0, B = B + Math.imul(Ot, ge) | 0, C = C + Math.imul(Rt, we) | 0, _ = _ + Math.imul(Rt, me) | 0, _ = _ + Math.imul(vt, we) | 0, B = B + Math.imul(vt, me) | 0, C = C + Math.imul(ft, ye) | 0, _ = _ + Math.imul(ft, be) | 0, _ = _ + Math.imul(Bt, ye) | 0, B = B + Math.imul(Bt, be) | 0;
        var lc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (lc >>> 26) | 0, lc &= 67108863, C = Math.imul(te, ae), _ = Math.imul(te, oe), _ = _ + Math.imul(ee, ae) | 0, B = Math.imul(ee, oe), C = C + Math.imul($t, ce) | 0, _ = _ + Math.imul($t, de) | 0, _ = _ + Math.imul(Kt, ce) | 0, B = B + Math.imul(Kt, de) | 0, C = C + Math.imul(jt, ue) | 0, _ = _ + Math.imul(jt, Ae) | 0, _ = _ + Math.imul(qt, ue) | 0, B = B + Math.imul(qt, Ae) | 0, C = C + Math.imul(Zt, le) | 0, _ = _ + Math.imul(Zt, he) | 0, _ = _ + Math.imul(Jt, le) | 0, B = B + Math.imul(Jt, he) | 0, C = C + Math.imul(Wt, _e) | 0, _ = _ + Math.imul(Wt, pe) | 0, _ = _ + Math.imul(Yt, _e) | 0, B = B + Math.imul(Yt, pe) | 0, C = C + Math.imul(Ht, fe) | 0, _ = _ + Math.imul(Ht, ge) | 0, _ = _ + Math.imul(Vt, fe) | 0, B = B + Math.imul(Vt, ge) | 0, C = C + Math.imul(Tt, we) | 0, _ = _ + Math.imul(Tt, me) | 0, _ = _ + Math.imul(Ot, we) | 0, B = B + Math.imul(Ot, me) | 0, C = C + Math.imul(Rt, ye) | 0, _ = _ + Math.imul(Rt, be) | 0, _ = _ + Math.imul(vt, ye) | 0, B = B + Math.imul(vt, be) | 0;
        var hc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (hc >>> 26) | 0, hc &= 67108863, C = Math.imul(te, ce), _ = Math.imul(te, de), _ = _ + Math.imul(ee, ce) | 0, B = Math.imul(ee, de), C = C + Math.imul($t, ue) | 0, _ = _ + Math.imul($t, Ae) | 0, _ = _ + Math.imul(Kt, ue) | 0, B = B + Math.imul(Kt, Ae) | 0, C = C + Math.imul(jt, le) | 0, _ = _ + Math.imul(jt, he) | 0, _ = _ + Math.imul(qt, le) | 0, B = B + Math.imul(qt, he) | 0, C = C + Math.imul(Zt, _e) | 0, _ = _ + Math.imul(Zt, pe) | 0, _ = _ + Math.imul(Jt, _e) | 0, B = B + Math.imul(Jt, pe) | 0, C = C + Math.imul(Wt, fe) | 0, _ = _ + Math.imul(Wt, ge) | 0, _ = _ + Math.imul(Yt, fe) | 0, B = B + Math.imul(Yt, ge) | 0, C = C + Math.imul(Ht, we) | 0, _ = _ + Math.imul(Ht, me) | 0, _ = _ + Math.imul(Vt, we) | 0, B = B + Math.imul(Vt, me) | 0, C = C + Math.imul(Tt, ye) | 0, _ = _ + Math.imul(Tt, be) | 0, _ = _ + Math.imul(Ot, ye) | 0, B = B + Math.imul(Ot, be) | 0;
        var _c = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (_c >>> 26) | 0, _c &= 67108863, C = Math.imul(te, ue), _ = Math.imul(te, Ae), _ = _ + Math.imul(ee, ue) | 0, B = Math.imul(ee, Ae), C = C + Math.imul($t, le) | 0, _ = _ + Math.imul($t, he) | 0, _ = _ + Math.imul(Kt, le) | 0, B = B + Math.imul(Kt, he) | 0, C = C + Math.imul(jt, _e) | 0, _ = _ + Math.imul(jt, pe) | 0, _ = _ + Math.imul(qt, _e) | 0, B = B + Math.imul(qt, pe) | 0, C = C + Math.imul(Zt, fe) | 0, _ = _ + Math.imul(Zt, ge) | 0, _ = _ + Math.imul(Jt, fe) | 0, B = B + Math.imul(Jt, ge) | 0, C = C + Math.imul(Wt, we) | 0, _ = _ + Math.imul(Wt, me) | 0, _ = _ + Math.imul(Yt, we) | 0, B = B + Math.imul(Yt, me) | 0, C = C + Math.imul(Ht, ye) | 0, _ = _ + Math.imul(Ht, be) | 0, _ = _ + Math.imul(Vt, ye) | 0, B = B + Math.imul(Vt, be) | 0;
        var pc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (pc >>> 26) | 0, pc &= 67108863, C = Math.imul(te, le), _ = Math.imul(te, he), _ = _ + Math.imul(ee, le) | 0, B = Math.imul(ee, he), C = C + Math.imul($t, _e) | 0, _ = _ + Math.imul($t, pe) | 0, _ = _ + Math.imul(Kt, _e) | 0, B = B + Math.imul(Kt, pe) | 0, C = C + Math.imul(jt, fe) | 0, _ = _ + Math.imul(jt, ge) | 0, _ = _ + Math.imul(qt, fe) | 0, B = B + Math.imul(qt, ge) | 0, C = C + Math.imul(Zt, we) | 0, _ = _ + Math.imul(Zt, me) | 0, _ = _ + Math.imul(Jt, we) | 0, B = B + Math.imul(Jt, me) | 0, C = C + Math.imul(Wt, ye) | 0, _ = _ + Math.imul(Wt, be) | 0, _ = _ + Math.imul(Yt, ye) | 0, B = B + Math.imul(Yt, be) | 0;
        var fc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (fc >>> 26) | 0, fc &= 67108863, C = Math.imul(te, _e), _ = Math.imul(te, pe), _ = _ + Math.imul(ee, _e) | 0, B = Math.imul(ee, pe), C = C + Math.imul($t, fe) | 0, _ = _ + Math.imul($t, ge) | 0, _ = _ + Math.imul(Kt, fe) | 0, B = B + Math.imul(Kt, ge) | 0, C = C + Math.imul(jt, we) | 0, _ = _ + Math.imul(jt, me) | 0, _ = _ + Math.imul(qt, we) | 0, B = B + Math.imul(qt, me) | 0, C = C + Math.imul(Zt, ye) | 0, _ = _ + Math.imul(Zt, be) | 0, _ = _ + Math.imul(Jt, ye) | 0, B = B + Math.imul(Jt, be) | 0;
        var gc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (gc >>> 26) | 0, gc &= 67108863, C = Math.imul(te, fe), _ = Math.imul(te, ge), _ = _ + Math.imul(ee, fe) | 0, B = Math.imul(ee, ge), C = C + Math.imul($t, we) | 0, _ = _ + Math.imul($t, me) | 0, _ = _ + Math.imul(Kt, we) | 0, B = B + Math.imul(Kt, me) | 0, C = C + Math.imul(jt, ye) | 0, _ = _ + Math.imul(jt, be) | 0, _ = _ + Math.imul(qt, ye) | 0, B = B + Math.imul(qt, be) | 0;
        var wc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (wc >>> 26) | 0, wc &= 67108863, C = Math.imul(te, we), _ = Math.imul(te, me), _ = _ + Math.imul(ee, we) | 0, B = Math.imul(ee, me), C = C + Math.imul($t, ye) | 0, _ = _ + Math.imul($t, be) | 0, _ = _ + Math.imul(Kt, ye) | 0, B = B + Math.imul(Kt, be) | 0;
        var mc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        O = (B + (_ >>> 13) | 0) + (mc >>> 26) | 0, mc &= 67108863, C = Math.imul(te, ye), _ = Math.imul(te, be), _ = _ + Math.imul(ee, ye) | 0, B = Math.imul(ee, be);
        var yc = (O + C | 0) + ((_ & 8191) << 13) | 0;
        return O = (B + (_ >>> 13) | 0) + (yc >>> 26) | 0, yc &= 67108863, T[0] = rc, T[1] = nc, T[2] = sc, T[3] = ic, T[4] = ac, T[5] = oc, T[6] = cc, T[7] = dc, T[8] = uc, T[9] = Ac, T[10] = lc, T[11] = hc, T[12] = _c, T[13] = pc, T[14] = fc, T[15] = gc, T[16] = wc, T[17] = mc, T[18] = yc, O !== 0 && (T[19] = O, f.length++), f;
      };
      Math.imul || (H = k);
      function X(R, u, l) {
        l.negative = u.negative ^ R.negative, l.length = R.length + u.length;
        for (var f = 0, m = 0, b = 0; b < l.length - 1; b++) {
          var T = m;
          m = 0;
          for (var O = f & 67108863, C = Math.min(b, u.length - 1), _ = Math.max(0, b - R.length + 1); _ <= C; _++) {
            var B = b - _, tt = R.words[B] | 0, et = u.words[_] | 0, nt = tt * et, Dt = nt & 67108863;
            T = T + (nt / 67108864 | 0) | 0, Dt = Dt + O | 0, O = Dt & 67108863, T = T + (Dt >>> 26) | 0, m += T >>> 26, T &= 67108863;
          }
          l.words[b] = O, f = T, T = m;
        }
        return f !== 0 ? l.words[b] = f : l.length--, l._strip();
      }
      function D(R, u, l) {
        return X(R, u, l);
      }
      i.prototype.mulTo = function(u, l) {
        var f, m = this.length + u.length;
        return this.length === 10 && u.length === 10 ? f = H(this, u, l) : m < 63 ? f = k(this, u, l) : m < 1024 ? f = X(this, u, l) : f = D(this, u, l), f;
      }, i.prototype.mul = function(u) {
        var l = new i(null);
        return l.words = new Array(this.length + u.length), this.mulTo(u, l);
      }, i.prototype.mulf = function(u) {
        var l = new i(null);
        return l.words = new Array(this.length + u.length), D(this, u, l);
      }, i.prototype.imul = function(u) {
        return this.clone().mulTo(u, this);
      }, i.prototype.imuln = function(u) {
        var l = u < 0;
        l && (u = -u), n(typeof u == "number"), n(u < 67108864);
        for (var f = 0, m = 0; m < this.length; m++) {
          var b = (this.words[m] | 0) * u, T = (b & 67108863) + (f & 67108863);
          f >>= 26, f += b / 67108864 | 0, f += T >>> 26, this.words[m] = T & 67108863;
        }
        return f !== 0 && (this.words[m] = f, this.length++), l ? this.ineg() : this;
      }, i.prototype.muln = function(u) {
        return this.clone().imuln(u);
      }, i.prototype.sqr = function() {
        return this.mul(this);
      }, i.prototype.isqr = function() {
        return this.imul(this.clone());
      }, i.prototype.pow = function(u) {
        var l = F(u);
        if (l.length === 0) return new i(1);
        for (var f = this, m = 0; m < l.length && l[m] === 0; m++, f = f.sqr())
          ;
        if (++m < l.length)
          for (var b = f.sqr(); m < l.length; m++, b = b.sqr())
            l[m] !== 0 && (f = f.mul(b));
        return f;
      }, i.prototype.iushln = function(u) {
        n(typeof u == "number" && u >= 0);
        var l = u % 26, f = (u - l) / 26, m = 67108863 >>> 26 - l << 26 - l, b;
        if (l !== 0) {
          var T = 0;
          for (b = 0; b < this.length; b++) {
            var O = this.words[b] & m, C = (this.words[b] | 0) - O << l;
            this.words[b] = C | T, T = O >>> 26 - l;
          }
          T && (this.words[b] = T, this.length++);
        }
        if (f !== 0) {
          for (b = this.length - 1; b >= 0; b--)
            this.words[b + f] = this.words[b];
          for (b = 0; b < f; b++)
            this.words[b] = 0;
          this.length += f;
        }
        return this._strip();
      }, i.prototype.ishln = function(u) {
        return n(this.negative === 0), this.iushln(u);
      }, i.prototype.iushrn = function(u, l, f) {
        n(typeof u == "number" && u >= 0);
        var m;
        l ? m = (l - l % 26) / 26 : m = 0;
        var b = u % 26, T = Math.min((u - b) / 26, this.length), O = 67108863 ^ 67108863 >>> b << b, C = f;
        if (m -= T, m = Math.max(0, m), C) {
          for (var _ = 0; _ < T; _++)
            C.words[_] = this.words[_];
          C.length = T;
        }
        if (T !== 0) if (this.length > T)
          for (this.length -= T, _ = 0; _ < this.length; _++)
            this.words[_] = this.words[_ + T];
        else
          this.words[0] = 0, this.length = 1;
        var B = 0;
        for (_ = this.length - 1; _ >= 0 && (B !== 0 || _ >= m); _--) {
          var tt = this.words[_] | 0;
          this.words[_] = B << 26 - b | tt >>> b, B = tt & O;
        }
        return C && B !== 0 && (C.words[C.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, i.prototype.ishrn = function(u, l, f) {
        return n(this.negative === 0), this.iushrn(u, l, f);
      }, i.prototype.shln = function(u) {
        return this.clone().ishln(u);
      }, i.prototype.ushln = function(u) {
        return this.clone().iushln(u);
      }, i.prototype.shrn = function(u) {
        return this.clone().ishrn(u);
      }, i.prototype.ushrn = function(u) {
        return this.clone().iushrn(u);
      }, i.prototype.testn = function(u) {
        n(typeof u == "number" && u >= 0);
        var l = u % 26, f = (u - l) / 26, m = 1 << l;
        if (this.length <= f) return !1;
        var b = this.words[f];
        return !!(b & m);
      }, i.prototype.imaskn = function(u) {
        n(typeof u == "number" && u >= 0);
        var l = u % 26, f = (u - l) / 26;
        if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
          return this;
        if (l !== 0 && f++, this.length = Math.min(f, this.length), l !== 0) {
          var m = 67108863 ^ 67108863 >>> l << l;
          this.words[this.length - 1] &= m;
        }
        return this._strip();
      }, i.prototype.maskn = function(u) {
        return this.clone().imaskn(u);
      }, i.prototype.iaddn = function(u) {
        return n(typeof u == "number"), n(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
      }, i.prototype._iaddn = function(u) {
        this.words[0] += u;
        for (var l = 0; l < this.length && this.words[l] >= 67108864; l++)
          this.words[l] -= 67108864, l === this.length - 1 ? this.words[l + 1] = 1 : this.words[l + 1]++;
        return this.length = Math.max(this.length, l + 1), this;
      }, i.prototype.isubn = function(u) {
        if (n(typeof u == "number"), n(u < 67108864), u < 0) return this.iaddn(-u);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(u), this.negative = 1, this;
        if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var l = 0; l < this.length && this.words[l] < 0; l++)
            this.words[l] += 67108864, this.words[l + 1] -= 1;
        return this._strip();
      }, i.prototype.addn = function(u) {
        return this.clone().iaddn(u);
      }, i.prototype.subn = function(u) {
        return this.clone().isubn(u);
      }, i.prototype.iabs = function() {
        return this.negative = 0, this;
      }, i.prototype.abs = function() {
        return this.clone().iabs();
      }, i.prototype._ishlnsubmul = function(u, l, f) {
        var m = u.length + f, b;
        this._expand(m);
        var T, O = 0;
        for (b = 0; b < u.length; b++) {
          T = (this.words[b + f] | 0) + O;
          var C = (u.words[b] | 0) * l;
          T -= C & 67108863, O = (T >> 26) - (C / 67108864 | 0), this.words[b + f] = T & 67108863;
        }
        for (; b < this.length - f; b++)
          T = (this.words[b + f] | 0) + O, O = T >> 26, this.words[b + f] = T & 67108863;
        if (O === 0) return this._strip();
        for (n(O === -1), O = 0, b = 0; b < this.length; b++)
          T = -(this.words[b] | 0) + O, O = T >> 26, this.words[b] = T & 67108863;
        return this.negative = 1, this._strip();
      }, i.prototype._wordDiv = function(u, l) {
        var f = this.length - u.length, m = this.clone(), b = u, T = b.words[b.length - 1] | 0, O = this._countBits(T);
        f = 26 - O, f !== 0 && (b = b.ushln(f), m.iushln(f), T = b.words[b.length - 1] | 0);
        var C = m.length - b.length, _;
        if (l !== "mod") {
          _ = new i(null), _.length = C + 1, _.words = new Array(_.length);
          for (var B = 0; B < _.length; B++)
            _.words[B] = 0;
        }
        var tt = m.clone()._ishlnsubmul(b, 1, C);
        tt.negative === 0 && (m = tt, _ && (_.words[C] = 1));
        for (var et = C - 1; et >= 0; et--) {
          var nt = (m.words[b.length + et] | 0) * 67108864 + (m.words[b.length + et - 1] | 0);
          for (nt = Math.min(nt / T | 0, 67108863), m._ishlnsubmul(b, nt, et); m.negative !== 0; )
            nt--, m.negative = 0, m._ishlnsubmul(b, 1, et), m.isZero() || (m.negative ^= 1);
          _ && (_.words[et] = nt);
        }
        return _ && _._strip(), m._strip(), l !== "div" && f !== 0 && m.iushrn(f), {
          div: _ || null,
          mod: m
        };
      }, i.prototype.divmod = function(u, l, f) {
        if (n(!u.isZero()), this.isZero())
          return {
            div: new i(0),
            mod: new i(0)
          };
        var m, b, T;
        return this.negative !== 0 && u.negative === 0 ? (T = this.neg().divmod(u, l), l !== "mod" && (m = T.div.neg()), l !== "div" && (b = T.mod.neg(), f && b.negative !== 0 && b.iadd(u)), {
          div: m,
          mod: b
        }) : this.negative === 0 && u.negative !== 0 ? (T = this.divmod(u.neg(), l), l !== "mod" && (m = T.div.neg()), {
          div: m,
          mod: T.mod
        }) : this.negative & u.negative ? (T = this.neg().divmod(u.neg(), l), l !== "div" && (b = T.mod.neg(), f && b.negative !== 0 && b.isub(u)), {
          div: T.div,
          mod: b
        }) : u.length > this.length || this.cmp(u) < 0 ? {
          div: new i(0),
          mod: this
        } : u.length === 1 ? l === "div" ? {
          div: this.divn(u.words[0]),
          mod: null
        } : l === "mod" ? {
          div: null,
          mod: new i(this.modrn(u.words[0]))
        } : {
          div: this.divn(u.words[0]),
          mod: new i(this.modrn(u.words[0]))
        } : this._wordDiv(u, l);
      }, i.prototype.div = function(u) {
        return this.divmod(u, "div", !1).div;
      }, i.prototype.mod = function(u) {
        return this.divmod(u, "mod", !1).mod;
      }, i.prototype.umod = function(u) {
        return this.divmod(u, "mod", !0).mod;
      }, i.prototype.divRound = function(u) {
        var l = this.divmod(u);
        if (l.mod.isZero()) return l.div;
        var f = l.div.negative !== 0 ? l.mod.isub(u) : l.mod, m = u.ushrn(1), b = u.andln(1), T = f.cmp(m);
        return T < 0 || b === 1 && T === 0 ? l.div : l.div.negative !== 0 ? l.div.isubn(1) : l.div.iaddn(1);
      }, i.prototype.modrn = function(u) {
        var l = u < 0;
        l && (u = -u), n(u <= 67108863);
        for (var f = (1 << 26) % u, m = 0, b = this.length - 1; b >= 0; b--)
          m = (f * m + (this.words[b] | 0)) % u;
        return l ? -m : m;
      }, i.prototype.modn = function(u) {
        return this.modrn(u);
      }, i.prototype.idivn = function(u) {
        var l = u < 0;
        l && (u = -u), n(u <= 67108863);
        for (var f = 0, m = this.length - 1; m >= 0; m--) {
          var b = (this.words[m] | 0) + f * 67108864;
          this.words[m] = b / u | 0, f = b % u;
        }
        return this._strip(), l ? this.ineg() : this;
      }, i.prototype.divn = function(u) {
        return this.clone().idivn(u);
      }, i.prototype.egcd = function(u) {
        n(u.negative === 0), n(!u.isZero());
        var l = this, f = u.clone();
        l.negative !== 0 ? l = l.umod(u) : l = l.clone();
        for (var m = new i(1), b = new i(0), T = new i(0), O = new i(1), C = 0; l.isEven() && f.isEven(); )
          l.iushrn(1), f.iushrn(1), ++C;
        for (var _ = f.clone(), B = l.clone(); !l.isZero(); ) {
          for (var tt = 0, et = 1; !(l.words[0] & et) && tt < 26; ++tt, et <<= 1) ;
          if (tt > 0)
            for (l.iushrn(tt); tt-- > 0; )
              (m.isOdd() || b.isOdd()) && (m.iadd(_), b.isub(B)), m.iushrn(1), b.iushrn(1);
          for (var nt = 0, Dt = 1; !(f.words[0] & Dt) && nt < 26; ++nt, Dt <<= 1) ;
          if (nt > 0)
            for (f.iushrn(nt); nt-- > 0; )
              (T.isOdd() || O.isOdd()) && (T.iadd(_), O.isub(B)), T.iushrn(1), O.iushrn(1);
          l.cmp(f) >= 0 ? (l.isub(f), m.isub(T), b.isub(O)) : (f.isub(l), T.isub(m), O.isub(b));
        }
        return {
          a: T,
          b: O,
          gcd: f.iushln(C)
        };
      }, i.prototype._invmp = function(u) {
        n(u.negative === 0), n(!u.isZero());
        var l = this, f = u.clone();
        l.negative !== 0 ? l = l.umod(u) : l = l.clone();
        for (var m = new i(1), b = new i(0), T = f.clone(); l.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
          for (var O = 0, C = 1; !(l.words[0] & C) && O < 26; ++O, C <<= 1) ;
          if (O > 0)
            for (l.iushrn(O); O-- > 0; )
              m.isOdd() && m.iadd(T), m.iushrn(1);
          for (var _ = 0, B = 1; !(f.words[0] & B) && _ < 26; ++_, B <<= 1) ;
          if (_ > 0)
            for (f.iushrn(_); _-- > 0; )
              b.isOdd() && b.iadd(T), b.iushrn(1);
          l.cmp(f) >= 0 ? (l.isub(f), m.isub(b)) : (f.isub(l), b.isub(m));
        }
        var tt;
        return l.cmpn(1) === 0 ? tt = m : tt = b, tt.cmpn(0) < 0 && tt.iadd(u), tt;
      }, i.prototype.gcd = function(u) {
        if (this.isZero()) return u.abs();
        if (u.isZero()) return this.abs();
        var l = this.clone(), f = u.clone();
        l.negative = 0, f.negative = 0;
        for (var m = 0; l.isEven() && f.isEven(); m++)
          l.iushrn(1), f.iushrn(1);
        do {
          for (; l.isEven(); )
            l.iushrn(1);
          for (; f.isEven(); )
            f.iushrn(1);
          var b = l.cmp(f);
          if (b < 0) {
            var T = l;
            l = f, f = T;
          } else if (b === 0 || f.cmpn(1) === 0)
            break;
          l.isub(f);
        } while (!0);
        return f.iushln(m);
      }, i.prototype.invm = function(u) {
        return this.egcd(u).a.umod(u);
      }, i.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, i.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, i.prototype.andln = function(u) {
        return this.words[0] & u;
      }, i.prototype.bincn = function(u) {
        n(typeof u == "number");
        var l = u % 26, f = (u - l) / 26, m = 1 << l;
        if (this.length <= f)
          return this._expand(f + 1), this.words[f] |= m, this;
        for (var b = m, T = f; b !== 0 && T < this.length; T++) {
          var O = this.words[T] | 0;
          O += b, b = O >>> 26, O &= 67108863, this.words[T] = O;
        }
        return b !== 0 && (this.words[T] = b, this.length++), this;
      }, i.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, i.prototype.cmpn = function(u) {
        var l = u < 0;
        if (this.negative !== 0 && !l) return -1;
        if (this.negative === 0 && l) return 1;
        this._strip();
        var f;
        if (this.length > 1)
          f = 1;
        else {
          l && (u = -u), n(u <= 67108863, "Number is too big");
          var m = this.words[0] | 0;
          f = m === u ? 0 : m < u ? -1 : 1;
        }
        return this.negative !== 0 ? -f | 0 : f;
      }, i.prototype.cmp = function(u) {
        if (this.negative !== 0 && u.negative === 0) return -1;
        if (this.negative === 0 && u.negative !== 0) return 1;
        var l = this.ucmp(u);
        return this.negative !== 0 ? -l | 0 : l;
      }, i.prototype.ucmp = function(u) {
        if (this.length > u.length) return 1;
        if (this.length < u.length) return -1;
        for (var l = 0, f = this.length - 1; f >= 0; f--) {
          var m = this.words[f] | 0, b = u.words[f] | 0;
          if (m !== b) {
            m < b ? l = -1 : m > b && (l = 1);
            break;
          }
        }
        return l;
      }, i.prototype.gtn = function(u) {
        return this.cmpn(u) === 1;
      }, i.prototype.gt = function(u) {
        return this.cmp(u) === 1;
      }, i.prototype.gten = function(u) {
        return this.cmpn(u) >= 0;
      }, i.prototype.gte = function(u) {
        return this.cmp(u) >= 0;
      }, i.prototype.ltn = function(u) {
        return this.cmpn(u) === -1;
      }, i.prototype.lt = function(u) {
        return this.cmp(u) === -1;
      }, i.prototype.lten = function(u) {
        return this.cmpn(u) <= 0;
      }, i.prototype.lte = function(u) {
        return this.cmp(u) <= 0;
      }, i.prototype.eqn = function(u) {
        return this.cmpn(u) === 0;
      }, i.prototype.eq = function(u) {
        return this.cmp(u) === 0;
      }, i.red = function(u) {
        return new Z(u);
      }, i.prototype.toRed = function(u) {
        return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
      }, i.prototype.fromRed = function() {
        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, i.prototype._forceRed = function(u) {
        return this.red = u, this;
      }, i.prototype.forceRed = function(u) {
        return n(!this.red, "Already a number in reduction context"), this._forceRed(u);
      }, i.prototype.redAdd = function(u) {
        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
      }, i.prototype.redIAdd = function(u) {
        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
      }, i.prototype.redSub = function(u) {
        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
      }, i.prototype.redISub = function(u) {
        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
      }, i.prototype.redShl = function(u) {
        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
      }, i.prototype.redMul = function(u) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
      }, i.prototype.redIMul = function(u) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
      }, i.prototype.redSqr = function() {
        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, i.prototype.redISqr = function() {
        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, i.prototype.redSqrt = function() {
        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, i.prototype.redInvm = function() {
        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, i.prototype.redNeg = function() {
        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, i.prototype.redPow = function(u) {
        return n(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
      };
      var M = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function P(R, u) {
        this.name = R, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      P.prototype._tmp = function() {
        var u = new i(null);
        return u.words = new Array(Math.ceil(this.n / 13)), u;
      }, P.prototype.ireduce = function(u) {
        var l = u, f;
        do
          this.split(l, this.tmp), l = this.imulK(l), l = l.iadd(this.tmp), f = l.bitLength();
        while (f > this.n);
        var m = f < this.n ? -1 : l.ucmp(this.p);
        return m === 0 ? (l.words[0] = 0, l.length = 1) : m > 0 ? l.isub(this.p) : l.strip !== void 0 ? l.strip() : l._strip(), l;
      }, P.prototype.split = function(u, l) {
        u.iushrn(this.n, 0, l);
      }, P.prototype.imulK = function(u) {
        return u.imul(this.k);
      };
      function U() {
        P.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      s(U, P), U.prototype.split = function(u, l) {
        for (var f = 4194303, m = Math.min(u.length, 9), b = 0; b < m; b++)
          l.words[b] = u.words[b];
        if (l.length = m, u.length <= 9) {
          u.words[0] = 0, u.length = 1;
          return;
        }
        var T = u.words[9];
        for (l.words[l.length++] = T & f, b = 10; b < u.length; b++) {
          var O = u.words[b] | 0;
          u.words[b - 10] = (O & f) << 4 | T >>> 22, T = O;
        }
        T >>>= 22, u.words[b - 10] = T, T === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
      }, U.prototype.imulK = function(u) {
        u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
        for (var l = 0, f = 0; f < u.length; f++) {
          var m = u.words[f] | 0;
          l += m * 977, u.words[f] = l & 67108863, l = m * 64 + (l / 67108864 | 0);
        }
        return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
      };
      function z() {
        P.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      s(z, P);
      function G() {
        P.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      s(G, P);
      function Y() {
        P.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      s(Y, P), Y.prototype.imulK = function(u) {
        for (var l = 0, f = 0; f < u.length; f++) {
          var m = (u.words[f] | 0) * 19 + l, b = m & 67108863;
          m >>>= 26, u.words[f] = b, l = m;
        }
        return l !== 0 && (u.words[u.length++] = l), u;
      }, i._prime = function(u) {
        if (M[u]) return M[u];
        var l;
        if (u === "k256")
          l = new U();
        else if (u === "p224")
          l = new z();
        else if (u === "p192")
          l = new G();
        else if (u === "p25519")
          l = new Y();
        else
          throw new Error("Unknown prime " + u);
        return M[u] = l, l;
      };
      function Z(R) {
        if (typeof R == "string") {
          var u = i._prime(R);
          this.m = u.p, this.prime = u;
        } else
          n(R.gtn(1), "modulus must be greater than 1"), this.m = R, this.prime = null;
      }
      Z.prototype._verify1 = function(u) {
        n(u.negative === 0, "red works only with positives"), n(u.red, "red works only with red numbers");
      }, Z.prototype._verify2 = function(u, l) {
        n((u.negative | l.negative) === 0, "red works only with positives"), n(
          u.red && u.red === l.red,
          "red works only with red numbers"
        );
      }, Z.prototype.imod = function(u) {
        return this.prime ? this.prime.ireduce(u)._forceRed(this) : (p(u, u.umod(this.m)._forceRed(this)), u);
      }, Z.prototype.neg = function(u) {
        return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
      }, Z.prototype.add = function(u, l) {
        this._verify2(u, l);
        var f = u.add(l);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
      }, Z.prototype.iadd = function(u, l) {
        this._verify2(u, l);
        var f = u.iadd(l);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f;
      }, Z.prototype.sub = function(u, l) {
        this._verify2(u, l);
        var f = u.sub(l);
        return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
      }, Z.prototype.isub = function(u, l) {
        this._verify2(u, l);
        var f = u.isub(l);
        return f.cmpn(0) < 0 && f.iadd(this.m), f;
      }, Z.prototype.shl = function(u, l) {
        return this._verify1(u), this.imod(u.ushln(l));
      }, Z.prototype.imul = function(u, l) {
        return this._verify2(u, l), this.imod(u.imul(l));
      }, Z.prototype.mul = function(u, l) {
        return this._verify2(u, l), this.imod(u.mul(l));
      }, Z.prototype.isqr = function(u) {
        return this.imul(u, u.clone());
      }, Z.prototype.sqr = function(u) {
        return this.mul(u, u);
      }, Z.prototype.sqrt = function(u) {
        if (u.isZero()) return u.clone();
        var l = this.m.andln(3);
        if (n(l % 2 === 1), l === 3) {
          var f = this.m.add(new i(1)).iushrn(2);
          return this.pow(u, f);
        }
        for (var m = this.m.subn(1), b = 0; !m.isZero() && m.andln(1) === 0; )
          b++, m.iushrn(1);
        n(!m.isZero());
        var T = new i(1).toRed(this), O = T.redNeg(), C = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
        for (_ = new i(2 * _ * _).toRed(this); this.pow(_, C).cmp(O) !== 0; )
          _.redIAdd(O);
        for (var B = this.pow(_, m), tt = this.pow(u, m.addn(1).iushrn(1)), et = this.pow(u, m), nt = b; et.cmp(T) !== 0; ) {
          for (var Dt = et, ft = 0; Dt.cmp(T) !== 0; ft++)
            Dt = Dt.redSqr();
          n(ft < nt);
          var Bt = this.pow(B, new i(1).iushln(nt - ft - 1));
          tt = tt.redMul(Bt), B = Bt.redSqr(), et = et.redMul(B), nt = ft;
        }
        return tt;
      }, Z.prototype.invm = function(u) {
        var l = u._invmp(this.m);
        return l.negative !== 0 ? (l.negative = 0, this.imod(l).redNeg()) : this.imod(l);
      }, Z.prototype.pow = function(u, l) {
        if (l.isZero()) return new i(1).toRed(this);
        if (l.cmpn(1) === 0) return u.clone();
        var f = 4, m = new Array(1 << f);
        m[0] = new i(1).toRed(this), m[1] = u;
        for (var b = 2; b < m.length; b++)
          m[b] = this.mul(m[b - 1], u);
        var T = m[0], O = 0, C = 0, _ = l.bitLength() % 26;
        for (_ === 0 && (_ = 26), b = l.length - 1; b >= 0; b--) {
          for (var B = l.words[b], tt = _ - 1; tt >= 0; tt--) {
            var et = B >> tt & 1;
            if (T !== m[0] && (T = this.sqr(T)), et === 0 && O === 0) {
              C = 0;
              continue;
            }
            O <<= 1, O |= et, C++, !(C !== f && (b !== 0 || tt !== 0)) && (T = this.mul(T, m[O]), C = 0, O = 0);
          }
          _ = 26;
        }
        return T;
      }, Z.prototype.convertTo = function(u) {
        var l = u.umod(this.m);
        return l === u ? l.clone() : l;
      }, Z.prototype.convertFrom = function(u) {
        var l = u.clone();
        return l.red = null, l;
      }, i.mont = function(u) {
        return new q(u);
      };
      function q(R) {
        Z.call(this, R), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      s(q, Z), q.prototype.convertTo = function(u) {
        return this.imod(u.ushln(this.shift));
      }, q.prototype.convertFrom = function(u) {
        var l = this.imod(u.mul(this.rinv));
        return l.red = null, l;
      }, q.prototype.imul = function(u, l) {
        if (u.isZero() || l.isZero())
          return u.words[0] = 0, u.length = 1, u;
        var f = u.imul(l), m = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(m).iushrn(this.shift), T = b;
        return b.cmp(this.m) >= 0 ? T = b.isub(this.m) : b.cmpn(0) < 0 && (T = b.iadd(this.m)), T._forceRed(this);
      }, q.prototype.mul = function(u, l) {
        if (u.isZero() || l.isZero()) return new i(0)._forceRed(this);
        var f = u.mul(l), m = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(m).iushrn(this.shift), T = b;
        return b.cmp(this.m) >= 0 ? T = b.isub(this.m) : b.cmpn(0) < 0 && (T = b.iadd(this.m)), T._forceRed(this);
      }, q.prototype.invm = function(u) {
        var l = this.imod(u._invmp(this.m).mul(this.r2));
        return l._forceRed(this);
      };
    })(r, AI);
  }(Fa)), Fa.exports;
}
var hI = lI();
const Ia = /* @__PURE__ */ k_(hI);
var _I = Object.defineProperty, Qr = (r, t) => _I(r, "name", { value: t, configurable: !0 }), U_ = 9, G_ = 3, ed = 9, Lt, z_ = (Lt = class extends Ia {
  constructor(e, n, s) {
    let i = e, a = n;
    if (Lt.isBN(e) ? i = e.toArray() : typeof e == "string" && e.slice(0, 2) === "0x" && (i = e.substring(2), a = n || "hex"), typeof i == "number" && i > Number.MAX_SAFE_INTEGER)
      throw new x(
        L.NUMBER_TOO_BIG,
        `Value ${i} is too large to be represented as a number, use string instead.`
      );
    super(i ?? 0, a, s);
    Q(this, "MAX_U64", "0xFFFFFFFFFFFFFFFF");
  }
  // ANCHOR: HELPERS
  // make sure we always include `0x` in hex strings
  toString(e, n) {
    const s = super.toString(e, n);
    return e === 16 || e === "hex" ? `0x${s}` : s;
  }
  toHex(e) {
    const s = (e || 0) * 2;
    if (this.isNeg())
      throw new x(L.CONVERTING_FAILED, "Cannot convert negative value to hex.");
    if (e && this.byteLength() > e)
      throw new x(
        L.CONVERTING_FAILED,
        `Provided value ${this} is too large. It should fit within ${e} bytes.`
      );
    return this.toString(16, s);
  }
  toBytes(e) {
    if (this.isNeg())
      throw new x(L.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
    return Uint8Array.from(this.toArray(void 0, e));
  }
  toJSON() {
    return this.toString(16);
  }
  valueOf() {
    return this.toString();
  }
  format(e) {
    const {
      units: n = ed,
      precision: s = U_,
      minPrecision: i = G_
    } = e || {};
    if (n === 0)
      return this.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    const a = i > s ? s : i, o = s > i ? s : i, d = this.formatUnits(n), [A, p = ""] = d.split("."), g = A.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (o === 0)
      return g;
    let y = p.replace(/0+$/, "");
    if (y.length > o)
      if (A === "0") {
        const v = y.search(/[1-9]/);
        v >= 0 && v < o ? y = y.slice(0, o) : y = y.slice(0, v + 1);
      } else
        y = y.slice(0, o);
    else
      y = y.slice(0, o);
    return y.length < a && (y = y.padEnd(a, "0")), y === "" && a === 0 ? g : y ? `${g}.${y}` : g;
  }
  formatUnits(e = ed) {
    const n = this.toString(), s = n.length;
    if (s <= e)
      return `0.${"0".repeat(e - s)}${n}`;
    const i = n.slice(0, s - e), a = n.slice(s - e);
    return `${i}.${a}`;
  }
  // END ANCHOR: HELPERS
  // ANCHOR: OVERRIDES to accept better inputs
  add(e) {
    return this.caller(e, "add");
  }
  pow(e) {
    return this.caller(e, "pow");
  }
  sub(e) {
    return this.caller(e, "sub");
  }
  div(e) {
    return this.caller(e, "div");
  }
  mul(e) {
    return this.caller(e, "mul");
  }
  mod(e) {
    return this.caller(e, "mod");
  }
  divRound(e) {
    return this.caller(e, "divRound");
  }
  lt(e) {
    return this.caller(e, "lt");
  }
  lte(e) {
    return this.caller(e, "lte");
  }
  gt(e) {
    return this.caller(e, "gt");
  }
  gte(e) {
    return this.caller(e, "gte");
  }
  eq(e) {
    return this.caller(e, "eq");
  }
  cmp(e) {
    return this.caller(e, "cmp");
  }
  // END ANCHOR: OVERRIDES to accept better inputs
  // ANCHOR: OVERRIDES to output our BN type
  sqr() {
    return new Lt(super.sqr().toArray());
  }
  neg() {
    return new Lt(super.neg().toArray());
  }
  abs() {
    return new Lt(super.abs().toArray());
  }
  toTwos(e) {
    return new Lt(super.toTwos(e).toArray());
  }
  fromTwos(e) {
    return new Lt(super.fromTwos(e).toArray());
  }
  // END ANCHOR: OVERRIDES to output our BN type
  // ANCHOR: OVERRIDES to avoid losing references
  caller(e, n) {
    const s = super[n](new Lt(e));
    return Lt.isBN(s) ? new Lt(s.toArray()) : s;
  }
  clone() {
    return new Lt(this.toArray());
  }
  mulTo(e, n) {
    const s = new Ia(this.toArray()).mulTo(e, n);
    return new Lt(s.toArray());
  }
  egcd(e) {
    const { a: n, b: s, gcd: i } = new Ia(this.toArray()).egcd(e);
    return {
      a: new Lt(n.toArray()),
      b: new Lt(s.toArray()),
      gcd: new Lt(i.toArray())
    };
  }
  divmod(e, n, s) {
    const { div: i, mod: a } = new Ia(this.toArray()).divmod(new Lt(e), n, s);
    return {
      div: new Lt(i == null ? void 0 : i.toArray()),
      mod: new Lt(a == null ? void 0 : a.toArray())
    };
  }
  maxU64() {
    return this.gte(this.MAX_U64) ? new Lt(this.MAX_U64) : this;
  }
  max(e) {
    return this.gte(e) ? new Lt(e) : this;
  }
  normalizeZeroToOne() {
    return this.isZero() ? new Lt(1) : this;
  }
  // END ANCHOR: OVERRIDES to avoid losing references
}, Qr(Lt, "BN"), Lt), I = /* @__PURE__ */ Qr((r, t, e) => new z_(r, t, e), "bn");
I.parseUnits = (r, t = ed) => {
  const e = r === "." ? "0." : r, [n = "0", s = "0"] = e.split("."), i = s.length;
  if (t === 0) {
    const d = e.replace(",", "").split(".")[0];
    return I(d);
  }
  if (i > t)
    throw new x(
      L.CONVERTING_FAILED,
      `Decimal can't have more than ${t} digits.`
    );
  const a = Array.from({ length: t }).fill("0");
  a.splice(0, i, s);
  const o = `${n.replaceAll(",", "")}${a.join("")}`;
  return I(o);
};
function pI(r, t) {
  const { precision: e = U_, minPrecision: n = G_ } = t || {}, [s = "0", i = "0"] = String(r || "0.0").split("."), a = /(\d)(?=(\d{3})+\b)/g, o = s.replace(a, "$1,");
  let d = i.slice(0, e);
  if (n < e) {
    const p = d.match(/.*[1-9]{1}/), g = (p == null ? void 0 : p[0].length) || 0, y = Math.max(n, g);
    d = d.slice(0, y);
  }
  const A = d ? `.${d}` : "";
  return `${o}${A}`;
}
Qr(pI, "toFixed");
function Ur(r) {
  return I(r).toNumber();
}
Qr(Ur, "toNumber");
function Co(r, t) {
  return I(r).toHex(t);
}
Qr(Co, "toHex");
function nr(r, t) {
  return I(r).toBytes(t);
}
Qr(nr, "toBytes");
function fI(r, t) {
  return I(r).formatUnits(t);
}
Qr(fI, "formatUnits");
function gI(r, t) {
  return I(r).format(t);
}
Qr(gI, "format");
function wI(...r) {
  return r.reduce((t, e) => I(e).gt(t) ? I(e) : t, I(0));
}
Qr(wI, "max");
function mI(...r) {
  return I(Math.ceil(r.reduce((t, e) => I(t).mul(e), I(1)).toNumber()));
}
Qr(mI, "multiply");
var Te = Uint8Array, Ze = Uint16Array, kd = Int32Array, Eo = new Te([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Bo = new Te([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), rd = new Te([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), X_ = function(r, t) {
  for (var e = new Ze(31), n = 0; n < 31; ++n)
    e[n] = t += 1 << r[n - 1];
  for (var s = new kd(e[30]), n = 1; n < 30; ++n)
    for (var i = e[n]; i < e[n + 1]; ++i)
      s[i] = i - e[n] << 5 | n;
  return { b: e, r: s };
}, H_ = X_(Eo, 2), V_ = H_.b, nd = H_.r;
V_[28] = 258, nd[258] = 28;
var W_ = X_(Bo, 0), yI = W_.b, lh = W_.r, sd = new Ze(32768);
for (var kt = 0; kt < 32768; ++kt) {
  var Hr = (kt & 43690) >> 1 | (kt & 21845) << 1;
  Hr = (Hr & 52428) >> 2 | (Hr & 13107) << 2, Hr = (Hr & 61680) >> 4 | (Hr & 3855) << 4, sd[kt] = ((Hr & 65280) >> 8 | (Hr & 255) << 8) >> 1;
}
var xr = function(r, t, e) {
  for (var n = r.length, s = 0, i = new Ze(t); s < n; ++s)
    r[s] && ++i[r[s] - 1];
  var a = new Ze(t);
  for (s = 1; s < t; ++s)
    a[s] = a[s - 1] + i[s - 1] << 1;
  var o;
  if (e) {
    o = new Ze(1 << t);
    var d = 15 - t;
    for (s = 0; s < n; ++s)
      if (r[s])
        for (var A = s << 4 | r[s], p = t - r[s], g = a[r[s] - 1]++ << p, y = g | (1 << p) - 1; g <= y; ++g)
          o[sd[g] >> d] = A;
  } else
    for (o = new Ze(n), s = 0; s < n; ++s)
      r[s] && (o[s] = sd[a[r[s] - 1]++] >> 15 - r[s]);
  return o;
}, an = new Te(288);
for (var kt = 0; kt < 144; ++kt)
  an[kt] = 8;
for (var kt = 144; kt < 256; ++kt)
  an[kt] = 9;
for (var kt = 256; kt < 280; ++kt)
  an[kt] = 7;
for (var kt = 280; kt < 288; ++kt)
  an[kt] = 8;
var ra = new Te(32);
for (var kt = 0; kt < 32; ++kt)
  ra[kt] = 5;
var bI = /* @__PURE__ */ xr(an, 9, 0), II = /* @__PURE__ */ xr(an, 9, 1), CI = /* @__PURE__ */ xr(ra, 5, 0), EI = /* @__PURE__ */ xr(ra, 5, 1), Dc = function(r) {
  for (var t = r[0], e = 1; e < r.length; ++e)
    r[e] > t && (t = r[e]);
  return t;
}, or = function(r, t, e) {
  var n = t / 8 | 0;
  return (r[n] | r[n + 1] << 8) >> (t & 7) & e;
}, Oc = function(r, t) {
  var e = t / 8 | 0;
  return (r[e] | r[e + 1] << 8 | r[e + 2] << 16) >> (t & 7);
}, Ud = function(r) {
  return (r + 7) / 8 | 0;
}, Y_ = function(r, t, e) {
  return (e == null || e > r.length) && (e = r.length), new Te(r.subarray(t, e));
}, BI = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], dr = function(r, t, e) {
  var n = new Error(t || BI[r]);
  if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, dr), !e)
    throw n;
  return n;
}, vI = function(r, t, e, n) {
  var s = r.length, i = 0;
  if (!s || t.f && !t.l)
    return e || new Te(0);
  var a = !e, o = a || t.i != 2, d = t.i;
  a && (e = new Te(s * 3));
  var A = function(Rt) {
    var vt = e.length;
    if (Rt > vt) {
      var Me = new Te(Math.max(vt * 2, Rt));
      Me.set(e), e = Me;
    }
  }, p = t.f || 0, g = t.p || 0, y = t.b || 0, v = t.l, N = t.d, E = t.m, F = t.n, k = s * 8;
  do {
    if (!v) {
      p = or(r, g, 1);
      var H = or(r, g + 1, 3);
      if (g += 3, H)
        if (H == 1)
          v = II, N = EI, E = 9, F = 5;
        else if (H == 2) {
          var P = or(r, g, 31) + 257, U = or(r, g + 10, 15) + 4, z = P + or(r, g + 5, 31) + 1;
          g += 14;
          for (var G = new Te(z), Y = new Te(19), Z = 0; Z < U; ++Z)
            Y[rd[Z]] = or(r, g + Z * 3, 7);
          g += U * 3;
          for (var q = Dc(Y), R = (1 << q) - 1, u = xr(Y, q, 1), Z = 0; Z < z; ) {
            var l = u[or(r, g, R)];
            g += l & 15;
            var X = l >> 4;
            if (X < 16)
              G[Z++] = X;
            else {
              var f = 0, m = 0;
              for (X == 16 ? (m = 3 + or(r, g, 3), g += 2, f = G[Z - 1]) : X == 17 ? (m = 3 + or(r, g, 7), g += 3) : X == 18 && (m = 11 + or(r, g, 127), g += 7); m--; )
                G[Z++] = f;
            }
          }
          var b = G.subarray(0, P), T = G.subarray(P);
          E = Dc(b), F = Dc(T), v = xr(b, E, 1), N = xr(T, F, 1);
        } else
          dr(1);
      else {
        var X = Ud(g) + 4, D = r[X - 4] | r[X - 3] << 8, M = X + D;
        if (M > s) {
          d && dr(0);
          break;
        }
        o && A(y + D), e.set(r.subarray(X, M), y), t.b = y += D, t.p = g = M * 8, t.f = p;
        continue;
      }
      if (g > k) {
        d && dr(0);
        break;
      }
    }
    o && A(y + 131072);
    for (var O = (1 << E) - 1, C = (1 << F) - 1, _ = g; ; _ = g) {
      var f = v[Oc(r, g) & O], B = f >> 4;
      if (g += f & 15, g > k) {
        d && dr(0);
        break;
      }
      if (f || dr(2), B < 256)
        e[y++] = B;
      else if (B == 256) {
        _ = g, v = null;
        break;
      } else {
        var tt = B - 254;
        if (B > 264) {
          var Z = B - 257, et = Eo[Z];
          tt = or(r, g, (1 << et) - 1) + V_[Z], g += et;
        }
        var nt = N[Oc(r, g) & C], Dt = nt >> 4;
        nt || dr(3), g += nt & 15;
        var T = yI[Dt];
        if (Dt > 3) {
          var et = Bo[Dt];
          T += Oc(r, g) & (1 << et) - 1, g += et;
        }
        if (g > k) {
          d && dr(0);
          break;
        }
        o && A(y + 131072);
        var ft = y + tt;
        if (y < T) {
          var Bt = i - T, ar = Math.min(T, ft);
          for (Bt + y < 0 && dr(3); y < ar; ++y)
            e[y] = n[Bt + y];
        }
        for (; y < ft; ++y)
          e[y] = e[y - T];
      }
    }
    t.l = v, t.p = _, t.b = y, t.f = p, v && (p = 1, t.m = E, t.d = N, t.n = F);
  } while (!p);
  return y != e.length && a ? Y_(e, 0, y) : e.subarray(0, y);
}, Dr = function(r, t, e) {
  e <<= t & 7;
  var n = t / 8 | 0;
  r[n] |= e, r[n + 1] |= e >> 8;
}, Gi = function(r, t, e) {
  e <<= t & 7;
  var n = t / 8 | 0;
  r[n] |= e, r[n + 1] |= e >> 8, r[n + 2] |= e >> 16;
}, Mc = function(r, t) {
  for (var e = [], n = 0; n < r.length; ++n)
    r[n] && e.push({ s: n, f: r[n] });
  var s = e.length, i = e.slice();
  if (!s)
    return { t: J_, l: 0 };
  if (s == 1) {
    var a = new Te(e[0].s + 1);
    return a[e[0].s] = 1, { t: a, l: 1 };
  }
  e.sort(function(M, P) {
    return M.f - P.f;
  }), e.push({ s: -1, f: 25001 });
  var o = e[0], d = e[1], A = 0, p = 1, g = 2;
  for (e[0] = { s: -1, f: o.f + d.f, l: o, r: d }; p != s - 1; )
    o = e[e[A].f < e[g].f ? A++ : g++], d = e[A != p && e[A].f < e[g].f ? A++ : g++], e[p++] = { s: -1, f: o.f + d.f, l: o, r: d };
  for (var y = i[0].s, n = 1; n < s; ++n)
    i[n].s > y && (y = i[n].s);
  var v = new Ze(y + 1), N = id(e[p - 1], v, 0);
  if (N > t) {
    var n = 0, E = 0, F = N - t, k = 1 << F;
    for (i.sort(function(P, U) {
      return v[U.s] - v[P.s] || P.f - U.f;
    }); n < s; ++n) {
      var H = i[n].s;
      if (v[H] > t)
        E += k - (1 << N - v[H]), v[H] = t;
      else
        break;
    }
    for (E >>= F; E > 0; ) {
      var X = i[n].s;
      v[X] < t ? E -= 1 << t - v[X]++ - 1 : ++n;
    }
    for (; n >= 0 && E; --n) {
      var D = i[n].s;
      v[D] == t && (--v[D], ++E);
    }
    N = t;
  }
  return { t: new Te(v), l: N };
}, id = function(r, t, e) {
  return r.s == -1 ? Math.max(id(r.l, t, e + 1), id(r.r, t, e + 1)) : t[r.s] = e;
}, hh = function(r) {
  for (var t = r.length; t && !r[--t]; )
    ;
  for (var e = new Ze(++t), n = 0, s = r[0], i = 1, a = function(d) {
    e[n++] = d;
  }, o = 1; o <= t; ++o)
    if (r[o] == s && o != t)
      ++i;
    else {
      if (!s && i > 2) {
        for (; i > 138; i -= 138)
          a(32754);
        i > 2 && (a(i > 10 ? i - 11 << 5 | 28690 : i - 3 << 5 | 12305), i = 0);
      } else if (i > 3) {
        for (a(s), --i; i > 6; i -= 6)
          a(8304);
        i > 2 && (a(i - 3 << 5 | 8208), i = 0);
      }
      for (; i--; )
        a(s);
      i = 1, s = r[o];
    }
  return { c: e.subarray(0, n), n: t };
}, zi = function(r, t) {
  for (var e = 0, n = 0; n < t.length; ++n)
    e += r[n] * t[n];
  return e;
}, Z_ = function(r, t, e) {
  var n = e.length, s = Ud(t + 2);
  r[s] = n & 255, r[s + 1] = n >> 8, r[s + 2] = r[s] ^ 255, r[s + 3] = r[s + 1] ^ 255;
  for (var i = 0; i < n; ++i)
    r[s + i + 4] = e[i];
  return (s + 4 + n) * 8;
}, _h = function(r, t, e, n, s, i, a, o, d, A, p) {
  Dr(t, p++, e), ++s[256];
  for (var g = Mc(s, 15), y = g.t, v = g.l, N = Mc(i, 15), E = N.t, F = N.l, k = hh(y), H = k.c, X = k.n, D = hh(E), M = D.c, P = D.n, U = new Ze(19), z = 0; z < H.length; ++z)
    ++U[H[z] & 31];
  for (var z = 0; z < M.length; ++z)
    ++U[M[z] & 31];
  for (var G = Mc(U, 7), Y = G.t, Z = G.l, q = 19; q > 4 && !Y[rd[q - 1]]; --q)
    ;
  var R = A + 5 << 3, u = zi(s, an) + zi(i, ra) + a, l = zi(s, y) + zi(i, E) + a + 14 + 3 * q + zi(U, Y) + 2 * U[16] + 3 * U[17] + 7 * U[18];
  if (d >= 0 && R <= u && R <= l)
    return Z_(t, p, r.subarray(d, d + A));
  var f, m, b, T;
  if (Dr(t, p, 1 + (l < u)), p += 2, l < u) {
    f = xr(y, v, 0), m = y, b = xr(E, F, 0), T = E;
    var O = xr(Y, Z, 0);
    Dr(t, p, X - 257), Dr(t, p + 5, P - 1), Dr(t, p + 10, q - 4), p += 14;
    for (var z = 0; z < q; ++z)
      Dr(t, p + 3 * z, Y[rd[z]]);
    p += 3 * q;
    for (var C = [H, M], _ = 0; _ < 2; ++_)
      for (var B = C[_], z = 0; z < B.length; ++z) {
        var tt = B[z] & 31;
        Dr(t, p, O[tt]), p += Y[tt], tt > 15 && (Dr(t, p, B[z] >> 5 & 127), p += B[z] >> 12);
      }
  } else
    f = bI, m = an, b = CI, T = ra;
  for (var z = 0; z < o; ++z) {
    var et = n[z];
    if (et > 255) {
      var tt = et >> 18 & 31;
      Gi(t, p, f[tt + 257]), p += m[tt + 257], tt > 7 && (Dr(t, p, et >> 23 & 31), p += Eo[tt]);
      var nt = et & 31;
      Gi(t, p, b[nt]), p += T[nt], nt > 3 && (Gi(t, p, et >> 5 & 8191), p += Bo[nt]);
    } else
      Gi(t, p, f[et]), p += m[et];
  }
  return Gi(t, p, f[256]), p + m[256];
}, xI = /* @__PURE__ */ new kd([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), J_ = /* @__PURE__ */ new Te(0), RI = function(r, t, e, n, s, i) {
  var a = i.z || r.length, o = new Te(n + a + 5 * (1 + Math.ceil(a / 7e3)) + s), d = o.subarray(n, o.length - s), A = i.l, p = (i.r || 0) & 7;
  if (t) {
    p && (d[0] = i.r >> 3);
    for (var g = xI[t - 1], y = g >> 13, v = g & 8191, N = (1 << e) - 1, E = i.p || new Ze(32768), F = i.h || new Ze(N + 1), k = Math.ceil(e / 3), H = 2 * k, X = function(Tt) {
      return (r[Tt] ^ r[Tt + 1] << k ^ r[Tt + 2] << H) & N;
    }, D = new kd(25e3), M = new Ze(288), P = new Ze(32), U = 0, z = 0, G = i.i || 0, Y = 0, Z = i.w || 0, q = 0; G + 2 < a; ++G) {
      var R = X(G), u = G & 32767, l = F[R];
      if (E[u] = l, F[R] = u, Z <= G) {
        var f = a - G;
        if ((U > 7e3 || Y > 24576) && (f > 423 || !A)) {
          p = _h(r, d, 0, D, M, P, z, Y, q, G - q, p), Y = U = z = 0, q = G;
          for (var m = 0; m < 286; ++m)
            M[m] = 0;
          for (var m = 0; m < 30; ++m)
            P[m] = 0;
        }
        var b = 2, T = 0, O = v, C = u - l & 32767;
        if (f > 2 && R == X(G - C))
          for (var _ = Math.min(y, f) - 1, B = Math.min(32767, G), tt = Math.min(258, f); C <= B && --O && u != l; ) {
            if (r[G + b] == r[G + b - C]) {
              for (var et = 0; et < tt && r[G + et] == r[G + et - C]; ++et)
                ;
              if (et > b) {
                if (b = et, T = C, et > _)
                  break;
                for (var nt = Math.min(C, et - 2), Dt = 0, m = 0; m < nt; ++m) {
                  var ft = G - C + m & 32767, Bt = E[ft], ar = ft - Bt & 32767;
                  ar > Dt && (Dt = ar, l = ft);
                }
              }
            }
            u = l, l = E[u], C += u - l & 32767;
          }
        if (T) {
          D[Y++] = 268435456 | nd[b] << 18 | lh[T];
          var Rt = nd[b] & 31, vt = lh[T] & 31;
          z += Eo[Rt] + Bo[vt], ++M[257 + Rt], ++P[vt], Z = G + b, ++U;
        } else
          D[Y++] = r[G], ++M[r[G]];
      }
    }
    for (G = Math.max(G, Z); G < a; ++G)
      D[Y++] = r[G], ++M[r[G]];
    p = _h(r, d, A, D, M, P, z, Y, q, G - q, p), A || (i.r = p & 7 | d[p / 8 | 0] << 3, p -= 7, i.h = F, i.p = E, i.i = G, i.w = Z);
  } else {
    for (var G = i.w || 0; G < a + A; G += 65535) {
      var Me = G + 65535;
      Me >= a && (d[p / 8 | 0] = A, Me = a), p = Z_(d, p + 1, r.subarray(G, Me));
    }
    i.i = a;
  }
  return Y_(o, 0, n + Ud(p) + s);
}, SI = /* @__PURE__ */ function() {
  for (var r = new Int32Array(256), t = 0; t < 256; ++t) {
    for (var e = t, n = 9; --n; )
      e = (e & 1 && -306674912) ^ e >>> 1;
    r[t] = e;
  }
  return r;
}(), TI = function() {
  var r = -1;
  return {
    p: function(t) {
      for (var e = r, n = 0; n < t.length; ++n)
        e = SI[e & 255 ^ t[n]] ^ e >>> 8;
      r = e;
    },
    d: function() {
      return ~r;
    }
  };
}, FI = function(r, t, e, n, s) {
  if (!s && (s = { l: 1 }, t.dictionary)) {
    var i = t.dictionary.subarray(-32768), a = new Te(i.length + r.length);
    a.set(i), a.set(r, i.length), r = a, s.w = i.length;
  }
  return RI(r, t.level == null ? 6 : t.level, t.mem == null ? s.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 20 : 12 + t.mem, e, n, s);
}, ad = function(r, t, e) {
  for (; e; ++t)
    r[t] = e, e >>>= 8;
}, NI = function(r, t) {
  var e = t.filename;
  if (r[0] = 31, r[1] = 139, r[2] = 8, r[8] = t.level < 2 ? 4 : t.level == 9 ? 2 : 0, r[9] = 3, t.mtime != 0 && ad(r, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), e) {
    r[3] = 8;
    for (var n = 0; n <= e.length; ++n)
      r[n + 10] = e.charCodeAt(n);
  }
}, QI = function(r) {
  (r[0] != 31 || r[1] != 139 || r[2] != 8) && dr(6, "invalid gzip data");
  var t = r[3], e = 10;
  t & 4 && (e += (r[10] | r[11] << 8) + 2);
  for (var n = (t >> 3 & 1) + (t >> 4 & 1); n > 0; n -= !r[e++])
    ;
  return e + (t & 2);
}, DI = function(r) {
  var t = r.length;
  return (r[t - 4] | r[t - 3] << 8 | r[t - 2] << 16 | r[t - 1] << 24) >>> 0;
}, OI = function(r) {
  return 10 + (r.filename ? r.filename.length + 1 : 0);
};
function MI(r, t) {
  t || (t = {});
  var e = TI(), n = r.length;
  e.p(r);
  var s = FI(r, t, OI(t), 8), i = s.length;
  return NI(s, t), ad(s, i - 8, e.d()), ad(s, i - 4, n), s;
}
function PI(r, t) {
  var e = QI(r);
  return e + 8 > r.length && dr(6, "invalid gzip data"), vI(r.subarray(e, -8), { i: 2 }, new Te(DI(r)), t);
}
var LI = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), kI = 0;
try {
  LI.decode(J_, { stream: !0 }), kI = 1;
} catch {
}
var UI = Object.defineProperty, Pt = (r, t) => UI(r, "name", { value: t, configurable: !0 }), PR = /* @__PURE__ */ Pt((r) => r.length ? r[0].toUpperCase() + r.slice(1) : r, "capitalizeString"), j_ = /* @__PURE__ */ Pt((r, t) => {
  const e = [];
  for (let o = 0; o < r.length; o += t) {
    const d = new Uint8Array(t);
    d.set(r.slice(o, o + t)), e.push(d);
  }
  const n = e[e.length - 1], s = r.length % t, i = s + (8 - s % 8) % 8, a = n.slice(0, i);
  return e[e.length - 1] = a, e;
}, "chunkAndPadBytes"), j = /* @__PURE__ */ Pt((r, t, e = !0) => {
  if (r instanceof Uint8Array)
    return e ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const i = new Uint8Array((r.length - 2) / 2);
    let a = 2;
    for (let o = 0; o < i.length; o++)
      i[o] = parseInt(r.substring(a, a + 2), 16), a += 2;
    return i;
  }
  const s = `invalid data:${t ? ` ${t} -` : ""} ${r}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;
  throw new x(L.INVALID_DATA, s);
}, "arrayify"), vo = /* @__PURE__ */ Pt((r) => {
  const t = r.map((s) => s instanceof Uint8Array ? s : Uint8Array.from(s)), e = t.reduce((s, i) => s + i.length, 0), n = new Uint8Array(e);
  return t.reduce((s, i) => (n.set(i, s), s + i.length), 0), n;
}, "concatBytes"), ct = /* @__PURE__ */ Pt((r) => {
  const t = r.map((e) => j(e));
  return vo(t);
}, "concat"), ph = "0123456789abcdef";
function W(r) {
  const t = j(r);
  let e = "0x";
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    e += ph[(s & 240) >> 4] + ph[s & 15];
  }
  return e;
}
Pt(W, "hexlify");
var LR = /* @__PURE__ */ Pt((r) => {
  const e = [
    (n) => n.replace(/\s+/g, "-"),
    // spaces to -
    (n) => n.replace(/\./g, "-"),
    // dots to -
    (n) => n.replace(/_/g, "-"),
    // underscore to -
    (n) => n.replace(/-[a-z]/g, (s) => s.slice(-1).toUpperCase()),
    // delete '-' and capitalize the letter after them
    (n) => n.replace(/-/g, ""),
    // delete any '-' left
    (n) => n.replace(/^\d+/, ""),
    // removes leading digits
    (n) => n[0].toUpperCase() + n.slice(1)
    // capitalize first letter
  ].reduce((n, s) => s(n), r);
  if (e === "") {
    const n = `The provided string '${r}' results in an empty output after`.concat(
      " normalization, therefore, it can't normalize string."
    );
    throw new x(L.PARSE_FAILED, n);
  }
  return e;
}, "normalizeString"), GI = 37, q_ = BigInt(2 ** 62) + BigInt(GI), zI = /* @__PURE__ */ Pt((r) => Math.floor(r / 1e3), "msToSeconds"), $_ = /* @__PURE__ */ Pt((r) => r * 1e3, "secondsToMs"), XI = /* @__PURE__ */ Pt((r) => Number(BigInt(r) - q_), "tai64ToUnixSeconds"), HI = /* @__PURE__ */ Pt((r) => String(BigInt(r) + q_), "unixSecondsToTai64"), VI = /* @__PURE__ */ Pt((r) => $_(XI(r)), "tai64ToUnixMilliseconds"), vr, K_ = (vr = class extends Date {
  /**
   * Generates a new DateTime instance from a Tai64 timestamp.
   *
   * @param tai64 - Tai64 timestamp
   * @returns a new DateTime instance
   */
  static fromTai64(t) {
    return new vr(VI(t));
  }
  /**
   * @param unixMilliseconds - unix milliseconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixMilliseconds(t) {
    return new vr(t);
  }
  /**
   * @param unixSeconds - unix seconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixSeconds(t) {
    return new vr($_(t));
  }
  /**
   * Hide the constructor to prevent direct instantiation.
   */
  constructor(t) {
    super(t);
  }
  /**
   * Returns the Tai64 timestamp.
   *
   * @returns the Tai64 timestamp
   */
  toTai64() {
    return HI(this.toUnixSeconds());
  }
  /**
   * @returns the unix milliseconds timestamp
   */
  toUnixMilliseconds() {
    return this.getTime();
  }
  /**
   * @returns the unix seconds timestamp
   */
  toUnixSeconds() {
    return zI(this.getTime());
  }
}, Pt(vr, "DateTime"), Q(vr, "TAI64_NULL", ""), vr);
function Gd(r) {
  return new Promise((t) => {
    setTimeout(() => {
      t(!0);
    }, r);
  });
}
Pt(Gd, "sleep");
var WI = {
  chain_name: "local_testnet",
  consensus_parameters: {
    V2: {
      tx_params: {
        V1: {
          max_inputs: 255,
          max_outputs: 255,
          max_witnesses: 255,
          max_gas_per_tx: 3e7,
          max_size: 112640,
          max_bytecode_subsections: 256
        }
      },
      predicate_params: {
        V1: {
          max_predicate_length: 24576,
          max_predicate_data_length: 24576,
          max_message_data_length: 102400,
          max_gas_per_predicate: 1e6
        }
      },
      script_params: {
        V1: {
          max_script_length: 102400,
          max_script_data_length: 102400
        }
      },
      contract_params: {
        V1: {
          contract_max_size: 112640,
          max_storage_slots: 1760
        }
      },
      fee_params: {
        V1: {
          gas_price_factor: 115e4,
          gas_per_byte: 63
        }
      },
      chain_id: 0,
      gas_costs: {
        V4: {
          add: 2,
          addi: 2,
          and: 2,
          andi: 2,
          bal: 274,
          bhei: 2,
          bhsh: 2,
          burn: 7566,
          cb: 2,
          cfsi: 2,
          div: 2,
          divi: 2,
          eck1: 1489,
          ecr1: 20513,
          eq: 2,
          exp: 2,
          expi: 2,
          flag: 2,
          gm: 2,
          gt: 2,
          gtf: 3,
          ji: 2,
          jmp: 2,
          jne: 2,
          jnei: 2,
          jnzi: 2,
          jmpf: 2,
          jmpb: 2,
          jnzf: 2,
          jnzb: 2,
          jnef: 2,
          jneb: 2,
          lb: 2,
          log: 80,
          lt: 2,
          lw: 2,
          mint: 6566,
          mlog: 2,
          mod: 2,
          modi: 2,
          move: 2,
          movi: 1,
          mroo: 3,
          mul: 2,
          muli: 2,
          mldv: 3,
          niop: 2,
          noop: 1,
          not: 2,
          or: 1,
          ori: 2,
          poph: 2,
          popl: 2,
          pshh: 5,
          pshl: 5,
          ret_contract: 43,
          rvrt_contract: 39,
          sb: 2,
          sll: 2,
          slli: 2,
          srl: 2,
          srli: 2,
          srw: 237,
          sub: 2,
          subi: 2,
          sw: 2,
          sww: 5708,
          time: 106,
          tr: 9253,
          tro: 7199,
          wdcm: 2,
          wqcm: 2,
          wdop: 2,
          wqop: 3,
          wdml: 3,
          wqml: 3,
          wddv: 3,
          wqdv: 4,
          wdmd: 6,
          wqmd: 9,
          wdam: 6,
          wqam: 6,
          wdmm: 6,
          wqmm: 6,
          xor: 2,
          xori: 2,
          ecop: 2,
          aloc: {
            LightOperation: {
              base: 2,
              units_per_gas: 35
            }
          },
          bsiz: {
            LightOperation: {
              base: 25,
              units_per_gas: 564
            }
          },
          bldd: {
            LightOperation: {
              base: 33,
              units_per_gas: 130
            }
          },
          cfe: {
            LightOperation: {
              base: 10,
              units_per_gas: 62
            }
          },
          cfei: {
            LightOperation: {
              base: 10,
              units_per_gas: 66
            }
          },
          call: {
            LightOperation: {
              base: 6934,
              units_per_gas: 14
            }
          },
          ccp: {
            LightOperation: {
              base: 21,
              units_per_gas: 155
            }
          },
          croo: {
            LightOperation: {
              base: 69,
              units_per_gas: 4
            }
          },
          csiz: {
            LightOperation: {
              base: 25,
              units_per_gas: 580
            }
          },
          ed19: {
            LightOperation: {
              base: 3232,
              units_per_gas: 7
            }
          },
          k256: {
            LightOperation: {
              base: 21,
              units_per_gas: 6
            }
          },
          ldc: {
            LightOperation: {
              base: 84,
              units_per_gas: 113
            }
          },
          logd: {
            LightOperation: {
              base: 278,
              units_per_gas: 5
            }
          },
          mcl: {
            LightOperation: {
              base: 2,
              units_per_gas: 1282
            }
          },
          mcli: {
            LightOperation: {
              base: 2,
              units_per_gas: 1250
            }
          },
          mcp: {
            LightOperation: {
              base: 3,
              units_per_gas: 385
            }
          },
          mcpi: {
            LightOperation: {
              base: 7,
              units_per_gas: 585
            }
          },
          meq: {
            LightOperation: {
              base: 2,
              units_per_gas: 1234
            }
          },
          retd_contract: {
            LightOperation: {
              base: 227,
              units_per_gas: 5
            }
          },
          s256: {
            LightOperation: {
              base: 25,
              units_per_gas: 5
            }
          },
          scwq: {
            HeavyOperation: {
              base: 5666,
              gas_per_unit: 6628
            }
          },
          smo: {
            LightOperation: {
              base: 14635,
              units_per_gas: 3
            }
          },
          srwq: {
            HeavyOperation: {
              base: 245,
              gas_per_unit: 243
            }
          },
          swwq: {
            HeavyOperation: {
              base: 5661,
              gas_per_unit: 5776
            }
          },
          epar: {
            HeavyOperation: {
              base: 5661,
              gas_per_unit: 5776
            }
          },
          contract_root: {
            LightOperation: {
              base: 24,
              units_per_gas: 3
            }
          },
          state_root: {
            HeavyOperation: {
              base: 189,
              gas_per_unit: 96
            }
          },
          new_storage_per_byte: 63,
          vm_initialization: {
            LightOperation: {
              base: 3127,
              units_per_gas: 61
            }
          }
        }
      },
      base_asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07",
      block_gas_limit: 3e7,
      block_transaction_size_limit: 260096,
      privileged_address: "0000000000000000000000000000000000000000000000000000000000000000"
    }
  },
  consensus: {
    PoA: {
      signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
    }
  }
}, YI = {
  chain_config: "chainConfig.json",
  table_encoding: {
    Json: {
      filepath: "stateConfig.json"
    }
  }
}, ZI = {
  coins: [],
  messages: [],
  contracts: [],
  blobs: [],
  block_height: 0,
  da_block_height: 0
}, kR = {
  chainConfig: WI,
  metadata: YI,
  stateConfig: ZI
}, UR = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298";
function Ge(r) {
  return r !== void 0;
}
Pt(Ge, "isDefined");
var tp = I(0), od = I(58), oo = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", Ca = null;
function ep(r) {
  if (Ca == null) {
    Ca = {};
    for (let e = 0; e < oo.length; e++)
      Ca[oo[e]] = I(e);
  }
  const t = Ca[r];
  if (t == null)
    throw new x(L.INVALID_DATA, `invalid base58 value ${r}`);
  return I(t);
}
Pt(ep, "getAlpha");
function zd(r) {
  const t = j(r);
  let e = I(t), n = "";
  for (; e.gt(tp); )
    n = oo[Number(e.mod(od))] + n, e = e.div(od);
  for (let s = 0; s < t.length && !t[s]; s++)
    n = oo[0] + n;
  return n;
}
Pt(zd, "encodeBase58");
function rp(r) {
  let t = tp;
  for (let e = 0; e < r.length; e++)
    t = t.mul(od), t = t.add(ep(r[e].toString()));
  return t;
}
Pt(rp, "decodeBase58");
function xo(r, t, e) {
  const n = j(r);
  if (e != null && e > n.length)
    throw new x(L.INVALID_DATA, "cannot slice beyond data bounds");
  return W(n.slice(t ?? 0, e ?? n.length));
}
Pt(xo, "dataSlice");
function pr(r, t = !0) {
  let e = r;
  t && (e = r.normalize("NFC"));
  const n = [];
  for (let s = 0; s < e.length; s += 1) {
    const i = e.charCodeAt(s);
    if (i < 128)
      n.push(i);
    else if (i < 2048)
      n.push(i >> 6 | 192), n.push(i & 63 | 128);
    else if ((i & 64512) === 55296) {
      s += 1;
      const a = e.charCodeAt(s);
      if (s >= e.length || (a & 64512) !== 56320)
        throw new x(
          L.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      const o = 65536 + ((i & 1023) << 10) + (a & 1023);
      n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
    } else
      n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
  }
  return new Uint8Array(n);
}
Pt(pr, "toUtf8Bytes");
function Jr(r, t, e, n, s) {
  return console.log(`invalid codepoint at offset ${t}; ${r}, bytes: ${e}`), t;
}
Pt(Jr, "onError");
function np(r) {
  return r.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(
    (t >> 10 & 1023) + 55296,
    (t & 1023) + 56320
  ))).join("");
}
Pt(np, "helper");
function sp(r) {
  const t = j(r, "bytes"), e = [];
  let n = 0;
  for (; n < t.length; ) {
    const s = t[n++];
    if (!(s >> 7)) {
      e.push(s);
      continue;
    }
    let i = null, a = null;
    if ((s & 224) === 192)
      i = 1, a = 127;
    else if ((s & 240) === 224)
      i = 2, a = 2047;
    else if ((s & 248) === 240)
      i = 3, a = 65535;
    else {
      (s & 192) === 128 ? n += Jr("UNEXPECTED_CONTINUE", n - 1, t) : n += Jr("BAD_PREFIX", n - 1, t);
      continue;
    }
    if (n - 1 + i >= t.length) {
      n += Jr("OVERRUN", n - 1, t);
      continue;
    }
    let o = s & (1 << 8 - i - 1) - 1;
    for (let d = 0; d < i; d++) {
      const A = t[n];
      if ((A & 192) !== 128) {
        n += Jr("MISSING_CONTINUE", n, t), o = null;
        break;
      }
      o = o << 6 | A & 63, n++;
    }
    if (o !== null) {
      if (o > 1114111) {
        n += Jr("OUT_OF_RANGE", n - 1 - i, t);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        n += Jr("UTF16_SURROGATE", n - 1 - i, t);
        continue;
      }
      if (o <= a) {
        n += Jr("OVERLONG", n - 1 - i, t);
        continue;
      }
      e.push(o);
    }
  }
  return e;
}
Pt(sp, "getUtf8CodePoints");
function Ro(r) {
  return np(sp(r));
}
Pt(Ro, "toUtf8String");
var GR = /* @__PURE__ */ Pt((r) => {
  if (!r)
    return "";
  const t = j(r), e = MI(t, { mtime: 0 }), n = String.fromCharCode.apply(
    null,
    new Uint8Array(e)
  );
  return btoa(n);
}, "compressBytecode"), JI = /* @__PURE__ */ Pt((r) => {
  const t = atob(r), e = new Uint8Array(t.length).map(
    (s, i) => t.charCodeAt(i)
  );
  return PI(e);
}, "decompressBytecode");
function So(r) {
  throw new Error("Didn't expect to get here");
}
Pt(So, "assertUnreachable");
function We(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function jI(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function pa(r, ...t) {
  if (!jI(r))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(r.length))
    throw new Error("Uint8Array expected of length " + t + ", got length=" + r.length);
}
function ip(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  We(r.outputLen), We(r.blockLen);
}
function Ci(r, t = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function ap(r, t) {
  pa(r);
  const e = t.outputLen;
  if (r.length < e)
    throw new Error("digestInto() expects output buffer of length at least " + e);
}
const jn = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Na(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function Qa(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function wr(r, t) {
  return r << 32 - t | r >>> t;
}
function It(r, t) {
  return r << t | r >>> 32 - t >>> 0;
}
const co = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function qI(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function uo(r) {
  for (let t = 0; t < r.length; t++)
    r[t] = qI(r[t]);
}
function $I(r) {
  if (typeof r != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof r);
  return new Uint8Array(new TextEncoder().encode(r));
}
function Ei(r) {
  return typeof r == "string" && (r = $I(r)), pa(r), r;
}
function KI(...r) {
  let t = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    pa(s), t += s.length;
  }
  const e = new Uint8Array(t);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    e.set(i, s), s += i.length;
  }
  return e;
}
class Xd {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function op(r, t) {
  if (t !== void 0 && {}.toString.call(t) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(r, t);
}
function To(r) {
  const t = (n) => r().update(Ei(n)).digest(), e = r();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => r(), t;
}
function tC(r = 32) {
  if (jn && typeof jn.getRandomValues == "function")
    return jn.getRandomValues(new Uint8Array(r));
  if (jn && typeof jn.randomBytes == "function")
    return jn.randomBytes(r);
  throw new Error("crypto.getRandomValues must be defined");
}
class cp extends Xd {
  constructor(t, e) {
    super(), this.finished = !1, this.destroyed = !1, ip(t);
    const n = Ei(e);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? t.create().update(n).digest() : n);
    for (let a = 0; a < i.length; a++)
      i[a] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let a = 0; a < i.length; a++)
      i[a] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return Ci(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ci(this), pa(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: n, finished: s, destroyed: i, blockLen: a, outputLen: o } = this;
    return t = t, t.finished = s, t.destroyed = i, t.blockLen = a, t.outputLen = o, t.oHash = e._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Fo = (r, t, e) => new cp(r, t).update(e).digest();
Fo.create = (r, t) => new cp(r, t);
function eC(r, t, e, n) {
  ip(r);
  const s = op({ dkLen: 32, asyncTick: 10 }, n), { c: i, dkLen: a, asyncTick: o } = s;
  if (We(i), We(a), We(o), i < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const d = Ei(t), A = Ei(e), p = new Uint8Array(a), g = Fo.create(r, d), y = g._cloneInto().update(A);
  return { c: i, dkLen: a, asyncTick: o, DK: p, PRF: g, PRFSalt: y };
}
function rC(r, t, e, n, s) {
  return r.destroy(), t.destroy(), n && n.destroy(), s.fill(0), e;
}
function Hd(r, t, e, n) {
  const { c: s, dkLen: i, DK: a, PRF: o, PRFSalt: d } = eC(r, t, e, n);
  let A;
  const p = new Uint8Array(4), g = Qa(p), y = new Uint8Array(o.outputLen);
  for (let v = 1, N = 0; N < i; v++, N += o.outputLen) {
    const E = a.subarray(N, N + o.outputLen);
    g.setInt32(0, v, !1), (A = d._cloneInto(A)).update(p).digestInto(y), E.set(y.subarray(0, E.length));
    for (let F = 1; F < s; F++) {
      o._cloneInto(A).update(y).digestInto(y);
      for (let k = 0; k < E.length; k++)
        E[k] ^= y[k];
    }
  }
  return rC(o, d, a, A, y);
}
function nC(r, t, e, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(t, e, n);
  const s = BigInt(32), i = BigInt(4294967295), a = Number(e >> s & i), o = Number(e & i), d = n ? 4 : 0, A = n ? 0 : 4;
  r.setUint32(t + d, a, n), r.setUint32(t + A, o, n);
}
function sC(r, t, e) {
  return r & t ^ ~r & e;
}
function iC(r, t, e) {
  return r & t ^ r & e ^ t & e;
}
class Vd extends Xd {
  constructor(t, e, n, s) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Qa(this.buffer);
  }
  update(t) {
    Ci(this);
    const { view: e, buffer: n, blockLen: s } = this;
    t = Ei(t);
    const i = t.length;
    for (let a = 0; a < i; ) {
      const o = Math.min(s - this.pos, i - a);
      if (o === s) {
        const d = Qa(t);
        for (; s <= i - a; a += s)
          this.process(d, a);
        continue;
      }
      n.set(t.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === s && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ci(this), ap(t, this), this.finished = !0;
    const { buffer: e, view: n, blockLen: s, isLE: i } = this;
    let { pos: a } = this;
    e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > s - a && (this.process(n, 0), a = 0);
    for (let g = a; g < s; g++)
      e[g] = 0;
    nC(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const o = Qa(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const A = d / 4, p = this.get();
    if (A > p.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let g = 0; g < A; g++)
      o.setUint32(4 * g, p[g], i);
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const n = t.slice(0, e);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: n, length: s, finished: i, destroyed: a, pos: o } = this;
    return t.length = s, t.pos = o, t.finished = i, t.destroyed = a, s % e && t.buffer.set(n), t;
  }
}
const aC = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Vr = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Wr = /* @__PURE__ */ new Uint32Array(64);
class oC extends Vd {
  constructor() {
    super(64, 32, 8, !1), this.A = Vr[0] | 0, this.B = Vr[1] | 0, this.C = Vr[2] | 0, this.D = Vr[3] | 0, this.E = Vr[4] | 0, this.F = Vr[5] | 0, this.G = Vr[6] | 0, this.H = Vr[7] | 0;
  }
  get() {
    const { A: t, B: e, C: n, D: s, E: i, F: a, G: o, H: d } = this;
    return [t, e, n, s, i, a, o, d];
  }
  // prettier-ignore
  set(t, e, n, s, i, a, o, d) {
    this.A = t | 0, this.B = e | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = a | 0, this.G = o | 0, this.H = d | 0;
  }
  process(t, e) {
    for (let g = 0; g < 16; g++, e += 4)
      Wr[g] = t.getUint32(e, !1);
    for (let g = 16; g < 64; g++) {
      const y = Wr[g - 15], v = Wr[g - 2], N = wr(y, 7) ^ wr(y, 18) ^ y >>> 3, E = wr(v, 17) ^ wr(v, 19) ^ v >>> 10;
      Wr[g] = E + Wr[g - 7] + N + Wr[g - 16] | 0;
    }
    let { A: n, B: s, C: i, D: a, E: o, F: d, G: A, H: p } = this;
    for (let g = 0; g < 64; g++) {
      const y = wr(o, 6) ^ wr(o, 11) ^ wr(o, 25), v = p + y + sC(o, d, A) + aC[g] + Wr[g] | 0, E = (wr(n, 2) ^ wr(n, 13) ^ wr(n, 22)) + iC(n, s, i) | 0;
      p = A, A = d, d = o, o = a + v | 0, a = i, i = s, s = n, n = v + E | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, d = d + this.F | 0, A = A + this.G | 0, p = p + this.H | 0, this.set(n, s, i, a, o, d, A, p);
  }
  roundClean() {
    Wr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const dn = /* @__PURE__ */ To(() => new oC());
function fh(r, t, e, n, s, i) {
  let a = r[t++] ^ e[n++], o = r[t++] ^ e[n++], d = r[t++] ^ e[n++], A = r[t++] ^ e[n++], p = r[t++] ^ e[n++], g = r[t++] ^ e[n++], y = r[t++] ^ e[n++], v = r[t++] ^ e[n++], N = r[t++] ^ e[n++], E = r[t++] ^ e[n++], F = r[t++] ^ e[n++], k = r[t++] ^ e[n++], H = r[t++] ^ e[n++], X = r[t++] ^ e[n++], D = r[t++] ^ e[n++], M = r[t++] ^ e[n++], P = a, U = o, z = d, G = A, Y = p, Z = g, q = y, R = v, u = N, l = E, f = F, m = k, b = H, T = X, O = D, C = M;
  for (let _ = 0; _ < 8; _ += 2)
    Y ^= It(P + b | 0, 7), u ^= It(Y + P | 0, 9), b ^= It(u + Y | 0, 13), P ^= It(b + u | 0, 18), l ^= It(Z + U | 0, 7), T ^= It(l + Z | 0, 9), U ^= It(T + l | 0, 13), Z ^= It(U + T | 0, 18), O ^= It(f + q | 0, 7), z ^= It(O + f | 0, 9), q ^= It(z + O | 0, 13), f ^= It(q + z | 0, 18), G ^= It(C + m | 0, 7), R ^= It(G + C | 0, 9), m ^= It(R + G | 0, 13), C ^= It(m + R | 0, 18), U ^= It(P + G | 0, 7), z ^= It(U + P | 0, 9), G ^= It(z + U | 0, 13), P ^= It(G + z | 0, 18), q ^= It(Z + Y | 0, 7), R ^= It(q + Z | 0, 9), Y ^= It(R + q | 0, 13), Z ^= It(Y + R | 0, 18), m ^= It(f + l | 0, 7), u ^= It(m + f | 0, 9), l ^= It(u + m | 0, 13), f ^= It(l + u | 0, 18), b ^= It(C + O | 0, 7), T ^= It(b + C | 0, 9), O ^= It(T + b | 0, 13), C ^= It(O + T | 0, 18);
  s[i++] = a + P | 0, s[i++] = o + U | 0, s[i++] = d + z | 0, s[i++] = A + G | 0, s[i++] = p + Y | 0, s[i++] = g + Z | 0, s[i++] = y + q | 0, s[i++] = v + R | 0, s[i++] = N + u | 0, s[i++] = E + l | 0, s[i++] = F + f | 0, s[i++] = k + m | 0, s[i++] = H + b | 0, s[i++] = X + T | 0, s[i++] = D + O | 0, s[i++] = M + C | 0;
}
function Pc(r, t, e, n, s) {
  let i = n + 0, a = n + 16 * s;
  for (let o = 0; o < 16; o++)
    e[a + o] = r[t + (2 * s - 1) * 16 + o];
  for (let o = 0; o < s; o++, i += 16, t += 16)
    fh(e, a, r, t, e, i), o > 0 && (a += 16), fh(e, i, r, t += 16, e, a);
}
function cC(r, t, e) {
  const n = op({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1073742848
  }, e), { N: s, r: i, p: a, dkLen: o, asyncTick: d, maxmem: A, onProgress: p } = n;
  if (We(s), We(i), We(a), We(o), We(d), We(A), p !== void 0 && typeof p != "function")
    throw new Error("progressCb should be function");
  const g = 128 * i, y = g / 4;
  if (s <= 1 || s & s - 1 || s > 2 ** 32)
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  if (a < 0 || a > (2 ** 32 - 1) * 32 / g)
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  if (o < 0 || o > (2 ** 32 - 1) * 32)
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  if (g * (s + a) > A)
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + A);
  const N = Hd(dn, r, t, { c: 1, dkLen: g * a }), E = Na(N), F = Na(new Uint8Array(g * s)), k = Na(new Uint8Array(g));
  let H = () => {
  };
  if (p) {
    const X = 2 * s * a, D = Math.max(Math.floor(X / 1e4), 1);
    let M = 0;
    H = () => {
      M++, p && (!(M % D) || M === X) && p(M / X);
    };
  }
  return { N: s, r: i, p: a, dkLen: o, blockSize32: y, V: F, B32: E, B: N, tmp: k, blockMixCb: H, asyncTick: d };
}
function dC(r, t, e, n, s) {
  const i = Hd(dn, r, e, { c: 1, dkLen: t });
  return e.fill(0), n.fill(0), s.fill(0), i;
}
function uC(r, t, e) {
  const { N: n, r: s, p: i, dkLen: a, blockSize32: o, V: d, B32: A, B: p, tmp: g, blockMixCb: y } = cC(r, t, e);
  co || uo(A);
  for (let v = 0; v < i; v++) {
    const N = o * v;
    for (let E = 0; E < o; E++)
      d[E] = A[N + E];
    for (let E = 0, F = 0; E < n - 1; E++)
      Pc(d, F, d, F += o, s), y();
    Pc(d, (n - 1) * o, A, N, s), y();
    for (let E = 0; E < n; E++) {
      const F = A[N + o - 16] % n;
      for (let k = 0; k < o; k++)
        g[k] = A[N + k] ^ d[F * o + k];
      Pc(g, 0, A, N, s), y();
    }
  }
  return co || uo(A), dC(r, a, p, d, g);
}
const Ea = /* @__PURE__ */ BigInt(2 ** 32 - 1), cd = /* @__PURE__ */ BigInt(32);
function dp(r, t = !1) {
  return t ? { h: Number(r & Ea), l: Number(r >> cd & Ea) } : { h: Number(r >> cd & Ea) | 0, l: Number(r & Ea) | 0 };
}
function up(r, t = !1) {
  let e = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: a } = dp(r[s], t);
    [e[s], n[s]] = [i, a];
  }
  return [e, n];
}
const AC = (r, t) => BigInt(r >>> 0) << cd | BigInt(t >>> 0), lC = (r, t, e) => r >>> e, hC = (r, t, e) => r << 32 - e | t >>> e, _C = (r, t, e) => r >>> e | t << 32 - e, pC = (r, t, e) => r << 32 - e | t >>> e, fC = (r, t, e) => r << 64 - e | t >>> e - 32, gC = (r, t, e) => r >>> e - 32 | t << 64 - e, wC = (r, t) => t, mC = (r, t) => r, Ap = (r, t, e) => r << e | t >>> 32 - e, lp = (r, t, e) => t << e | r >>> 32 - e, hp = (r, t, e) => t << e - 32 | r >>> 64 - e, _p = (r, t, e) => r << e - 32 | t >>> 64 - e;
function yC(r, t, e, n) {
  const s = (t >>> 0) + (n >>> 0);
  return { h: r + e + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const bC = (r, t, e) => (r >>> 0) + (t >>> 0) + (e >>> 0), IC = (r, t, e, n) => t + e + n + (r / 2 ** 32 | 0) | 0, CC = (r, t, e, n) => (r >>> 0) + (t >>> 0) + (e >>> 0) + (n >>> 0), EC = (r, t, e, n, s) => t + e + n + s + (r / 2 ** 32 | 0) | 0, BC = (r, t, e, n, s) => (r >>> 0) + (t >>> 0) + (e >>> 0) + (n >>> 0) + (s >>> 0), vC = (r, t, e, n, s, i) => t + e + n + s + i + (r / 2 ** 32 | 0) | 0, gt = {
  fromBig: dp,
  split: up,
  toBig: AC,
  shrSH: lC,
  shrSL: hC,
  rotrSH: _C,
  rotrSL: pC,
  rotrBH: fC,
  rotrBL: gC,
  rotr32H: wC,
  rotr32L: mC,
  rotlSH: Ap,
  rotlSL: lp,
  rotlBH: hp,
  rotlBL: _p,
  add: yC,
  add3L: bC,
  add3H: IC,
  add4L: CC,
  add4H: EC,
  add5H: vC,
  add5L: BC
}, pp = [], fp = [], gp = [], xC = /* @__PURE__ */ BigInt(0), Xi = /* @__PURE__ */ BigInt(1), RC = /* @__PURE__ */ BigInt(2), SC = /* @__PURE__ */ BigInt(7), TC = /* @__PURE__ */ BigInt(256), FC = /* @__PURE__ */ BigInt(113);
for (let r = 0, t = Xi, e = 1, n = 0; r < 24; r++) {
  [e, n] = [n, (2 * e + 3 * n) % 5], pp.push(2 * (5 * n + e)), fp.push((r + 1) * (r + 2) / 2 % 64);
  let s = xC;
  for (let i = 0; i < 7; i++)
    t = (t << Xi ^ (t >> SC) * FC) % TC, t & RC && (s ^= Xi << (Xi << /* @__PURE__ */ BigInt(i)) - Xi);
  gp.push(s);
}
const [NC, QC] = /* @__PURE__ */ up(gp, !0), gh = (r, t, e) => e > 32 ? hp(r, t, e) : Ap(r, t, e), wh = (r, t, e) => e > 32 ? _p(r, t, e) : lp(r, t, e);
function DC(r, t = 24) {
  const e = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let a = 0; a < 10; a++)
      e[a] = r[a] ^ r[a + 10] ^ r[a + 20] ^ r[a + 30] ^ r[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const o = (a + 8) % 10, d = (a + 2) % 10, A = e[d], p = e[d + 1], g = gh(A, p, 1) ^ e[o], y = wh(A, p, 1) ^ e[o + 1];
      for (let v = 0; v < 50; v += 10)
        r[a + v] ^= g, r[a + v + 1] ^= y;
    }
    let s = r[2], i = r[3];
    for (let a = 0; a < 24; a++) {
      const o = fp[a], d = gh(s, i, o), A = wh(s, i, o), p = pp[a];
      s = r[p], i = r[p + 1], r[p] = d, r[p + 1] = A;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let o = 0; o < 10; o++)
        e[o] = r[a + o];
      for (let o = 0; o < 10; o++)
        r[a + o] ^= ~e[(o + 2) % 10] & e[(o + 4) % 10];
    }
    r[0] ^= NC[n], r[1] ^= QC[n];
  }
  e.fill(0);
}
class Wd extends Xd {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, e, n, s = !1, i = 24) {
    if (super(), this.blockLen = t, this.suffix = e, this.outputLen = n, this.enableXOF = s, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, We(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Na(this.state);
  }
  keccak() {
    co || uo(this.state32), DC(this.state32, this.rounds), co || uo(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    Ci(this);
    const { blockLen: e, state: n } = this;
    t = Ei(t);
    const s = t.length;
    for (let i = 0; i < s; ) {
      const a = Math.min(e - this.pos, s - i);
      for (let o = 0; o < a; o++)
        n[this.pos++] ^= t[i++];
      this.pos === e && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: e, pos: n, blockLen: s } = this;
    t[n] ^= e, e & 128 && n === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    Ci(this, !1), pa(t), this.finish();
    const e = this.state, { blockLen: n } = this;
    for (let s = 0, i = t.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const a = Math.min(n - this.posOut, i - s);
      t.set(e.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return We(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (ap(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: e, suffix: n, outputLen: s, rounds: i, enableXOF: a } = this;
    return t || (t = new Wd(e, n, s, a, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = n, t.outputLen = s, t.enableXOF = a, t.destroyed = this.destroyed, t;
  }
}
const OC = (r, t, e) => To(() => new Wd(t, r, e)), MC = /* @__PURE__ */ OC(1, 136, 256 / 8), PC = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), wp = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((r, t) => t)), LC = /* @__PURE__ */ wp.map((r) => (9 * r + 5) % 16);
let Yd = [wp], Zd = [LC];
for (let r = 0; r < 4; r++)
  for (let t of [Yd, Zd])
    t.push(t[r].map((e) => PC[e]));
const mp = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((r) => new Uint8Array(r)), kC = /* @__PURE__ */ Yd.map((r, t) => r.map((e) => mp[t][e])), UC = /* @__PURE__ */ Zd.map((r, t) => r.map((e) => mp[t][e])), GC = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), zC = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function mh(r, t, e, n) {
  return r === 0 ? t ^ e ^ n : r === 1 ? t & e | ~t & n : r === 2 ? (t | ~e) ^ n : r === 3 ? t & n | e & ~n : t ^ (e | ~n);
}
const Ba = /* @__PURE__ */ new Uint32Array(16);
class XC extends Vd {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: e, h2: n, h3: s, h4: i } = this;
    return [t, e, n, s, i];
  }
  set(t, e, n, s, i) {
    this.h0 = t | 0, this.h1 = e | 0, this.h2 = n | 0, this.h3 = s | 0, this.h4 = i | 0;
  }
  process(t, e) {
    for (let v = 0; v < 16; v++, e += 4)
      Ba[v] = t.getUint32(e, !0);
    let n = this.h0 | 0, s = n, i = this.h1 | 0, a = i, o = this.h2 | 0, d = o, A = this.h3 | 0, p = A, g = this.h4 | 0, y = g;
    for (let v = 0; v < 5; v++) {
      const N = 4 - v, E = GC[v], F = zC[v], k = Yd[v], H = Zd[v], X = kC[v], D = UC[v];
      for (let M = 0; M < 16; M++) {
        const P = It(n + mh(v, i, o, A) + Ba[k[M]] + E, X[M]) + g | 0;
        n = g, g = A, A = It(o, 10) | 0, o = i, i = P;
      }
      for (let M = 0; M < 16; M++) {
        const P = It(s + mh(N, a, d, p) + Ba[H[M]] + F, D[M]) + y | 0;
        s = y, y = p, p = It(d, 10) | 0, d = a, a = P;
      }
    }
    this.set(this.h1 + o + p | 0, this.h2 + A + y | 0, this.h3 + g + s | 0, this.h4 + n + a | 0, this.h0 + i + d | 0);
  }
  roundClean() {
    Ba.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const HC = /* @__PURE__ */ To(() => new XC()), [VC, WC] = gt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((r) => BigInt(r))), Yr = /* @__PURE__ */ new Uint32Array(80), Zr = /* @__PURE__ */ new Uint32Array(80);
class YC extends Vd {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: e, Bh: n, Bl: s, Ch: i, Cl: a, Dh: o, Dl: d, Eh: A, El: p, Fh: g, Fl: y, Gh: v, Gl: N, Hh: E, Hl: F } = this;
    return [t, e, n, s, i, a, o, d, A, p, g, y, v, N, E, F];
  }
  // prettier-ignore
  set(t, e, n, s, i, a, o, d, A, p, g, y, v, N, E, F) {
    this.Ah = t | 0, this.Al = e | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = a | 0, this.Dh = o | 0, this.Dl = d | 0, this.Eh = A | 0, this.El = p | 0, this.Fh = g | 0, this.Fl = y | 0, this.Gh = v | 0, this.Gl = N | 0, this.Hh = E | 0, this.Hl = F | 0;
  }
  process(t, e) {
    for (let X = 0; X < 16; X++, e += 4)
      Yr[X] = t.getUint32(e), Zr[X] = t.getUint32(e += 4);
    for (let X = 16; X < 80; X++) {
      const D = Yr[X - 15] | 0, M = Zr[X - 15] | 0, P = gt.rotrSH(D, M, 1) ^ gt.rotrSH(D, M, 8) ^ gt.shrSH(D, M, 7), U = gt.rotrSL(D, M, 1) ^ gt.rotrSL(D, M, 8) ^ gt.shrSL(D, M, 7), z = Yr[X - 2] | 0, G = Zr[X - 2] | 0, Y = gt.rotrSH(z, G, 19) ^ gt.rotrBH(z, G, 61) ^ gt.shrSH(z, G, 6), Z = gt.rotrSL(z, G, 19) ^ gt.rotrBL(z, G, 61) ^ gt.shrSL(z, G, 6), q = gt.add4L(U, Z, Zr[X - 7], Zr[X - 16]), R = gt.add4H(q, P, Y, Yr[X - 7], Yr[X - 16]);
      Yr[X] = R | 0, Zr[X] = q | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: a, Ch: o, Cl: d, Dh: A, Dl: p, Eh: g, El: y, Fh: v, Fl: N, Gh: E, Gl: F, Hh: k, Hl: H } = this;
    for (let X = 0; X < 80; X++) {
      const D = gt.rotrSH(g, y, 14) ^ gt.rotrSH(g, y, 18) ^ gt.rotrBH(g, y, 41), M = gt.rotrSL(g, y, 14) ^ gt.rotrSL(g, y, 18) ^ gt.rotrBL(g, y, 41), P = g & v ^ ~g & E, U = y & N ^ ~y & F, z = gt.add5L(H, M, U, WC[X], Zr[X]), G = gt.add5H(z, k, D, P, VC[X], Yr[X]), Y = z | 0, Z = gt.rotrSH(n, s, 28) ^ gt.rotrBH(n, s, 34) ^ gt.rotrBH(n, s, 39), q = gt.rotrSL(n, s, 28) ^ gt.rotrBL(n, s, 34) ^ gt.rotrBL(n, s, 39), R = n & i ^ n & o ^ i & o, u = s & a ^ s & d ^ a & d;
      k = E | 0, H = F | 0, E = v | 0, F = N | 0, v = g | 0, N = y | 0, { h: g, l: y } = gt.add(A | 0, p | 0, G | 0, Y | 0), A = o | 0, p = d | 0, o = i | 0, d = a | 0, i = n | 0, a = s | 0;
      const l = gt.add3L(Y, q, u);
      n = gt.add3H(l, G, Z, R), s = l | 0;
    }
    ({ h: n, l: s } = gt.add(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: a } = gt.add(this.Bh | 0, this.Bl | 0, i | 0, a | 0), { h: o, l: d } = gt.add(this.Ch | 0, this.Cl | 0, o | 0, d | 0), { h: A, l: p } = gt.add(this.Dh | 0, this.Dl | 0, A | 0, p | 0), { h: g, l: y } = gt.add(this.Eh | 0, this.El | 0, g | 0, y | 0), { h: v, l: N } = gt.add(this.Fh | 0, this.Fl | 0, v | 0, N | 0), { h: E, l: F } = gt.add(this.Gh | 0, this.Gl | 0, E | 0, F | 0), { h: k, l: H } = gt.add(this.Hh | 0, this.Hl | 0, k | 0, H | 0), this.set(n, s, i, a, o, d, A, p, g, y, v, N, E, F, k, H);
  }
  roundClean() {
    Yr.fill(0), Zr.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const yp = /* @__PURE__ */ To(() => new YC());
var ZC = Object.defineProperty, ze = (r, t) => ZC(r, "name", { value: t, configurable: !0 }), JC = /* @__PURE__ */ ze((r) => {
  const { password: t, salt: e, n, p: s, r: i, dklen: a } = r;
  return uC(t, e, { N: n, r: i, p: s, dkLen: a });
}, "scrypt"), jC = /* @__PURE__ */ ze((r) => MC(r), "keccak256");
function bp(r) {
  const t = j(r, "data");
  return HC(t);
}
ze(bp, "ripemd160");
var as = /* @__PURE__ */ ze((r, t = "base64") => {
  switch (t) {
    case "utf-8":
      return new TextEncoder().encode(r);
    case "base64": {
      const e = atob(r), n = e.length;
      return new Uint8Array(n).map((i, a) => e.charCodeAt(a));
    }
    case "hex":
    default: {
      const e = r.length / 2;
      return new Uint8Array(e).map((s, i) => {
        const a = i * 2;
        return parseInt(r.substring(a, a + 2), 16);
      });
    }
  }
}, "bufferFromString"), Ip = /* @__PURE__ */ ze((r, t, e, n, s) => {
  const i = { sha256: dn, sha512: yp }[s];
  return W(Hd(i, r, t, { c: e, dkLen: n }));
}, "pbkdf2"), { crypto: fa, btoa: Cp } = globalThis;
if (!fa)
  throw new x(
    L.ENV_DEPENDENCY_MISSING,
    "Could not find 'crypto' in current browser environment."
  );
if (!Cp)
  throw new x(
    L.ENV_DEPENDENCY_MISSING,
    "Could not find 'btoa' in current browser environment."
  );
var dd = /* @__PURE__ */ ze((r) => fa.getRandomValues(new Uint8Array(r)), "randomBytes"), Da = /* @__PURE__ */ ze((r, t = "base64") => {
  switch (t) {
    case "utf-8":
      return new TextDecoder().decode(r);
    case "base64": {
      const e = String.fromCharCode.apply(null, new Uint8Array(r));
      return Cp(e);
    }
    case "hex":
    default: {
      let e = "";
      for (let n = 0; n < r.length; n += 1) {
        const s = r[n].toString(16);
        e += s.length === 1 ? `0${s}` : s;
      }
      return e;
    }
  }
}, "stringFromBuffer"), Ep = "AES-CTR", Jd = /* @__PURE__ */ ze((r, t) => {
  const e = as(String(r).normalize("NFKC"), "utf-8"), n = Ip(e, t, 1e5, 32, "sha256");
  return j(n);
}, "keyFromPassword"), qC = /* @__PURE__ */ ze(async (r, t) => {
  const e = dd(16), n = dd(32), s = Jd(r, n), i = JSON.stringify(t), a = as(i, "utf-8"), o = {
    name: Ep,
    counter: e,
    length: 64
  }, d = await crypto.subtle.importKey("raw", s, o, !1, ["encrypt"]), A = await crypto.subtle.encrypt(o, d, a);
  return {
    data: Da(new Uint8Array(A)),
    iv: Da(e),
    salt: Da(n)
  };
}, "encrypt"), $C = /* @__PURE__ */ ze(async (r, t) => {
  const e = as(t.iv), n = as(t.salt), s = Jd(r, n), i = as(t.data), a = {
    name: Ep,
    counter: e,
    length: 64
  }, o = await crypto.subtle.importKey("raw", s, a, !1, ["decrypt"]), d = await crypto.subtle.decrypt(a, o, i), A = new TextDecoder().decode(d);
  try {
    return JSON.parse(A);
  } catch {
    throw new x(L.INVALID_CREDENTIALS, "Invalid credentials.");
  }
}, "decrypt"), KC = /* @__PURE__ */ ze(async (r, t, e) => {
  const n = fa.subtle, s = new Uint8Array(t.subarray(0, 16)), i = e, a = r, o = await n.importKey(
    "raw",
    s,
    { name: "AES-CTR", length: 128 },
    !1,
    ["encrypt", "decrypt"]
  ), d = await n.encrypt(
    { name: "AES-CTR", counter: i, length: 128 },
    o,
    a
  );
  return new Uint8Array(d);
}, "encryptJsonWalletData"), tE = /* @__PURE__ */ ze(async (r, t, e) => {
  const n = fa.subtle, s = new Uint8Array(t.subarray(0, 16)).buffer, i = new Uint8Array(e).buffer, a = new Uint8Array(r).buffer, o = await n.importKey(
    "raw",
    s,
    { name: "AES-CTR", length: 128 },
    !1,
    ["encrypt", "decrypt"]
  ), d = await n.decrypt(
    { name: "AES-CTR", counter: i, length: 128 },
    o,
    a
  );
  return new Uint8Array(d);
}, "decryptJsonWalletData"), eE = /* @__PURE__ */ ze((r, t, e) => {
  const n = r === "sha256" ? dn : yp, s = Fo.create(n, t).update(e).digest();
  return W(s);
}, "computeHmac"), rE = /* @__PURE__ */ ze(() => fa.randomUUID(), "randomUUID"), nE = {
  bufferFromString: as,
  stringFromBuffer: Da,
  decrypt: $C,
  encrypt: qC,
  keyFromPassword: Jd,
  randomBytes: dd,
  scrypt: JC,
  keccak256: jC,
  decryptJsonWalletData: tE,
  encryptJsonWalletData: KC,
  computeHmac: eE,
  pbkdf2: Ip,
  ripemd160: bp,
  randomUUID: rE
}, sE = nE, {
  bufferFromString: wn,
  decrypt: iE,
  encrypt: aE,
  keyFromPassword: zR,
  randomBytes: ir,
  stringFromBuffer: Yi,
  scrypt: Bp,
  keccak256: vp,
  decryptJsonWalletData: oE,
  encryptJsonWalletData: cE,
  pbkdf2: dE,
  computeHmac: xp,
  ripemd160: uE,
  randomUUID: AE
} = sE, lE = Object.defineProperty, No = (r, t) => lE(r, "name", { value: t, configurable: !0 }), hE = `Fuel Signed Message:
`;
function Xt(r) {
  return W(dn(j(r)));
}
No(Xt, "sha256");
function gr(r) {
  return Xt(r);
}
No(gr, "hash");
function Rp(r) {
  const t = BigInt(r), e = new ArrayBuffer(8), n = new DataView(e);
  return n.setBigUint64(0, t, !1), new Uint8Array(n.buffer);
}
No(Rp, "uint64ToBytesBE");
function Sp(r) {
  if (typeof r == "string")
    return Xt(pr(r));
  const { personalSign: t } = r, e = typeof t == "string" ? pr(t) : t, n = ct([
    pr(hE),
    pr(String(e.length)),
    e
  ]);
  return W(Xt(n));
}
No(Sp, "hashMessage");
var _E = Object.defineProperty, pt = (r, t) => _E(r, "name", { value: t, configurable: !0 }), os, yt = (os = class {
  constructor(t, e, n) {
    Q(this, "name");
    Q(this, "type");
    Q(this, "encodedLength");
    this.name = t, this.type = e, this.encodedLength = n;
  }
}, pt(os, "Coder"), os), pE = "u8", fE = "u16", gE = "u32", wE = "u64", mE = "u256", yE = "raw untyped ptr", bE = "raw untyped slice", IE = "bool", CE = "b256", EE = "struct std::b512::B512", Ao = "enum std::option::Option", BE = "struct std::vec::Vec", vE = "struct std::bytes::Bytes", xE = "struct std::string::String", RE = "str", ga = "()", Tp = /^enum (std::option::)?Option$/m, Fp = /^str\[(?<length>[0-9]+)\]/, ud = /^\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/, Np = /^struct.+/, Qp = /^enum.+$/, SE = /^\((?<items>.*)\)$/, TE = /^generic.+$/, FE = /([^\s]+)$/m, Bi = "1", ht = 8, Xr = 32, lo = Xr + 2, na = Xr, Ad = Xr, NE = Xr, QE = ht * 4, DE = ht * 2, Dp = 2 ** 32 - 1, Op = /* @__PURE__ */ pt(({ maxInputs: r }) => Xr + // Tx ID
na + // Base asset ID
// Asset ID/Balance coin input pairs
r * (na + ht) + ht, "calculateVmTxMemory"), Mp = ht + // Identifier
ht + // Gas limit
ht + // Script size
ht + // Script data size
ht + // Policies
ht + // Inputs size
ht + // Outputs size
ht + // Witnesses size
Xr, XR = ht + // Identifier
QE + // Utxo Length
ht + // Output Index
NE + // Owner
ht + // Amount
na + // Asset id
DE + // TxPointer
ht + // Witnesses index
ht + // Predicate size
ht + // Predicate data size
ht, yh = /* @__PURE__ */ pt((r) => r instanceof Uint8Array, "isUint8Array"), Di = /* @__PURE__ */ pt((r) => {
  const t = Array.isArray(r) ? r : Object.values(r);
  for (const e of t)
    if (e.type === Ao || "coder" in e && e.coder.type === Ao || "coders" in e && Di(e.coders))
      return !0;
  return !1;
}, "hasNestedOption"), ca, cs, mt = (cs = class extends yt {
  constructor(e, n) {
    super("array", `[${e.type}; ${n}]`, n * e.encodedLength);
    Q(this, "coder");
    Q(this, "length");
    Ce(this, ca);
    this.coder = e, this.length = n, Gt(this, ca, Di([e]));
  }
  encode(e) {
    if (!Array.isArray(e))
      throw new x(L.ENCODE_ERROR, "Expected array value.");
    if (this.length !== e.length)
      throw new x(L.ENCODE_ERROR, "Types/values length mismatch.");
    return ct(Array.from(e).map((n) => this.coder.encode(n)));
  }
  decode(e, n) {
    if (!_t(this, ca) && e.length < this.encodedLength || e.length > Dp)
      throw new x(L.DECODE_ERROR, "Invalid array data size.");
    let s = n;
    return [Array(this.length).fill(0).map(() => {
      let a;
      return [a, s] = this.coder.decode(e, s), a;
    }), s];
  }
}, ca = new WeakMap(), pt(cs, "ArrayCoder"), cs), ds, ot = (ds = class extends yt {
  constructor() {
    super("b256", "b256", ht * 4);
  }
  encode(t) {
    let e;
    try {
      e = j(t);
    } catch {
      throw new x(L.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (e.length !== this.encodedLength)
      throw new x(L.ENCODE_ERROR, `Invalid ${this.type}.`);
    return e;
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid b256 data size.");
    let n = t.slice(e, e + this.encodedLength);
    if (I(n).isZero() && (n = new Uint8Array(32)), n.length !== this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid b256 byte data size.");
    return [Co(n, 32), e + 32];
  }
}, pt(ds, "B256Coder"), ds), us, OE = (us = class extends yt {
  constructor() {
    super("b512", "struct B512", ht * 8);
  }
  encode(t) {
    let e;
    try {
      e = j(t);
    } catch {
      throw new x(L.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (e.length !== this.encodedLength)
      throw new x(L.ENCODE_ERROR, `Invalid ${this.type}.`);
    return e;
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid b512 data size.");
    let n = t.slice(e, e + this.encodedLength);
    if (I(n).isZero() && (n = new Uint8Array(64)), n.length !== this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid b512 byte data size.");
    return [Co(n, this.encodedLength), e + this.encodedLength];
  }
}, pt(us, "B512Coder"), us), ME = {
  u64: ht,
  u256: ht * 4
}, As, rt = (As = class extends yt {
  constructor(t) {
    super("bigNumber", t, ME[t]);
  }
  encode(t) {
    let e;
    if (typeof t == "number" && t > Number.MAX_SAFE_INTEGER)
      throw new x(
        L.ENCODE_ERROR,
        `Invalid ${this.type} type - number value is too large. Number can only safely handle up to 53 bits.`
      );
    try {
      e = nr(t, this.encodedLength);
    } catch {
      throw new x(L.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return e;
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, `Invalid ${this.type} data size.`);
    let n = t.slice(e, e + this.encodedLength);
    if (n = n.slice(0, this.encodedLength), n.length !== this.encodedLength)
      throw new x(L.DECODE_ERROR, `Invalid ${this.type} byte data size.`);
    return [I(n), e + this.encodedLength];
  }
}, pt(As, "BigNumberCoder"), As), ls, PE = (ls = class extends yt {
  constructor(e = {
    padToWordSize: !1
  }) {
    const n = e.padToWordSize ? ht : 1;
    super("boolean", "boolean", n);
    Q(this, "options");
    this.options = e;
  }
  encode(e) {
    if (!(e === !0 || e === !1))
      throw new x(L.ENCODE_ERROR, "Invalid boolean value.");
    return nr(e ? 1 : 0, this.encodedLength);
  }
  decode(e, n) {
    if (e.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid boolean data size.");
    const s = I(e.slice(n, n + this.encodedLength));
    if (s.isZero())
      return [!1, n + this.encodedLength];
    if (!s.eq(I(1)))
      throw new x(L.DECODE_ERROR, "Invalid boolean value.");
    return [!0, n + this.encodedLength];
  }
}, pt(ls, "BooleanCoder"), ls), Cn, LE = (Cn = class extends yt {
  constructor() {
    super("struct", "struct Bytes", ht);
  }
  encode(t) {
    const e = t instanceof Uint8Array ? t : new Uint8Array(t), n = new rt("u64").encode(e.length);
    return new Uint8Array([...n, ...e]);
  }
  decode(t, e) {
    if (t.length < ht)
      throw new x(L.DECODE_ERROR, "Invalid byte data size.");
    const n = e + ht, s = t.slice(e, n), i = I(new rt("u64").decode(s, 0)[0]).toNumber(), a = t.slice(n, n + i);
    if (a.length !== i)
      throw new x(L.DECODE_ERROR, "Invalid bytes byte data size.");
    return [a, n + i];
  }
}, pt(Cn, "ByteCoder"), Q(Cn, "memorySize", 1), Cn), En, da, hs, cn, Lp, kp, Up, _s, Pp = (_s = class extends yt {
  constructor(e, n) {
    const s = new rt("u64"), i = Object.values(n).reduce(
      (a, o) => Math.min(a, o.encodedLength),
      0
    );
    super(`enum ${e}`, `enum ${e}`, s.encodedLength + i);
    Ce(this, cn);
    Q(this, "name");
    Q(this, "coders");
    Ce(this, En);
    Ce(this, da);
    Ce(this, hs);
    this.name = e, this.coders = n, Gt(this, En, s), Gt(this, da, i), Gt(this, hs, !(Tp.test(this.type) || Di(n)));
  }
  encode(e) {
    if (typeof e == "string" && this.coders[e])
      return un(this, cn, kp).call(this, e);
    const [n, ...s] = Object.keys(e);
    if (!n)
      throw new x(L.INVALID_DECODE_VALUE, "A field for the case must be provided.");
    if (s.length !== 0)
      throw new x(L.INVALID_DECODE_VALUE, "Only one field must be provided.");
    const i = this.coders[n], a = Object.keys(this.coders).indexOf(n);
    if (a === -1) {
      const d = Object.keys(this.coders).map((A) => `'${A}'`).join(", ");
      throw new x(
        L.INVALID_DECODE_VALUE,
        `Invalid case '${n}'. Valid cases: ${d}.`
      );
    }
    const o = i.encode(e[n]);
    return new Uint8Array([..._t(this, En).encode(a), ...o]);
  }
  decode(e, n) {
    if (_t(this, hs) && e.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid enum data size.");
    const s = new rt("u64").decode(e, n)[0], i = Ur(s), a = Object.keys(this.coders)[i];
    if (!a)
      throw new x(
        L.INVALID_DECODE_VALUE,
        `Invalid caseIndex "${i}". Valid cases: ${Object.keys(this.coders)}.`
      );
    const o = this.coders[a], d = n + _t(this, En).encodedLength;
    if (_t(this, hs) && e.length < d + o.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid enum data size.");
    const [A, p] = o.decode(e, d);
    return un(this, cn, Lp).call(this, this.coders[a]) ? un(this, cn, Up).call(this, a, p) : [{ [a]: A }, p];
  }
}, En = new WeakMap(), da = new WeakMap(), hs = new WeakMap(), cn = new WeakSet(), // Checks that we're handling a native enum that is of type void.
Lp = function(e) {
  return this.type !== Ao && e.type === ga;
}, kp = function(e) {
  const n = this.coders[e], s = n.encode([]), i = Object.keys(this.coders).indexOf(e), a = new Uint8Array(_t(this, da) - n.encodedLength);
  return ct([_t(this, En).encode(i), a, s]);
}, Up = function(e, n) {
  return [e, n];
}, pt(_s, "EnumCoder"), _s), kE = /* @__PURE__ */ pt((r) => {
  switch (r) {
    case "u8":
      return 1;
    case "u16":
      return 2;
    case "u32":
      return 4;
    default:
      throw new x(L.TYPE_NOT_SUPPORTED, `Invalid number type: ${r}`);
  }
}, "getLength"), ps, K = (ps = class extends yt {
  constructor(e, n = {
    padToWordSize: !1
  }) {
    const s = n.padToWordSize ? ht : kE(e);
    super("number", e, s);
    Q(this, "baseType");
    Q(this, "options");
    this.baseType = e, this.options = n;
  }
  encode(e) {
    let n;
    try {
      n = nr(e);
    } catch {
      throw new x(L.ENCODE_ERROR, `Invalid ${this.baseType}.`);
    }
    if (n.length > this.encodedLength)
      throw new x(L.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
    return nr(n, this.encodedLength);
  }
  decode(e, n) {
    if (e.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid number data size.");
    const s = e.slice(n, n + this.encodedLength);
    if (s.length !== this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid number byte data size.");
    return [Ur(s), n + this.encodedLength];
  }
}, pt(ps, "NumberCoder"), ps), fs, Gp = (fs = class extends Pp {
  encode(t) {
    return super.encode(this.toSwayOption(t));
  }
  toSwayOption(t) {
    return t !== void 0 ? { Some: t } : { None: [] };
  }
  decode(t, e) {
    const [n, s] = super.decode(t, e);
    return [this.toOption(n), s];
  }
  toOption(t) {
    if (t && "Some" in t)
      return t.Some;
  }
}, pt(fs, "OptionCoder"), fs), gs, UE = (gs = class extends yt {
  constructor() {
    super("raw untyped slice", "raw untyped slice", ht);
  }
  encode(t) {
    if (!Array.isArray(t))
      throw new x(L.ENCODE_ERROR, "Expected array value.");
    const n = new mt(new K("u8"), t.length).encode(t), s = new rt("u64").encode(n.length);
    return new Uint8Array([...s, ...n]);
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid raw slice data size.");
    const n = e + ht, s = t.slice(e, n), i = I(new rt("u64").decode(s, 0)[0]).toNumber(), a = t.slice(n, n + i);
    if (a.length !== i)
      throw new x(L.DECODE_ERROR, "Invalid raw slice byte data size.");
    const o = new mt(new K("u8"), i), [d] = o.decode(a, 0);
    return [d, n + i];
  }
}, pt(gs, "RawSliceCoder"), gs), Bn, Qo = (Bn = class extends yt {
  constructor() {
    super("struct", "struct String", ht);
  }
  encode(t) {
    const e = pr(t), n = new rt("u64").encode(t.length);
    return new Uint8Array([...n, ...e]);
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid std string data size.");
    const n = e + ht, s = t.slice(e, n), i = I(new rt("u64").decode(s, 0)[0]).toNumber(), a = t.slice(n, n + i);
    if (a.length !== i)
      throw new x(L.DECODE_ERROR, "Invalid std string byte data size.");
    return [Ro(a), n + i];
  }
}, pt(Bn, "StdStringCoder"), Q(Bn, "memorySize", 1), Bn), vn, GE = (vn = class extends yt {
  constructor() {
    super("strSlice", "str", ht);
  }
  encode(t) {
    const e = pr(t), n = new rt("u64").encode(t.length);
    return new Uint8Array([...n, ...e]);
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid string slice data size.");
    const n = e + ht, s = t.slice(e, n), i = I(new rt("u64").decode(s, 0)[0]).toNumber(), a = t.slice(n, n + i);
    if (a.length !== i)
      throw new x(L.DECODE_ERROR, "Invalid string slice byte data size.");
    return [Ro(a), n + i];
  }
}, pt(vn, "StrSliceCoder"), Q(vn, "memorySize", 1), vn), ws, zE = (ws = class extends yt {
  constructor(t) {
    super("string", `str[${t}]`, t);
  }
  encode(t) {
    if (t.length !== this.encodedLength)
      throw new x(L.ENCODE_ERROR, "Value length mismatch during encode.");
    return pr(t);
  }
  decode(t, e) {
    if (t.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid string data size.");
    const n = t.slice(e, e + this.encodedLength);
    if (n.length !== this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid string byte data size.");
    return [Ro(n), e + this.encodedLength];
  }
}, pt(ws, "StringCoder"), ws), ua, ms, Do = (ms = class extends yt {
  constructor(e, n) {
    const s = Object.values(n).reduce(
      (i, a) => i + a.encodedLength,
      0
    );
    super("struct", `struct ${e}`, s);
    Q(this, "name");
    Q(this, "coders");
    Ce(this, ua);
    this.name = e, this.coders = n, Gt(this, ua, Di(n));
  }
  encode(e) {
    return vo(
      Object.keys(this.coders).map((n) => {
        const s = this.coders[n], i = e[n];
        if (!(s instanceof Gp) && i == null)
          throw new x(
            L.ENCODE_ERROR,
            `Invalid ${this.type}. Field "${n}" not present.`
          );
        return s.encode(i);
      })
    );
  }
  decode(e, n) {
    if (!_t(this, ua) && e.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid struct data size.");
    let s = n;
    return [Object.keys(this.coders).reduce((a, o) => {
      const d = this.coders[o];
      let A;
      return [A, s] = d.decode(e, s), a[o] = A, a;
    }, {}), s];
  }
}, ua = new WeakMap(), pt(ms, "StructCoder"), ms), Aa, ys, zp = (ys = class extends yt {
  constructor(e) {
    const n = e.reduce((s, i) => s + i.encodedLength, 0);
    super("tuple", `(${e.map((s) => s.type).join(", ")})`, n);
    Q(this, "coders");
    Ce(this, Aa);
    this.coders = e, Gt(this, Aa, Di(e));
  }
  encode(e) {
    if (this.coders.length !== e.length)
      throw new x(L.ENCODE_ERROR, "Types/values length mismatch.");
    return vo(this.coders.map((n, s) => n.encode(e[s])));
  }
  decode(e, n) {
    if (!_t(this, Aa) && e.length < this.encodedLength)
      throw new x(L.DECODE_ERROR, "Invalid tuple data size.");
    let s = n;
    return [this.coders.map((a) => {
      let o;
      return [o, s] = a.decode(e, s), o;
    }), s];
  }
}, Aa = new WeakMap(), pt(ys, "TupleCoder"), ys), bs, Is, XE = (Is = class extends yt {
  constructor(e) {
    super("struct", "struct Vec", ht);
    Q(this, "coder");
    Ce(this, bs);
    this.coder = e, Gt(this, bs, Di([e]));
  }
  encode(e) {
    if (!Array.isArray(e) && !yh(e))
      throw new x(
        L.ENCODE_ERROR,
        "Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array."
      );
    const n = new rt("u64");
    if (yh(e))
      return new Uint8Array([...n.encode(e.length), ...e]);
    const s = e.map((a) => this.coder.encode(a)), i = n.encode(e.length);
    return new Uint8Array([...i, ...vo(s)]);
  }
  decode(e, n) {
    if (!_t(this, bs) && e.length < this.encodedLength || e.length > Dp)
      throw new x(L.DECODE_ERROR, "Invalid vec data size.");
    const s = n + ht, i = e.slice(n, s), a = I(new rt("u64").decode(i, 0)[0]).toNumber(), o = a * this.coder.encodedLength, d = e.slice(s, s + o);
    if (!_t(this, bs) && d.length !== o)
      throw new x(L.DECODE_ERROR, "Invalid vec byte data size.");
    let A = s;
    const p = [];
    for (let g = 0; g < a; g++) {
      const [y, v] = this.coder.decode(e, A);
      p.push(y), A = v;
    }
    return [p, A];
  }
}, bs = new WeakMap(), pt(Is, "VecCoder"), Is), Xp = /* @__PURE__ */ pt((r) => {
  switch (r) {
    case void 0:
    case Bi:
      return Bi;
    default:
      throw new x(
        L.UNSUPPORTED_ENCODING_VERSION,
        `Encoding version '${r}' is unsupported.`
      );
  }
}, "getEncodingVersion"), $i = /* @__PURE__ */ pt((r, t) => {
  const e = r.types.find((n) => n.typeId === t);
  if (!e)
    throw new x(
      L.TYPE_NOT_FOUND,
      `Type with typeId '${t}' doesn't exist in the ABI.`
    );
  return e;
}, "findTypeById"), HE = /* @__PURE__ */ pt((r, t) => t.filter((e) => $i(r, e.type).type !== ga), "findNonVoidInputs"), VE = /* @__PURE__ */ pt((r) => {
  var n;
  const t = r.find((s) => s.name === "buf"), e = (n = t == null ? void 0 : t.originalTypeArguments) == null ? void 0 : n[0];
  if (!t || !e)
    throw new x(
      L.INVALID_COMPONENT,
      "The Vec type provided is missing or has a malformed 'buf' component."
    );
  return e;
}, "findVectorBufferArgument"), hr, jd = (hr = class {
  constructor(t, e) {
    Q(this, "abi");
    Q(this, "name");
    Q(this, "type");
    Q(this, "originalTypeArguments");
    Q(this, "components");
    this.abi = t, this.name = e.name;
    const n = $i(t, e.type);
    if (n.type.length > 256)
      throw new x(
        L.INVALID_COMPONENT,
        `The provided ABI type is too long: ${n.type}.`
      );
    this.type = n.type, this.originalTypeArguments = e.typeArguments, this.components = hr.getResolvedGenericComponents(
      t,
      e,
      n.components,
      n.typeParameters ?? hr.getImplicitGenericTypeParameters(t, n.components)
    );
  }
  static getResolvedGenericComponents(t, e, n, s) {
    if (n === null)
      return null;
    if (s === null || s.length === 0)
      return n.map((o) => new hr(t, o));
    const i = s.reduce(
      (o, d, A) => {
        var g;
        const p = { ...o };
        return p[d] = structuredClone(
          (g = e.typeArguments) == null ? void 0 : g[A]
        ), p;
      },
      {}
    );
    return this.resolveGenericArgTypes(
      t,
      n,
      i
    ).map((o) => new hr(t, o));
  }
  static resolveGenericArgTypes(t, e, n) {
    return e.map((s) => {
      if (n[s.type] !== void 0)
        return {
          ...n[s.type],
          name: s.name
        };
      if (s.typeArguments)
        return {
          ...structuredClone(s),
          typeArguments: this.resolveGenericArgTypes(
            t,
            s.typeArguments,
            n
          )
        };
      const i = $i(t, s.type), a = this.getImplicitGenericTypeParameters(t, i.components);
      return a && a.length > 0 ? {
        ...structuredClone(s),
        typeArguments: a.map((o) => n[o])
      } : s;
    });
  }
  static getImplicitGenericTypeParameters(t, e, n) {
    if (!Array.isArray(e))
      return null;
    const s = n ?? [];
    return e.forEach((i) => {
      const a = $i(t, i.type);
      if (TE.test(a.type)) {
        s.push(a.typeId);
        return;
      }
      Array.isArray(i.typeArguments) && this.getImplicitGenericTypeParameters(t, i.typeArguments, s);
    }), s.length > 0 ? s : null;
  }
  getSignature() {
    const t = this.getArgSignaturePrefix(), e = this.getArgSignatureContent();
    return `${t}${e}`;
  }
  getArgSignaturePrefix() {
    return Np.test(this.type) ? "s" : ud.test(this.type) ? "a" : Qp.test(this.type) ? "e" : "";
  }
  getArgSignatureContent() {
    var i, a;
    if (this.type === "raw untyped ptr")
      return "rawptr";
    if (this.type === "raw untyped slice")
      return "rawslice";
    const t = (i = Fp.exec(this.type)) == null ? void 0 : i.groups;
    if (t)
      return `str[${t.length}]`;
    if (this.components === null)
      return this.type;
    const e = (a = ud.exec(this.type)) == null ? void 0 : a.groups;
    if (e)
      return `[${this.components[0].getSignature()};${e.length}]`;
    const n = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((o) => new hr(this.abi, o).getSignature()).join(",")}>` : "", s = `(${this.components.map((o) => o.getSignature()).join(",")})`;
    return `${n}${s}`;
  }
}, pt(hr, "ResolvedAbiType"), hr), Cs, WE = (Cs = class extends yt {
  constructor() {
    super("void", ga, 0);
  }
  encode(t) {
    return new Uint8Array([]);
  }
  decode(t, e) {
    return [void 0, e];
  }
}, pt(Cs, "VoidCoder"), Cs);
function ld(r, t) {
  const { getCoder: e } = t;
  return r.reduce((n, s) => {
    const i = n;
    return i[s.name] = e(s, t), i;
  }, {});
}
pt(ld, "getCoders");
var ts = /* @__PURE__ */ pt((r, t) => {
  var A, p, g, y;
  switch (r.type) {
    case pE:
    case fE:
    case gE:
      return new K(r.type);
    case wE:
    case yE:
      return new rt("u64");
    case mE:
      return new rt("u256");
    case bE:
      return new UE();
    case IE:
      return new PE();
    case CE:
      return new ot();
    case EE:
      return new OE();
    case vE:
      return new LE();
    case xE:
      return new Qo();
    case RE:
      return new GE();
    case ga:
      return new WE();
  }
  const e = (A = Fp.exec(r.type)) == null ? void 0 : A.groups;
  if (e) {
    const v = parseInt(e.length, 10);
    return new zE(v);
  }
  const n = r.components, s = (p = ud.exec(r.type)) == null ? void 0 : p.groups;
  if (s) {
    const v = parseInt(s.length, 10), N = n[0];
    if (!N)
      throw new x(
        L.INVALID_COMPONENT,
        "The provided Array type is missing an item of 'component'."
      );
    const E = ts(N);
    return new mt(E, v);
  }
  if (r.type === BE) {
    const v = VE(n), N = new jd(r.abi, v), E = ts(N, { encoding: Bi });
    return new XE(E);
  }
  const i = (g = r.type.match(FE)) == null ? void 0 : g[0];
  if (Np.test(r.type) && i) {
    const v = ld(n, { getCoder: ts });
    return new Do(i, v);
  }
  if (Qp.test(r.type) && i) {
    const v = ld(n, { getCoder: ts });
    return r.type === Ao ? new Gp(i, v) : new Pp(i, v);
  }
  if ((y = SE.exec(r.type)) == null ? void 0 : y.groups) {
    const v = n.map((N) => ts(N, { encoding: Bi }));
    return new zp(v);
  }
  throw new x(
    L.CODER_NOT_FOUND,
    `Coder not found: ${JSON.stringify(r)}.`
  );
}, "getCoder");
function Hp(r = Bi) {
  switch (r) {
    case Bi:
      return ts;
    default:
      throw new x(
        L.UNSUPPORTED_ENCODING_VERSION,
        `Encoding version ${r} is unsupported.`
      );
  }
}
pt(Hp, "getCoderForEncoding");
var Es, mn = (Es = class {
  static getCoder(t, e, n = {
    padToWordSize: !1
  }) {
    const s = new jd(t, e);
    return Hp(n.encoding)(s, n);
  }
  static encode(t, e, n, s) {
    return this.getCoder(t, e, s).encode(n);
  }
  static decode(t, e, n, s, i) {
    return this.getCoder(t, e, i).decode(n, s);
  }
}, pt(Es, "AbiCoder"), Es), YE = /* @__PURE__ */ pt((r) => {
  const { jsonAbi: t, inputs: e } = r;
  let n = !1;
  return e.reduceRight((s, i) => {
    const a = $i(t, i.type);
    return n = n || a.type !== ga && !Tp.test(a.type), [{ ...i, isOptional: !n }, ...s];
  }, []);
}, "getFunctionInputs"), ZE = /* @__PURE__ */ pt((r, t) => {
  if (r.length >= t.length)
    return r;
  const e = r.slice();
  return e.length = t.length, e.fill(void 0, r.length), e;
}, "padValuesWithUndefined"), nn, JE = (nn = class {
  constructor(t, e) {
    Q(this, "signature");
    Q(this, "selector");
    Q(this, "selectorBytes");
    Q(this, "encoding");
    Q(this, "name");
    Q(this, "jsonFn");
    Q(this, "attributes");
    Q(this, "jsonAbiOld");
    Q(this, "jsonFnOld");
    this.jsonFn = e, this.jsonAbiOld = t, this.jsonFnOld = t.functions.find((n) => n.name === e.name), this.name = e.name, this.signature = nn.getSignature(this.jsonAbiOld, this.jsonFnOld), this.selector = nn.getFunctionSelector(this.signature), this.selectorBytes = new Qo().encode(this.name), this.encoding = Xp(t.encoding), this.attributes = this.jsonFn.attributes ?? [];
  }
  static getSignature(t, e) {
    const n = e.inputs.map(
      (s) => new jd(t, s).getSignature()
    );
    return `${e.name}(${n.join(",")})`;
  }
  static getFunctionSelector(t) {
    const e = Xt(wn(t, "utf-8"));
    return I(e.slice(0, 10)).toHex(8);
  }
  encodeArguments(t) {
    const n = YE({ jsonAbi: this.jsonAbiOld, inputs: this.jsonFnOld.inputs }).filter((a) => !a.isOptional).length;
    if (t.length < n)
      throw new x(
        L.ABI_TYPES_AND_VALUES_MISMATCH,
        `Invalid number of arguments. Expected a minimum of ${n} arguments, received ${t.length}`
      );
    const s = this.jsonFnOld.inputs.map(
      (a) => mn.getCoder(this.jsonAbiOld, a, {
        encoding: this.encoding
      })
    ), i = ZE(t, this.jsonFn.inputs);
    return new zp(s).encode(i);
  }
  decodeArguments(t) {
    const e = j(t), n = HE(this.jsonAbiOld, this.jsonFnOld.inputs);
    if (n.length === 0) {
      if (e.length === 0)
        return;
      throw new x(
        L.DECODE_ERROR,
        `Types/values length mismatch during decode. ${JSON.stringify({
          count: {
            types: this.jsonFn.inputs.length,
            nonVoidInputs: n.length,
            values: e.length
          },
          value: {
            args: this.jsonFn.inputs,
            nonVoidInputs: n,
            values: e
          }
        })}`
      );
    }
    return this.jsonFnOld.inputs.reduce(
      (i, a) => {
        const o = mn.getCoder(this.jsonAbiOld, a, { encoding: this.encoding }), [d, A] = o.decode(e, i.offset);
        return {
          decoded: [...i.decoded, d],
          offset: A
        };
      },
      { decoded: [], offset: 0 }
    ).decoded;
  }
  decodeOutput(t) {
    const e = j(t);
    return mn.getCoder(this.jsonAbiOld, this.jsonFnOld.output, {
      encoding: this.encoding
    }).decode(e, 0);
  }
  /**
   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.
   *
   * @returns True if the function is read-only or pure, false otherwise.
   */
  isReadOnly() {
    var e;
    const t = this.attributes.find((n) => n.name === "storage");
    return !((e = t == null ? void 0 : t.arguments) != null && e.includes("write"));
  }
}, pt(nn, "FunctionFragment"), nn), jE = /* @__PURE__ */ pt((r, t) => r.find((e) => e.concreteTypeId === t), "findTypeByConcreteId"), qd = /* @__PURE__ */ pt((r, t) => r.concreteTypes.find((e) => e.concreteTypeId === t), "findConcreteTypeById");
function Oo(r, t, e) {
  const n = qd(r, e);
  if (n.metadataTypeId !== void 0)
    return n.metadataTypeId;
  const s = jE(t, e);
  return s ? s.typeId : (t.push({
    typeId: t.length,
    type: n.type,
    components: Mo(n.components),
    concreteTypeId: e,
    typeParameters: n.typeParameters ?? null,
    originalConcreteTypeId: n == null ? void 0 : n.concreteTypeId
  }), t.length - 1);
}
pt(Oo, "finsertTypeIdByConcreteTypeId");
function $d(r, t, e) {
  var n;
  return ((n = e.typeArguments) == null ? void 0 : n.map((s) => {
    const i = qd(r, s);
    return {
      name: "",
      type: isNaN(s) ? Oo(r, t, s) : s,
      // originalTypeId: cTypeId,
      typeArguments: $d(r, t, i)
    };
  })) ?? null;
}
pt($d, "parseFunctionTypeArguments");
function yn(r, t, e, n) {
  const s = Oo(r, t, e), i = qd(r, e);
  return {
    name: n ?? "",
    type: s,
    // concreteTypeId,
    typeArguments: $d(r, t, i)
  };
}
pt(yn, "parseConcreteType");
function Mo(r, t, e) {
  return (e == null ? void 0 : e.map((n) => {
    const { typeId: s, name: i, typeArguments: a } = n, o = isNaN(s) ? Oo(r, t, s) : s;
    return {
      name: i,
      type: o,
      // originalTypeId: typeId,
      typeArguments: Mo(r, t, a)
    };
  })) ?? null;
}
pt(Mo, "parseComponents");
function Vp(r) {
  if (!r.specVersion)
    return r;
  const t = [];
  r.metadataTypes.forEach((a) => {
    const o = {
      typeId: a.metadataTypeId,
      type: a.type,
      components: a.components ?? (a.type === "()" ? [] : null),
      typeParameters: a.typeParameters ?? null
    };
    t.push(o);
  }), t.forEach((a) => {
    a.components = Mo(r, t, a.components);
  });
  const e = r.functions.map((a) => {
    const o = a.inputs.map(
      ({ concreteTypeId: A, name: p }) => yn(r, t, A, p)
    ), d = yn(r, t, a.output, "");
    return { ...a, inputs: o, output: d };
  }), n = r.configurables.map((a) => ({
    name: a.name,
    configurableType: yn(r, t, a.concreteTypeId),
    offset: a.offset
  })), s = r.loggedTypes.map((a) => ({
    logId: a.logId,
    loggedType: yn(r, t, a.concreteTypeId)
  }));
  return {
    encoding: r.encodingVersion,
    types: t,
    functions: e,
    loggedTypes: s,
    messagesTypes: r.messagesTypes,
    configurables: n,
    errorCodes: r.errorCodes
  };
}
pt(Vp, "transpileAbi");
var Bs, Je = (Bs = class {
  constructor(t) {
    Q(this, "functions");
    Q(this, "configurables");
    Q(this, "jsonAbi");
    Q(this, "encoding");
    Q(this, "jsonAbiOld");
    this.jsonAbi = t, this.encoding = Xp(t.encodingVersion), this.jsonAbiOld = Vp(t), this.functions = Object.fromEntries(
      this.jsonAbi.functions.map((e) => [e.name, new JE(this.jsonAbiOld, e)])
    ), this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((e) => [e.name, e]));
  }
  /**
   * Returns function fragment for a dynamic input.
   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
   */
  getFunction(t) {
    const e = Object.values(this.functions).find(
      (n) => n.name === t || n.signature === t || n.selector === t
    );
    if (e !== void 0)
      return e;
    throw new x(
      L.FUNCTION_NOT_FOUND,
      `function ${t} not found: ${JSON.stringify(e)}.`
    );
  }
  // Decode the result of a function call
  decodeFunctionResult(t, e) {
    return (typeof t == "string" ? this.getFunction(t) : t).decodeOutput(e);
  }
  decodeLog(t, e) {
    const n = this.jsonAbiOld.loggedTypes.find((s) => s.logId === e);
    if (!n)
      throw new x(
        L.LOG_TYPE_NOT_FOUND,
        `Log type with logId '${e}' doesn't exist in the ABI.`
      );
    return mn.decode(this.jsonAbiOld, n.loggedType, j(t), 0, {
      encoding: this.encoding
    });
  }
  encodeConfigurable(t, e) {
    const n = this.jsonAbiOld.configurables.find((s) => s.name === t);
    if (!n)
      throw new x(
        L.CONFIGURABLE_NOT_FOUND,
        `A configurable with the '${t}' was not found in the ABI.`
      );
    return mn.encode(this.jsonAbiOld, n.configurableType, e, {
      encoding: this.encoding
    });
  }
  encodeType(t, e) {
    const n = yn(
      this.jsonAbi,
      this.jsonAbiOld.types,
      t,
      ""
    );
    return mn.encode(this.jsonAbiOld, n, e, {
      encoding: this.encoding
    });
  }
  decodeType(t, e) {
    const n = yn(
      this.jsonAbi,
      this.jsonAbiOld.types,
      t,
      ""
    );
    return mn.decode(this.jsonAbiOld, n, e, 0, { encoding: this.encoding });
  }
}, pt(Bs, "Interface"), Bs), HR = /* @__PURE__ */ pt((r, t) => {
  const [e, n] = new rt("u64").decode(r, 0), [s, i] = new ot().decode(r, n), [a, o] = new ot().decode(r, i), [d, A] = new Qo().decode(
    r,
    o + ht + ht
  ), p = r.slice(A), g = t ? new Je(t).getFunction(d).decodeArguments(p) : void 0;
  return {
    amount: e,
    assetId: s,
    contractId: a,
    functionSelector: d,
    functionArgs: g
  };
}, "decodeScriptData"), qE = Object.defineProperty, je = (r, t) => qE(r, "name", { value: t, configurable: !0 });
function zn(r) {
  return r.length === 66 && /(0x)[0-9a-f]{64}$/i.test(r);
}
je(zn, "isB256");
function Kd(r) {
  return r.length === 130 && /(0x)[0-9a-f]{128}$/i.test(r);
}
je(Kd, "isPublicKey");
function Po(r) {
  return r.length === 42 && /(0x)[0-9a-f]{40}$/i.test(r);
}
je(Po, "isEvmAddress");
function Wp(r) {
  return r.toLowerCase();
}
je(Wp, "normalizeB256");
function Oa(r) {
  return "b256Address" in r;
}
je(Oa, "isAddress");
var Zi = /* @__PURE__ */ je((r) => {
  if (Oa(r))
    return r;
  if ("address" in r && Oa(r.address))
    return r.address;
  if ("id" in r && Oa(r.id))
    return r.id;
  throw new x(x.CODES.INVALID_ADDRESS, "Invalid address");
}, "addressify"), $E = /* @__PURE__ */ je(() => W(ir(32)), "getRandomB256"), KE = /* @__PURE__ */ je((r) => {
  try {
    if (!zn(r))
      throw new x(x.CODES.INVALID_B256_ADDRESS, `Invalid B256 Address: ${r}.`);
    const t = j(r).slice(12), e = new Uint8Array(12).fill(0);
    return W(ct([e, t]));
  } catch {
    throw new x(
      x.CODES.PARSE_FAILED,
      `Cannot generate EVM Address B256 from: ${r}.`
    );
  }
}, "toB256AddressEvm"), tB = /* @__PURE__ */ je((r) => {
  if (!Po(r))
    throw new x(x.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
  return r.replace("0x", "0x000000000000000000000000");
}, "padFirst12BytesOfEvmAddress"), eB = /* @__PURE__ */ je((r) => tB(r), "fromEvmAddressToB256"), Yp = /* @__PURE__ */ je((r) => {
  if (!Kd(r))
    throw new x(x.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${r}.`);
  return W(dn(j(r)));
}, "fromPublicKeyToB256"), rB = /* @__PURE__ */ je((r) => {
  if (typeof r != "string" && "toB256" in r)
    return r.toB256();
  if (zn(r))
    return r;
  if (Kd(r))
    return Yp(r);
  if (Po(r))
    return eB(r);
  throw new x(
    x.CODES.PARSE_FAILED,
    "Unknown address format: only 'B256', 'Public Key (512)', or 'EVM Address' are supported."
  );
}, "fromDynamicInputToB256"), Le, wt = (Le = class {
  // #endregion address-2
  /**
   * @param address - A B256 address, public key, EVM address, or Address instance
   */
  constructor(t) {
    // #region address-2
    Q(this, "b256Address");
    const e = rB(t);
    this.b256Address = Wp(e);
  }
  /**
   * Takes an B256 Address and returns back an checksum address.
   * The implementation follows the ERC-55 https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md.
   *
   * @returns A new `ChecksumAddress` instance
   */
  toChecksum() {
    return Le.toChecksum(this.b256Address);
  }
  /**
   * Returns the `b256Address` property
   */
  toAddress() {
    return this.b256Address;
  }
  /**
   * Returns the B256 hash address as a string
   *
   * @returns The B256 address
   */
  toB256() {
    return this.b256Address;
  }
  /**
   * Returns the B256 hash address as a Uint8Array
   *
   * @returns The B256 address as a Uint8Array
   */
  toBytes() {
    return j(this.b256Address);
  }
  /**
   * Returns the B256 hash address as a string
   *
   * @returns The B256 address
   */
  toHexString() {
    return this.toB256();
  }
  /**
   * returns the address `checksum` as a string
   *
   * @returns The `b256Address` property as a string
   */
  toString() {
    return this.toChecksum();
  }
  /**
   * Converts and returns the `b256Address` property as a string
   * @returns The `b256Address` property as a JSON string
   */
  toJSON() {
    return this.b256Address;
  }
  /**
   * Converts to an EVM address
   *
   * @returns an {@link EvmAddress | `EvmAddress`} representation of the address
   */
  toEvmAddress() {
    return {
      bits: KE(this.b256Address)
    };
  }
  /**
   * Wraps the B256 property and returns as an `AssetId`.
   * @returns The B256 property as an {@link AssetId | `AssetId`}
   */
  toAssetId() {
    return {
      bits: this.b256Address
    };
  }
  /**
   * Wraps the B256 address `checksum` and returns it as a string
   * @returns The B256 address `checksum` as a string
   */
  valueOf() {
    return this.toChecksum();
  }
  /**
   * Compares this the `b256Address` property to another for direct equality
   * @param other - Another address to compare against
   * @returns The equality of the comparison
   */
  equals(t) {
    return this.toChecksum() === t.toChecksum();
  }
  /**
   * Takes a Public Key, hashes it, and creates an `Address`
   *
   * @param publicKey - A wallets public key
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromPublicKey(t) {
    const e = Yp(t);
    return new Le(e);
  }
  /**
   * Takes a B256 Address and creates an `Address`
   *
   * @param b256Address - A b256 hash
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromB256(t) {
    if (!zn(t))
      throw new x(
        x.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${t}.`
      );
    return new Le(t);
  }
  /**
   * Creates an `Address` with a randomized `b256Address` property
   *
   * @returns A new `Address` instance
   */
  static fromRandom() {
    return new Le($E());
  }
  /**
   * Takes an ambiguous string and attempts to create an `Address`
   *
   * @param address - An ambiguous string
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromString(t) {
    return new Le(t);
  }
  /**
   * Takes an ambiguous string or address and creates an `Address`
   *
   * @returns a new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromAddressOrString(t) {
    return new Le(t);
  }
  /**
   * Takes a dynamic string or `Address` and creates an `Address`
   *
   * @param addressId - A string containing B256, or Public Key
   * @throws Error - Unknown address if the format is not recognized
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromDynamicInput(t) {
    return new Le(t);
  }
  /**
   * Takes an Evm Address and returns back an `Address`
   *
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromEvmAddress(t) {
    if (!Po(t))
      throw new x(
        x.CODES.INVALID_EVM_ADDRESS,
        `Invalid Evm Address: ${t}.`
      );
    return new Le(t);
  }
  /**
   * Takes an ChecksumAddress and validates if it is a valid checksum address.
   *
   * @returns A `boolean` instance indicating if the address is valid.
   */
  static isChecksumValid(t) {
    let e = t;
    return t.startsWith("0x") || (e = `0x${t}`), e.trim().length !== 66 ? !1 : Le.toChecksum(W(e)) === e;
  }
  /** @hidden */
  static toChecksum(t) {
    if (!zn(t))
      throw new x(
        x.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${t}.`
      );
    const e = W(t).toLowerCase().slice(2), n = dn(e);
    let s = "0x";
    for (let i = 0; i < 32; ++i) {
      const a = n[i], o = e.charAt(i * 2), d = e.charAt(i * 2 + 1);
      s += (a & 240) >= 128 ? o.toUpperCase() : o, s += (a & 15) >= 8 ? d.toUpperCase() : d;
    }
    return s;
  }
}, je(Le, "Address"), Le), nB = Object.defineProperty, Ft = (r, t) => nB(r, "name", { value: t, configurable: !0 }), qr, vs, Mt = (vs = class extends yt {
  constructor(e) {
    const n = (8 - e % 8) % 8, s = e + n;
    super(
      "ByteArray",
      // While this might sound like a [u8; N] coder it's actually not.
      // A [u8; N] coder would pad every u8 to 8 bytes which would
      // make every u8 have the same size as a u64.
      // We are packing four u8s into u64s here, avoiding this padding.
      `[u64; ${s / 4}]`,
      s
    );
    Q(this, "length");
    Ce(this, qr);
    this.length = e, Gt(this, qr, n);
  }
  encode(e) {
    const n = [], s = j(e);
    return n.push(s), _t(this, qr) && n.push(new Uint8Array(_t(this, qr))), ct(n);
  }
  decode(e, n) {
    let s, i = n;
    [s, i] = [W(e.slice(i, i + this.length)), i + this.length];
    const a = s;
    return _t(this, qr) && ([s, i] = [null, i + _t(this, qr)]), [a, i];
  }
}, qr = new WeakMap(), Ft(vs, "ByteArrayCoder"), vs), xs, Xn = (xs = class extends Do {
  constructor() {
    super("TxPointer", {
      blockHeight: new K("u32", { padToWordSize: !0 }),
      txIndex: new K("u16", { padToWordSize: !0 })
    });
  }
  static decodeFromGqlScalar(t) {
    if (t.length !== 12)
      throw new x(
        L.DECODE_ERROR,
        `Invalid TxPointer scalar string length ${t.length}. It must have length 12.`
      );
    const [e, n] = [t.substring(0, 8), t.substring(8)];
    return {
      blockHeight: parseInt(e, 16),
      txIndex: parseInt(n, 16)
    };
  }
}, Ft(xs, "TxPointerCoder"), xs), xt = /* @__PURE__ */ ((r) => (r[r.Coin = 0] = "Coin", r[r.Contract = 1] = "Contract", r[r.Message = 2] = "Message", r))(xt || {}), Rs, bh = (Rs = class extends yt {
  constructor() {
    super("InputCoin", "struct InputCoin", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.txID)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputIndex)), e.push(new ot().encode(t.owner)), e.push(new rt("u64").encode(t.amount)), e.push(new ot().encode(t.assetId)), e.push(new Xn().encode(t.txPointer)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessIndex)), e.push(new rt("u64").encode(t.predicateGasUsed)), e.push(new rt("u64").encode(t.predicateLength)), e.push(new rt("u64").encode(t.predicateDataLength)), e.push(new Mt(t.predicateLength.toNumber()).encode(t.predicate)), e.push(
      new Mt(t.predicateDataLength.toNumber()).encode(t.predicateData)
    ), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const a = n;
    [n, s] = new ot().decode(t, s);
    const o = n;
    [n, s] = new rt("u64").decode(t, s);
    const d = n;
    [n, s] = new ot().decode(t, s);
    const A = n;
    [n, s] = new Xn().decode(t, s);
    const p = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const g = Number(n);
    [n, s] = new rt("u64").decode(t, s);
    const y = n;
    [n, s] = new rt("u64").decode(t, s);
    const v = n;
    [n, s] = new rt("u64").decode(t, s);
    const N = n;
    [n, s] = new Mt(v.toNumber()).decode(t, s);
    const E = n;
    return [n, s] = new Mt(N.toNumber()).decode(t, s), [
      {
        type: 0,
        txID: i,
        outputIndex: a,
        owner: o,
        amount: d,
        assetId: A,
        txPointer: p,
        witnessIndex: g,
        predicateGasUsed: y,
        predicateLength: v,
        predicateDataLength: N,
        predicate: E,
        predicateData: n
      },
      s
    ];
  }
}, Ft(Rs, "InputCoinCoder"), Rs), Ss, ho = (Ss = class extends yt {
  constructor() {
    super("InputContract", "struct InputContract", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.txID)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputIndex)), e.push(new ot().encode(t.balanceRoot)), e.push(new ot().encode(t.stateRoot)), e.push(new Xn().encode(t.txPointer)), e.push(new ot().encode(t.contractID)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const a = n;
    [n, s] = new ot().decode(t, s);
    const o = n;
    [n, s] = new ot().decode(t, s);
    const d = n;
    [n, s] = new Xn().decode(t, s);
    const A = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 1,
        txID: i,
        outputIndex: a,
        balanceRoot: o,
        stateRoot: d,
        txPointer: A,
        contractID: n
      },
      s
    ];
  }
}, Ft(Ss, "InputContractCoder"), Ss), Qn, bn = (Qn = class extends yt {
  constructor() {
    super("InputMessage", "struct InputMessage", 0);
  }
  static getMessageId(t) {
    const e = [];
    return e.push(new Mt(32).encode(t.sender)), e.push(new Mt(32).encode(t.recipient)), e.push(new Mt(32).encode(t.nonce)), e.push(new rt("u64").encode(t.amount)), e.push(j(t.data || "0x")), Xt(ct(e));
  }
  static encodeData(t) {
    const e = j(t || "0x"), n = e.length;
    return new Mt(n).encode(e);
  }
  encode(t) {
    const e = [], n = Qn.encodeData(t.data);
    return e.push(new Mt(32).encode(t.sender)), e.push(new Mt(32).encode(t.recipient)), e.push(new rt("u64").encode(t.amount)), e.push(new Mt(32).encode(t.nonce)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessIndex)), e.push(new rt("u64").encode(t.predicateGasUsed)), e.push(new rt("u64").encode(n.length)), e.push(new rt("u64").encode(t.predicateLength)), e.push(new rt("u64").encode(t.predicateDataLength)), e.push(new Mt(n.length).encode(n)), e.push(new Mt(t.predicateLength.toNumber()).encode(t.predicate)), e.push(
      new Mt(t.predicateDataLength.toNumber()).encode(t.predicateData)
    ), ct(e);
  }
  static decodeData(t) {
    const e = j(t), n = e.length, [s] = new Mt(n).decode(e, 0);
    return j(s);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new ot().decode(t, s);
    const a = n;
    [n, s] = new rt("u64").decode(t, s);
    const o = n;
    [n, s] = new ot().decode(t, s);
    const d = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const A = Number(n);
    [n, s] = new rt("u64").decode(t, s);
    const p = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const g = n;
    [n, s] = new rt("u64").decode(t, s);
    const y = n;
    [n, s] = new rt("u64").decode(t, s);
    const v = n;
    [n, s] = new Mt(g).decode(t, s);
    const N = n;
    [n, s] = new Mt(y.toNumber()).decode(t, s);
    const E = n;
    return [n, s] = new Mt(v.toNumber()).decode(t, s), [
      {
        type: 2,
        sender: i,
        recipient: a,
        amount: o,
        witnessIndex: A,
        nonce: d,
        predicateGasUsed: p,
        dataLength: g,
        predicateLength: y,
        predicateDataLength: v,
        data: N,
        predicate: E,
        predicateData: n
      },
      s
    ];
  }
}, Ft(Qn, "InputMessageCoder"), Qn), Ts, Rr = (Ts = class extends yt {
  constructor() {
    super("Input", "struct Input", 0);
  }
  encode(t) {
    const e = [];
    e.push(new K("u8", { padToWordSize: !0 }).encode(t.type));
    const { type: n } = t;
    switch (n) {
      case 0: {
        e.push(new bh().encode(t));
        break;
      }
      case 1: {
        e.push(new ho().encode(t));
        break;
      }
      case 2: {
        e.push(new bn().encode(t));
        break;
      }
      default:
        throw new x(
          L.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${n}.`
        );
    }
    return ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u8", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    switch (i) {
      case 0:
        return [n, s] = new bh().decode(t, s), [n, s];
      case 1:
        return [n, s] = new ho().decode(t, s), [n, s];
      case 2:
        return [n, s] = new bn().decode(t, s), [n, s];
      default:
        throw new x(
          L.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${i}.`
        );
    }
  }
}, Ft(Ts, "InputCoder"), Ts), lt = /* @__PURE__ */ ((r) => (r[r.Coin = 0] = "Coin", r[r.Contract = 1] = "Contract", r[r.Change = 2] = "Change", r[r.Variable = 3] = "Variable", r[r.ContractCreated = 4] = "ContractCreated", r))(lt || {}), Fs, Ih = (Fs = class extends yt {
  constructor() {
    super("OutputCoin", "struct OutputCoin", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.to)), e.push(new rt("u64").encode(t.amount)), e.push(new ot().encode(t.assetId)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new rt("u64").decode(t, s);
    const a = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 0,
        to: i,
        amount: a,
        assetId: n
      },
      s
    ];
  }
}, Ft(Fs, "OutputCoinCoder"), Fs), Ns, _o = (Ns = class extends yt {
  constructor() {
    super("OutputContract", "struct OutputContract", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new K("u8", { padToWordSize: !0 }).encode(t.inputIndex)), e.push(new ot().encode(t.balanceRoot)), e.push(new ot().encode(t.stateRoot)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u8", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    [n, s] = new ot().decode(t, s);
    const a = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 1,
        inputIndex: i,
        balanceRoot: a,
        stateRoot: n
      },
      s
    ];
  }
}, Ft(Ns, "OutputContractCoder"), Ns), Qs, Ch = (Qs = class extends yt {
  constructor() {
    super("OutputChange", "struct OutputChange", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.to)), e.push(new rt("u64").encode(t.amount)), e.push(new ot().encode(t.assetId)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new rt("u64").decode(t, s);
    const a = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 2,
        to: i,
        amount: a,
        assetId: n
      },
      s
    ];
  }
}, Ft(Qs, "OutputChangeCoder"), Qs), Ds, Eh = (Ds = class extends yt {
  constructor() {
    super("OutputVariable", "struct OutputVariable", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.to)), e.push(new rt("u64").encode(t.amount)), e.push(new ot().encode(t.assetId)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new rt("u64").decode(t, s);
    const a = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 3,
        to: i,
        amount: a,
        assetId: n
      },
      s
    ];
  }
}, Ft(Ds, "OutputVariableCoder"), Ds), Os, Bh = (Os = class extends yt {
  constructor() {
    super("OutputContractCreated", "struct OutputContractCreated", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.contractId)), e.push(new ot().encode(t.stateRoot)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    return [n, s] = new ot().decode(t, s), [
      {
        type: 4,
        contractId: i,
        stateRoot: n
      },
      s
    ];
  }
}, Ft(Os, "OutputContractCreatedCoder"), Os), Ms, Sr = (Ms = class extends yt {
  constructor() {
    super("Output", " struct Output", 0);
  }
  encode(t) {
    const e = [];
    e.push(new K("u8", { padToWordSize: !0 }).encode(t.type));
    const { type: n } = t;
    switch (n) {
      case 0: {
        e.push(new Ih().encode(t));
        break;
      }
      case 1: {
        e.push(new _o().encode(t));
        break;
      }
      case 2: {
        e.push(new Ch().encode(t));
        break;
      }
      case 3: {
        e.push(new Eh().encode(t));
        break;
      }
      case 4: {
        e.push(new Bh().encode(t));
        break;
      }
      default:
        throw new x(
          L.INVALID_TRANSACTION_OUTPUT,
          `Invalid transaction output type: ${n}.`
        );
    }
    return ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u8", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    switch (i) {
      case 0:
        return [n, s] = new Ih().decode(t, s), [n, s];
      case 1:
        return [n, s] = new _o().decode(t, s), [n, s];
      case 2:
        return [n, s] = new Ch().decode(t, s), [n, s];
      case 3:
        return [n, s] = new Eh().decode(t, s), [n, s];
      case 4:
        return [n, s] = new Bh().decode(t, s), [n, s];
      default:
        throw new x(
          L.INVALID_TRANSACTION_OUTPUT,
          `Invalid transaction output type: ${i}.`
        );
    }
  }
}, Ft(Ms, "OutputCoder"), Ms), Qe = /* @__PURE__ */ ((r) => (r[r.Tip = 1] = "Tip", r[r.WitnessLimit = 2] = "WitnessLimit", r[r.Maturity = 4] = "Maturity", r[r.MaxFee = 8] = "MaxFee", r[r.Expiration = 16] = "Expiration", r[r.Owner = 32] = "Owner", r))(Qe || {}), sB = /* @__PURE__ */ Ft((r) => r.sort((t, e) => t.type - e.type), "sortPolicies");
function Zp(r) {
  const t = /* @__PURE__ */ new Set();
  r.forEach((e) => {
    if (t.has(e.type))
      throw new x(
        L.DUPLICATED_POLICY,
        "Duplicate policy type found: 8"
      );
    t.add(e.type);
  });
}
Ft(Zp, "validateDuplicatedPolicies");
function Jp(r) {
  const t = [];
  let e = r >>> 0;
  for (; e !== 0; ) {
    const n = e & -e;
    t.push(n), e &= e - 1;
  }
  return t;
}
Ft(Jp, "getPolicyTypesArray");
var Ps, Tr = (Ps = class extends yt {
  constructor() {
    super("Policies", "array Policy", 0);
  }
  encode(t) {
    Zp(t);
    const e = sB(t), n = [];
    return e.forEach(({ data: s, type: i }) => {
      switch (i) {
        case 8:
        case 1:
        case 2:
          n.push(new rt("u64").encode(s));
          break;
        case 4:
        case 16:
          n.push(new K("u32", { padToWordSize: !0 }).encode(s));
          break;
        case 32:
          n.push(new rt("u64").encode(s));
          break;
        default:
          throw new x(L.INVALID_POLICY_TYPE, `Invalid policy type: ${i}`);
      }
    }), ct(n);
  }
  decode(t, e, n) {
    let s = e;
    const i = [], a = Jp(n);
    for (const d of a)
      switch (d) {
        case 1: {
          const [A, p] = new rt("u64").decode(t, s);
          s = p, i.push({ type: 1, data: A });
          break;
        }
        case 2: {
          const [A, p] = new rt("u64").decode(t, s);
          s = p, i.push({ type: 2, data: A });
          break;
        }
        case 4: {
          const [A, p] = new K("u32", { padToWordSize: !0 }).decode(
            t,
            s
          );
          s = p, i.push({ type: 4, data: A });
          break;
        }
        case 8: {
          const [A, p] = new rt("u64").decode(t, s);
          s = p, i.push({ type: 8, data: A });
          break;
        }
        case 16: {
          const [A, p] = new K("u32", { padToWordSize: !0 }).decode(
            t,
            s
          );
          s = p, i.push({ type: 16, data: A });
          break;
        }
        case 32: {
          const [A, p] = new rt("u64").decode(t, s);
          s = p, i.push({ type: 32, data: A });
          break;
        }
      }
    const o = a.length - i.length;
    return o > 0 && (console.warn(
      `${o} unknown policy types found in the transaction, please update fuels to the latest version`
    ), s += o * ht), [i, s];
  }
}, Ft(Ps, "PoliciesCoder"), Ps), At = /* @__PURE__ */ ((r) => (r[r.Call = 0] = "Call", r[r.Return = 1] = "Return", r[r.ReturnData = 2] = "ReturnData", r[r.Panic = 3] = "Panic", r[r.Revert = 4] = "Revert", r[r.Log = 5] = "Log", r[r.LogData = 6] = "LogData", r[r.Transfer = 7] = "Transfer", r[r.TransferOut = 8] = "TransferOut", r[r.ScriptResult = 9] = "ScriptResult", r[r.MessageOut = 10] = "MessageOut", r[r.Mint = 11] = "Mint", r[r.Burn = 12] = "Burn", r))(At || {}), hd = /* @__PURE__ */ Ft((r, t) => {
  const e = j(r), n = j(t);
  return Xt(ct([e, n]));
}, "getMintedAssetId"), VR = /* @__PURE__ */ Ft((r, t) => ({
  bits: hd(r, t)
}), "createAssetId"), WR = /* @__PURE__ */ Ft((r) => {
  const t = [];
  return t.push(new Mt(32).encode(r.sender)), t.push(new Mt(32).encode(r.recipient)), t.push(new Mt(32).encode(r.nonce)), t.push(new rt("u64").encode(r.amount)), t.push(j(r.data || "0x")), Xt(ct(t));
}, "getMessageId"), Ls, vh = (Ls = class extends Do {
  constructor() {
    super("StorageSlot", {
      key: new ot(),
      value: new ot()
    });
  }
}, Ft(Ls, "StorageSlotCoder"), Ls), Ke = /* @__PURE__ */ ((r) => (r[r.ConsensusParameters = 0] = "ConsensusParameters", r[r.StateTransition = 1] = "StateTransition", r))(Ke || {}), ks, xh = (ks = class extends yt {
  constructor() {
    super("UpgradePurpose", "UpgradePurpose", 0);
  }
  encode(t) {
    const e = [], { type: n } = t;
    switch (e.push(new K("u8", { padToWordSize: !0 }).encode(n)), n) {
      case 0: {
        const s = t.data;
        e.push(new K("u16", { padToWordSize: !0 }).encode(s.witnessIndex)), e.push(new ot().encode(s.checksum));
        break;
      }
      case 1: {
        const s = t.data;
        e.push(new ot().encode(s.bytecodeRoot));
        break;
      }
      default:
        throw new x(
          L.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${n}`
        );
    }
    return ct(e);
  }
  decode(t, e) {
    let n = e, s;
    [s, n] = new K("u8", { padToWordSize: !0 }).decode(t, n);
    const i = s;
    switch (i) {
      case 0: {
        [s, n] = new K("u16", { padToWordSize: !0 }).decode(t, n);
        const a = s;
        return [s, n] = new ot().decode(t, n), [{ type: i, data: { witnessIndex: a, checksum: s } }, n];
      }
      case 1:
        return [s, n] = new ot().decode(t, n), [{ type: i, data: { bytecodeRoot: s } }, n];
      default:
        throw new x(
          L.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${i}`
        );
    }
  }
}, Ft(ks, "UpgradePurposeCoder"), ks), Us, Fr = (Us = class extends yt {
  constructor() {
    super(
      "Witness",
      // Types of dynamic length are not supported in the ABI
      "unknown",
      0
    );
  }
  encode(t) {
    const e = [];
    return e.push(new K("u32", { padToWordSize: !0 }).encode(t.dataLength)), e.push(new Mt(t.dataLength).encode(t.data)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    return [n, s] = new Mt(i).decode(t, s), [
      {
        dataLength: i,
        data: n
      },
      s
    ];
  }
}, Ft(Us, "WitnessCoder"), Us), Ct = /* @__PURE__ */ ((r) => (r[r.Script = 0] = "Script", r[r.Create = 1] = "Create", r[r.Mint = 2] = "Mint", r[r.Upgrade = 3] = "Upgrade", r[r.Upload = 4] = "Upload", r[r.Blob = 5] = "Blob", r))(Ct || {}), Gs, Rh = (Gs = class extends yt {
  constructor() {
    super("TransactionScript", "struct TransactionScript", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new rt("u64").encode(t.scriptGasLimit)), e.push(new ot().encode(t.receiptsRoot)), e.push(new rt("u64").encode(t.scriptLength)), e.push(new rt("u64").encode(t.scriptDataLength)), e.push(new K("u32", { padToWordSize: !0 }).encode(t.policyTypes)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.inputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessesCount)), e.push(new Mt(t.scriptLength.toNumber()).encode(t.script)), e.push(new Mt(t.scriptDataLength.toNumber()).encode(t.scriptData)), e.push(new Tr().encode(t.policies)), e.push(new mt(new Rr(), t.inputsCount).encode(t.inputs)), e.push(new mt(new Sr(), t.outputsCount).encode(t.outputs)), e.push(new mt(new Fr(), t.witnessesCount).encode(t.witnesses)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new rt("u64").decode(t, s);
    const i = n;
    [n, s] = new ot().decode(t, s);
    const a = n;
    [n, s] = new rt("u64").decode(t, s);
    const o = n;
    [n, s] = new rt("u64").decode(t, s);
    const d = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const A = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const p = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const g = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const y = n;
    [n, s] = new Mt(o.toNumber()).decode(t, s);
    const v = n;
    [n, s] = new Mt(d.toNumber()).decode(t, s);
    const N = n;
    [n, s] = new Tr().decode(t, s, A);
    const E = n;
    [n, s] = new mt(new Rr(), p).decode(t, s);
    const F = n;
    [n, s] = new mt(new Sr(), g).decode(t, s);
    const k = n;
    return [n, s] = new mt(new Fr(), y).decode(t, s), [
      {
        type: 0,
        scriptGasLimit: i,
        scriptLength: o,
        scriptDataLength: d,
        policyTypes: A,
        inputsCount: p,
        outputsCount: g,
        witnessesCount: y,
        receiptsRoot: a,
        script: v,
        scriptData: N,
        policies: E,
        inputs: F,
        outputs: k,
        witnesses: n
      },
      s
    ];
  }
}, Ft(Gs, "TransactionScriptCoder"), Gs), zs, Sh = (zs = class extends yt {
  constructor() {
    super("TransactionCreate", "struct TransactionCreate", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new K("u16", { padToWordSize: !0 }).encode(t.bytecodeWitnessIndex)), e.push(new ot().encode(t.salt)), e.push(new rt("u64").encode(t.storageSlotsCount)), e.push(new K("u32", { padToWordSize: !0 }).encode(t.policyTypes)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.inputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessesCount)), e.push(
      new mt(new vh(), t.storageSlotsCount.toNumber()).encode(
        t.storageSlots
      )
    ), e.push(new Tr().encode(t.policies)), e.push(new mt(new Rr(), t.inputsCount).encode(t.inputs)), e.push(new mt(new Sr(), t.outputsCount).encode(t.outputs)), e.push(new mt(new Fr(), t.witnessesCount).encode(t.witnesses)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    [n, s] = new ot().decode(t, s);
    const a = n;
    [n, s] = new rt("u64").decode(t, s);
    const o = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const d = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const A = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const p = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const g = n;
    [n, s] = new mt(new vh(), o.toNumber()).decode(
      t,
      s
    );
    const y = n;
    [n, s] = new Tr().decode(t, s, d);
    const v = n;
    [n, s] = new mt(new Rr(), A).decode(t, s);
    const N = n;
    [n, s] = new mt(new Sr(), p).decode(t, s);
    const E = n;
    return [n, s] = new mt(new Fr(), g).decode(t, s), [
      {
        type: 1,
        bytecodeWitnessIndex: i,
        policyTypes: d,
        storageSlotsCount: o,
        inputsCount: A,
        outputsCount: p,
        witnessesCount: g,
        salt: a,
        policies: v,
        storageSlots: y,
        inputs: N,
        outputs: E,
        witnesses: n
      },
      s
    ];
  }
}, Ft(zs, "TransactionCreateCoder"), zs), Xs, Th = (Xs = class extends yt {
  constructor() {
    super("TransactionMint", "struct TransactionMint", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new Xn().encode(t.txPointer)), e.push(new ho().encode(t.inputContract)), e.push(new _o().encode(t.outputContract)), e.push(new rt("u64").encode(t.mintAmount)), e.push(new ot().encode(t.mintAssetId)), e.push(new rt("u64").encode(t.gasPrice)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new Xn().decode(t, s);
    const i = n;
    [n, s] = new ho().decode(t, s);
    const a = n;
    [n, s] = new _o().decode(t, s);
    const o = n;
    [n, s] = new rt("u64").decode(t, s);
    const d = n;
    [n, s] = new ot().decode(t, s);
    const A = n;
    return [n, s] = new rt("u64").decode(t, s), [
      {
        type: 2,
        txPointer: i,
        inputContract: a,
        outputContract: o,
        mintAmount: d,
        mintAssetId: A,
        gasPrice: n
      },
      s
    ];
  }
}, Ft(Xs, "TransactionMintCoder"), Xs), Hs, Fh = (Hs = class extends yt {
  constructor() {
    super("TransactionUpgrade", "struct TransactionUpgrade", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new xh().encode(t.upgradePurpose)), e.push(new K("u32", { padToWordSize: !0 }).encode(t.policyTypes)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.inputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessesCount)), e.push(new Tr().encode(t.policies)), e.push(new mt(new Rr(), t.inputsCount).encode(t.inputs)), e.push(new mt(new Sr(), t.outputsCount).encode(t.outputs)), e.push(new mt(new Fr(), t.witnessesCount).encode(t.witnesses)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new xh().decode(t, s);
    const i = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const a = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const o = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const d = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const A = n;
    [n, s] = new Tr().decode(t, s, a);
    const p = n;
    [n, s] = new mt(new Rr(), o).decode(t, s);
    const g = n;
    [n, s] = new mt(new Sr(), d).decode(t, s);
    const y = n;
    return [n, s] = new mt(new Fr(), A).decode(t, s), [
      {
        type: 3,
        upgradePurpose: i,
        policyTypes: a,
        inputsCount: o,
        outputsCount: d,
        witnessesCount: A,
        policies: p,
        inputs: g,
        outputs: y,
        witnesses: n
      },
      s
    ];
  }
}, Ft(Hs, "TransactionUpgradeCoder"), Hs), Vs, Nh = (Vs = class extends yt {
  constructor() {
    super("TransactionUpload", "struct TransactionUpload", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.root)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessIndex)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.subsectionIndex)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.subsectionsNumber)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.proofSetCount)), e.push(new K("u32", { padToWordSize: !0 }).encode(t.policyTypes)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.inputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessesCount)), e.push(new mt(new ot(), t.proofSetCount).encode(t.proofSet)), e.push(new Tr().encode(t.policies)), e.push(new mt(new Rr(), t.inputsCount).encode(t.inputs)), e.push(new mt(new Sr(), t.outputsCount).encode(t.outputs)), e.push(new mt(new Fr(), t.witnessesCount).encode(t.witnesses)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const a = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const o = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const d = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const A = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const p = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const g = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const y = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const v = n;
    [n, s] = new mt(new ot(), A).decode(t, s);
    const N = n;
    [n, s] = new Tr().decode(t, s, p);
    const E = n;
    [n, s] = new mt(new Rr(), g).decode(t, s);
    const F = n;
    [n, s] = new mt(new Sr(), y).decode(t, s);
    const k = n;
    return [n, s] = new mt(new Fr(), v).decode(t, s), [
      {
        type: 4,
        root: i,
        witnessIndex: a,
        subsectionIndex: o,
        subsectionsNumber: d,
        proofSetCount: A,
        policyTypes: p,
        inputsCount: g,
        outputsCount: y,
        witnessesCount: v,
        proofSet: N,
        policies: E,
        inputs: F,
        outputs: k,
        witnesses: n
      },
      s
    ];
  }
}, Ft(Vs, "TransactionUploadCoder"), Vs), Ws, Qh = (Ws = class extends yt {
  constructor() {
    super("TransactionBlob", "struct TransactionBlob", 0);
  }
  encode(t) {
    const e = [];
    return e.push(new ot().encode(t.blobId)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessIndex)), e.push(new K("u32", { padToWordSize: !0 }).encode(t.policyTypes)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.inputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.outputsCount)), e.push(new K("u16", { padToWordSize: !0 }).encode(t.witnessesCount)), e.push(new Tr().encode(t.policies)), e.push(new mt(new Rr(), t.inputsCount).encode(t.inputs)), e.push(new mt(new Sr(), t.outputsCount).encode(t.outputs)), e.push(new mt(new Fr(), t.witnessesCount).encode(t.witnesses)), ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new ot().decode(t, s);
    const i = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const a = n;
    [n, s] = new K("u32", { padToWordSize: !0 }).decode(t, s);
    const o = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const d = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const A = n;
    [n, s] = new K("u16", { padToWordSize: !0 }).decode(t, s);
    const p = n;
    [n, s] = new Tr().decode(t, s, o);
    const g = n;
    [n, s] = new mt(new Rr(), d).decode(t, s);
    const y = n;
    [n, s] = new mt(new Sr(), A).decode(t, s);
    const v = n;
    return [n, s] = new mt(new Fr(), p).decode(t, s), [
      {
        type: 5,
        blobId: i,
        witnessIndex: a,
        policyTypes: o,
        inputsCount: d,
        outputsCount: A,
        witnessesCount: p,
        policies: g,
        inputs: y,
        outputs: v,
        witnesses: n
      },
      s
    ];
  }
}, Ft(Ws, "TransactionBlobCoder"), Ws), Ys, sr = (Ys = class extends yt {
  constructor() {
    super("Transaction", "struct Transaction", 0);
  }
  encode(t) {
    const e = [];
    e.push(new K("u8", { padToWordSize: !0 }).encode(t.type));
    const { type: n } = t;
    switch (t.type) {
      case 0: {
        e.push(
          new Rh().encode(t)
        );
        break;
      }
      case 1: {
        e.push(
          new Sh().encode(t)
        );
        break;
      }
      case 2: {
        e.push(new Th().encode(t));
        break;
      }
      case 3: {
        e.push(
          new Fh().encode(t)
        );
        break;
      }
      case 4: {
        e.push(
          new Nh().encode(t)
        );
        break;
      }
      case 5: {
        e.push(new Qh().encode(t));
        break;
      }
      default:
        throw new x(
          L.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${n}`
        );
    }
    return ct(e);
  }
  decode(t, e) {
    let n, s = e;
    [n, s] = new K("u8", { padToWordSize: !0 }).decode(t, s);
    const i = n;
    switch (i) {
      case 0:
        return [n, s] = new Rh().decode(t, s), [n, s];
      case 1:
        return [n, s] = new Sh().decode(t, s), [n, s];
      case 2:
        return [n, s] = new Th().decode(t, s), [n, s];
      case 3:
        return [n, s] = new Fh().decode(t, s), [n, s];
      case 4:
        return [n, s] = new Nh().decode(t, s), [n, s];
      case 5:
        return [n, s] = new Qh().decode(t, s), [n, s];
      default:
        throw new x(
          L.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${i}`
        );
    }
  }
}, Ft(Ys, "TransactionCoder"), Ys), Zs, YR = (Zs = class extends Do {
  constructor() {
    super("UtxoId", {
      transactionId: new ot(),
      outputIndex: new K("u16", { padToWordSize: !0 })
    });
  }
}, Ft(Zs, "UtxoIdCoder"), Zs);
function Ut(r) {
  return r != null && typeof r == "object" && r["@@functional/placeholder"] === !0;
}
function zr(r) {
  return function t(e) {
    return arguments.length === 0 || Ut(e) ? t : r.apply(this, arguments);
  };
}
function hn(r) {
  return function t(e, n) {
    switch (arguments.length) {
      case 0:
        return t;
      case 1:
        return Ut(e) ? t : zr(function(s) {
          return r(e, s);
        });
      default:
        return Ut(e) && Ut(n) ? t : Ut(e) ? zr(function(s) {
          return r(s, n);
        }) : Ut(n) ? zr(function(s) {
          return r(e, s);
        }) : r(e, n);
    }
  };
}
function iB(r) {
  return function t(e, n, s) {
    switch (arguments.length) {
      case 0:
        return t;
      case 1:
        return Ut(e) ? t : hn(function(i, a) {
          return r(e, i, a);
        });
      case 2:
        return Ut(e) && Ut(n) ? t : Ut(e) ? hn(function(i, a) {
          return r(i, n, a);
        }) : Ut(n) ? hn(function(i, a) {
          return r(e, i, a);
        }) : zr(function(i) {
          return r(e, n, i);
        });
      default:
        return Ut(e) && Ut(n) && Ut(s) ? t : Ut(e) && Ut(n) ? hn(function(i, a) {
          return r(i, a, s);
        }) : Ut(e) && Ut(s) ? hn(function(i, a) {
          return r(i, n, a);
        }) : Ut(n) && Ut(s) ? hn(function(i, a) {
          return r(e, i, a);
        }) : Ut(e) ? zr(function(i) {
          return r(i, n, s);
        }) : Ut(n) ? zr(function(i) {
          return r(e, i, s);
        }) : Ut(s) ? zr(function(i) {
          return r(e, n, i);
        }) : r(e, n, s);
    }
  };
}
const aB = Array.isArray || function(t) {
  return t != null && t.length >= 0 && Object.prototype.toString.call(t) === "[object Array]";
};
var oB = /* @__PURE__ */ zr(function(t) {
  return t === null ? "Null" : t === void 0 ? "Undefined" : Object.prototype.toString.call(t).slice(8, -1);
});
function cB(r) {
  return new RegExp(r.source, r.flags ? r.flags : (r.global ? "g" : "") + (r.ignoreCase ? "i" : "") + (r.multiline ? "m" : "") + (r.sticky ? "y" : "") + (r.unicode ? "u" : "") + (r.dotAll ? "s" : ""));
}
function jp(r, t, e) {
  if (e || (e = new uB()), dB(r))
    return r;
  var n = function(i) {
    var a = e.get(r);
    if (a)
      return a;
    e.set(r, i);
    for (var o in r)
      Object.prototype.hasOwnProperty.call(r, o) && (i[o] = jp(r[o], !0, e));
    return i;
  };
  switch (oB(r)) {
    case "Object":
      return n(Object.create(Object.getPrototypeOf(r)));
    case "Array":
      return n(Array(r.length));
    case "Date":
      return new Date(r.valueOf());
    case "RegExp":
      return cB(r);
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      return r.slice();
    default:
      return r;
  }
}
function dB(r) {
  var t = typeof r;
  return r == null || t != "object" && t != "function";
}
var uB = /* @__PURE__ */ function() {
  function r() {
    this.map = {}, this.length = 0;
  }
  return r.prototype.set = function(t, e) {
    var n = this.hash(t), s = this.map[n];
    s || (this.map[n] = s = []), s.push([t, e]), this.length += 1;
  }, r.prototype.hash = function(t) {
    var e = [];
    for (var n in t)
      e.push(Object.prototype.toString.call(t[n]));
    return e.join();
  }, r.prototype.get = function(t) {
    if (this.length <= 180) {
      for (var e in this.map)
        for (var a = this.map[e], n = 0; n < a.length; n += 1) {
          var s = a[n];
          if (s[0] === t)
            return s[1];
        }
      return;
    }
    var i = this.hash(t), a = this.map[i];
    if (a)
      for (var n = 0; n < a.length; n += 1) {
        var s = a[n];
        if (s[0] === t)
          return s[1];
      }
  }, r;
}(), ve = /* @__PURE__ */ zr(function(t) {
  return t != null && typeof t.clone == "function" ? t.clone() : jp(t);
});
function AB(r, t) {
  return function() {
    var e = arguments.length;
    if (e === 0)
      return t();
    var n = arguments[e - 1];
    return aB(n) || typeof n[r] != "function" ? t.apply(this, arguments) : n[r].apply(n, Array.prototype.slice.call(arguments, 0, e - 1));
  };
}
var lB = /* @__PURE__ */ iB(/* @__PURE__ */ AB("slice", function(t, e, n) {
  return Array.prototype.slice.call(n, t, e);
})), Dh = /* @__PURE__ */ hn(function(t, e) {
  if (t <= 0)
    throw new Error("First argument to splitEvery must be a positive integer");
  for (var n = [], s = 0; s < e.length; )
    n.push(lB(s, s += t, e));
  return n;
});
const tu = JSON, hB = (r) => r.toUpperCase(), _B = (r) => {
  const t = {};
  return r.forEach((e, n) => {
    t[n] = e;
  }), t;
}, pB = (r, t, e) => r.document ? r : {
  document: r,
  variables: t,
  requestHeaders: e,
  signal: void 0
}, fB = (r, t, e) => r.query ? r : {
  query: r,
  variables: t,
  requestHeaders: e,
  signal: void 0
}, gB = (r, t) => r.documents ? r : {
  documents: r,
  requestHeaders: t,
  signal: void 0
};
function Ma(r, t) {
  if (!!!r)
    throw new Error(t);
}
function wB(r) {
  return typeof r == "object" && r !== null;
}
function mB(r, t) {
  if (!!!r)
    throw new Error(
      "Unexpected invariant triggered."
    );
}
const yB = /\r\n|[\n\r]/g;
function _d(r, t) {
  let e = 0, n = 1;
  for (const s of r.body.matchAll(yB)) {
    if (typeof s.index == "number" || mB(!1), s.index >= t)
      break;
    e = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: t + 1 - e
  };
}
function bB(r) {
  return qp(
    r.source,
    _d(r.source, r.start)
  );
}
function qp(r, t) {
  const e = r.locationOffset.column - 1, n = "".padStart(e) + r.body, s = t.line - 1, i = r.locationOffset.line - 1, a = t.line + i, o = t.line === 1 ? e : 0, d = t.column + o, A = `${r.name}:${a}:${d}
`, p = n.split(/\r\n|[\n\r]/g), g = p[s];
  if (g.length > 120) {
    const y = Math.floor(d / 80), v = d % 80, N = [];
    for (let E = 0; E < g.length; E += 80)
      N.push(g.slice(E, E + 80));
    return A + Oh([
      [`${a} |`, N[0]],
      ...N.slice(1, y + 1).map((E) => ["|", E]),
      ["|", "^".padStart(v)],
      ["|", N[y + 1]]
    ]);
  }
  return A + Oh([
    // Lines specified like this: ["prefix", "string"],
    [`${a - 1} |`, p[s - 1]],
    [`${a} |`, g],
    ["|", "^".padStart(d)],
    [`${a + 1} |`, p[s + 1]]
  ]);
}
function Oh(r) {
  const t = r.filter(([n, s]) => s !== void 0), e = Math.max(...t.map(([n]) => n.length));
  return t.map(([n, s]) => n.padStart(e) + (s ? " " + s : "")).join(`
`);
}
function IB(r) {
  const t = r[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : t;
}
class eu extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...e) {
    var n, s, i;
    const { nodes: a, source: o, positions: d, path: A, originalError: p, extensions: g } = IB(e);
    super(t), this.name = "GraphQLError", this.path = A ?? void 0, this.originalError = p ?? void 0, this.nodes = Mh(
      Array.isArray(a) ? a : a ? [a] : void 0
    );
    const y = Mh(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((N) => N.loc).filter((N) => N != null)
    );
    this.source = o ?? (y == null || (s = y[0]) === null || s === void 0 ? void 0 : s.source), this.positions = d ?? (y == null ? void 0 : y.map((N) => N.start)), this.locations = d && o ? d.map((N) => _d(o, N)) : y == null ? void 0 : y.map((N) => _d(N.source, N.start));
    const v = wB(
      p == null ? void 0 : p.extensions
    ) ? p == null ? void 0 : p.extensions : void 0;
    this.extensions = (i = g ?? v) !== null && i !== void 0 ? i : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), p != null && p.stack ? Object.defineProperty(this, "stack", {
      value: p.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, eu) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const e of this.nodes)
        e.loc && (t += `

` + bB(e.loc));
    else if (this.source && this.locations)
      for (const e of this.locations)
        t += `

` + qp(this.source, e);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function Mh(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function Be(r, t, e) {
  return new eu(`Syntax Error: ${e}`, {
    source: r,
    positions: [t]
  });
}
class CB {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, e, n) {
    this.start = t.start, this.end = e.end, this.startToken = t, this.endToken = e, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class $p {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, e, n, s, i, a) {
    this.kind = t, this.start = e, this.end = n, this.line = s, this.column = i, this.value = a, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const Kp = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, EB = new Set(Object.keys(Kp));
function Ph(r) {
  const t = r == null ? void 0 : r.kind;
  return typeof t == "string" && EB.has(t);
}
var ns;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(ns || (ns = {}));
var pd;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(pd || (pd = {}));
var ut;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(ut || (ut = {}));
function fd(r) {
  return r === 9 || r === 32;
}
function sa(r) {
  return r >= 48 && r <= 57;
}
function tf(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function ef(r) {
  return tf(r) || r === 95;
}
function BB(r) {
  return tf(r) || sa(r) || r === 95;
}
function vB(r) {
  var t;
  let e = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let a = 0; a < r.length; ++a) {
    var i;
    const o = r[a], d = xB(o);
    d !== o.length && (n = (i = n) !== null && i !== void 0 ? i : a, s = a, a !== 0 && d < e && (e = d));
  }
  return r.map((a, o) => o === 0 ? a : a.slice(e)).slice(
    (t = n) !== null && t !== void 0 ? t : 0,
    s + 1
  );
}
function xB(r) {
  let t = 0;
  for (; t < r.length && fd(r.charCodeAt(t)); )
    ++t;
  return t;
}
function RB(r, t) {
  const e = r.replace(/"""/g, '\\"""'), n = e.split(/\r\n|[\n\r]/g), s = n.length === 1, i = n.length > 1 && n.slice(1).every((v) => v.length === 0 || fd(v.charCodeAt(0))), a = e.endsWith('\\"""'), o = r.endsWith('"') && !a, d = r.endsWith("\\"), A = o || d, p = (
    // add leading and trailing new lines only if it improves readability
    !s || r.length > 70 || A || i || a
  );
  let g = "";
  const y = s && fd(r.charCodeAt(0));
  return (p && !y || i) && (g += `
`), g += e, (p || A) && (g += `
`), '"""' + g + '"""';
}
var J;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(J || (J = {}));
class SB {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const e = new $p(J.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = e, this.token = e, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== J.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const e = FB(this, t.end);
          t.next = e, e.prev = t, t = e;
        }
      while (t.kind === J.COMMENT);
    return t;
  }
}
function TB(r) {
  return r === J.BANG || r === J.DOLLAR || r === J.AMP || r === J.PAREN_L || r === J.PAREN_R || r === J.SPREAD || r === J.COLON || r === J.EQUALS || r === J.AT || r === J.BRACKET_L || r === J.BRACKET_R || r === J.BRACE_L || r === J.PIPE || r === J.BRACE_R;
}
function Oi(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function Lo(r, t) {
  return rf(r.charCodeAt(t)) && nf(r.charCodeAt(t + 1));
}
function rf(r) {
  return r >= 55296 && r <= 56319;
}
function nf(r) {
  return r >= 56320 && r <= 57343;
}
function Hn(r, t) {
  const e = r.source.body.codePointAt(t);
  if (e === void 0)
    return J.EOF;
  if (e >= 32 && e <= 126) {
    const n = String.fromCodePoint(e);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + e.toString(16).toUpperCase().padStart(4, "0");
}
function Ie(r, t, e, n, s) {
  const i = r.line, a = 1 + e - r.lineStart;
  return new $p(t, e, n, i, a, s);
}
function FB(r, t) {
  const e = r.source.body, n = e.length;
  let s = t;
  for (; s < n; ) {
    const i = e.charCodeAt(s);
    switch (i) {
      // Ignored ::
      //   - UnicodeBOM
      //   - WhiteSpace
      //   - LineTerminator
      //   - Comment
      //   - Comma
      //
      // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
      //
      // WhiteSpace ::
      //   - "Horizontal Tab (U+0009)"
      //   - "Space (U+0020)"
      //
      // Comma :: ,
      case 65279:
      // <BOM>
      case 9:
      // \t
      case 32:
      // <space>
      case 44:
        ++s;
        continue;
      // LineTerminator ::
      //   - "New Line (U+000A)"
      //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
      //   - "Carriage Return (U+000D)" "New Line (U+000A)"
      case 10:
        ++s, ++r.line, r.lineStart = s;
        continue;
      case 13:
        e.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++r.line, r.lineStart = s;
        continue;
      // Comment
      case 35:
        return NB(r, s);
      // Token ::
      //   - Punctuator
      //   - Name
      //   - IntValue
      //   - FloatValue
      //   - StringValue
      //
      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
      case 33:
        return Ie(r, J.BANG, s, s + 1);
      case 36:
        return Ie(r, J.DOLLAR, s, s + 1);
      case 38:
        return Ie(r, J.AMP, s, s + 1);
      case 40:
        return Ie(r, J.PAREN_L, s, s + 1);
      case 41:
        return Ie(r, J.PAREN_R, s, s + 1);
      case 46:
        if (e.charCodeAt(s + 1) === 46 && e.charCodeAt(s + 2) === 46)
          return Ie(r, J.SPREAD, s, s + 3);
        break;
      case 58:
        return Ie(r, J.COLON, s, s + 1);
      case 61:
        return Ie(r, J.EQUALS, s, s + 1);
      case 64:
        return Ie(r, J.AT, s, s + 1);
      case 91:
        return Ie(r, J.BRACKET_L, s, s + 1);
      case 93:
        return Ie(r, J.BRACKET_R, s, s + 1);
      case 123:
        return Ie(r, J.BRACE_L, s, s + 1);
      case 124:
        return Ie(r, J.PIPE, s, s + 1);
      case 125:
        return Ie(r, J.BRACE_R, s, s + 1);
      // StringValue
      case 34:
        return e.charCodeAt(s + 1) === 34 && e.charCodeAt(s + 2) === 34 ? LB(r, s) : DB(r, s);
    }
    if (sa(i) || i === 45)
      return QB(r, s, i);
    if (ef(i))
      return kB(r, s);
    throw Be(
      r.source,
      s,
      i === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Oi(i) || Lo(e, s) ? `Unexpected character: ${Hn(r, s)}.` : `Invalid character: ${Hn(r, s)}.`
    );
  }
  return Ie(r, J.EOF, n, n);
}
function NB(r, t) {
  const e = r.source.body, n = e.length;
  let s = t + 1;
  for (; s < n; ) {
    const i = e.charCodeAt(s);
    if (i === 10 || i === 13)
      break;
    if (Oi(i))
      ++s;
    else if (Lo(e, s))
      s += 2;
    else
      break;
  }
  return Ie(
    r,
    J.COMMENT,
    t,
    s,
    e.slice(t + 1, s)
  );
}
function QB(r, t, e) {
  const n = r.source.body;
  let s = t, i = e, a = !1;
  if (i === 45 && (i = n.charCodeAt(++s)), i === 48) {
    if (i = n.charCodeAt(++s), sa(i))
      throw Be(
        r.source,
        s,
        `Invalid number, unexpected digit after 0: ${Hn(
          r,
          s
        )}.`
      );
  } else
    s = Lc(r, s, i), i = n.charCodeAt(s);
  if (i === 46 && (a = !0, i = n.charCodeAt(++s), s = Lc(r, s, i), i = n.charCodeAt(s)), (i === 69 || i === 101) && (a = !0, i = n.charCodeAt(++s), (i === 43 || i === 45) && (i = n.charCodeAt(++s)), s = Lc(r, s, i), i = n.charCodeAt(s)), i === 46 || ef(i))
    throw Be(
      r.source,
      s,
      `Invalid number, expected digit but got: ${Hn(
        r,
        s
      )}.`
    );
  return Ie(
    r,
    a ? J.FLOAT : J.INT,
    t,
    s,
    n.slice(t, s)
  );
}
function Lc(r, t, e) {
  if (!sa(e))
    throw Be(
      r.source,
      t,
      `Invalid number, expected digit but got: ${Hn(
        r,
        t
      )}.`
    );
  const n = r.source.body;
  let s = t + 1;
  for (; sa(n.charCodeAt(s)); )
    ++s;
  return s;
}
function DB(r, t) {
  const e = r.source.body, n = e.length;
  let s = t + 1, i = s, a = "";
  for (; s < n; ) {
    const o = e.charCodeAt(s);
    if (o === 34)
      return a += e.slice(i, s), Ie(r, J.STRING, t, s + 1, a);
    if (o === 92) {
      a += e.slice(i, s);
      const d = e.charCodeAt(s + 1) === 117 ? e.charCodeAt(s + 2) === 123 ? OB(r, s) : MB(r, s) : PB(r, s);
      a += d.value, s += d.size, i = s;
      continue;
    }
    if (o === 10 || o === 13)
      break;
    if (Oi(o))
      ++s;
    else if (Lo(e, s))
      s += 2;
    else
      throw Be(
        r.source,
        s,
        `Invalid character within String: ${Hn(
          r,
          s
        )}.`
      );
  }
  throw Be(r.source, s, "Unterminated string.");
}
function OB(r, t) {
  const e = r.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const i = e.charCodeAt(t + s++);
    if (i === 125) {
      if (s < 5 || !Oi(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | Ji(i), n < 0)
      break;
  }
  throw Be(
    r.source,
    t,
    `Invalid Unicode escape sequence: "${e.slice(
      t,
      t + s
    )}".`
  );
}
function MB(r, t) {
  const e = r.source.body, n = Lh(e, t + 2);
  if (Oi(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (rf(n) && e.charCodeAt(t + 6) === 92 && e.charCodeAt(t + 7) === 117) {
    const s = Lh(e, t + 8);
    if (nf(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw Be(
    r.source,
    t,
    `Invalid Unicode escape sequence: "${e.slice(t, t + 6)}".`
  );
}
function Lh(r, t) {
  return Ji(r.charCodeAt(t)) << 12 | Ji(r.charCodeAt(t + 1)) << 8 | Ji(r.charCodeAt(t + 2)) << 4 | Ji(r.charCodeAt(t + 3));
}
function Ji(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function PB(r, t) {
  const e = r.source.body;
  switch (e.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Be(
    r.source,
    t,
    `Invalid character escape sequence: "${e.slice(
      t,
      t + 2
    )}".`
  );
}
function LB(r, t) {
  const e = r.source.body, n = e.length;
  let s = r.lineStart, i = t + 3, a = i, o = "";
  const d = [];
  for (; i < n; ) {
    const A = e.charCodeAt(i);
    if (A === 34 && e.charCodeAt(i + 1) === 34 && e.charCodeAt(i + 2) === 34) {
      o += e.slice(a, i), d.push(o);
      const p = Ie(
        r,
        J.BLOCK_STRING,
        t,
        i + 3,
        // Return a string of the lines joined with U+000A.
        vB(d).join(`
`)
      );
      return r.line += d.length - 1, r.lineStart = s, p;
    }
    if (A === 92 && e.charCodeAt(i + 1) === 34 && e.charCodeAt(i + 2) === 34 && e.charCodeAt(i + 3) === 34) {
      o += e.slice(a, i), a = i + 1, i += 4;
      continue;
    }
    if (A === 10 || A === 13) {
      o += e.slice(a, i), d.push(o), A === 13 && e.charCodeAt(i + 1) === 10 ? i += 2 : ++i, o = "", a = i, s = i;
      continue;
    }
    if (Oi(A))
      ++i;
    else if (Lo(e, i))
      i += 2;
    else
      throw Be(
        r.source,
        i,
        `Invalid character within String: ${Hn(
          r,
          i
        )}.`
      );
  }
  throw Be(r.source, i, "Unterminated string.");
}
function kB(r, t) {
  const e = r.source.body, n = e.length;
  let s = t + 1;
  for (; s < n; ) {
    const i = e.charCodeAt(s);
    if (BB(i))
      ++s;
    else
      break;
  }
  return Ie(
    r,
    J.NAME,
    t,
    s,
    e.slice(t, s)
  );
}
const UB = 10, sf = 2;
function ru(r) {
  return ko(r, []);
}
function ko(r, t) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return GB(r, t);
    default:
      return String(r);
  }
}
function GB(r, t) {
  if (r === null)
    return "null";
  if (t.includes(r))
    return "[Circular]";
  const e = [...t, r];
  if (zB(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : ko(n, e);
  } else if (Array.isArray(r))
    return HB(r, e);
  return XB(r, e);
}
function zB(r) {
  return typeof r.toJSON == "function";
}
function XB(r, t) {
  const e = Object.entries(r);
  return e.length === 0 ? "{}" : t.length > sf ? "[" + VB(r) + "]" : "{ " + e.map(
    ([s, i]) => s + ": " + ko(i, t)
  ).join(", ") + " }";
}
function HB(r, t) {
  if (r.length === 0)
    return "[]";
  if (t.length > sf)
    return "[Array]";
  const e = Math.min(UB, r.length), n = r.length - e, s = [];
  for (let i = 0; i < e; ++i)
    s.push(ko(r[i], t));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function VB(r) {
  const t = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof r.constructor == "function") {
    const e = r.constructor.name;
    if (typeof e == "string" && e !== "")
      return e;
  }
  return t;
}
const WB = globalThis.process && // eslint-disable-next-line no-undef
!0, YB = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  WB ? function(t, e) {
    return t instanceof e;
  } : function(t, e) {
    if (t instanceof e)
      return !0;
    if (typeof t == "object" && t !== null) {
      var n;
      const s = e.prototype[Symbol.toStringTag], i = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (n = t.constructor) === null || n === void 0 ? void 0 : n.name
      );
      if (s === i) {
        const a = ru(t);
        throw new Error(`Cannot use ${s} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class af {
  constructor(t, e = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || Ma(!1, `Body must be a string. Received: ${ru(t)}.`), this.body = t, this.name = e, this.locationOffset = n, this.locationOffset.line > 0 || Ma(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Ma(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function ZB(r) {
  return YB(r, af);
}
function of(r, t) {
  const e = new JB(r, t), n = e.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: e.tokenCount
  }), n;
}
class JB {
  constructor(t, e = {}) {
    const n = ZB(t) ? t : new af(t);
    this._lexer = new SB(n), this._options = e, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(J.NAME);
    return this.node(t, {
      kind: ut.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: ut.DOCUMENT,
      definitions: this.many(
        J.SOF,
        this.parseDefinition,
        J.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(J.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), e = t ? this._lexer.lookahead() : this._lexer.token;
    if (e.kind === J.NAME) {
      switch (e.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw Be(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (e.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(e);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(J.BRACE_L))
      return this.node(t, {
        kind: ut.OPERATION_DEFINITION,
        operation: ns.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const e = this.parseOperationType();
    let n;
    return this.peek(J.NAME) && (n = this.parseName()), this.node(t, {
      kind: ut.OPERATION_DEFINITION,
      operation: e,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(J.NAME);
    switch (t.value) {
      case "query":
        return ns.QUERY;
      case "mutation":
        return ns.MUTATION;
      case "subscription":
        return ns.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      J.PAREN_L,
      this.parseVariableDefinition,
      J.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: ut.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(J.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(J.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(J.DOLLAR), this.node(t, {
      kind: ut.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: ut.SELECTION_SET,
      selections: this.many(
        J.BRACE_L,
        this.parseSelection,
        J.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(J.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, e = this.parseName();
    let n, s;
    return this.expectOptionalToken(J.COLON) ? (n = e, s = this.parseName()) : s = e, this.node(t, {
      kind: ut.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(J.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const e = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(J.PAREN_L, e, J.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const e = this._lexer.token, n = this.parseName();
    return this.expectToken(J.COLON), this.node(e, {
      kind: ut.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(J.SPREAD);
    const e = this.expectOptionalKeyword("on");
    return !e && this.peek(J.NAME) ? this.node(t, {
      kind: ut.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: ut.INLINE_FRAGMENT,
      typeCondition: e ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: ut.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: ut.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const e = this._lexer.token;
    switch (e.kind) {
      case J.BRACKET_L:
        return this.parseList(t);
      case J.BRACE_L:
        return this.parseObject(t);
      case J.INT:
        return this.advanceLexer(), this.node(e, {
          kind: ut.INT,
          value: e.value
        });
      case J.FLOAT:
        return this.advanceLexer(), this.node(e, {
          kind: ut.FLOAT,
          value: e.value
        });
      case J.STRING:
      case J.BLOCK_STRING:
        return this.parseStringLiteral();
      case J.NAME:
        switch (this.advanceLexer(), e.value) {
          case "true":
            return this.node(e, {
              kind: ut.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(e, {
              kind: ut.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(e, {
              kind: ut.NULL
            });
          default:
            return this.node(e, {
              kind: ut.ENUM,
              value: e.value
            });
        }
      case J.DOLLAR:
        if (t)
          if (this.expectToken(J.DOLLAR), this._lexer.token.kind === J.NAME) {
            const n = this._lexer.token.value;
            throw Be(
              this._lexer.source,
              e.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(e);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: ut.STRING,
      value: t.value,
      block: t.kind === J.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const e = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: ut.LIST,
      values: this.any(J.BRACKET_L, e, J.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const e = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: ut.OBJECT,
      fields: this.any(J.BRACE_L, e, J.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const e = this._lexer.token, n = this.parseName();
    return this.expectToken(J.COLON), this.node(e, {
      kind: ut.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const e = [];
    for (; this.peek(J.AT); )
      e.push(this.parseDirective(t));
    return e;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const e = this._lexer.token;
    return this.expectToken(J.AT), this.node(e, {
      kind: ut.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let e;
    if (this.expectOptionalToken(J.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(J.BRACKET_R), e = this.node(t, {
        kind: ut.LIST_TYPE,
        type: n
      });
    } else
      e = this.parseNamedType();
    return this.expectOptionalToken(J.BANG) ? this.node(t, {
      kind: ut.NON_NULL_TYPE,
      type: e
    }) : e;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: ut.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(J.STRING) || this.peek(J.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      J.BRACE_L,
      this.parseOperationTypeDefinition,
      J.BRACE_R
    );
    return this.node(t, {
      kind: ut.SCHEMA_DEFINITION,
      description: e,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, e = this.parseOperationType();
    this.expectToken(J.COLON);
    const n = this.parseNamedType();
    return this.node(t, {
      kind: ut.OPERATION_TYPE_DEFINITION,
      operation: e,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(t, {
      kind: ut.SCALAR_TYPE_DEFINITION,
      description: e,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(t, {
      kind: ut.OBJECT_TYPE_DEFINITION,
      description: e,
      name: n,
      interfaces: s,
      directives: i,
      fields: a
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(J.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      J.BRACE_L,
      this.parseFieldDefinition,
      J.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, e = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(J.COLON);
    const i = this.parseTypeReference(), a = this.parseConstDirectives();
    return this.node(t, {
      kind: ut.FIELD_DEFINITION,
      description: e,
      name: n,
      arguments: s,
      type: i,
      directives: a
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      J.PAREN_L,
      this.parseInputValueDef,
      J.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, e = this.parseDescription(), n = this.parseName();
    this.expectToken(J.COLON);
    const s = this.parseTypeReference();
    let i;
    this.expectOptionalToken(J.EQUALS) && (i = this.parseConstValueLiteral());
    const a = this.parseConstDirectives();
    return this.node(t, {
      kind: ut.INPUT_VALUE_DEFINITION,
      description: e,
      name: n,
      type: s,
      defaultValue: i,
      directives: a
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(t, {
      kind: ut.INTERFACE_TYPE_DEFINITION,
      description: e,
      name: n,
      interfaces: s,
      directives: i,
      fields: a
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: ut.UNION_TYPE_DEFINITION,
      description: e,
      name: n,
      directives: s,
      types: i
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(J.EQUALS) ? this.delimitedMany(J.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: ut.ENUM_TYPE_DEFINITION,
      description: e,
      name: n,
      directives: s,
      values: i
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      J.BRACE_L,
      this.parseEnumValueDefinition,
      J.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, e = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(t, {
      kind: ut.ENUM_VALUE_DEFINITION,
      description: e,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Be(
        this._lexer.source,
        this._lexer.token.start,
        `${va(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: ut.INPUT_OBJECT_TYPE_DEFINITION,
      description: e,
      name: n,
      directives: s,
      fields: i
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      J.BRACE_L,
      this.parseInputValueDef,
      J.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === J.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const e = this.parseConstDirectives(), n = this.optionalMany(
      J.BRACE_L,
      this.parseOperationTypeDefinition,
      J.BRACE_R
    );
    if (e.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.SCHEMA_EXTENSION,
      directives: e,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const e = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.SCALAR_TYPE_EXTENSION,
      name: e,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const e = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.OBJECT_TYPE_EXTENSION,
      name: e,
      interfaces: n,
      directives: s,
      fields: i
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const e = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.INTERFACE_TYPE_EXTENSION,
      name: e,
      interfaces: n,
      directives: s,
      fields: i
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const e = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.UNION_TYPE_EXTENSION,
      name: e,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const e = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.ENUM_TYPE_EXTENSION,
      name: e,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const e = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ut.INPUT_OBJECT_TYPE_EXTENSION,
      name: e,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, e = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(J.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), i = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const a = this.parseDirectiveLocations();
    return this.node(t, {
      kind: ut.DIRECTIVE_DEFINITION,
      description: e,
      name: n,
      arguments: s,
      repeatable: i,
      locations: a
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(J.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, e = this.parseName();
    if (Object.prototype.hasOwnProperty.call(pd, e.value))
      return e;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, e) {
    return this._options.noLocation !== !0 && (e.loc = new CB(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), e;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const e = this._lexer.token;
    if (e.kind === t)
      return this.advanceLexer(), e;
    throw Be(
      this._lexer.source,
      e.start,
      `Expected ${cf(t)}, found ${va(e)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const e = this._lexer.token;
    if (e.kind === J.NAME && e.value === t)
      this.advanceLexer();
    else
      throw Be(
        this._lexer.source,
        e.start,
        `Expected "${t}", found ${va(e)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const e = this._lexer.token;
    return e.kind === J.NAME && e.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const e = t ?? this._lexer.token;
    return Be(
      this._lexer.source,
      e.start,
      `Unexpected ${va(e)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, e, n) {
    this.expectToken(t);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(e.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, e, n) {
    if (this.expectOptionalToken(t)) {
      const s = [];
      do
        s.push(e.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, e, n) {
    this.expectToken(t);
    const s = [];
    do
      s.push(e.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, e) {
    this.expectOptionalToken(t);
    const n = [];
    do
      n.push(e.call(this));
    while (this.expectOptionalToken(t));
    return n;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, e = this._lexer.advance();
    if (e.kind !== J.EOF && (++this._tokenCounter, t !== void 0 && this._tokenCounter > t))
      throw Be(
        this._lexer.source,
        e.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function va(r) {
  const t = r.value;
  return cf(r.kind) + (t != null ? ` "${t}"` : "");
}
function cf(r) {
  return TB(r) ? `"${r}"` : r;
}
function jB(r) {
  return `"${r.replace(qB, $B)}"`;
}
const qB = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function $B(r) {
  return KB[r.charCodeAt(0)];
}
const KB = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], tv = Object.freeze({});
function ev(r, t, e = Kp) {
  const n = /* @__PURE__ */ new Map();
  for (const k of Object.values(ut))
    n.set(k, rv(t, k));
  let s, i = Array.isArray(r), a = [r], o = -1, d = [], A = r, p, g;
  const y = [], v = [];
  do {
    o++;
    const k = o === a.length, H = k && d.length !== 0;
    if (k) {
      if (p = v.length === 0 ? void 0 : y[y.length - 1], A = g, g = v.pop(), H)
        if (i) {
          A = A.slice();
          let D = 0;
          for (const [M, P] of d) {
            const U = M - D;
            P === null ? (A.splice(U, 1), D++) : A[U] = P;
          }
        } else {
          A = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(A)
          );
          for (const [D, M] of d)
            A[D] = M;
        }
      o = s.index, a = s.keys, d = s.edits, i = s.inArray, s = s.prev;
    } else if (g) {
      if (p = i ? o : a[o], A = g[p], A == null)
        continue;
      y.push(p);
    }
    let X;
    if (!Array.isArray(A)) {
      var N, E;
      Ph(A) || Ma(!1, `Invalid AST Node: ${ru(A)}.`);
      const D = k ? (N = n.get(A.kind)) === null || N === void 0 ? void 0 : N.leave : (E = n.get(A.kind)) === null || E === void 0 ? void 0 : E.enter;
      if (X = D == null ? void 0 : D.call(t, A, p, g, y, v), X === tv)
        break;
      if (X === !1) {
        if (!k) {
          y.pop();
          continue;
        }
      } else if (X !== void 0 && (d.push([p, X]), !k))
        if (Ph(X))
          A = X;
        else {
          y.pop();
          continue;
        }
    }
    if (X === void 0 && H && d.push([p, A]), k)
      y.pop();
    else {
      var F;
      s = {
        inArray: i,
        index: o,
        keys: a,
        edits: d,
        prev: s
      }, i = Array.isArray(A), a = i ? A : (F = e[A.kind]) !== null && F !== void 0 ? F : [], o = -1, d = [], g && v.push(g), g = A;
    }
  } while (s !== void 0);
  return d.length !== 0 ? d[d.length - 1][1] : r;
}
function rv(r, t) {
  const e = r[t];
  return typeof e == "object" ? e : typeof e == "function" ? {
    enter: e,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function df(r) {
  return ev(r, sv);
}
const nv = 80, sv = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => it(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const t = bt("(", it(r.variableDefinitions, ", "), ")"), e = it(
        [
          r.operation,
          it([r.name, t]),
          it(r.directives, " ")
        ],
        " "
      );
      return (e === "query" ? "" : e + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: t, defaultValue: e, directives: n }) => r + ": " + t + bt(" = ", e) + bt(" ", it(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => cr(r)
  },
  Field: {
    leave({ alias: r, name: t, arguments: e, directives: n, selectionSet: s }) {
      const i = bt("", r, ": ") + t;
      let a = i + bt("(", it(e, ", "), ")");
      return a.length > nv && (a = i + bt(`(
`, Pa(it(e, `
`)), `
)`)), it([a, it(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: t }) => r + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: t }) => "..." + r + bt(" ", it(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: t, selectionSet: e }) => it(
      [
        "...",
        bt("on ", r),
        it(t, " "),
        e
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: t, variableDefinitions: e, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${r}${bt("(", it(e, ", "), ")")} on ${t} ${bt("", it(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: t }) => t ? RB(r) : jB(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + it(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + it(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: t }) => r + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: t }) => "@" + r + bt("(", it(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: t, operationTypes: e }) => bt("", r, `
`) + it(["schema", it(t, " "), cr(e)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: t }) => r + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: t, directives: e }) => bt("", r, `
`) + it(["scalar", t, it(e, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: t, interfaces: e, directives: n, fields: s }) => bt("", r, `
`) + it(
      [
        "type",
        t,
        bt("implements ", it(e, " & ")),
        it(n, " "),
        cr(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: t, arguments: e, type: n, directives: s }) => bt("", r, `
`) + t + (kh(e) ? bt(`(
`, Pa(it(e, `
`)), `
)`) : bt("(", it(e, ", "), ")")) + ": " + n + bt(" ", it(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: t, type: e, defaultValue: n, directives: s }) => bt("", r, `
`) + it(
      [t + ": " + e, bt("= ", n), it(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: t, interfaces: e, directives: n, fields: s }) => bt("", r, `
`) + it(
      [
        "interface",
        t,
        bt("implements ", it(e, " & ")),
        it(n, " "),
        cr(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: t, directives: e, types: n }) => bt("", r, `
`) + it(
      ["union", t, it(e, " "), bt("= ", it(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: t, directives: e, values: n }) => bt("", r, `
`) + it(["enum", t, it(e, " "), cr(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: t, directives: e }) => bt("", r, `
`) + it([t, it(e, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: t, directives: e, fields: n }) => bt("", r, `
`) + it(["input", t, it(e, " "), cr(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: t, arguments: e, repeatable: n, locations: s }) => bt("", r, `
`) + "directive @" + t + (kh(e) ? bt(`(
`, Pa(it(e, `
`)), `
)`) : bt("(", it(e, ", "), ")")) + (n ? " repeatable" : "") + " on " + it(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: t }) => it(
      ["extend schema", it(r, " "), cr(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: t }) => it(["extend scalar", r, it(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: t, directives: e, fields: n }) => it(
      [
        "extend type",
        r,
        bt("implements ", it(t, " & ")),
        it(e, " "),
        cr(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: t, directives: e, fields: n }) => it(
      [
        "extend interface",
        r,
        bt("implements ", it(t, " & ")),
        it(e, " "),
        cr(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: t, types: e }) => it(
      [
        "extend union",
        r,
        it(t, " "),
        bt("= ", it(e, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: t, values: e }) => it(["extend enum", r, it(t, " "), cr(e)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: t, fields: e }) => it(["extend input", r, it(t, " "), cr(e)], " ")
  }
};
function it(r, t = "") {
  var e;
  return (e = r == null ? void 0 : r.filter((n) => n).join(t)) !== null && e !== void 0 ? e : "";
}
function cr(r) {
  return bt(`{
`, Pa(it(r, `
`)), `
}`);
}
function bt(r, t, e = "") {
  return t != null && t !== "" ? r + t + e : "";
}
function Pa(r) {
  return bt("  ", r.replace(/\n/g, `
  `));
}
function kh(r) {
  var t;
  return (t = r == null ? void 0 : r.some((e) => e.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
const Uh = (r) => {
  var n, s;
  let t;
  const e = r.definitions.filter((i) => i.kind === "OperationDefinition");
  return e.length === 1 && (t = (s = (n = e[0]) == null ? void 0 : n.name) == null ? void 0 : s.value), t;
}, kc = (r) => {
  if (typeof r == "string") {
    let e;
    try {
      const n = of(r);
      e = Uh(n);
    } catch {
    }
    return { query: r, operationName: e };
  }
  const t = Uh(r);
  return { query: df(r), operationName: t };
};
class Ki extends Error {
  constructor(t, e) {
    const n = `${Ki.extractMessage(t)}: ${JSON.stringify({
      response: t,
      request: e
    })}`;
    super(n), Object.setPrototypeOf(this, Ki.prototype), this.response = t, this.request = e, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Ki);
  }
  static extractMessage(t) {
    var e, n;
    return ((n = (e = t.errors) == null ? void 0 : e[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${t.status})`;
  }
}
var xa = { exports: {} }, Gh;
function iv() {
  return Gh || (Gh = 1, function(r, t) {
    var e = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof uh < "u" && uh, n = function() {
      function i() {
        this.fetch = !1, this.DOMException = e.DOMException;
      }
      return i.prototype = e, new i();
    }();
    (function(i) {
      (function(a) {
        var o = typeof i < "u" && i || typeof self < "u" && self || typeof o < "u" && o, d = {
          searchParams: "URLSearchParams" in o,
          iterable: "Symbol" in o && "iterator" in Symbol,
          blob: "FileReader" in o && "Blob" in o && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in o,
          arrayBuffer: "ArrayBuffer" in o
        };
        function A(l) {
          return l && DataView.prototype.isPrototypeOf(l);
        }
        if (d.arrayBuffer)
          var p = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], g = ArrayBuffer.isView || function(l) {
            return l && p.indexOf(Object.prototype.toString.call(l)) > -1;
          };
        function y(l) {
          if (typeof l != "string" && (l = String(l)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(l) || l === "")
            throw new TypeError('Invalid character in header field name: "' + l + '"');
          return l.toLowerCase();
        }
        function v(l) {
          return typeof l != "string" && (l = String(l)), l;
        }
        function N(l) {
          var f = {
            next: function() {
              var m = l.shift();
              return { done: m === void 0, value: m };
            }
          };
          return d.iterable && (f[Symbol.iterator] = function() {
            return f;
          }), f;
        }
        function E(l) {
          this.map = {}, l instanceof E ? l.forEach(function(f, m) {
            this.append(m, f);
          }, this) : Array.isArray(l) ? l.forEach(function(f) {
            this.append(f[0], f[1]);
          }, this) : l && Object.getOwnPropertyNames(l).forEach(function(f) {
            this.append(f, l[f]);
          }, this);
        }
        E.prototype.append = function(l, f) {
          l = y(l), f = v(f);
          var m = this.map[l];
          this.map[l] = m ? m + ", " + f : f;
        }, E.prototype.delete = function(l) {
          delete this.map[y(l)];
        }, E.prototype.get = function(l) {
          return l = y(l), this.has(l) ? this.map[l] : null;
        }, E.prototype.has = function(l) {
          return this.map.hasOwnProperty(y(l));
        }, E.prototype.set = function(l, f) {
          this.map[y(l)] = v(f);
        }, E.prototype.forEach = function(l, f) {
          for (var m in this.map)
            this.map.hasOwnProperty(m) && l.call(f, this.map[m], m, this);
        }, E.prototype.keys = function() {
          var l = [];
          return this.forEach(function(f, m) {
            l.push(m);
          }), N(l);
        }, E.prototype.values = function() {
          var l = [];
          return this.forEach(function(f) {
            l.push(f);
          }), N(l);
        }, E.prototype.entries = function() {
          var l = [];
          return this.forEach(function(f, m) {
            l.push([m, f]);
          }), N(l);
        }, d.iterable && (E.prototype[Symbol.iterator] = E.prototype.entries);
        function F(l) {
          if (l.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          l.bodyUsed = !0;
        }
        function k(l) {
          return new Promise(function(f, m) {
            l.onload = function() {
              f(l.result);
            }, l.onerror = function() {
              m(l.error);
            };
          });
        }
        function H(l) {
          var f = new FileReader(), m = k(f);
          return f.readAsArrayBuffer(l), m;
        }
        function X(l) {
          var f = new FileReader(), m = k(f);
          return f.readAsText(l), m;
        }
        function D(l) {
          for (var f = new Uint8Array(l), m = new Array(f.length), b = 0; b < f.length; b++)
            m[b] = String.fromCharCode(f[b]);
          return m.join("");
        }
        function M(l) {
          if (l.slice)
            return l.slice(0);
          var f = new Uint8Array(l.byteLength);
          return f.set(new Uint8Array(l)), f.buffer;
        }
        function P() {
          return this.bodyUsed = !1, this._initBody = function(l) {
            this.bodyUsed = this.bodyUsed, this._bodyInit = l, l ? typeof l == "string" ? this._bodyText = l : d.blob && Blob.prototype.isPrototypeOf(l) ? this._bodyBlob = l : d.formData && FormData.prototype.isPrototypeOf(l) ? this._bodyFormData = l : d.searchParams && URLSearchParams.prototype.isPrototypeOf(l) ? this._bodyText = l.toString() : d.arrayBuffer && d.blob && A(l) ? (this._bodyArrayBuffer = M(l.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : d.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(l) || g(l)) ? this._bodyArrayBuffer = M(l) : this._bodyText = l = Object.prototype.toString.call(l) : this._bodyText = "", this.headers.get("content-type") || (typeof l == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : d.searchParams && URLSearchParams.prototype.isPrototypeOf(l) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, d.blob && (this.blob = function() {
            var l = F(this);
            if (l)
              return l;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var l = F(this);
              return l || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
                this._bodyArrayBuffer.buffer.slice(
                  this._bodyArrayBuffer.byteOffset,
                  this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                )
              ) : Promise.resolve(this._bodyArrayBuffer));
            } else
              return this.blob().then(H);
          }), this.text = function() {
            var l = F(this);
            if (l)
              return l;
            if (this._bodyBlob)
              return X(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(D(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, d.formData && (this.formData = function() {
            return this.text().then(Y);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var U = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function z(l) {
          var f = l.toUpperCase();
          return U.indexOf(f) > -1 ? f : l;
        }
        function G(l, f) {
          if (!(this instanceof G))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          f = f || {};
          var m = f.body;
          if (l instanceof G) {
            if (l.bodyUsed)
              throw new TypeError("Already read");
            this.url = l.url, this.credentials = l.credentials, f.headers || (this.headers = new E(l.headers)), this.method = l.method, this.mode = l.mode, this.signal = l.signal, !m && l._bodyInit != null && (m = l._bodyInit, l.bodyUsed = !0);
          } else
            this.url = String(l);
          if (this.credentials = f.credentials || this.credentials || "same-origin", (f.headers || !this.headers) && (this.headers = new E(f.headers)), this.method = z(f.method || this.method || "GET"), this.mode = f.mode || this.mode || null, this.signal = f.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && m)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          if (this._initBody(m), (this.method === "GET" || this.method === "HEAD") && (f.cache === "no-store" || f.cache === "no-cache")) {
            var b = /([?&])_=[^&]*/;
            if (b.test(this.url))
              this.url = this.url.replace(b, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
            else {
              var T = /\?/;
              this.url += (T.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
            }
          }
        }
        G.prototype.clone = function() {
          return new G(this, { body: this._bodyInit });
        };
        function Y(l) {
          var f = new FormData();
          return l.trim().split("&").forEach(function(m) {
            if (m) {
              var b = m.split("="), T = b.shift().replace(/\+/g, " "), O = b.join("=").replace(/\+/g, " ");
              f.append(decodeURIComponent(T), decodeURIComponent(O));
            }
          }), f;
        }
        function Z(l) {
          var f = new E(), m = l.replace(/\r?\n[\t ]+/g, " ");
          return m.split("\r").map(function(b) {
            return b.indexOf(`
`) === 0 ? b.substr(1, b.length) : b;
          }).forEach(function(b) {
            var T = b.split(":"), O = T.shift().trim();
            if (O) {
              var C = T.join(":").trim();
              f.append(O, C);
            }
          }), f;
        }
        P.call(G.prototype);
        function q(l, f) {
          if (!(this instanceof q))
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          f || (f = {}), this.type = "default", this.status = f.status === void 0 ? 200 : f.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = f.statusText === void 0 ? "" : "" + f.statusText, this.headers = new E(f.headers), this.url = f.url || "", this._initBody(l);
        }
        P.call(q.prototype), q.prototype.clone = function() {
          return new q(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new E(this.headers),
            url: this.url
          });
        }, q.error = function() {
          var l = new q(null, { status: 0, statusText: "" });
          return l.type = "error", l;
        };
        var R = [301, 302, 303, 307, 308];
        q.redirect = function(l, f) {
          if (R.indexOf(f) === -1)
            throw new RangeError("Invalid status code");
          return new q(null, { status: f, headers: { location: l } });
        }, a.DOMException = o.DOMException;
        try {
          new a.DOMException();
        } catch {
          a.DOMException = function(f, m) {
            this.message = f, this.name = m;
            var b = Error(f);
            this.stack = b.stack;
          }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException;
        }
        function u(l, f) {
          return new Promise(function(m, b) {
            var T = new G(l, f);
            if (T.signal && T.signal.aborted)
              return b(new a.DOMException("Aborted", "AbortError"));
            var O = new XMLHttpRequest();
            function C() {
              O.abort();
            }
            O.onload = function() {
              var B = {
                status: O.status,
                statusText: O.statusText,
                headers: Z(O.getAllResponseHeaders() || "")
              };
              B.url = "responseURL" in O ? O.responseURL : B.headers.get("X-Request-URL");
              var tt = "response" in O ? O.response : O.responseText;
              setTimeout(function() {
                m(new q(tt, B));
              }, 0);
            }, O.onerror = function() {
              setTimeout(function() {
                b(new TypeError("Network request failed"));
              }, 0);
            }, O.ontimeout = function() {
              setTimeout(function() {
                b(new TypeError("Network request failed"));
              }, 0);
            }, O.onabort = function() {
              setTimeout(function() {
                b(new a.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function _(B) {
              try {
                return B === "" && o.location.href ? o.location.href : B;
              } catch {
                return B;
              }
            }
            O.open(T.method, _(T.url), !0), T.credentials === "include" ? O.withCredentials = !0 : T.credentials === "omit" && (O.withCredentials = !1), "responseType" in O && (d.blob ? O.responseType = "blob" : d.arrayBuffer && T.headers.get("Content-Type") && T.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (O.responseType = "arraybuffer")), f && typeof f.headers == "object" && !(f.headers instanceof E) ? Object.getOwnPropertyNames(f.headers).forEach(function(B) {
              O.setRequestHeader(B, v(f.headers[B]));
            }) : T.headers.forEach(function(B, tt) {
              O.setRequestHeader(tt, B);
            }), T.signal && (T.signal.addEventListener("abort", C), O.onreadystatechange = function() {
              O.readyState === 4 && T.signal.removeEventListener("abort", C);
            }), O.send(typeof T._bodyInit > "u" ? null : T._bodyInit);
          });
        }
        return u.polyfill = !0, o.fetch || (o.fetch = u, o.Headers = E, o.Request = G, o.Response = q), a.Headers = E, a.Request = G, a.Response = q, a.fetch = u, a;
      })({});
    })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
    var s = e.fetch ? e : n;
    t = s.fetch, t.default = s.fetch, t.fetch = s.fetch, t.Headers = s.Headers, t.Request = s.Request, t.Response = s.Response, r.exports = t;
  }(xa, xa.exports)), xa.exports;
}
var po = iv();
const La = /* @__PURE__ */ k_(po), av = /* @__PURE__ */ Tw({
  __proto__: null,
  default: La
}, [po]), qn = (r) => {
  let t = {};
  return r && (typeof Headers < "u" && r instanceof Headers || av && po.Headers && r instanceof po.Headers ? t = _B(r) : Array.isArray(r) ? r.forEach(([e, n]) => {
    e && n !== void 0 && (t[e] = n);
  }) : t = r), t;
}, zh = (r) => r.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), ov = (r) => {
  if (!Array.isArray(r.query)) {
    const n = r, s = [`query=${encodeURIComponent(zh(n.query))}`];
    return r.variables && s.push(`variables=${encodeURIComponent(n.jsonSerializer.stringify(n.variables))}`), n.operationName && s.push(`operationName=${encodeURIComponent(n.operationName)}`), s.join("&");
  }
  if (typeof r.variables < "u" && !Array.isArray(r.variables))
    throw new Error("Cannot create query with given variable type, array expected");
  const t = r, e = r.query.reduce((n, s, i) => (n.push({
    query: zh(s),
    variables: t.variables ? t.jsonSerializer.stringify(t.variables[i]) : void 0
  }), n), []);
  return `query=${encodeURIComponent(t.jsonSerializer.stringify(e))}`;
}, cv = (r) => async (t) => {
  const { url: e, query: n, variables: s, operationName: i, fetch: a, fetchOptions: o, middleware: d } = t, A = { ...t.headers };
  let p = "", g;
  r === "POST" ? (g = uv(n, s, i, o.jsonSerializer), typeof g == "string" && (A["Content-Type"] = "application/json")) : p = ov({
    query: n,
    variables: s,
    operationName: i,
    jsonSerializer: o.jsonSerializer ?? tu
  });
  const y = {
    method: r,
    headers: A,
    body: g,
    ...o
  };
  let v = e, N = y;
  if (d) {
    const E = await Promise.resolve(d({ ...y, url: e, operationName: i, variables: s })), { url: F, ...k } = E;
    v = F, N = k;
  }
  return p && (v = `${v}?${p}`), await a(v, N);
};
class dv {
  constructor(t, e = {}) {
    this.url = t, this.requestConfig = e, this.rawRequest = async (...n) => {
      const [s, i, a] = n, o = fB(s, i, a), { headers: d, fetch: A = La, method: p = "POST", requestMiddleware: g, responseMiddleware: y, ...v } = this.requestConfig, { url: N } = this;
      o.signal !== void 0 && (v.signal = o.signal);
      const { operationName: E } = kc(o.query);
      return Uc({
        url: N,
        query: o.query,
        variables: o.variables,
        headers: {
          ...qn(Gc(d)),
          ...qn(o.requestHeaders)
        },
        operationName: E,
        fetch: A,
        method: p,
        fetchOptions: v,
        middleware: g
      }).then((F) => (y && y(F), F)).catch((F) => {
        throw y && y(F), F;
      });
    };
  }
  async request(t, ...e) {
    const [n, s] = e, i = pB(t, n, s), { headers: a, fetch: o = La, method: d = "POST", requestMiddleware: A, responseMiddleware: p, ...g } = this.requestConfig, { url: y } = this;
    i.signal !== void 0 && (g.signal = i.signal);
    const { query: v, operationName: N } = kc(i.document);
    return Uc({
      url: y,
      query: v,
      variables: i.variables,
      headers: {
        ...qn(Gc(a)),
        ...qn(i.requestHeaders)
      },
      operationName: N,
      fetch: o,
      method: d,
      fetchOptions: g,
      middleware: A
    }).then((E) => (p && p(E), E.data)).catch((E) => {
      throw p && p(E), E;
    });
  }
  // prettier-ignore
  batchRequests(t, e) {
    const n = gB(t, e), { headers: s, ...i } = this.requestConfig;
    n.signal !== void 0 && (i.signal = n.signal);
    const a = n.documents.map(({ document: d }) => kc(d).query), o = n.documents.map(({ variables: d }) => d);
    return Uc({
      url: this.url,
      query: a,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: o,
      headers: {
        ...qn(Gc(s)),
        ...qn(n.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? La,
      method: this.requestConfig.method || "POST",
      fetchOptions: i,
      middleware: this.requestConfig.requestMiddleware
    }).then((d) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(d), d.data)).catch((d) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(d), d;
    });
  }
  setHeaders(t) {
    return this.requestConfig.headers = t, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(t, e) {
    const { headers: n } = this.requestConfig;
    return n ? n[t] = e : this.requestConfig.headers = { [t]: e }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(t) {
    return this.url = t, this;
  }
}
const Uc = async (r) => {
  const { query: t, variables: e, fetchOptions: n } = r, s = cv(hB(r.method ?? "post")), i = Array.isArray(r.query), a = await s(r), o = await Av(a, n.jsonSerializer ?? tu), d = Array.isArray(o) ? !o.some(({ data: p }) => !p) : !!o.data, A = Array.isArray(o) || !o.errors || Array.isArray(o.errors) && !o.errors.length || n.errorPolicy === "all" || n.errorPolicy === "ignore";
  if (a.ok && A && d) {
    const { errors: p, ...g } = (Array.isArray(o), o), y = n.errorPolicy === "ignore" ? g : o;
    return {
      ...i ? { data: y } : y,
      headers: a.headers,
      status: a.status
    };
  } else {
    const p = typeof o == "string" ? {
      error: o
    } : o;
    throw new Ki(
      // @ts-expect-error TODO
      { ...p, status: a.status, headers: a.headers },
      { query: t, variables: e }
    );
  }
}, uv = (r, t, e, n) => {
  const s = n ?? tu;
  if (!Array.isArray(r))
    return s.stringify({ query: r, variables: t, operationName: e });
  if (typeof t < "u" && !Array.isArray(t))
    throw new Error("Cannot create request body with given variable type, array expected");
  const i = r.reduce((a, o, d) => (a.push({ query: o, variables: t ? t[d] : void 0 }), a), []);
  return s.stringify(i);
}, Av = async (r, t) => {
  let e;
  return r.headers.forEach((n, s) => {
    s.toLowerCase() === "content-type" && (e = n);
  }), e && (e.toLowerCase().startsWith("application/json") || e.toLowerCase().startsWith("application/graphql+json") || e.toLowerCase().startsWith("application/graphql-response+json")) ? t.parse(await r.text()) : r.text();
}, Gc = (r) => typeof r == "function" ? r() : r;
var fo = function() {
  return fo = Object.assign || function(t) {
    for (var e, n = 1, s = arguments.length; n < s; n++) {
      e = arguments[n];
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, fo.apply(this, arguments);
};
var ka = /* @__PURE__ */ new Map(), gd = /* @__PURE__ */ new Map(), uf = !0, go = !1;
function Af(r) {
  return r.replace(/[\s,]+/g, " ").trim();
}
function lv(r) {
  return Af(r.source.body.substring(r.start, r.end));
}
function hv(r) {
  var t = /* @__PURE__ */ new Set(), e = [];
  return r.definitions.forEach(function(n) {
    if (n.kind === "FragmentDefinition") {
      var s = n.name.value, i = lv(n.loc), a = gd.get(s);
      a && !a.has(i) ? uf && console.warn("Warning: fragment with name " + s + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : a || gd.set(s, a = /* @__PURE__ */ new Set()), a.add(i), t.has(i) || (t.add(i), e.push(n));
    } else
      e.push(n);
  }), fo(fo({}, r), { definitions: e });
}
function _v(r) {
  var t = new Set(r.definitions);
  t.forEach(function(n) {
    n.loc && delete n.loc, Object.keys(n).forEach(function(s) {
      var i = n[s];
      i && typeof i == "object" && t.add(i);
    });
  });
  var e = r.loc;
  return e && (delete e.startToken, delete e.endToken), r;
}
function pv(r) {
  var t = Af(r);
  if (!ka.has(t)) {
    var e = of(r, {
      experimentalFragmentVariables: go,
      allowLegacyFragmentVariables: go
    });
    if (!e || e.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    ka.set(t, _v(hv(e)));
  }
  return ka.get(t);
}
function $(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  typeof r == "string" && (r = [r]);
  var n = r[0];
  return t.forEach(function(s, i) {
    s && s.kind === "Document" ? n += s.loc.source.body : n += s, n += r[i + 1];
  }), pv(n);
}
function fv() {
  ka.clear(), gd.clear();
}
function gv() {
  uf = !1;
}
function wv() {
  go = !0;
}
function mv() {
  go = !1;
}
var Hi = {
  gql: $,
  resetCaches: fv,
  disableFragmentWarnings: gv,
  enableExperimentalFragmentVariables: wv,
  disableExperimentalFragmentVariables: mv
};
(function(r) {
  r.gql = Hi.gql, r.resetCaches = Hi.resetCaches, r.disableFragmentWarnings = Hi.disableFragmentWarnings, r.enableExperimentalFragmentVariables = Hi.enableExperimentalFragmentVariables, r.disableExperimentalFragmentVariables = Hi.disableExperimentalFragmentVariables;
})($ || ($ = {}));
$.default = $;
var St = "0x0000000000000000000000000000000000000000000000000000000000000000", ZR = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", JR = 16 * 1024, jR = 16, qR = 1024 * 1024 * 1024, $R = 1024 * 1024 * 1024, KR = 255, tS = 1024 * 1024, eS = 1024 * 1024, lf = "0xffffffffffff0000", nu = "0xffffffffffff0001", hf = "0xffffffffffff0003", _f = "0xffffffffffff0004", pf = "0xffffffffffff0005", yv = "0xffffffffffff0006", bv = [
  "ArithmeticError",
  "ArithmeticOverflow",
  "AssetIdNotFound",
  "BalanceOverflow",
  "BlobIdAlreadyUploaded",
  "BlobNotFound",
  "BytecodeAlreadyUploaded",
  "CanNotGetGasPriceInPredicate",
  "ContractIdAlreadyDeployed",
  "ContractInstructionNotAllowed",
  "ContractMaxSize",
  "ContractMismatch",
  "ContractNotFound",
  "ContractNotInInputs",
  "EcalError",
  "ExpectedCoinInput",
  "ExpectedInternalContext",
  "ExpectedNestedCaller",
  "ExpectedOutputVariable",
  "ExpectedParentInternalContext",
  "ExpectedUnallocatedStack",
  "GasCostNotDefined",
  "InputContractDoesNotExist",
  "InputNotFound",
  "InternalBalanceOverflow",
  "InvalidBlockHeight",
  "InvalidEllipticCurvePoint",
  "InvalidFlags",
  "InvalidImmediateValue",
  "InvalidInstruction",
  "InvalidMetadataIdentifier",
  "InvalidUpgradePurposeType",
  "MalformedCallStructure",
  "MaxStaticContractsReached",
  "MemoryGrowthOverlap",
  "MemoryNotExecutable",
  "MemoryOverflow",
  "MemoryOwnership",
  "MemoryWriteOverlap",
  "MessageDataTooLong",
  "NotEnoughBalance",
  "OutOfGas",
  "OutputNotFound",
  "OverridingConsensusParameters",
  "OverridingStateTransactionBytecode",
  "PolicyIsNotSet",
  "PolicyNotFound",
  "PredicateReturnedNonOne",
  "ProofInUploadNotFound",
  "ReservedRegisterNotWritable",
  "Revert",
  "StorageSlotsNotFound",
  "ThePartIsNotSequentiallyConnected",
  "TooManyReceipts",
  "TooManySlots",
  "TransactionMaturity",
  "TransactionValidity",
  "TransferAmountCannotBeZero",
  "TransferZeroCoins",
  "UninitalizedMemoryAccess",
  "UnknownPanicReason",
  "UnknownStateTransactionBytecodeRoot",
  "UnsupportedCurveId",
  "UnsupportedOperationType",
  "WitnessNotFound"
], Iv = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html", Cv = {
  FAILED_REQUIRE_SIGNAL: lf,
  FAILED_TRANSFER_TO_ADDRESS_SIGNAL: nu,
  FAILED_ASSERT_EQ_SIGNAL: hf,
  FAILED_ASSERT_SIGNAL: _f,
  FAILED_ASSERT_NE_SIGNAL: pf,
  REVERT_WITH_LOG_SIGNAL: yv
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Uo = /* @__PURE__ */ BigInt(0), Go = /* @__PURE__ */ BigInt(1), Ev = /* @__PURE__ */ BigInt(2);
function Vn(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function wa(r) {
  if (!Vn(r))
    throw new Error("Uint8Array expected");
}
function vi(r, t) {
  if (typeof t != "boolean")
    throw new Error(r + " boolean expected, got " + t);
}
const Bv = /* @__PURE__ */ Array.from({ length: 256 }, (r, t) => t.toString(16).padStart(2, "0"));
function xi(r) {
  wa(r);
  let t = "";
  for (let e = 0; e < r.length; e++)
    t += Bv[r[e]];
  return t;
}
function ss(r) {
  const t = r.toString(16);
  return t.length & 1 ? "0" + t : t;
}
function su(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return r === "" ? Uo : BigInt("0x" + r);
}
const Or = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Xh(r) {
  if (r >= Or._0 && r <= Or._9)
    return r - Or._0;
  if (r >= Or.A && r <= Or.F)
    return r - (Or.A - 10);
  if (r >= Or.a && r <= Or.f)
    return r - (Or.a - 10);
}
function Ri(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const t = r.length, e = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(e);
  for (let s = 0, i = 0; s < e; s++, i += 2) {
    const a = Xh(r.charCodeAt(i)), o = Xh(r.charCodeAt(i + 1));
    if (a === void 0 || o === void 0) {
      const d = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + d + '" at index ' + i);
    }
    n[s] = a * 16 + o;
  }
  return n;
}
function Fn(r) {
  return su(xi(r));
}
function iu(r) {
  return wa(r), su(xi(Uint8Array.from(r).reverse()));
}
function Si(r, t) {
  return Ri(r.toString(16).padStart(t * 2, "0"));
}
function au(r, t) {
  return Si(r, t).reverse();
}
function vv(r) {
  return Ri(ss(r));
}
function ur(r, t, e) {
  let n;
  if (typeof t == "string")
    try {
      n = Ri(t);
    } catch (i) {
      throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
  else if (Vn(t))
    n = Uint8Array.from(t);
  else
    throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof e == "number" && s !== e)
    throw new Error(r + " of length " + e + " expected, got " + s);
  return n;
}
function ia(...r) {
  let t = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    wa(s), t += s.length;
  }
  const e = new Uint8Array(t);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    e.set(i, s), s += i.length;
  }
  return e;
}
function xv(r, t) {
  if (r.length !== t.length)
    return !1;
  let e = 0;
  for (let n = 0; n < r.length; n++)
    e |= r[n] ^ t[n];
  return e === 0;
}
function Rv(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
const zc = (r) => typeof r == "bigint" && Uo <= r;
function zo(r, t, e) {
  return zc(r) && zc(t) && zc(e) && t <= r && r < e;
}
function Nn(r, t, e, n) {
  if (!zo(t, e, n))
    throw new Error("expected valid " + r + ": " + e + " <= n < " + n + ", got " + t);
}
function ff(r) {
  let t;
  for (t = 0; r > Uo; r >>= Go, t += 1)
    ;
  return t;
}
function Sv(r, t) {
  return r >> BigInt(t) & Go;
}
function Tv(r, t, e) {
  return r | (e ? Go : Uo) << BigInt(t);
}
const ou = (r) => (Ev << BigInt(r - 1)) - Go, Xc = (r) => new Uint8Array(r), Hh = (r) => Uint8Array.from(r);
function gf(r, t, e) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof e != "function")
    throw new Error("hmacFn must be a function");
  let n = Xc(r), s = Xc(r), i = 0;
  const a = () => {
    n.fill(1), s.fill(0), i = 0;
  }, o = (...g) => e(s, n, ...g), d = (g = Xc()) => {
    s = o(Hh([0]), g), n = o(), g.length !== 0 && (s = o(Hh([1]), g), n = o());
  }, A = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let g = 0;
    const y = [];
    for (; g < t; ) {
      n = o();
      const v = n.slice();
      y.push(v), g += n.length;
    }
    return ia(...y);
  };
  return (g, y) => {
    a(), d(g);
    let v;
    for (; !(v = y(A())); )
      d();
    return a(), v;
  };
}
const Fv = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || Vn(r),
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, t) => t.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function ma(r, t, e = {}) {
  const n = (s, i, a) => {
    const o = Fv[i];
    if (typeof o != "function")
      throw new Error("invalid validator function");
    const d = r[s];
    if (!(a && d === void 0) && !o(d, r))
      throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + d);
  };
  for (const [s, i] of Object.entries(t))
    n(s, i, !1);
  for (const [s, i] of Object.entries(e))
    n(s, i, !0);
  return r;
}
const Nv = () => {
  throw new Error("not implemented");
};
function wd(r) {
  const t = /* @__PURE__ */ new WeakMap();
  return (e, ...n) => {
    const s = t.get(e);
    if (s !== void 0)
      return s;
    const i = r(e, ...n);
    return t.set(e, i), i;
  };
}
const Qv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: Nn,
  abool: vi,
  abytes: wa,
  bitGet: Sv,
  bitLen: ff,
  bitMask: ou,
  bitSet: Tv,
  bytesToHex: xi,
  bytesToNumberBE: Fn,
  bytesToNumberLE: iu,
  concatBytes: ia,
  createHmacDrbg: gf,
  ensureBytes: ur,
  equalBytes: xv,
  hexToBytes: Ri,
  hexToNumber: su,
  inRange: zo,
  isBytes: Vn,
  memoized: wd,
  notImplemented: Nv,
  numberToBytesBE: Si,
  numberToBytesLE: au,
  numberToHexUnpadded: ss,
  numberToVarBytesBE: vv,
  utf8ToBytes: Rv,
  validateObject: ma
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const xe = BigInt(0), zt = BigInt(1), fn = /* @__PURE__ */ BigInt(2), Dv = /* @__PURE__ */ BigInt(3), md = /* @__PURE__ */ BigInt(4), Vh = /* @__PURE__ */ BigInt(5), Wh = /* @__PURE__ */ BigInt(8);
function Ue(r, t) {
  const e = r % t;
  return e >= xe ? e : t + e;
}
function Ov(r, t, e) {
  if (t < xe)
    throw new Error("invalid exponent, negatives unsupported");
  if (e <= xe)
    throw new Error("invalid modulus");
  if (e === zt)
    return xe;
  let n = zt;
  for (; t > xe; )
    t & zt && (n = n * r % e), r = r * r % e, t >>= zt;
  return n;
}
function qe(r, t, e) {
  let n = r;
  for (; t-- > xe; )
    n *= n, n %= e;
  return n;
}
function yd(r, t) {
  if (r === xe)
    throw new Error("invert: expected non-zero number");
  if (t <= xe)
    throw new Error("invert: expected positive modulus, got " + t);
  let e = Ue(r, t), n = t, s = xe, i = zt;
  for (; e !== xe; ) {
    const o = n / e, d = n % e, A = s - i * o;
    n = e, e = d, s = i, i = A;
  }
  if (n !== zt)
    throw new Error("invert: does not exist");
  return Ue(s, t);
}
function Mv(r) {
  const t = (r - zt) / fn;
  let e, n, s;
  for (e = r - zt, n = 0; e % fn === xe; e /= fn, n++)
    ;
  for (s = fn; s < r && Ov(s, t, r) !== r - zt; s++)
    if (s > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (n === 1) {
    const a = (r + zt) / md;
    return function(d, A) {
      const p = d.pow(A, a);
      if (!d.eql(d.sqr(p), A))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  const i = (e + zt) / fn;
  return function(o, d) {
    if (o.pow(d, t) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let A = n, p = o.pow(o.mul(o.ONE, s), e), g = o.pow(d, i), y = o.pow(d, e);
    for (; !o.eql(y, o.ONE); ) {
      if (o.eql(y, o.ZERO))
        return o.ZERO;
      let v = 1;
      for (let E = o.sqr(y); v < A && !o.eql(E, o.ONE); v++)
        E = o.sqr(E);
      const N = o.pow(p, zt << BigInt(A - v - 1));
      p = o.sqr(N), g = o.mul(g, N), y = o.mul(y, p), A = v;
    }
    return g;
  };
}
function Pv(r) {
  if (r % md === Dv) {
    const t = (r + zt) / md;
    return function(n, s) {
      const i = n.pow(s, t);
      if (!n.eql(n.sqr(i), s))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (r % Wh === Vh) {
    const t = (r - Vh) / Wh;
    return function(n, s) {
      const i = n.mul(s, fn), a = n.pow(i, t), o = n.mul(s, a), d = n.mul(n.mul(o, fn), a), A = n.mul(o, n.sub(d, n.ONE));
      if (!n.eql(n.sqr(A), s))
        throw new Error("Cannot find square root");
      return A;
    };
  }
  return Mv(r);
}
const Lv = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function kv(r) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, e = Lv.reduce((n, s) => (n[s] = "function", n), t);
  return ma(r, e);
}
function Uv(r, t, e) {
  if (e < xe)
    throw new Error("invalid exponent, negatives unsupported");
  if (e === xe)
    return r.ONE;
  if (e === zt)
    return t;
  let n = r.ONE, s = t;
  for (; e > xe; )
    e & zt && (n = r.mul(n, s)), s = r.sqr(s), e >>= zt;
  return n;
}
function Gv(r, t) {
  const e = new Array(t.length), n = t.reduce((i, a, o) => r.is0(a) ? i : (e[o] = i, r.mul(i, a)), r.ONE), s = r.inv(n);
  return t.reduceRight((i, a, o) => r.is0(a) ? i : (e[o] = r.mul(i, e[o]), r.mul(i, a)), s), e;
}
function wf(r, t) {
  const e = t !== void 0 ? t : r.toString(2).length, n = Math.ceil(e / 8);
  return { nBitLength: e, nByteLength: n };
}
function mf(r, t, e = !1, n = {}) {
  if (r <= xe)
    throw new Error("invalid field: expected ORDER > 0, got " + r);
  const { nBitLength: s, nByteLength: i } = wf(r, t);
  if (i > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a;
  const o = Object.freeze({
    ORDER: r,
    isLE: e,
    BITS: s,
    BYTES: i,
    MASK: ou(s),
    ZERO: xe,
    ONE: zt,
    create: (d) => Ue(d, r),
    isValid: (d) => {
      if (typeof d != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof d);
      return xe <= d && d < r;
    },
    is0: (d) => d === xe,
    isOdd: (d) => (d & zt) === zt,
    neg: (d) => Ue(-d, r),
    eql: (d, A) => d === A,
    sqr: (d) => Ue(d * d, r),
    add: (d, A) => Ue(d + A, r),
    sub: (d, A) => Ue(d - A, r),
    mul: (d, A) => Ue(d * A, r),
    pow: (d, A) => Uv(o, d, A),
    div: (d, A) => Ue(d * yd(A, r), r),
    // Same as above, but doesn't normalize
    sqrN: (d) => d * d,
    addN: (d, A) => d + A,
    subN: (d, A) => d - A,
    mulN: (d, A) => d * A,
    inv: (d) => yd(d, r),
    sqrt: n.sqrt || ((d) => (a || (a = Pv(r)), a(o, d))),
    invertBatch: (d) => Gv(o, d),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (d, A, p) => p ? A : d,
    toBytes: (d) => e ? au(d, i) : Si(d, i),
    fromBytes: (d) => {
      if (d.length !== i)
        throw new Error("Field.fromBytes: expected " + i + " bytes, got " + d.length);
      return e ? iu(d) : Fn(d);
    }
  });
  return Object.freeze(o);
}
function yf(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const t = r.toString(2).length;
  return Math.ceil(t / 8);
}
function bf(r) {
  const t = yf(r);
  return t + Math.ceil(t / 2);
}
function zv(r, t, e = !1) {
  const n = r.length, s = yf(t), i = bf(t);
  if (n < 16 || n < i || n > 1024)
    throw new Error("expected " + i + "-1024 bytes of input, got " + n);
  const a = e ? iu(r) : Fn(r), o = Ue(a, t - zt) + zt;
  return e ? au(o, s) : Si(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yh = BigInt(0), Ra = BigInt(1);
function Hc(r, t) {
  const e = t.negate();
  return r ? e : t;
}
function If(r, t) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + r);
}
function Vc(r, t) {
  If(r, t);
  const e = Math.ceil(t / r) + 1, n = 2 ** (r - 1);
  return { windows: e, windowSize: n };
}
function Xv(r, t) {
  if (!Array.isArray(r))
    throw new Error("array expected");
  r.forEach((e, n) => {
    if (!(e instanceof t))
      throw new Error("invalid point at index " + n);
  });
}
function Hv(r, t) {
  if (!Array.isArray(r))
    throw new Error("array of scalars expected");
  r.forEach((e, n) => {
    if (!t.isValid(e))
      throw new Error("invalid scalar at index " + n);
  });
}
const Wc = /* @__PURE__ */ new WeakMap(), Cf = /* @__PURE__ */ new WeakMap();
function Yc(r) {
  return Cf.get(r) || 1;
}
function Vv(r, t) {
  return {
    constTimeNegate: Hc,
    hasPrecomputes(e) {
      return Yc(e) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(e, n, s = r.ZERO) {
      let i = e;
      for (; n > Yh; )
        n & Ra && (s = s.add(i)), i = i.double(), n >>= Ra;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(e, n) {
      const { windows: s, windowSize: i } = Vc(n, t), a = [];
      let o = e, d = o;
      for (let A = 0; A < s; A++) {
        d = o, a.push(d);
        for (let p = 1; p < i; p++)
          d = d.add(o), a.push(d);
        o = d.double();
      }
      return a;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(e, n, s) {
      const { windows: i, windowSize: a } = Vc(e, t);
      let o = r.ZERO, d = r.BASE;
      const A = BigInt(2 ** e - 1), p = 2 ** e, g = BigInt(e);
      for (let y = 0; y < i; y++) {
        const v = y * a;
        let N = Number(s & A);
        s >>= g, N > a && (N -= p, s += Ra);
        const E = v, F = v + Math.abs(N) - 1, k = y % 2 !== 0, H = N < 0;
        N === 0 ? d = d.add(Hc(k, n[E])) : o = o.add(Hc(H, n[F]));
      }
      return { p: o, f: d };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(e, n, s, i = r.ZERO) {
      const { windows: a, windowSize: o } = Vc(e, t), d = BigInt(2 ** e - 1), A = 2 ** e, p = BigInt(e);
      for (let g = 0; g < a; g++) {
        const y = g * o;
        if (s === Yh)
          break;
        let v = Number(s & d);
        if (s >>= p, v > o && (v -= A, s += Ra), v === 0)
          continue;
        let N = n[y + Math.abs(v) - 1];
        v < 0 && (N = N.negate()), i = i.add(N);
      }
      return i;
    },
    getPrecomputes(e, n, s) {
      let i = Wc.get(n);
      return i || (i = this.precomputeWindow(n, e), e !== 1 && Wc.set(n, s(i))), i;
    },
    wNAFCached(e, n, s) {
      const i = Yc(e);
      return this.wNAF(i, this.getPrecomputes(i, e, s), n);
    },
    wNAFCachedUnsafe(e, n, s, i) {
      const a = Yc(e);
      return a === 1 ? this.unsafeLadder(e, n, i) : this.wNAFUnsafe(a, this.getPrecomputes(a, e, s), n, i);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(e, n) {
      If(n, t), Cf.set(e, n), Wc.delete(e);
    }
  };
}
function Wv(r, t, e, n) {
  if (Xv(e, r), Hv(n, t), e.length !== n.length)
    throw new Error("arrays of points and scalars must have equal length");
  const s = r.ZERO, i = ff(BigInt(e.length)), a = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, o = (1 << a) - 1, d = new Array(o + 1).fill(s), A = Math.floor((t.BITS - 1) / a) * a;
  let p = s;
  for (let g = A; g >= 0; g -= a) {
    d.fill(s);
    for (let v = 0; v < n.length; v++) {
      const N = n[v], E = Number(N >> BigInt(g) & BigInt(o));
      d[E] = d[E].add(e[v]);
    }
    let y = s;
    for (let v = d.length - 1, N = s; v > 0; v--)
      N = N.add(d[v]), y = y.add(N);
    if (p = p.add(y), g !== 0)
      for (let v = 0; v < a; v++)
        p = p.double();
  }
  return p;
}
function Ef(r) {
  return kv(r.Fp), ma(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...wf(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Zh(r) {
  r.lowS !== void 0 && vi("lowS", r.lowS), r.prehash !== void 0 && vi("prehash", r.prehash);
}
function Yv(r) {
  const t = Ef(r);
  ma(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: e, Fp: n, a: s } = t;
  if (e) {
    if (!n.eql(s, n.ZERO))
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof e != "object" || typeof e.beta != "bigint" || typeof e.splitScalar != "function")
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: Zv, hexToBytes: Jv } = Qv;
class jv extends Error {
  constructor(t = "") {
    super(t);
  }
}
const Lr = {
  // asn.1 DER encoding utils
  Err: jv,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (r, t) => {
      const { Err: e } = Lr;
      if (r < 0 || r > 256)
        throw new e("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new e("tlv.encode: unpadded data");
      const n = t.length / 2, s = ss(n);
      if (s.length / 2 & 128)
        throw new e("tlv.encode: long form length too big");
      const i = n > 127 ? ss(s.length / 2 | 128) : "";
      return ss(r) + i + s + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(r, t) {
      const { Err: e } = Lr;
      let n = 0;
      if (r < 0 || r > 256)
        throw new e("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== r)
        throw new e("tlv.decode: wrong tlv");
      const s = t[n++], i = !!(s & 128);
      let a = 0;
      if (!i)
        a = s;
      else {
        const d = s & 127;
        if (!d)
          throw new e("tlv.decode(long): indefinite length not supported");
        if (d > 4)
          throw new e("tlv.decode(long): byte length is too big");
        const A = t.subarray(n, n + d);
        if (A.length !== d)
          throw new e("tlv.decode: length bytes not complete");
        if (A[0] === 0)
          throw new e("tlv.decode(long): zero leftmost byte");
        for (const p of A)
          a = a << 8 | p;
        if (n += d, a < 128)
          throw new e("tlv.decode(long): not minimal encoding");
      }
      const o = t.subarray(n, n + a);
      if (o.length !== a)
        throw new e("tlv.decode: wrong value length");
      return { v: o, l: t.subarray(n + a) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(r) {
      const { Err: t } = Lr;
      if (r < Gr)
        throw new t("integer: negative integers are not allowed");
      let e = ss(r);
      if (Number.parseInt(e[0], 16) & 8 && (e = "00" + e), e.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return e;
    },
    decode(r) {
      const { Err: t } = Lr;
      if (r[0] & 128)
        throw new t("invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return Zv(r);
    }
  },
  toSig(r) {
    const { Err: t, _int: e, _tlv: n } = Lr, s = typeof r == "string" ? Jv(r) : r;
    wa(s);
    const { v: i, l: a } = n.decode(48, s);
    if (a.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: o, l: d } = n.decode(2, i), { v: A, l: p } = n.decode(2, d);
    if (p.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: e.decode(o), s: e.decode(A) };
  },
  hexFromSig(r) {
    const { _tlv: t, _int: e } = Lr, n = t.encode(2, e.encode(r.r)), s = t.encode(2, e.encode(r.s)), i = n + s;
    return t.encode(48, i);
  }
}, Gr = BigInt(0), Ee = BigInt(1);
BigInt(2);
const Jh = BigInt(3);
BigInt(4);
function qv(r) {
  const t = Yv(r), { Fp: e } = t, n = mf(t.n, t.nBitLength), s = t.toBytes || ((E, F, k) => {
    const H = F.toAffine();
    return ia(Uint8Array.from([4]), e.toBytes(H.x), e.toBytes(H.y));
  }), i = t.fromBytes || ((E) => {
    const F = E.subarray(1), k = e.fromBytes(F.subarray(0, e.BYTES)), H = e.fromBytes(F.subarray(e.BYTES, 2 * e.BYTES));
    return { x: k, y: H };
  });
  function a(E) {
    const { a: F, b: k } = t, H = e.sqr(E), X = e.mul(H, E);
    return e.add(e.add(X, e.mul(E, F)), k);
  }
  if (!e.eql(e.sqr(t.Gy), a(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(E) {
    return zo(E, Ee, t.n);
  }
  function d(E) {
    const { allowedPrivateKeyLengths: F, nByteLength: k, wrapPrivateKey: H, n: X } = t;
    if (F && typeof E != "bigint") {
      if (Vn(E) && (E = xi(E)), typeof E != "string" || !F.includes(E.length))
        throw new Error("invalid private key");
      E = E.padStart(k * 2, "0");
    }
    let D;
    try {
      D = typeof E == "bigint" ? E : Fn(ur("private key", E, k));
    } catch {
      throw new Error("invalid private key, expected hex or " + k + " bytes, got " + typeof E);
    }
    return H && (D = Ue(D, X)), Nn("private key", D, Ee, X), D;
  }
  function A(E) {
    if (!(E instanceof y))
      throw new Error("ProjectivePoint expected");
  }
  const p = wd((E, F) => {
    const { px: k, py: H, pz: X } = E;
    if (e.eql(X, e.ONE))
      return { x: k, y: H };
    const D = E.is0();
    F == null && (F = D ? e.ONE : e.inv(X));
    const M = e.mul(k, F), P = e.mul(H, F), U = e.mul(X, F);
    if (D)
      return { x: e.ZERO, y: e.ZERO };
    if (!e.eql(U, e.ONE))
      throw new Error("invZ was invalid");
    return { x: M, y: P };
  }), g = wd((E) => {
    if (E.is0()) {
      if (t.allowInfinityPoint && !e.is0(E.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: F, y: k } = E.toAffine();
    if (!e.isValid(F) || !e.isValid(k))
      throw new Error("bad point: x or y not FE");
    const H = e.sqr(k), X = a(F);
    if (!e.eql(H, X))
      throw new Error("bad point: equation left != right");
    if (!E.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class y {
    constructor(F, k, H) {
      if (this.px = F, this.py = k, this.pz = H, F == null || !e.isValid(F))
        throw new Error("x required");
      if (k == null || !e.isValid(k))
        throw new Error("y required");
      if (H == null || !e.isValid(H))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(F) {
      const { x: k, y: H } = F || {};
      if (!F || !e.isValid(k) || !e.isValid(H))
        throw new Error("invalid affine point");
      if (F instanceof y)
        throw new Error("projective point not allowed");
      const X = (D) => e.eql(D, e.ZERO);
      return X(k) && X(H) ? y.ZERO : new y(k, H, e.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(F) {
      const k = e.invertBatch(F.map((H) => H.pz));
      return F.map((H, X) => H.toAffine(k[X])).map(y.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(F) {
      const k = y.fromAffine(i(ur("pointHex", F)));
      return k.assertValidity(), k;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(F) {
      return y.BASE.multiply(d(F));
    }
    // Multiscalar Multiplication
    static msm(F, k) {
      return Wv(y, n, F, k);
    }
    // "Private method", don't use it directly
    _setWindowSize(F) {
      N.setWindowSize(this, F);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      g(this);
    }
    hasEvenY() {
      const { y: F } = this.toAffine();
      if (e.isOdd)
        return !e.isOdd(F);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(F) {
      A(F);
      const { px: k, py: H, pz: X } = this, { px: D, py: M, pz: P } = F, U = e.eql(e.mul(k, P), e.mul(D, X)), z = e.eql(e.mul(H, P), e.mul(M, X));
      return U && z;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new y(this.px, e.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: F, b: k } = t, H = e.mul(k, Jh), { px: X, py: D, pz: M } = this;
      let P = e.ZERO, U = e.ZERO, z = e.ZERO, G = e.mul(X, X), Y = e.mul(D, D), Z = e.mul(M, M), q = e.mul(X, D);
      return q = e.add(q, q), z = e.mul(X, M), z = e.add(z, z), P = e.mul(F, z), U = e.mul(H, Z), U = e.add(P, U), P = e.sub(Y, U), U = e.add(Y, U), U = e.mul(P, U), P = e.mul(q, P), z = e.mul(H, z), Z = e.mul(F, Z), q = e.sub(G, Z), q = e.mul(F, q), q = e.add(q, z), z = e.add(G, G), G = e.add(z, G), G = e.add(G, Z), G = e.mul(G, q), U = e.add(U, G), Z = e.mul(D, M), Z = e.add(Z, Z), G = e.mul(Z, q), P = e.sub(P, G), z = e.mul(Z, Y), z = e.add(z, z), z = e.add(z, z), new y(P, U, z);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(F) {
      A(F);
      const { px: k, py: H, pz: X } = this, { px: D, py: M, pz: P } = F;
      let U = e.ZERO, z = e.ZERO, G = e.ZERO;
      const Y = t.a, Z = e.mul(t.b, Jh);
      let q = e.mul(k, D), R = e.mul(H, M), u = e.mul(X, P), l = e.add(k, H), f = e.add(D, M);
      l = e.mul(l, f), f = e.add(q, R), l = e.sub(l, f), f = e.add(k, X);
      let m = e.add(D, P);
      return f = e.mul(f, m), m = e.add(q, u), f = e.sub(f, m), m = e.add(H, X), U = e.add(M, P), m = e.mul(m, U), U = e.add(R, u), m = e.sub(m, U), G = e.mul(Y, f), U = e.mul(Z, u), G = e.add(U, G), U = e.sub(R, G), G = e.add(R, G), z = e.mul(U, G), R = e.add(q, q), R = e.add(R, q), u = e.mul(Y, u), f = e.mul(Z, f), R = e.add(R, u), u = e.sub(q, u), u = e.mul(Y, u), f = e.add(f, u), q = e.mul(R, f), z = e.add(z, q), q = e.mul(m, f), U = e.mul(l, U), U = e.sub(U, q), q = e.mul(l, R), G = e.mul(m, G), G = e.add(G, q), new y(U, z, G);
    }
    subtract(F) {
      return this.add(F.negate());
    }
    is0() {
      return this.equals(y.ZERO);
    }
    wNAF(F) {
      return N.wNAFCached(this, F, y.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(F) {
      const { endo: k, n: H } = t;
      Nn("scalar", F, Gr, H);
      const X = y.ZERO;
      if (F === Gr)
        return X;
      if (this.is0() || F === Ee)
        return this;
      if (!k || N.hasPrecomputes(this))
        return N.wNAFCachedUnsafe(this, F, y.normalizeZ);
      let { k1neg: D, k1: M, k2neg: P, k2: U } = k.splitScalar(F), z = X, G = X, Y = this;
      for (; M > Gr || U > Gr; )
        M & Ee && (z = z.add(Y)), U & Ee && (G = G.add(Y)), Y = Y.double(), M >>= Ee, U >>= Ee;
      return D && (z = z.negate()), P && (G = G.negate()), G = new y(e.mul(G.px, k.beta), G.py, G.pz), z.add(G);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(F) {
      const { endo: k, n: H } = t;
      Nn("scalar", F, Ee, H);
      let X, D;
      if (k) {
        const { k1neg: M, k1: P, k2neg: U, k2: z } = k.splitScalar(F);
        let { p: G, f: Y } = this.wNAF(P), { p: Z, f: q } = this.wNAF(z);
        G = N.constTimeNegate(M, G), Z = N.constTimeNegate(U, Z), Z = new y(e.mul(Z.px, k.beta), Z.py, Z.pz), X = G.add(Z), D = Y.add(q);
      } else {
        const { p: M, f: P } = this.wNAF(F);
        X = M, D = P;
      }
      return y.normalizeZ([X, D])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(F, k, H) {
      const X = y.BASE, D = (P, U) => U === Gr || U === Ee || !P.equals(X) ? P.multiplyUnsafe(U) : P.multiply(U), M = D(this, k).add(D(F, H));
      return M.is0() ? void 0 : M;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(F) {
      return p(this, F);
    }
    isTorsionFree() {
      const { h: F, isTorsionFree: k } = t;
      if (F === Ee)
        return !0;
      if (k)
        return k(y, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: F, clearCofactor: k } = t;
      return F === Ee ? this : k ? k(y, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(F = !0) {
      return vi("isCompressed", F), this.assertValidity(), s(y, this, F);
    }
    toHex(F = !0) {
      return vi("isCompressed", F), xi(this.toRawBytes(F));
    }
  }
  y.BASE = new y(t.Gx, t.Gy, e.ONE), y.ZERO = new y(e.ZERO, e.ONE, e.ZERO);
  const v = t.nBitLength, N = Vv(y, t.endo ? Math.ceil(v / 2) : v);
  return {
    CURVE: t,
    ProjectivePoint: y,
    normPrivateKeyToScalar: d,
    weierstrassEquation: a,
    isWithinCurveOrder: o
  };
}
function $v(r) {
  const t = Ef(r);
  return ma(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function Kv(r) {
  const t = $v(r), { Fp: e, n } = t, s = e.BYTES + 1, i = 2 * e.BYTES + 1;
  function a(u) {
    return Ue(u, n);
  }
  function o(u) {
    return yd(u, n);
  }
  const { ProjectivePoint: d, normPrivateKeyToScalar: A, weierstrassEquation: p, isWithinCurveOrder: g } = qv({
    ...t,
    toBytes(u, l, f) {
      const m = l.toAffine(), b = e.toBytes(m.x), T = ia;
      return vi("isCompressed", f), f ? T(Uint8Array.from([l.hasEvenY() ? 2 : 3]), b) : T(Uint8Array.from([4]), b, e.toBytes(m.y));
    },
    fromBytes(u) {
      const l = u.length, f = u[0], m = u.subarray(1);
      if (l === s && (f === 2 || f === 3)) {
        const b = Fn(m);
        if (!zo(b, Ee, e.ORDER))
          throw new Error("Point is not on curve");
        const T = p(b);
        let O;
        try {
          O = e.sqrt(T);
        } catch (B) {
          const tt = B instanceof Error ? ": " + B.message : "";
          throw new Error("Point is not on curve" + tt);
        }
        const C = (O & Ee) === Ee;
        return (f & 1) === 1 !== C && (O = e.neg(O)), { x: b, y: O };
      } else if (l === i && f === 4) {
        const b = e.fromBytes(m.subarray(0, e.BYTES)), T = e.fromBytes(m.subarray(e.BYTES, 2 * e.BYTES));
        return { x: b, y: T };
      } else {
        const b = s, T = i;
        throw new Error("invalid Point, expected length of " + b + ", or uncompressed " + T + ", got " + l);
      }
    }
  }), y = (u) => xi(Si(u, t.nByteLength));
  function v(u) {
    const l = n >> Ee;
    return u > l;
  }
  function N(u) {
    return v(u) ? a(-u) : u;
  }
  const E = (u, l, f) => Fn(u.slice(l, f));
  class F {
    constructor(l, f, m) {
      this.r = l, this.s = f, this.recovery = m, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(l) {
      const f = t.nByteLength;
      return l = ur("compactSignature", l, f * 2), new F(E(l, 0, f), E(l, f, 2 * f));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(l) {
      const { r: f, s: m } = Lr.toSig(ur("DER", l));
      return new F(f, m);
    }
    assertValidity() {
      Nn("r", this.r, Ee, n), Nn("s", this.s, Ee, n);
    }
    addRecoveryBit(l) {
      return new F(this.r, this.s, l);
    }
    recoverPublicKey(l) {
      const { r: f, s: m, recovery: b } = this, T = P(ur("msgHash", l));
      if (b == null || ![0, 1, 2, 3].includes(b))
        throw new Error("recovery id invalid");
      const O = b === 2 || b === 3 ? f + t.n : f;
      if (O >= e.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const C = b & 1 ? "03" : "02", _ = d.fromHex(C + y(O)), B = o(O), tt = a(-T * B), et = a(m * B), nt = d.BASE.multiplyAndAddUnsafe(_, tt, et);
      if (!nt)
        throw new Error("point at infinify");
      return nt.assertValidity(), nt;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return v(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new F(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Ri(this.toDERHex());
    }
    toDERHex() {
      return Lr.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Ri(this.toCompactHex());
    }
    toCompactHex() {
      return y(this.r) + y(this.s);
    }
  }
  const k = {
    isValidPrivateKey(u) {
      try {
        return A(u), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: A,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const u = bf(t.n);
      return zv(t.randomBytes(u), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(u = 8, l = d.BASE) {
      return l._setWindowSize(u), l.multiply(BigInt(3)), l;
    }
  };
  function H(u, l = !0) {
    return d.fromPrivateKey(u).toRawBytes(l);
  }
  function X(u) {
    const l = Vn(u), f = typeof u == "string", m = (l || f) && u.length;
    return l ? m === s || m === i : f ? m === 2 * s || m === 2 * i : u instanceof d;
  }
  function D(u, l, f = !0) {
    if (X(u))
      throw new Error("first arg must be private key");
    if (!X(l))
      throw new Error("second arg must be public key");
    return d.fromHex(l).multiply(A(u)).toRawBytes(f);
  }
  const M = t.bits2int || function(u) {
    if (u.length > 8192)
      throw new Error("input is too large");
    const l = Fn(u), f = u.length * 8 - t.nBitLength;
    return f > 0 ? l >> BigInt(f) : l;
  }, P = t.bits2int_modN || function(u) {
    return a(M(u));
  }, U = ou(t.nBitLength);
  function z(u) {
    return Nn("num < 2^" + t.nBitLength, u, Gr, U), Si(u, t.nByteLength);
  }
  function G(u, l, f = Y) {
    if (["recovered", "canonical"].some((ft) => ft in f))
      throw new Error("sign() legacy options not supported");
    const { hash: m, randomBytes: b } = t;
    let { lowS: T, prehash: O, extraEntropy: C } = f;
    T == null && (T = !0), u = ur("msgHash", u), Zh(f), O && (u = ur("prehashed msgHash", m(u)));
    const _ = P(u), B = A(l), tt = [z(B), z(_)];
    if (C != null && C !== !1) {
      const ft = C === !0 ? b(e.BYTES) : C;
      tt.push(ur("extraEntropy", ft));
    }
    const et = ia(...tt), nt = _;
    function Dt(ft) {
      const Bt = M(ft);
      if (!g(Bt))
        return;
      const ar = o(Bt), Rt = d.BASE.multiply(Bt).toAffine(), vt = a(Rt.x);
      if (vt === Gr)
        return;
      const Me = a(ar * a(nt + vt * B));
      if (Me === Gr)
        return;
      let Tt = (Rt.x === vt ? 0 : 2) | Number(Rt.y & Ee), Ot = Me;
      return T && v(Me) && (Ot = N(Me), Tt ^= 1), new F(vt, Ot, Tt);
    }
    return { seed: et, k2sig: Dt };
  }
  const Y = { lowS: t.lowS, prehash: !1 }, Z = { lowS: t.lowS, prehash: !1 };
  function q(u, l, f = Y) {
    const { seed: m, k2sig: b } = G(u, l, f), T = t;
    return gf(T.hash.outputLen, T.nByteLength, T.hmac)(m, b);
  }
  d.BASE._setWindowSize(8);
  function R(u, l, f, m = Z) {
    var Tt;
    const b = u;
    l = ur("msgHash", l), f = ur("publicKey", f);
    const { lowS: T, prehash: O, format: C } = m;
    if (Zh(m), "strict" in m)
      throw new Error("options.strict was renamed to lowS");
    if (C !== void 0 && C !== "compact" && C !== "der")
      throw new Error("format must be compact or der");
    const _ = typeof b == "string" || Vn(b), B = !_ && !C && typeof b == "object" && b !== null && typeof b.r == "bigint" && typeof b.s == "bigint";
    if (!_ && !B)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let tt, et;
    try {
      if (B && (tt = new F(b.r, b.s)), _) {
        try {
          C !== "compact" && (tt = F.fromDER(b));
        } catch (Ot) {
          if (!(Ot instanceof Lr.Err))
            throw Ot;
        }
        !tt && C !== "der" && (tt = F.fromCompact(b));
      }
      et = d.fromHex(f);
    } catch {
      return !1;
    }
    if (!tt || T && tt.hasHighS())
      return !1;
    O && (l = t.hash(l));
    const { r: nt, s: Dt } = tt, ft = P(l), Bt = o(Dt), ar = a(ft * Bt), Rt = a(nt * Bt), vt = (Tt = d.BASE.multiplyAndAddUnsafe(et, ar, Rt)) == null ? void 0 : Tt.toAffine();
    return vt ? a(vt.x) === nt : !1;
  }
  return {
    CURVE: t,
    getPublicKey: H,
    getSharedSecret: D,
    sign: q,
    verify: R,
    ProjectivePoint: d,
    Signature: F,
    utils: k
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function t1(r) {
  return {
    hash: r,
    hmac: (t, ...e) => Fo(r, t, KI(...e)),
    randomBytes: tC
  };
}
function e1(r, t) {
  const e = (n) => Kv({ ...r, ...t1(n) });
  return { ...e(t), create: e };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Bf = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), jh = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), r1 = BigInt(1), bd = BigInt(2), qh = (r, t) => (r + t / bd) / t;
function n1(r) {
  const t = Bf, e = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), a = BigInt(23), o = BigInt(44), d = BigInt(88), A = r * r * r % t, p = A * A * r % t, g = qe(p, e, t) * p % t, y = qe(g, e, t) * p % t, v = qe(y, bd, t) * A % t, N = qe(v, s, t) * v % t, E = qe(N, i, t) * N % t, F = qe(E, o, t) * E % t, k = qe(F, d, t) * F % t, H = qe(k, o, t) * E % t, X = qe(H, e, t) * p % t, D = qe(X, a, t) * N % t, M = qe(D, n, t) * A % t, P = qe(M, bd, t);
  if (!Id.eql(Id.sqr(P), r))
    throw new Error("Cannot find square root");
  return P;
}
const Id = mf(Bf, void 0, void 0, { sqrt: n1 }), jr = e1({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  Fp: Id,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: jh,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const t = jh, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -r1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = e, a = BigInt("0x100000000000000000000000000000000"), o = qh(i * r, t), d = qh(-n * r, t);
      let A = Ue(r - o * e - d * s, t), p = Ue(-o * n - d * i, t);
      const g = A > a, y = p > a;
      if (g && (A = t - A), y && (p = t - p), A > a || p > a)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: g, k1: A, k2neg: y, k2: p };
    }
  }
}, dn);
BigInt(0);
jr.ProjectivePoint;
var Sa = { exports: {} }, $h;
function s1() {
  if ($h) return Sa.exports;
  $h = 1;
  var r = typeof Reflect == "object" ? Reflect : null, t = r && typeof r.apply == "function" ? r.apply : function(M, P, U) {
    return Function.prototype.apply.call(M, P, U);
  }, e;
  r && typeof r.ownKeys == "function" ? e = r.ownKeys : Object.getOwnPropertySymbols ? e = function(M) {
    return Object.getOwnPropertyNames(M).concat(Object.getOwnPropertySymbols(M));
  } : e = function(M) {
    return Object.getOwnPropertyNames(M);
  };
  function n(D) {
    console && console.warn && console.warn(D);
  }
  var s = Number.isNaN || function(M) {
    return M !== M;
  };
  function i() {
    i.init.call(this);
  }
  Sa.exports = i, Sa.exports.once = k, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var a = 10;
  function o(D) {
    if (typeof D != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof D);
  }
  Object.defineProperty(i, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(D) {
      if (typeof D != "number" || D < 0 || s(D))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + D + ".");
      a = D;
    }
  }), i.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(M) {
    if (typeof M != "number" || M < 0 || s(M))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + M + ".");
    return this._maxListeners = M, this;
  };
  function d(D) {
    return D._maxListeners === void 0 ? i.defaultMaxListeners : D._maxListeners;
  }
  i.prototype.getMaxListeners = function() {
    return d(this);
  }, i.prototype.emit = function(M) {
    for (var P = [], U = 1; U < arguments.length; U++) P.push(arguments[U]);
    var z = M === "error", G = this._events;
    if (G !== void 0)
      z = z && G.error === void 0;
    else if (!z)
      return !1;
    if (z) {
      var Y;
      if (P.length > 0 && (Y = P[0]), Y instanceof Error)
        throw Y;
      var Z = new Error("Unhandled error." + (Y ? " (" + Y.message + ")" : ""));
      throw Z.context = Y, Z;
    }
    var q = G[M];
    if (q === void 0)
      return !1;
    if (typeof q == "function")
      t(q, this, P);
    else
      for (var R = q.length, u = N(q, R), U = 0; U < R; ++U)
        t(u[U], this, P);
    return !0;
  };
  function A(D, M, P, U) {
    var z, G, Y;
    if (o(P), G = D._events, G === void 0 ? (G = D._events = /* @__PURE__ */ Object.create(null), D._eventsCount = 0) : (G.newListener !== void 0 && (D.emit(
      "newListener",
      M,
      P.listener ? P.listener : P
    ), G = D._events), Y = G[M]), Y === void 0)
      Y = G[M] = P, ++D._eventsCount;
    else if (typeof Y == "function" ? Y = G[M] = U ? [P, Y] : [Y, P] : U ? Y.unshift(P) : Y.push(P), z = d(D), z > 0 && Y.length > z && !Y.warned) {
      Y.warned = !0;
      var Z = new Error("Possible EventEmitter memory leak detected. " + Y.length + " " + String(M) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Z.name = "MaxListenersExceededWarning", Z.emitter = D, Z.type = M, Z.count = Y.length, n(Z);
    }
    return D;
  }
  i.prototype.addListener = function(M, P) {
    return A(this, M, P, !1);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(M, P) {
    return A(this, M, P, !0);
  };
  function p() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function g(D, M, P) {
    var U = { fired: !1, wrapFn: void 0, target: D, type: M, listener: P }, z = p.bind(U);
    return z.listener = P, U.wrapFn = z, z;
  }
  i.prototype.once = function(M, P) {
    return o(P), this.on(M, g(this, M, P)), this;
  }, i.prototype.prependOnceListener = function(M, P) {
    return o(P), this.prependListener(M, g(this, M, P)), this;
  }, i.prototype.removeListener = function(M, P) {
    var U, z, G, Y, Z;
    if (o(P), z = this._events, z === void 0)
      return this;
    if (U = z[M], U === void 0)
      return this;
    if (U === P || U.listener === P)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete z[M], z.removeListener && this.emit("removeListener", M, U.listener || P));
    else if (typeof U != "function") {
      for (G = -1, Y = U.length - 1; Y >= 0; Y--)
        if (U[Y] === P || U[Y].listener === P) {
          Z = U[Y].listener, G = Y;
          break;
        }
      if (G < 0)
        return this;
      G === 0 ? U.shift() : E(U, G), U.length === 1 && (z[M] = U[0]), z.removeListener !== void 0 && this.emit("removeListener", M, Z || P);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(M) {
    var P, U, z;
    if (U = this._events, U === void 0)
      return this;
    if (U.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : U[M] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete U[M]), this;
    if (arguments.length === 0) {
      var G = Object.keys(U), Y;
      for (z = 0; z < G.length; ++z)
        Y = G[z], Y !== "removeListener" && this.removeAllListeners(Y);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (P = U[M], typeof P == "function")
      this.removeListener(M, P);
    else if (P !== void 0)
      for (z = P.length - 1; z >= 0; z--)
        this.removeListener(M, P[z]);
    return this;
  };
  function y(D, M, P) {
    var U = D._events;
    if (U === void 0)
      return [];
    var z = U[M];
    return z === void 0 ? [] : typeof z == "function" ? P ? [z.listener || z] : [z] : P ? F(z) : N(z, z.length);
  }
  i.prototype.listeners = function(M) {
    return y(this, M, !0);
  }, i.prototype.rawListeners = function(M) {
    return y(this, M, !1);
  }, i.listenerCount = function(D, M) {
    return typeof D.listenerCount == "function" ? D.listenerCount(M) : v.call(D, M);
  }, i.prototype.listenerCount = v;
  function v(D) {
    var M = this._events;
    if (M !== void 0) {
      var P = M[D];
      if (typeof P == "function")
        return 1;
      if (P !== void 0)
        return P.length;
    }
    return 0;
  }
  i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? e(this._events) : [];
  };
  function N(D, M) {
    for (var P = new Array(M), U = 0; U < M; ++U)
      P[U] = D[U];
    return P;
  }
  function E(D, M) {
    for (; M + 1 < D.length; M++)
      D[M] = D[M + 1];
    D.pop();
  }
  function F(D) {
    for (var M = new Array(D.length), P = 0; P < M.length; ++P)
      M[P] = D[P].listener || D[P];
    return M;
  }
  function k(D, M) {
    return new Promise(function(P, U) {
      function z(Y) {
        D.removeListener(M, G), U(Y);
      }
      function G() {
        typeof D.removeListener == "function" && D.removeListener("error", z), P([].slice.call(arguments));
      }
      X(D, M, G, { once: !0 }), M !== "error" && H(D, z, { once: !0 });
    });
  }
  function H(D, M, P) {
    typeof D.on == "function" && X(D, "error", M, P);
  }
  function X(D, M, P, U) {
    if (typeof D.on == "function")
      U.once ? D.once(M, P) : D.on(M, P);
    else if (typeof D.addEventListener == "function")
      D.addEventListener(M, function z(G) {
        U.once && D.removeEventListener(M, z), P(G);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof D);
  }
  return Sa.exports;
}
var vf = s1(), i1 = Object.defineProperty, Re = (r, t) => i1(r, "name", { value: t, configurable: !0 }), a1 = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", Js, o1 = (Js = class {
  constructor(t, e, n, s, i, a = 0) {
    Q(this, "left");
    Q(this, "right");
    Q(this, "parent");
    Q(this, "hash");
    Q(this, "data");
    Q(this, "index");
    this.left = t, this.right = e, this.parent = n, this.hash = s, this.data = i, this.index = a;
  }
}, Re(Js, "Node"), Js), wo = o1;
function cu(r) {
  return gr("0x00".concat(r.slice(2)));
}
Re(cu, "hashLeaf");
function du(r, t) {
  return gr("0x01".concat(r.slice(2)).concat(t.slice(2)));
}
Re(du, "hashNode");
function c1(r) {
  const t = [];
  for (let a = 0; a < r.length; a += 1) {
    const o = cu(r[a]), d = new wo(-1, -1, -1, o, r[a]);
    d.index = a, t.push(d);
  }
  const e = [...t];
  let n = [...t], s = t.length + 1 >> 1, i = t.length & 1;
  for (; ; ) {
    let a = 0;
    for (; a < s - i; a += 1) {
      const o = a << 1, d = du(n[o].hash, n[o + 1].hash);
      t[a] = new wo(n[o].index, n[o + 1].index, -1, d, "");
      const A = e.length;
      t[a].index = A, e[n[o].index].parent = A, e[n[o + 1].index].parent = A, e.push(t[a]);
    }
    if (s === 1)
      break;
    i === 1 && (t[a] = n[a << 1]), i = s & 1, s = s + 1 >> 1, n = [...t];
  }
  return e;
}
Re(c1, "constructTree");
function uu(r) {
  if (!r.length)
    return a1;
  const t = [];
  for (let i = 0; i < r.length; i += 1) {
    const a = cu(r[i]);
    t.push(new wo(-1, -1, -1, a, r[i]));
  }
  let e = t, n = t.length + 1 >> 1, s = t.length & 1;
  for (; ; ) {
    let i = 0;
    for (; i < n - s; i += 1) {
      const a = i << 1, o = du(e[a].hash, e[a + 1].hash);
      t[i] = new wo(e[a].index, e[a + 1].index, -1, o, "");
    }
    if (s === 1 && (t[i] = e[i << 1]), n === 1)
      break;
    s = n & 1, n = n + 1 >> 1, e = t;
  }
  return t[0].hash;
}
Re(uu, "calcRoot");
function d1(r, t) {
  const e = [];
  for (let n = t, s = r[t].parent; s !== -1; n = s, s = r[s].parent)
    r[s].left === n ? e.push(r[r[s].right].hash) : e.push(r[r[s].left].hash);
  return e;
}
Re(d1, "getProof");
var u1 = "0x00", xf = "0x01";
function Rf(r, t) {
  const e = "0x00".concat(r.slice(2)).concat(gr(t).slice(2));
  return [gr(e), e];
}
Re(Rf, "hashLeaf");
function _n(r, t) {
  const e = "0x01".concat(r.slice(2)).concat(t.slice(2));
  return [gr(e), e];
}
Re(_n, "hashNode");
function Ua(r) {
  const t = xf.length;
  return ["0x".concat(r.slice(t, t + 64)), "0x".concat(r.slice(t + 64))];
}
Re(Ua, "parseLeaf");
function Sf(r) {
  const t = xf.length;
  return ["0x".concat(r.slice(t, t + 64)), "0x".concat(r.slice(t + 64))];
}
Re(Sf, "parseNode");
function Ga(r) {
  return r.slice(0, 4) === u1;
}
Re(Ga, "isLeaf");
var js, A1 = (js = class {
  constructor(t, e, n, s, i) {
    Q(this, "SideNodes");
    Q(this, "NonMembershipLeafData");
    Q(this, "BitMask");
    Q(this, "NumSideNodes");
    Q(this, "SiblingData");
    this.SideNodes = t, this.NonMembershipLeafData = e, this.BitMask = n, this.NumSideNodes = s, this.SiblingData = i;
  }
}, Re(js, "SparseCompactMerkleProof"), js), l1 = A1, qs, h1 = (qs = class {
  constructor(t, e, n) {
    Q(this, "SideNodes");
    Q(this, "NonMembershipLeafData");
    Q(this, "SiblingData");
    this.SideNodes = t, this.NonMembershipLeafData = e, this.SiblingData = n;
  }
}, Re(qs, "SparseMerkleProof"), qs), _1 = h1, Xe = "0x0000000000000000000000000000000000000000000000000000000000000000", Pr = 256;
function In(r, t) {
  const e = r.slice(2), n = "0x".concat(
    e.slice(Math.floor(t / 8) * 2, Math.floor(t / 8) * 2 + 2)
  );
  return (Number(n) & 1 << 7 - t % 8) > 0 ? 1 : 0;
}
Re(In, "getBitAtFromMSB");
function Tf(r) {
  let t = 0, e = r.length - 1;
  const n = r;
  for (; t < e; )
    [n[t], n[e]] = [
      n[e],
      n[t]
    ], t += 1, e -= 1;
  return n;
}
Re(Tf, "reverseSideNodes");
function Ff(r, t) {
  let e = 0;
  for (let n = 0; n < Pr && In(r, n) === In(t, n); n += 1)
    e += 1;
  return e;
}
Re(Ff, "countCommonPrefix");
function Nf(r) {
  const t = [], e = [];
  let n;
  for (let i = 0; i < r.SideNodes.length; i += 1)
    n = r.SideNodes[i], n === Xe ? t.push(0) : (e.push(n), t.push(1));
  return new l1(
    e,
    r.NonMembershipLeafData,
    t,
    r.SideNodes.length,
    r.SiblingData
  );
}
Re(Nf, "compactProof");
var $s, p1 = ($s = class {
  constructor() {
    Q(this, "ms");
    Q(this, "root");
    const t = {};
    this.ms = t, this.root = Xe, this.ms[this.root] = Xe;
  }
  get(t) {
    return this.ms[t];
  }
  set(t, e) {
    this.ms[t] = e;
  }
  setRoot(t) {
    this.root = t;
  }
  sideNodesForRoot(t, e) {
    const n = [];
    if (e === Xe)
      return [n, Xe, "", ""];
    let s = this.get(e);
    if (Ga(s))
      return [n, e, s, ""];
    let i, a, o = "", d = "";
    for (let p = 0; p < Pr; p += 1) {
      if ([i, a] = Sf(s), In(t, p) === 1 ? (d = i, o = a) : (d = a, o = i), n.push(d), o === Xe) {
        s = "";
        break;
      }
      if (s = this.get(o), Ga(s))
        break;
    }
    const A = this.get(d);
    return [Tf(n), o, s, A];
  }
  deleteWithSideNodes(t, e, n, s) {
    if (n === Xe)
      return this.root;
    const [i] = Ua(s);
    if (i !== t)
      return this.root;
    let a = "", o = "", d = "", A = "", p = !1;
    for (let g = 0; g < e.length; g += 1)
      if (e[g] !== "") {
        if (d = e[g], o === "")
          if (A = this.get(d), Ga(A)) {
            a = d, o = d;
            continue;
          } else
            o = Xe, p = !0;
        !p && d === Xe || (p || (p = !0), In(t, e.length - 1 - g) === 1 ? [a, o] = _n(d, o) : [a, o] = _n(o, d), this.set(a, o), o = a);
      }
    return a === "" && (a = Xe), a;
  }
  updateWithSideNodes(t, e, n, s, i) {
    let a, o;
    this.set(gr(e), e), [a, o] = Rf(t, e), this.set(a, o), o = a;
    let d;
    if (s === Xe)
      d = Pr;
    else {
      const [A] = Ua(i);
      d = Ff(t, A);
    }
    d !== Pr && (In(t, d) === 1 ? [a, o] = _n(s, o) : [a, o] = _n(o, s), this.set(a, o), o = a);
    for (let A = 0; A < Pr; A += 1) {
      let p;
      const g = Pr - n.length;
      if (A - g < 0 || n[A - g] === "")
        if (d !== Pr && d > Pr - 1 - A)
          p = Xe;
        else
          continue;
      else
        p = n[A - g];
      In(t, Pr - 1 - A) === 1 ? [a, o] = _n(p, o) : [a, o] = _n(o, p), this.set(a, o), o = a;
    }
    return a;
  }
  update(t, e) {
    const [n, s, i] = this.sideNodesForRoot(t, this.root), a = this.updateWithSideNodes(t, e, n, s, i);
    this.setRoot(a);
  }
  delete(t) {
    const [e, n, s] = this.sideNodesForRoot(t, this.root), i = this.deleteWithSideNodes(t, e, n, s);
    this.setRoot(i);
  }
  prove(t) {
    const [e, n, s, i] = this.sideNodesForRoot(t, this.root), a = [];
    for (let A = 0; A < e.length; A += 1)
      e[A] !== "" && a.push(e[A]);
    let o = "";
    if (n !== Xe) {
      const [A] = Ua(s);
      A !== t && (o = s);
    }
    return new _1(a, o, i);
  }
  proveCompacted(t) {
    const e = this.prove(t);
    return Nf(e);
  }
}, Re($s, "SparseMerkleTree"), $s), f1 = Object.defineProperty, S = (r, t) => f1(r, "name", { value: t, configurable: !0 }), at = {
  eth: {
    mainnet: 1,
    sepolia: 11155111,
    foundry: 31337
  },
  fuel: {
    devnet: 0,
    testnet: 0,
    mainnet: 9889
  }
}, g1 = /* @__PURE__ */ S((r) => {
  if (r === "ethereum")
    return at.eth.sepolia;
  if (r === "fuel")
    return at.fuel.testnet;
}, "getDefaultChainId"), w1 = /* @__PURE__ */ S(({
  asset: r,
  chainId: t,
  networkType: e
}) => r.networks.find(
  (s) => s.chainId === t && s.type === e
), "getAssetNetwork"), Qf = /* @__PURE__ */ S(({
  asset: r,
  chainId: t,
  networkType: e
}) => {
  const { networks: n, ...s } = r, i = t ?? g1(e);
  if (i === void 0)
    return;
  const a = w1({
    asset: r,
    chainId: i,
    networkType: e
  });
  if (a)
    return {
      ...s,
      ...a
    };
}, "getAssetWithNetwork"), rS = /* @__PURE__ */ S((r, t) => Qf({
  asset: r,
  networkType: "ethereum",
  chainId: t
}), "getAssetEth"), nS = /* @__PURE__ */ S((r, t) => Qf({
  asset: r,
  networkType: "fuel",
  chainId: t
}), "getAssetFuel"), m1 = "/", y1 = /^\/|\/$/g, b1 = /* @__PURE__ */ S((r = "") => r.replace(y1, ""), "trimPath");
function Df(r, ...t) {
  const e = r != null, n = (r == null ? void 0 : r[0]) === "/" && r.length > 1, s = [r, ...t].filter(Boolean).map(b1);
  return n && e && s.unshift(""), s.join(m1);
}
S(Df, "urlJoin");
function Of(r, t = "./") {
  return r.map((e) => ({
    ...e,
    icon: Df(t, e.icon)
  }));
}
S(Of, "resolveIconPaths");
var I1 = "https://assets.fuel.network/providers/", C1 = [
  {
    name: "Ethereum",
    symbol: "ETH",
    icon: "eth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.sepolia,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: at.eth.foundry,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.devnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      },
      {
        type: "fuel",
        chainId: at.fuel.testnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      }
    ]
  },
  {
    name: "WETH",
    symbol: "WETH",
    icon: "weth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3",
        decimals: 9
      }
    ]
  },
  {
    name: "weETH",
    symbol: "weETH",
    icon: "weETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab",
        decimals: 9
      }
    ]
  },
  {
    name: "rsETH",
    symbol: "rsETH",
    icon: "rsETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849",
        decimals: 9
      }
    ]
  },
  {
    name: "rETH",
    symbol: "rETH",
    icon: "reth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xae78736cd615f374d3085123a210448e74fc6393",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16",
        decimals: 9
      }
    ]
  },
  {
    name: "wbETH",
    symbol: "wbETH",
    icon: "wbeth.png",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xa2E3356610840701BDf5611a53974510Ae27E2e1",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe",
        decimals: 9
      }
    ]
  },
  {
    name: "rstETH",
    symbol: "rstETH",
    icon: "rstETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x7a4EffD87C2f3C55CA251080b1343b605f327E3a",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a",
        decimals: 9
      }
    ]
  },
  {
    name: "amphrETH",
    symbol: "amphrETH",
    icon: "amphrETH.png",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x5fD13359Ba15A84B76f7F87568309040176167cd",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mBTC",
    symbol: "Manta mBTC",
    icon: "manta-mbtc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x4041381e947CFD3D483d67a25C6aa9Dc924250c5",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mETH",
    symbol: "Manta mETH",
    icon: "manta-meth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x8CdF550C04Bc9B9F10938368349C9c8051A772b6",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mUSD",
    symbol: "Manta mUSD",
    icon: "manta-musd.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x3f24E1d7a973867fC2A03fE199E5502514E0e11E",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4",
        decimals: 9
      }
    ]
  },
  {
    name: "pumpBTC",
    symbol: "pumpBTC",
    icon: "pumpbtc.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xf469fbd2abcd6b9de8e169d128226c0fc90a012e",
        decimals: 8
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f",
        decimals: 8
      }
    ]
  },
  {
    name: "FBTC",
    symbol: "FBTC",
    icon: "fbtc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xc96de26018a54d51c097160568752c4e3bd6c364",
        decimals: 8
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a",
        decimals: 8
      }
    ]
  },
  {
    name: "SolvBTC",
    symbol: "SolvBTC",
    icon: "solvBTC.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x7a56e1c57c7475ccf742a1832b028f0456652f97",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f",
        decimals: 9
      }
    ]
  },
  {
    name: "SolvBTC.BBN",
    symbol: "SolvBTC.BBN",
    icon: "SolvBTC.BBN.png",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xd9d920aa40f578ab794426f5c90f6c731d159def",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f",
        decimals: 9
      }
    ]
  },
  {
    name: "Mantle mETH",
    symbol: "Mantle mETH",
    icon: "mantle-meth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b",
        decimals: 9
      }
    ]
  },
  {
    name: "sDAI",
    symbol: "sDAI",
    icon: "sdai.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x83f20f44975d03b1b09e64809b757c47f942beea",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958",
        decimals: 9
      }
    ]
  },
  {
    name: "USDT",
    symbol: "USDT",
    icon: "usdt.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        decimals: 6
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e",
        decimals: 6
      }
    ]
  },
  {
    name: "USDC",
    symbol: "USDC",
    icon: "usdc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        decimals: 6
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b",
        decimals: 6
      }
    ]
  },
  {
    name: "USDe",
    symbol: "USDe",
    icon: "USDe.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x4c9edd5852cd905f086c759e8383e09bff1e68b3",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651",
        decimals: 9
      }
    ]
  },
  {
    name: "sUSDe",
    symbol: "sUSDe",
    icon: "sUSDe.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x9d39a5de30e57443bff2a8307a4256c8797a3497",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc",
        decimals: 9
      }
    ]
  },
  {
    name: "rsUSDe",
    symbol: "rsUSDe",
    icon: "rsUSDe.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9",
        decimals: 9
      }
    ]
  },
  {
    name: "wstETH",
    symbol: "wstETH",
    icon: "wsteth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b",
        decimals: 9
      }
    ]
  },
  {
    name: "ezETH",
    symbol: "ezETH",
    icon: "ezeth.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xbf5495Efe5DB9ce00f80364C8B423567e58d2110",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0",
        decimals: 9
      }
    ]
  },
  {
    name: "pzETH",
    symbol: "pzETH",
    icon: "pzETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68",
        decimals: 9
      }
    ]
  },
  {
    name: "Re7LRT",
    symbol: "Re7LRT",
    icon: "Re7LRT.png",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995",
        decimals: 9
      }
    ]
  },
  {
    name: "steakLRT",
    symbol: "steakLRT",
    icon: "steakLRT.png",
    networks: [
      {
        type: "ethereum",
        chainId: at.eth.mainnet,
        address: "0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: at.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30",
        decimals: 9
      }
    ]
  }
], sS = Of(C1, I1), Mf = {
  mainnet: "https://mainnet-explorer.fuel.network",
  testnet: "https://explorer-indexer-testnet.fuel.network"
}, Pf = /* @__PURE__ */ S(async (r, t) => {
  const e = await fetch(`${r}${t}`, {
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    }
  });
  try {
    return await e.json();
  } catch {
    return null;
  }
}, "request"), E1 = /* @__PURE__ */ S((r) => {
  const t = new URLSearchParams();
  return Object.entries(r).forEach(([e, n]) => {
    t.set(e, n.toString());
  }), t.size > 0 ? `?${t.toString()}` : "";
}, "buildQueryString"), iS = /* @__PURE__ */ S((r) => {
  const { network: t = "mainnet", assetId: e } = r, n = Mf[t];
  return Pf(n, `/assets/${e}`);
}, "getAssetById"), aS = /* @__PURE__ */ S(async (r) => {
  const { network: t = "mainnet", owner: e, pagination: n = { last: 10 } } = r, s = Mf[t], { last: i } = n, a = E1({ last: i }), o = await Pf(s, `/accounts/${e}/assets${a}`);
  return o || { data: [], pageInfo: { count: 0 } };
}, "getAssetsByOwner"), Au = /* @__PURE__ */ S((r) => {
  let t, e, n;
  return Array.isArray(r) ? (e = r[0], t = r[1], n = r[2] ?? void 0) : (e = r.amount, t = r.assetId, n = r.max ?? void 0), {
    assetId: W(t),
    amount: I(e),
    max: n ? I(n) : void 0
  };
}, "coinQuantityfy"), B1 = /* @__PURE__ */ S((r) => {
  const { amount: t, assetId: e } = r, n = [...r.coinQuantities], s = n.findIndex((i) => i.assetId === e);
  return s !== -1 ? n[s].amount = n[s].amount.add(t) : n.push({ assetId: e, amount: t }), n;
}, "addAmountToCoinQuantities"), v1 = $`
    fragment InputCoinFragment on InputCoin {
  type: __typename
  utxoId
  owner
  amount
  assetId
  txPointer
  coinWitnessIndex: witnessIndex
  predicateGasUsed
  predicate
  predicateData
}
    `, x1 = $`
    fragment InputMessageFragment on InputMessage {
  type: __typename
  sender
  recipient
  amount
  nonce
  messageWitnessIndex: witnessIndex
  predicateGasUsed
  data
  predicate
  predicateData
}
    `, R1 = $`
    fragment InputContractFragment on InputContract {
  type: __typename
  utxoId
  balanceRoot
  stateRoot
  txPointer
  contractId
}
    `, S1 = $`
    fragment OutputCoinFragment on CoinOutput {
  type: __typename
  to
  amount
  assetId
}
    `, T1 = $`
    fragment OutputContractFragment on ContractOutput {
  type: __typename
  inputIndex
  balanceRoot
  stateRoot
}
    `, F1 = $`
    fragment OutputChangeFragment on ChangeOutput {
  type: __typename
  to
  amount
  assetId
}
    `, N1 = $`
    fragment OutputVariableFragment on VariableOutput {
  type: __typename
  to
  amount
  assetId
}
    `, Q1 = $`
    fragment OutputContractCreatedFragment on ContractCreated {
  type: __typename
  contract
  stateRoot
}
    `, lu = $`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `, Zn = $`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `, Lf = $`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${Zn}`, kf = $`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${Lf}`, D1 = $`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `, Uf = $`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${Zn}`, Gf = $`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${Uf}`, hu = $`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `, zf = $`
    fragment PreconfirmationSuccessStatusFragment on PreconfirmationSuccessStatus {
  type: __typename
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${Zn}`, Xf = $`
    fragment PreconfirmationFailureStatusFragment on PreconfirmationFailureStatus {
  type: __typename
  reason
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${Zn}`, Hf = $`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
  ... on PreconfirmationSuccessStatus {
    ...PreconfirmationSuccessStatusFragment
  }
  ... on PreconfirmationFailureStatus {
    ...PreconfirmationFailureStatusFragment
  }
}
    ${lu}
${kf}
${D1}
${Gf}
${hu}
${zf}
${Xf}`, O1 = $`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${lu}
${Lf}
${Uf}
${hu}`, Vf = $`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${O1}`, M1 = $`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `, P1 = $`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `, Wf = $`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${P1}`, L1 = $`
    fragment dryRunFailureAssembleTxFragment on DryRunFailureStatus {
  type: __typename
  reason
  receipts {
    ...receiptFragment
  }
}
    ${Zn}`, k1 = $`
    fragment dryRunSuccessAssembleTxFragment on DryRunSuccessStatus {
  type: __typename
  receipts {
    ...receiptFragment
  }
}
    ${Zn}`, U1 = $`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `, G1 = $`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `, z1 = $`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${U1}
${G1}`, X1 = $`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${z1}
${Zn}`, Xo = $`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `, _u = $`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `, H1 = $`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `, Yf = $`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `, V1 = $`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${Yf}`, W1 = $`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `, Y1 = $`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `, Z1 = $`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `, J1 = $`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `, j1 = $`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `, q1 = $`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `, $1 = $`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `, K1 = $`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${$1}`, tx = $`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${Y1}
${Z1}
${J1}
${j1}
${q1}
${K1}`, Zf = $`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
  latestBlock {
    header {
      consensusParametersVersion
    }
  }
}
    ${tx}`, ex = $`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `, Mi = $`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `, Jf = $`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
  indexation {
    balances
    coinsToSpend
    assetMetadata
  }
}
    `, rx = $`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `, nx = $`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `, sx = $`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${Jf}`, ix = $`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${Zf}`, ax = $`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${Zf}
${Jf}`, ox = $`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${Vf}`, cx = $`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
      ... on PreconfirmationSuccessStatus {
        ...PreconfirmationSuccessStatusFragment
      }
      ... on PreconfirmationFailureStatus {
        ...PreconfirmationFailureStatusFragment
      }
    }
  }
}
    ${lu}
${kf}
${Gf}
${hu}
${zf}
${Xf}`, dx = $`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${Mi}`, ux = $`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${Mi}
${Vf}`, Ax = $`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${Wf}`, lx = $`
    query estimatePredicatesAndGasPrice($encodedTransaction: HexString!, $blockHorizon: U32!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    ${Wf}`, hx = $`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${Xo}`, _x = $`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `, px = $`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${Xo}`, fx = $`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${Xo}
${M1}`, gx = $`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${Mi}
${Xo}`, wx = $`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${_u}`, mx = $`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${Mi}
${_u}`, yx = $`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${_u}
${H1}`, bx = $`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `, Ix = $`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ex}`, Cx = $`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `, Ex = $`
    query getBalanceV2($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amountU128
  }
}
    `, Bx = $`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `, vx = $`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `, xx = $`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    `, Rx = $`
    query getBalancesV2($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int, $supportsPagination: Boolean!) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo @include(if: $supportsPagination) {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amountU128
      }
    }
  }
}
    ${Mi}`, Sx = $`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${Mi}
${V1}`, Tx = $`
    query daCompressedBlock($height: U32!) {
  daCompressedBlock(height: $height) {
    bytes
  }
}
    `, Fx = $`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${W1}`, Nx = $`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `, Qx = $`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${rx}`, Dx = $`
    query getAssetDetails($assetId: AssetId!) {
  assetDetails(id: $assetId) {
    subId
    contractId
    totalSupply
  }
}
    `, Ox = $`
    query assembleTx($tx: HexString!, $blockHorizon: U32!, $requiredBalances: [RequiredBalance!]!, $feeAddressIndex: U16!, $excludeInput: ExcludeInput, $estimatePredicates: Boolean, $reserveGas: U64) {
  assembleTx(
    tx: $tx
    blockHorizon: $blockHorizon
    requiredBalances: $requiredBalances
    feeAddressIndex: $feeAddressIndex
    excludeInput: $excludeInput
    estimatePredicates: $estimatePredicates
    reserveGas: $reserveGas
  ) {
    transaction {
      id
      inputs {
        ... on InputCoin {
          ...InputCoinFragment
        }
        ... on InputContract {
          ...InputContractFragment
        }
        ... on InputMessage {
          ...InputMessageFragment
        }
      }
      outputs {
        ... on CoinOutput {
          ...OutputCoinFragment
        }
        ... on ContractOutput {
          ...OutputContractFragment
        }
        ... on ChangeOutput {
          ...OutputChangeFragment
        }
        ... on VariableOutput {
          ...OutputVariableFragment
        }
        ... on ContractCreated {
          ...OutputContractCreatedFragment
        }
      }
      policies {
        tip
        witnessLimit
        maturity
        maxFee
      }
      witnesses
      scriptGasLimit
    }
    status {
      ... on DryRunFailureStatus {
        ...dryRunFailureAssembleTxFragment
      }
      ... on DryRunSuccessStatus {
        ...dryRunSuccessAssembleTxFragment
      }
    }
    gasPrice
  }
}
    ${v1}
${R1}
${x1}
${S1}
${T1}
${F1}
${N1}
${Q1}
${L1}
${k1}`, Mx = $`
    query dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${X1}`, Px = $`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `, Lx = $`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `, kx = $`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${Yf}`, Ux = $`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `, Gx = $`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `, zx = $`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!, $estimatePredicates: Boolean, $includePreConfirmation: Boolean) {
  submitAndAwaitStatus(
    tx: $encodedTransaction
    estimatePredicates: $estimatePredicates
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${Hf}`, Xx = $`
    subscription statusChange($transactionId: TransactionId!, $includePreConfirmation: Boolean) {
  statusChange(
    id: $transactionId
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${Hf}`;
function jf(r) {
  return {
    getVersion(t, e) {
      return r(nx, t, e);
    },
    getNodeInfo(t, e) {
      return r(sx, t, e);
    },
    getChain(t, e) {
      return r(ix, t, e);
    },
    getChainAndNodeInfo(t, e) {
      return r(ax, t, e);
    },
    getTransaction(t, e) {
      return r(ox, t, e);
    },
    getTransactionWithReceipts(t, e) {
      return r(cx, t, e);
    },
    getTransactions(t, e) {
      return r(dx, t, e);
    },
    getTransactionsByOwner(t, e) {
      return r(ux, t, e);
    },
    estimatePredicates(t, e) {
      return r(Ax, t, e);
    },
    estimatePredicatesAndGasPrice(t, e) {
      return r(lx, t, e);
    },
    getLatestBlock(t, e) {
      return r(hx, t, e);
    },
    getLatestBlockHeight(t, e) {
      return r(_x, t, e);
    },
    getBlock(t, e) {
      return r(px, t, e);
    },
    getBlockWithTransactions(t, e) {
      return r(fx, t, e);
    },
    getBlocks(t, e) {
      return r(gx, t, e);
    },
    getCoin(t, e) {
      return r(wx, t, e);
    },
    getCoins(t, e) {
      return r(mx, t, e);
    },
    getCoinsToSpend(t, e) {
      return r(yx, t, e);
    },
    getContract(t, e) {
      return r(bx, t, e);
    },
    getContractBalance(t, e) {
      return r(Ix, t, e);
    },
    getBalance(t, e) {
      return r(Cx, t, e);
    },
    getBalanceV2(t, e) {
      return r(Ex, t, e);
    },
    getLatestGasPrice(t, e) {
      return r(Bx, t, e);
    },
    estimateGasPrice(t, e) {
      return r(vx, t, e);
    },
    getBalances(t, e) {
      return r(xx, t, e);
    },
    getBalancesV2(t, e) {
      return r(Rx, t, e);
    },
    getMessages(t, e) {
      return r(Sx, t, e);
    },
    daCompressedBlock(t, e) {
      return r(Tx, t, e);
    },
    getMessageProof(t, e) {
      return r(Fx, t, e);
    },
    getMessageStatus(t, e) {
      return r(Nx, t, e);
    },
    getRelayedTransactionStatus(t, e) {
      return r(Qx, t, e);
    },
    getAssetDetails(t, e) {
      return r(Dx, t, e);
    },
    assembleTx(t, e) {
      return r(Ox, t, e);
    },
    dryRun(t, e) {
      return r(Mx, t, e);
    },
    submit(t, e) {
      return r(Px, t, e);
    },
    produceBlocks(t, e) {
      return r(Lx, t, e);
    },
    getMessageByNonce(t, e) {
      return r(kx, t, e);
    },
    isUserAccount(t, e) {
      return r(Ux, t, e);
    },
    getConsensusParametersVersion(t, e) {
      return r(Gx, t, e);
    },
    submitAndAwaitStatus(t, e) {
      return r(zx, t, e);
    },
    statusChange(t, e) {
      return r(Xx, t, e);
    }
  };
}
S(jf, "getSdk");
var Kh = /* @__PURE__ */ S((r) => {
  const t = {};
  return "bytes" in r ? t.predicate = {
    predicate: W(r.bytes),
    predicateAddress: r.address.toB256(),
    predicateData: W(r.getPredicateData())
  } : t.address = r.address.toB256(), t;
}, "resolveAccountForAssembleTxParams"), is = /* @__PURE__ */ S(async (r) => {
  const { gasPrice: t, transactionRequest: e, setGasLimit: n, setMaxFee: s, provider: i } = r, a = Ge(n), o = Ge(s), d = e.type === Ct.Script;
  if (a && d) {
    const A = e.gasLimit;
    if (I(n).lt(I(A)))
      throw new x(
        L.GAS_LIMIT_TOO_LOW,
        `Gas limit '${n}' is lower than the required: '${A}'.`
      );
    e.gasLimit = I(n);
  }
  if (o) {
    const A = e.maxFee;
    if (I(s).lt(A))
      throw new x(
        L.MAX_FEE_TOO_LOW,
        `Max fee '${s}' is lower than the required: '${A}'.`
      );
    e.maxFee = I(s);
  }
  if (a && !o) {
    const { maxFee: A } = await i.estimateTxGasAndFee({
      transactionRequest: e,
      gasPrice: t
    });
    e.maxFee = A;
  }
  return e;
}, "setAndValidateGasAndFeeForAssembledTx"), Zc = /[0-9a-fA-F]{32,64}/g, mr = {
  RPC_CONSISTENCY: /The required fuel block height is higher than the current block height. Required: \d+, Current: \d+/,
  INSUFFICIENT_FUNDS: /the target cannot be met due to insufficient coins available for [0-9a-fA-F]{32,64}. Collected: \d+/,
  MAX_COINS_REACHED: /the target for [0-9a-fA-F]{32,64} cannot be met due to exceeding the \d+ coin limit. Collected: \d+./,
  ASSET_NOT_FOUND: /resource was not found in table/,
  MULTIPLE_CHANGE_POLICIES: /The asset ([a-fA-F0-9]{64}) has multiple change policies/,
  DUPLICATE_CHANGE_OUTPUT_ACCOUNT: /required balances contain duplicate \(asset, account\) pair/,
  INSUFFICIENT_FEE_AMOUNT: /InsufficientFeeAmount { expected: (\d+), provided: (\d+) }/
}, Hx = /* @__PURE__ */ S((r) => {
  if (mr.INSUFFICIENT_FUNDS.test(r.message) || mr.MAX_COINS_REACHED.test(r.message)) {
    const t = r.message.match(Zc), e = t ? `0x${t[0]}` : null, n = e ? `
For the following asset ID: '${e}'.` : "";
    return new x(
      L.INSUFFICIENT_FUNDS_OR_MAX_COINS,
      `Insufficient funds or too many small value coins. Consider combining UTXOs.${n}`,
      { assetId: e },
      r
    );
  }
  if (mr.MAX_COINS_REACHED.test(r.message)) {
    const t = r.message.match(Zc), e = t ? `0x${t[0]}` : null, n = t ? `0x${t[1]}` : null;
    let s = "";
    return e && (s += `
	Asset ID: '${e}'.`), n && (s += `
	Owner: '${n}'.`), new x(
      L.MAX_COINS_REACHED,
      `You have too many small value coins - consider combining UTXOs.${s}`,
      { assetId: e, owner: n },
      r
    );
  }
  if (mr.INSUFFICIENT_FUNDS.test(r.message)) {
    const t = r.message.match(Zc), e = t ? `0x${t[0]}` : null, n = t ? `0x${t[1]}` : null;
    let s = "";
    return e && (s += `
	Asset ID: '${e}'.`), n && (s += `
	Owner: '${n}'.`), new x(
      L.INSUFFICIENT_FUNDS,
      `Insufficient funds.${s}`,
      { assetId: e, owner: n },
      r
    );
  }
  if (mr.MULTIPLE_CHANGE_POLICIES.test(r.message)) {
    const t = r.message.match(/asset ([a-fA-F0-9]{64})/), e = (t == null ? void 0 : t[1]) || "";
    return new x(
      L.CHANGE_OUTPUT_COLLISION,
      `OutputChange address for asset 0x${e} differs between transaction request and assembleTx parameters.`,
      {},
      r
    );
  }
  if (mr.DUPLICATE_CHANGE_OUTPUT_ACCOUNT.test(r.message))
    return new x(
      L.DUPLICATE_CHANGE_OUTPUT_ACCOUNT,
      "The parameter 'accountCoinQuantities' of assembleTx contains duplicate entries for the same assetId with different 'changeOutputAccount'.",
      {},
      r
    );
  if (mr.ASSET_NOT_FOUND.test(r.message))
    return new x(
      L.ASSET_NOT_FOUND,
      "Asset not found for given asset id.",
      {},
      r
    );
  if (mr.RPC_CONSISTENCY.test(r.message))
    return new x(L.RPC_CONSISTENCY, r.message, {}, r);
  if (mr.INSUFFICIENT_FEE_AMOUNT.test(r.message)) {
    const t = r.message.match(mr.INSUFFICIENT_FEE_AMOUNT);
    return new x(L.FUNDS_TOO_LOW, (t == null ? void 0 : t[0]) || r.message, {}, r);
  }
  return new x(L.INVALID_REQUEST, r.message, {}, r);
}, "mapGqlErrorMessage"), t_ = /* @__PURE__ */ S((r, t) => t ? new x(
  r.code,
  `${r.message}

${t}`,
  r.metadata,
  r.rawError
) : r, "mapGqlErrorWithIncompatibleNodeVersion"), qf = /* @__PURE__ */ S((r, t = !1) => {
  if (!Array.isArray(r))
    return;
  const e = r.map(Hx);
  if (e.length === 1)
    throw t_(e[0], t);
  const n = e.map((s) => s.message).join(`
`);
  throw t_(
    new x(L.INVALID_REQUEST, n, {}, e),
    t
  );
}, "assertGqlResponseHasNoErrors"), Ye, Cd = (Ye = class {
  constructor(t, e) {
    Q(this, "events", []);
    Q(this, "parsingLeftover", "");
    this.stream = t, this.onEvent = e;
  }
  static async create(t) {
    const { url: e, query: n, variables: s, fetchFn: i, operationName: a, onEvent: o } = t, d = await i(`${e}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: df(n),
        variables: s,
        operationName: a
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    }), [A, p] = d.body.tee().map((g) => g.getReader());
    return await new Ye(A).next(), new Ye(p, o);
  }
  /**
   * This method will take a stream reader and parse the event from the stream.
   *
   * @param reader - The reader of the SSE stream
   * @param parsingLeftover - The leftover string from parsing the previous event
   * @returns The event parsed as a full GraphQL response, whether the stream is done and the leftover string after parsing
   */
  static async readEvent(t, e = "") {
    let n = e;
    const s = /data:.*\n\n/g;
    for (; ; ) {
      const i = [...n.matchAll(s)].flatMap((A) => A);
      if (i.length > 0)
        try {
          return {
            event: JSON.parse(i[0].replace(/^data:/, "")),
            done: !1,
            parsingLeftover: n.replace(i[0], "")
          };
        } catch {
          throw new x(
            L.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${n}`
          );
        }
      const { value: a, done: o } = await t.read();
      if (o)
        return { event: void 0, done: o, parsingLeftover: "" };
      const d = Ye.textDecoder.decode(a).replace(`:keep-alive-text

`, "");
      n += d;
    }
  }
  /**
   * Gets automatically called when iterating in a `for-await-of` loop.
   * It can also be called manually.
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next
   */
  async next() {
    var t;
    for (; ; ) {
      const e = this.events.shift();
      if (e)
        return (t = this.onEvent) == null || t.call(this, e), qf(
          e.errors,
          Ye.incompatibleNodeVersionMessage
        ), { value: e.data, done: !1 };
      const { event: n, done: s, parsingLeftover: i } = await Ye.readEvent(
        this.stream,
        this.parsingLeftover
      );
      if (this.parsingLeftover = i, s)
        return { value: void 0, done: !0 };
      this.events.push(n);
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  return() {
    return Promise.resolve({ done: !0, value: void 0 });
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}, S(Ye, "FuelGraphqlSubscriber"), Q(Ye, "incompatibleNodeVersionMessage", !1), Q(Ye, "textDecoder", new TextDecoder()), Ye), Vx = /* @__PURE__ */ S((r) => {
  const { type: t } = r;
  switch (r.type) {
    case xt.Coin: {
      const e = j(r.predicate ?? "0x"), n = j(r.predicateData ?? "0x");
      return {
        type: xt.Coin,
        txID: W(j(r.id).slice(0, Xr)),
        outputIndex: Ur(j(r.id).slice(Xr, lo)),
        owner: W(r.owner),
        amount: I(r.amount),
        assetId: W(r.assetId),
        txPointer: {
          blockHeight: Ur(j(r.txPointer).slice(0, 8)),
          txIndex: Ur(j(r.txPointer).slice(8, 16))
        },
        witnessIndex: r.witnessIndex,
        predicateGasUsed: I(r.predicateGasUsed),
        predicateLength: I(e.length),
        predicateDataLength: I(n.length),
        predicate: W(e),
        predicateData: W(n)
      };
    }
    case xt.Contract:
      return {
        type: xt.Contract,
        txID: W(r.txID || St),
        outputIndex: 0,
        balanceRoot: St,
        stateRoot: St,
        txPointer: {
          blockHeight: Ur(j(r.txPointer).slice(0, 8)),
          txIndex: Ur(j(r.txPointer).slice(8, 16))
        },
        contractID: W(r.contractId)
      };
    case xt.Message: {
      const e = j(r.predicate ?? "0x"), n = j(r.predicateData ?? "0x"), s = j(r.data ?? "0x");
      return {
        type: xt.Message,
        sender: W(r.sender),
        recipient: W(r.recipient),
        amount: I(r.amount),
        nonce: W(r.nonce),
        witnessIndex: r.witnessIndex,
        predicateGasUsed: I(r.predicateGasUsed),
        predicateLength: I(e.length),
        predicateDataLength: I(n.length),
        predicate: W(e),
        predicateData: W(n),
        data: W(s),
        dataLength: s.length
      };
    }
    default:
      throw new x(
        L.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${t}.`
      );
  }
}, "inputify"), Wx = /* @__PURE__ */ S((r) => {
  const { type: t } = r;
  switch (t) {
    case lt.Coin:
      return {
        type: lt.Coin,
        to: W(r.to),
        amount: I(r.amount),
        assetId: W(r.assetId)
      };
    case lt.Contract:
      return {
        type: lt.Contract,
        inputIndex: r.inputIndex,
        balanceRoot: St,
        stateRoot: St
      };
    case lt.Change:
      return {
        type: lt.Change,
        to: W(r.to),
        amount: I(0),
        assetId: W(r.assetId)
      };
    case lt.Variable:
      return {
        type: lt.Variable,
        to: W(r.to || St),
        amount: I(r.amount),
        assetId: W(r.assetId || St)
      };
    case lt.ContractCreated:
      return {
        type: lt.ContractCreated,
        contractId: W(r.contractId),
        stateRoot: W(r.stateRoot)
      };
    default:
      throw new x(
        L.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${t}.`
      );
  }
}, "outputify"), e_ = /* @__PURE__ */ S((r) => !("data" in r), "isMessageCoin"), oS = /* @__PURE__ */ S((r) => "utxoId" in r, "isRawCoin"), cS = /* @__PURE__ */ S((r) => "recipient" in r, "isRawMessage"), Yx = /* @__PURE__ */ S((r) => "id" in r, "isCoin"), dS = /* @__PURE__ */ S((r) => "recipient" in r, "isMessage"), Ed = /* @__PURE__ */ S((r) => {
  const { name: t, daHeight: e, consensusParameters: n, latestBlock: s } = r, {
    contractParams: i,
    feeParams: a,
    predicateParams: o,
    scriptParams: d,
    txParams: A,
    gasCosts: p,
    baseAssetId: g,
    chainId: y,
    version: v
  } = n;
  return {
    name: t,
    baseChainHeight: I(e),
    consensusParameters: {
      version: v,
      chainId: I(y),
      baseAssetId: g,
      feeParameters: {
        version: a.version,
        gasPerByte: I(a.gasPerByte),
        gasPriceFactor: I(a.gasPriceFactor)
      },
      contractParameters: {
        version: i.version,
        contractMaxSize: I(i.contractMaxSize),
        maxStorageSlots: I(i.maxStorageSlots)
      },
      txParameters: {
        version: A.version,
        maxInputs: I(A.maxInputs),
        maxOutputs: I(A.maxOutputs),
        maxWitnesses: I(A.maxWitnesses),
        maxGasPerTx: I(A.maxGasPerTx),
        maxSize: I(A.maxSize),
        maxBytecodeSubsections: I(A.maxBytecodeSubsections)
      },
      predicateParameters: {
        version: o.version,
        maxPredicateLength: I(o.maxPredicateLength),
        maxPredicateDataLength: I(o.maxPredicateDataLength),
        maxGasPerPredicate: I(o.maxGasPerPredicate),
        maxMessageDataLength: I(o.maxMessageDataLength)
      },
      scriptParameters: {
        version: d.version,
        maxScriptLength: I(d.maxScriptLength),
        maxScriptDataLength: I(d.maxScriptDataLength)
      },
      gasCosts: p
    },
    latestBlock: s
  };
}, "deserializeChain"), Zx = /* @__PURE__ */ S((r) => {
  const { name: t, baseChainHeight: e, consensusParameters: n, latestBlock: s } = r, {
    contractParameters: i,
    feeParameters: a,
    predicateParameters: o,
    scriptParameters: d,
    txParameters: A,
    gasCosts: p,
    baseAssetId: g,
    chainId: y,
    version: v
  } = n;
  return {
    name: t,
    daHeight: e.toString(),
    consensusParameters: {
      version: v,
      chainId: y.toString(),
      baseAssetId: g,
      feeParams: {
        version: a.version,
        gasPerByte: a.gasPerByte.toString(),
        gasPriceFactor: a.gasPriceFactor.toString()
      },
      contractParams: {
        version: i.version,
        contractMaxSize: i.contractMaxSize.toString(),
        maxStorageSlots: i.maxStorageSlots.toString()
      },
      txParams: {
        version: A.version,
        maxInputs: A.maxInputs.toString(),
        maxOutputs: A.maxOutputs.toString(),
        maxWitnesses: A.maxWitnesses.toString(),
        maxGasPerTx: A.maxGasPerTx.toString(),
        maxSize: A.maxSize.toString(),
        maxBytecodeSubsections: A.maxBytecodeSubsections.toString()
      },
      predicateParams: {
        version: o.version,
        maxPredicateLength: o.maxPredicateLength.toString(),
        maxPredicateDataLength: o.maxPredicateDataLength.toString(),
        maxGasPerPredicate: o.maxGasPerPredicate.toString(),
        maxMessageDataLength: o.maxMessageDataLength.toString()
      },
      scriptParams: {
        version: d.version,
        maxScriptLength: d.maxScriptLength.toString(),
        maxScriptDataLength: d.maxScriptDataLength.toString()
      },
      gasCosts: p
    },
    latestBlock: s
  };
}, "serializeChain"), Bd = /* @__PURE__ */ S((r) => {
  const { maxDepth: t, maxTx: e, nodeVersion: n, utxoValidation: s, vmBacktrace: i, indexation: a } = r;
  return {
    maxDepth: I(t),
    maxTx: I(e),
    nodeVersion: n,
    utxoValidation: s,
    vmBacktrace: i,
    indexation: a
  };
}, "deserializeNodeInfo"), Jx = /* @__PURE__ */ S((r) => {
  const { maxDepth: t, maxTx: e, nodeVersion: n, utxoValidation: s, vmBacktrace: i, indexation: a } = r;
  return {
    maxDepth: t.toString(),
    maxTx: e.toString(),
    nodeVersion: n,
    utxoValidation: s,
    vmBacktrace: i,
    indexation: a
  };
}, "serializeNodeInfo"), jx = /* @__PURE__ */ S((r) => ({
  consensusParametersTimestamp: r.consensusParametersTimestamp,
  chain: Ed(r.chain),
  nodeInfo: Bd(r.nodeInfo)
}), "deserializeProviderCache"), $f = /* @__PURE__ */ S(async (r) => ({
  consensusParametersTimestamp: r.consensusParametersTimestamp,
  chain: Zx(await r.getChain()),
  nodeInfo: Jx(await r.getNode())
}), "serializeProviderCache"), Qt = /* @__PURE__ */ S((r) => r || St, "hexOrZero"), Se = /* @__PURE__ */ S((r) => {
  const { receiptType: t } = r;
  switch (t) {
    case "CALL": {
      const e = Qt(r.id || r.contractId);
      return {
        type: At.Call,
        id: e,
        to: Qt(r == null ? void 0 : r.to),
        amount: I(r.amount),
        assetId: Qt(r.assetId),
        gas: I(r.gas),
        param1: I(r.param1),
        param2: I(r.param2),
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    case "RETURN":
      return {
        type: At.Return,
        id: Qt(r.id || r.contractId),
        val: I(r.val),
        pc: I(r.pc),
        is: I(r.is)
      };
    case "RETURN_DATA":
      return {
        type: At.ReturnData,
        id: Qt(r.id || r.contractId),
        ptr: I(r.ptr),
        len: I(r.len),
        digest: Qt(r.digest),
        pc: I(r.pc),
        data: Qt(r.data),
        is: I(r.is)
      };
    case "PANIC":
      return {
        type: At.Panic,
        id: Qt(r.id),
        reason: I(r.reason),
        pc: I(r.pc),
        is: I(r.is),
        contractId: Qt(r.contractId)
      };
    case "REVERT":
      return {
        type: At.Revert,
        id: Qt(r.id || r.contractId),
        val: I(r.ra),
        pc: I(r.pc),
        is: I(r.is)
      };
    case "LOG": {
      const e = I(r.ra), n = I(r.rb), s = I(r.rc), i = I(r.rd);
      return {
        type: At.Log,
        id: Qt(r.id || r.contractId),
        ra: e,
        rb: n,
        rc: s,
        rd: i,
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    case "LOG_DATA": {
      const e = I(r.ra), n = I(r.rb);
      return {
        type: At.LogData,
        id: Qt(r.id || r.contractId),
        ra: e,
        rb: n,
        ptr: I(r.ptr),
        len: I(r.len),
        digest: Qt(r.digest),
        pc: I(r.pc),
        data: Qt(r.data),
        is: I(r.is)
      };
    }
    case "TRANSFER": {
      const e = Qt(r.id || r.contractId);
      return {
        type: At.Transfer,
        id: e,
        to: Qt(r.toAddress || (r == null ? void 0 : r.to)),
        amount: I(r.amount),
        assetId: Qt(r.assetId),
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    case "TRANSFER_OUT": {
      const e = Qt(r.id || r.contractId);
      return {
        type: At.TransferOut,
        id: e,
        to: Qt(r.toAddress || r.to),
        amount: I(r.amount),
        assetId: Qt(r.assetId),
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    case "SCRIPT_RESULT":
      return {
        type: At.ScriptResult,
        result: I(r.result),
        gasUsed: I(r.gasUsed)
      };
    case "MESSAGE_OUT": {
      const e = Qt(r.sender), n = Qt(r.recipient), s = Qt(r.nonce), i = I(r.amount), a = r.data ? j(r.data) : Uint8Array.from([]), o = Qt(r.digest), d = I(r.len).toNumber(), A = bn.getMessageId({
        sender: e,
        recipient: n,
        nonce: s,
        amount: i,
        data: W(a)
      });
      return {
        type: At.MessageOut,
        sender: e,
        recipient: n,
        amount: i,
        nonce: s,
        len: d,
        data: a,
        digest: o,
        messageId: A
      };
    }
    case "MINT": {
      const e = Qt(r.id || r.contractId), n = Qt(r.subId), s = hd(e, n);
      return {
        type: At.Mint,
        subId: n,
        contractId: e,
        assetId: s,
        val: I(r.val),
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    case "BURN": {
      const e = Qt(r.id || r.contractId), n = Qt(r.subId), s = hd(e, n);
      return {
        type: At.Burn,
        subId: n,
        contractId: e,
        assetId: s,
        val: I(r.val),
        pc: I(r.pc),
        is: I(r.is)
      };
    }
    default:
      throw new x(L.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${t}.`);
  }
}, "deserializeReceipt"), qx = /* @__PURE__ */ S((r) => {
  let t;
  switch (r.type) {
    case "InputCoin":
      t = {
        type: xt.Coin,
        id: r.utxoId,
        amount: I(r.amount),
        assetId: r.assetId,
        owner: r.owner,
        txPointer: `0x${r.txPointer}`,
        witnessIndex: Number(r.coinWitnessIndex),
        predicate: r.predicate,
        predicateData: r.predicateData,
        predicateGasUsed: I(r.predicateGasUsed)
      };
      break;
    case "InputMessage":
      t = {
        type: xt.Message,
        nonce: r.nonce,
        amount: I(r.amount),
        recipient: r.recipient,
        sender: r.sender,
        data: r.data,
        witnessIndex: Number(r.messageWitnessIndex),
        predicate: r.predicate,
        predicateData: r.predicateData,
        predicateGasUsed: I(r.predicateGasUsed)
      };
      break;
    case "InputContract":
      t = {
        type: xt.Contract,
        contractId: r.contractId,
        txPointer: `0x${r.txPointer}`,
        txID: W(j(r.utxoId).slice(0, 32))
      };
      break;
    default:
      So();
  }
  return t;
}, "deserializeInput"), $x = /* @__PURE__ */ S((r) => {
  let t;
  switch (r.type) {
    case "CoinOutput":
      t = {
        type: lt.Coin,
        amount: I(r.amount),
        assetId: r.assetId,
        to: r.to
      };
      break;
    case "ContractOutput":
      t = {
        type: lt.Contract,
        inputIndex: Number(r.inputIndex)
      };
      break;
    case "ChangeOutput":
      t = {
        type: lt.Change,
        assetId: r.assetId,
        to: r.to
      };
      break;
    case "ContractCreated":
      t = {
        type: lt.ContractCreated,
        stateRoot: r.stateRoot,
        contractId: r.contract
      };
      break;
    case "VariableOutput":
      t = {
        type: lt.Variable,
        amount: I(r.amount),
        assetId: r.assetId,
        to: r.to
      };
      break;
    default:
      So();
  }
  return t;
}, "deserializeOutput"), Kf = /* @__PURE__ */ S((r) => {
  let t;
  switch (r.type) {
    case "CoinOutput":
      t = {
        type: lt.Coin,
        amount: I(r.amount),
        assetId: r.assetId,
        to: r.to
      };
      break;
    case "ContractOutput":
      t = {
        type: lt.Contract,
        inputIndex: Number(r.inputIndex),
        balanceRoot: r.balanceRoot,
        stateRoot: r.stateRoot
      };
      break;
    case "ChangeOutput":
      t = {
        type: lt.Change,
        assetId: r.assetId,
        to: r.to,
        amount: I(r.amount)
      };
      break;
    case "ContractCreated":
      t = {
        type: lt.ContractCreated,
        stateRoot: r.stateRoot,
        contractId: r.contract
      };
      break;
    case "VariableOutput":
      t = {
        type: lt.Variable,
        amount: I(r.amount),
        assetId: r.assetId,
        to: r.to
      };
      break;
    default:
      So();
  }
  return t;
}, "deserializeProcessedTxOutput"), Kx = /* @__PURE__ */ S((r) => r.type === At.Revert && r.val.toString("hex") === nu, "doesReceiptHaveMissingOutputVariables"), t2 = /* @__PURE__ */ S((r) => r.type === At.Panic && r.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000", "doesReceiptHaveMissingContractId"), r_ = /* @__PURE__ */ S((r) => r.reduce(
  (t, e) => (Kx(e) && t.missingOutputVariables.push(e), t2(e) && t.missingOutputContractIds.push(e), t),
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
), "getReceiptsWithMissingData"), uS = /* @__PURE__ */ S((r) => Se(r), "assembleReceiptByType"), e2 = "https://app.fuel.network", r2 = /* @__PURE__ */ S((r, t) => `${{
  address: "address",
  txId: "transaction",
  blockNumber: "block"
}[r] || r}/${t}`, "getPathFromInput"), AS = /* @__PURE__ */ S((r = {}) => {
  const { blockExplorerUrl: t, path: e, providerUrl: n, address: s, txId: i, blockNumber: a } = r, o = t || e2, d = [
    {
      key: "address",
      value: s
    },
    {
      key: "txId",
      value: i
    },
    {
      key: "blockNumber",
      value: a
    }
  ], A = d.filter((D) => !!D.value).map(({ key: D, value: M }) => ({
    key: D,
    value: M
  })), p = A.length > 0;
  if (A.length > 1)
    throw new x(
      L.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `Only one of the following can be passed in to buildBlockExplorerUrl: ${d.map((D) => D.key).join(", ")}.`
    );
  if (e && A.length > 0) {
    const D = d.map(({ key: M }) => M).join(", ");
    throw new x(
      L.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${D}.`
    );
  }
  const g = p ? r2(
    A[0].key,
    A[0].value
  ) : "", y = /^\/|\/$/gm, v = e ? e.replace(y, "") : g, N = o.replace(y, ""), E = n == null ? void 0 : n.replace(y, ""), F = E ? encodeURIComponent(E) : void 0, k = N.match(/^https?:\/\//) ? "" : "https://", H = E != null && E.match(/^https?:\/\//) ? "" : "https://";
  return `${k}${N}/${v}${F ? `?providerUrl=${H}${F}` : ""}`;
}, "buildBlockExplorerUrl"), Pi = /* @__PURE__ */ S((r) => r.filter(
  (n) => n.type === At.ScriptResult
).reduce((n, s) => n.add(s.gasUsed), I(0)), "getGasUsedFromReceipts");
function De(r, t) {
  const e = I(t.base);
  let n = I(0);
  return "unitsPerGas" in t ? n = I(r).div(I(t.unitsPerGas)) : n = I(r).mul(I(t.gasPerUnit)), e.add(n);
}
S(De, "resolveGasDependentCosts");
function tg(r, t, e) {
  const n = [], s = r.filter((o) => {
    if ("owner" in o || "sender" in o) {
      if ("predicate" in o && o.predicate && o.predicate !== "0x")
        return !0;
      if (!n.includes(o.witnessIndex))
        return n.push(o.witnessIndex), !0;
    }
    return !1;
  }), i = De(t, e.vmInitialization);
  return s.reduce((o, d) => "predicate" in d && d.predicate && d.predicate !== "0x" ? o.add(
    i.add(De(j(d.predicate).length, e.contractRoot)).add(I(d.predicateGasUsed))
  ) : o.add(e.ecr1), I(0));
}
S(tg, "gasUsedByInputs");
function pu(r) {
  const { gasCosts: t, gasPerByte: e, inputs: n, metadataGas: s, txBytesSize: i } = r, a = De(i, t.vmInitialization), o = I(i).mul(e), d = tg(n, i, t);
  return a.add(o).add(d).add(s).maxU64();
}
S(pu, "getMinGas");
function Ho(r) {
  const {
    gasPerByte: t,
    witnessesLength: e,
    witnessLimit: n,
    minGas: s,
    gasLimit: i = I(0),
    maxGasPerTx: a
  } = r;
  let o = I(0);
  n != null && n.gt(0) && n.gte(e) && (o = I(n).sub(e).mul(t));
  const d = o.add(s).add(i);
  return d.gte(a) ? a : d;
}
S(Ho, "getMaxGas");
function fu({
  gasCosts: r,
  stateRootSize: t,
  txBytesSize: e,
  contractBytesSize: n
}) {
  const s = De(n, r.contractRoot), i = De(t, r.stateRoot), a = De(e, r.s256), o = I(100), d = De(o, r.s256);
  return s.add(i).add(a).add(d).maxU64();
}
S(fu, "calculateMetadataGasForTxCreate");
function gu({
  gasCosts: r,
  txBytesSize: t
}) {
  return De(t, r.s256);
}
S(gu, "calculateMetadataGasForTxScript");
function eg({
  gasCosts: r,
  txBytesSize: t,
  witnessBytesSize: e
}) {
  const n = De(t, r.s256), s = De(e, r.s256);
  return n.add(s);
}
S(eg, "calculateMetadataGasForTxBlob");
function vd({
  gasCosts: r,
  txBytesSize: t,
  consensusSize: e
}) {
  const n = De(t, r.s256);
  if (e) {
    const s = De(e, r.s256);
    n.add(s);
  }
  return n;
}
S(vd, "calculateMetadataGasForTxUpgrade");
function rg({
  gasCosts: r,
  txBytesSize: t,
  subsectionSize: e,
  subsectionsSize: n
}) {
  const s = De(t, r.s256), i = De(e, r.s256);
  s.add(i);
  const a = De(n, r.stateRoot);
  return s.add(a), s;
}
S(rg, "calculateMetadataGasForTxUpload");
function ng({
  gasCosts: r,
  baseMinGas: t,
  subsectionSize: e
}) {
  const n = I(r.newStoragePerByte).mul(e);
  return I(t).add(n);
}
S(ng, "calculateMinGasForTxUpload");
var on = /* @__PURE__ */ S((r) => {
  const { gas: t, gasPrice: e, priceFactor: n, tip: s } = r;
  return t.mul(e).div(n).add(I(s));
}, "calculateGasFee");
function mo(r) {
  return Object.keys(r).forEach((t) => {
    var e;
    switch ((e = r[t]) == null ? void 0 : e.constructor.name) {
      case "Uint8Array":
        r[t] = W(r[t]);
        break;
      case "Array":
        r[t] = mo(r[t]);
        break;
      case "BN":
        r[t] = r[t].toHex();
        break;
      case "Address":
        r[t] = r[t].toB256();
        break;
      case "Object":
        r[t] = mo(r[t]);
        break;
    }
  }), r;
}
S(mo, "normalize");
function sg(r) {
  return mo(ve(r));
}
S(sg, "normalizeJSON");
var n2 = /* @__PURE__ */ S((r, t) => {
  let e = `The transaction reverted with reason: "${r}".`;
  return bv.includes(r) && (e = `${e}

You can read more about this error at:

${Iv}#variant.${r}`), new x(L.SCRIPT_REVERTED, e, {
    ...t,
    reason: r
  });
}, "assemblePanicError"), $n = /* @__PURE__ */ S((r) => JSON.stringify(r, null, 2), "stringify"), s2 = /* @__PURE__ */ S((r, t, e) => {
  let n = "The transaction reverted with an unknown reason.", s = "";
  const i = t[t.length - 1], a = t[t.length - 2];
  switch (r) {
    case lf: {
      s = "require", n = `The transaction reverted because a "require" statement has thrown ${t.length ? $n(i) : "an error."}.`;
      break;
    }
    case hf: {
      const o = t.length >= 2 ? ` comparing ${$n(i)} and ${$n(a)}.` : ".";
      s = "assert_eq", n = `The transaction reverted because of an "assert_eq" statement${o}`;
      break;
    }
    case pf: {
      const o = t.length >= 2 ? ` comparing ${$n(a)} and ${$n(i)}.` : ".";
      s = "assert_ne", n = `The transaction reverted because of an "assert_ne" statement${o}`;
      break;
    }
    case _f:
      s = "assert", n = 'The transaction reverted because an "assert" statement failed to evaluate to true.';
      break;
    case nu:
      s = "MissingOutputVariable", n = `The transaction reverted because it's missing an "OutputVariable".`;
      break;
    default:
      s = "revert_with_log", n = `The transaction reverted because a "revert_with_log" statement has thrown ${t.length ? $n(i) : "an error."}.`;
      break;
  }
  return new x(L.SCRIPT_REVERTED, n, {
    ...e,
    reason: s
  });
}, "assembleSignalErrorMessage");
function ig(r, t, e, n) {
  const { pos: s, msg: i } = r;
  let a = "";
  const o = s ? `

This error originated at ${JSON.stringify(s, null, 2)}` : "";
  if (i)
    a = `A sway "panic" expression was invoked with the message: "${i}".${o}`;
  else {
    const d = t[t.length - 1];
    a = `A sway "panic" expression was invoked with the value: ${JSON.stringify(d)}.${o}`;
  }
  return new x(L.SCRIPT_REVERTED, a, {
    ...e,
    abiError: r,
    reason: n
  });
}
S(ig, "buildAbiErrorMessage");
function ag(r, t = []) {
  var e;
  for (const n of t)
    if ((e = n.errorCodes) != null && e[r])
      return n.errorCodes[r];
}
S(ag, "findErrorInAbis");
var i2 = /* @__PURE__ */ S((r, t, e, n, s) => {
  const i = n.match(/Revert\((\d+)\)/), a = (i == null ? void 0 : i[1]) ?? n, o = I(a).toHex();
  if (Object.values(Cv).includes(o))
    return s2(o, t, e);
  let d;
  if (s) {
    const p = [s.main, ...Object.values(s.otherContractsAbis)];
    d = ag(a, p);
  }
  if (d)
    return ig(d, t, e, a);
  const A = `The transaction reverted with reason: ${a}.`;
  return new x(L.SCRIPT_REVERTED, A, {
    ...e,
    reason: a
  });
}, "assembleRevertError"), wu = /* @__PURE__ */ S((r) => {
  const { receipts: t, statusReason: e, logs: n, groupedLogs: s, abis: i } = r, a = t.some(({ type: p }) => p === At.Panic), o = t.some(({ type: p }) => p === At.Revert), d = {
    logs: n,
    groupedLogs: s,
    receipts: t,
    panic: a,
    revert: o,
    reason: ""
  };
  if (a)
    return n2(e, d);
  const A = n.filter((p) => {
    const g = p;
    return !(g !== null && typeof g == "object" && "__decoded" in g && g.__decoded === !1);
  });
  return i2(t, A, d, e, i);
}, "extractTxError"), za = /* @__PURE__ */ S((...r) => {
  const t = {};
  function e({ amount: n, assetId: s }) {
    t[s] ? t[s] = t[s].add(n) : t[s] = n;
  }
  return S(e, "addToMap"), r.forEach((n) => n.forEach(e)), Object.entries(t).map(([n, s]) => ({ assetId: n, amount: s }));
}, "mergeQuantities"), Ks, lS = (Ks = class extends Error {
  constructor() {
    super(...arguments);
    Q(this, "name", "ChangeOutputCollisionError");
    Q(this, "message", 'A ChangeOutput with the same "assetId" already exists for a different "to" address');
  }
}, S(Ks, "ChangeOutputCollisionError"), Ks), ti, a2 = (ti = class extends Error {
  constructor(e) {
    super();
    Q(this, "name", "NoWitnessAtIndexError");
    this.index = e, this.message = `Witness at index "${e}" was not found`;
  }
}, S(ti, "NoWitnessAtIndexError"), ti), ei, hS = (ei = class extends Error {
  constructor(e) {
    super();
    Q(this, "name", "NoWitnessByOwnerError");
    this.owner = e, this.message = `A witness for the given owner "${e}" was not found`;
  }
}, S(ei, "NoWitnessByOwnerError"), ei), fr = /* @__PURE__ */ S((r) => r.type === xt.Coin, "isRequestInputCoin"), Vo = /* @__PURE__ */ S((r) => r.type === xt.Message, "isRequestInputMessage"), og = /* @__PURE__ */ S((r) => r.type === xt.Message && I(r.data).isZero(), "isRequestInputMessageWithoutData"), Wo = /* @__PURE__ */ S((r) => fr(r) || Vo(r), "isRequestInputCoinOrMessage"), Wn = /* @__PURE__ */ S((r) => fr(r) || og(r), "isRequestInputResource"), cg = /* @__PURE__ */ S((r) => fr(r) ? r.owner : r.recipient, "getRequestInputResourceOwner"), xd = /* @__PURE__ */ S((r, t) => cg(r) === t.toB256(), "isRequestInputResourceFromOwner"), n_ = /* @__PURE__ */ S((r) => Wo(r) && !!r.predicate && W(r.predicate) !== "0x", "isPredicate"), o2 = /* @__PURE__ */ S((r, t, e) => r.filter(Wn).reduce((n, s) => fr(s) && s.assetId === t || Vo(s) && t === e ? n.add(s.amount) : n, I(0)), "getAssetAmountInRequestInputs"), _S = /* @__PURE__ */ S((r) => r.filter(Wn).reduce(
  (t, e) => (fr(e) ? t.utxos.push(e.id) : t.messages.push(e.nonce), t),
  {
    utxos: [],
    messages: []
  }
), "cacheRequestInputsResources"), c2 = /* @__PURE__ */ S((r, t) => r.reduce(
  (e, n) => (fr(n) && n.owner === t.toB256() ? e.utxos.push(n.id) : Vo(n) && n.recipient === t.toB256() && e.messages.push(n.nonce), e),
  {
    utxos: [],
    messages: []
  }
), "cacheRequestInputsResourcesFromOwner"), d2 = /* @__PURE__ */ S((r, t) => {
  const { inputs: e, outputs: n } = t, s = new Set(e.filter(fr).map((o) => o.assetId));
  e.some((o) => Vo(o) && I(o.amount).gt(0)) && s.add(r);
  const i = new Set(
    n.filter((o) => o.type === lt.Change).map((o) => o.assetId)
  );
  return new Set([...s].filter((o) => !i.has(o))).size;
}, "getBurnableAssetCount"), dg = /* @__PURE__ */ S((r, t, e = !1) => {
  if (e === !0 || d2(r, t) <= 0)
    return;
  const n = [
    "Asset burn detected.",
    "Add the relevant change outputs to the transaction to avoid burning assets.",
    "Or enable asset burn, upon sending the transaction."
  ].join(`
`);
  throw new x(L.ASSET_BURN_DETECTED, n);
}, "validateTransactionForAssetBurn"), u2 = /* @__PURE__ */ S((r) => {
  const t = j(r);
  return {
    data: W(t),
    dataLength: t.length
  };
}, "witnessify"), Dn, ya = (Dn = class {
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    tip: t,
    maturity: e,
    expiration: n,
    ownerInputIndex: s,
    maxFee: i,
    witnessLimit: a,
    inputs: o,
    outputs: d,
    witnesses: A,
    flag: p
  } = {}) {
    /** Gas price for transaction */
    Q(this, "tip");
    /** Block until which tx cannot be included */
    Q(this, "maturity");
    /** The block number after which the transaction is no longer valid. */
    Q(this, "expiration");
    /** The index of the owner input */
    Q(this, "ownerInputIndex");
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    Q(this, "maxFee");
    /** The maximum amount of witness data allowed for the transaction */
    Q(this, "witnessLimit");
    /** List of inputs */
    Q(this, "inputs", []);
    /** List of outputs */
    Q(this, "outputs", []);
    /** List of witnesses */
    Q(this, "witnesses", []);
    /**
     * The current status of the transaction
     */
    Q(this, "flag", { state: void 0, transactionId: void 0, summary: void 0 });
    this.tip = t ? I(t) : void 0, this.maturity = e && e > 0 ? e : void 0, this.expiration = n && n > 0 ? n : void 0, this.witnessLimit = Ge(a) ? I(a) : void 0, this.ownerInputIndex = s ?? void 0, this.maxFee = I(i), this.inputs = o ?? [], this.outputs = d ?? [], this.witnesses = A ?? [], this.flag = p ?? { state: void 0, transactionId: void 0, summary: void 0 };
  }
  static getPolicyMeta(t) {
    let e = 0;
    const n = [], { tip: s, witnessLimit: i, maturity: a, expiration: o } = t;
    return I(s).gt(0) && (e += Qe.Tip, n.push({ data: I(s), type: Qe.Tip })), Ge(i) && I(i).gte(0) && (e += Qe.WitnessLimit, n.push({ data: I(i), type: Qe.WitnessLimit })), a && a > 0 && (e += Qe.Maturity, n.push({ data: a, type: Qe.Maturity })), e += Qe.MaxFee, n.push({ data: t.maxFee, type: Qe.MaxFee }), o && o > 0 && (e += Qe.Expiration, n.push({ data: o, type: Qe.Expiration })), Ge(t.ownerInputIndex) && (e += Qe.Owner, n.push({ data: I(t.ownerInputIndex), type: Qe.Owner })), {
      policyTypes: e,
      policies: n
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    var a, o, d;
    const t = ((a = this.inputs) == null ? void 0 : a.map(Vx)) ?? [], e = ((o = this.outputs) == null ? void 0 : o.map(Wx)) ?? [], n = ((d = this.witnesses) == null ? void 0 : d.map(u2)) ?? [], { policyTypes: s, policies: i } = Dn.getPolicyMeta(this);
    return {
      policyTypes: s,
      inputs: t,
      outputs: e,
      policies: i,
      witnesses: n,
      inputsCount: t.length,
      outputsCount: e.length,
      witnessesCount: n.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new sr().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(t) {
    return this.inputs.push(t), this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(t) {
    return this.outputs.push(t), this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes a witness to the list and returns the index
   *
   * @param signature - The signature to add to the witness.
   * @returns The index of the created witness.
   */
  addWitness(t) {
    return this.witnesses.push(t), this.witnesses.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   *
   * @returns The index of the created witness.
   */
  addEmptyWitness() {
    return this.addWitness(ct([St, St]));
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(t, e) {
    const n = new wt(t), s = this.getCoinInputWitnessIndexByOwner(n);
    typeof s == "number" && this.updateWitness(s, e);
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(t, e) {
    if (!this.witnesses[t])
      throw new a2(t);
    this.witnesses[t] = e;
  }
  /**
   * Helper function to add an external signature to the transaction.
   *
   * @param account - The account/s to sign to the transaction.
   * @returns The transaction with the signature witness added.
   */
  async addAccountWitnesses(t) {
    const e = Array.isArray(t) ? t : [t];
    return await Promise.all(
      e.map(async (n) => {
        this.addWitness(await n.signTransaction(this));
      })
    ), this;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (t) => t.type === xt.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (t) => t.type === lt.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (t) => t.type === lt.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(t) {
    const e = Zi(t), n = this.inputs.find((s) => {
      switch (s.type) {
        case xt.Coin:
          return W(s.owner) === e.toB256();
        case xt.Message:
          return W(s.recipient) === e.toB256();
        default:
          return !1;
      }
    });
    return n == null ? void 0 : n.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   */
  addCoinInput(t) {
    const { assetId: e, owner: n, amount: s, id: i, predicate: a, predicateData: o } = t;
    let d;
    t.predicate ? d = 0 : (d = this.getCoinInputWitnessIndexByOwner(n), typeof d != "number" && (d = this.addEmptyWitness()));
    const A = {
      id: i,
      type: xt.Coin,
      owner: n.toB256(),
      amount: s,
      assetId: e,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex: d,
      predicate: a,
      predicateData: o
    };
    this.pushInput(A), this.addChangeOutput(n, e);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * asset against the message
   *
   * @param message - Message resource.
   */
  addMessageInput(t) {
    const { recipient: e, sender: n, amount: s, predicate: i, nonce: a, predicateData: o } = t;
    let d;
    t.predicate ? d = 0 : (d = this.getCoinInputWitnessIndexByOwner(e), typeof d != "number" && (d = this.addEmptyWitness()));
    const A = {
      nonce: a,
      type: xt.Message,
      sender: n.toB256(),
      recipient: e.toB256(),
      data: e_(t) ? "0x" : t.data,
      amount: s,
      witnessIndex: d,
      predicate: i,
      predicateData: o
    };
    this.pushInput(A), e_(t) && this.addChangeOutput(e, t.assetId);
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(t) {
    return Yx(t) ? this.addCoinInput(t) : this.addMessageInput(t), this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(t) {
    return t.forEach((e) => this.addResource(e)), this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(t, e, n) {
    return this.pushOutput({
      type: lt.Coin,
      to: Zi(t).toB256(),
      amount: e,
      assetId: n
    }), this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(t, e) {
    return e.map(Au).forEach((n) => {
      this.pushOutput({
        type: lt.Coin,
        to: Zi(t).toB256(),
        amount: n.amount,
        assetId: n.assetId
      });
    }), this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(t, e) {
    this.getChangeOutputs().find(
      (s) => W(s.assetId) === e
    ) || this.pushOutput({
      type: lt.Change,
      to: Zi(t).toB256(),
      assetId: e
    });
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(t) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(t) {
    const { consensusParameters: e } = t, {
      gasCosts: n,
      feeParameters: { gasPerByte: s }
    } = e;
    return pu({
      gasPerByte: s,
      gasCosts: n,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(n)
    });
  }
  calculateMaxGas(t, e) {
    const { consensusParameters: n } = t, {
      feeParameters: { gasPerByte: s },
      txParameters: { maxGasPerTx: i }
    } = n, a = this.toTransaction().witnesses.reduce(
      (o, d) => o + d.dataLength,
      0
    );
    return Ho({
      gasPerByte: s,
      minGas: e,
      witnessesLength: a,
      witnessLimit: this.witnessLimit,
      maxGasPerTx: i
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   * @param baseAssetId - The base asset to fund the transaction.
   * @deprecated - This method is deprecated and will be removed in future versions.
   * Please use `Account.generateFakeResources` along with `this.addResources` instead.
   */
  fundWithFakeUtxos(t, e, n) {
    const s = /* @__PURE__ */ S((a) => this.inputs.find((o) => "assetId" in o ? o.assetId === a : !1), "findAssetInput"), i = /* @__PURE__ */ S((a, o) => {
      const d = s(a);
      let A = o;
      a === e && (A = I("1000000000000000000")), d && "assetId" in d ? (d.id = W(ir(lo)), d.amount = A) : this.addResources([
        {
          id: W(ir(lo)),
          amount: A,
          assetId: a,
          owner: n || wt.fromRandom(),
          blockCreated: I(1),
          txCreatedIdx: I(1)
        }
      ]);
    }, "updateAssetInput");
    return i(e, I(1e11)), t.forEach((a) => i(a.assetId, a.amount)), this;
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    return this.getCoinOutputs().map(({ amount: e, assetId: n }) => ({
      amount: I(e),
      assetId: n.toString()
    }));
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return sg(this);
  }
  removeWitness(t) {
    this.witnesses.splice(t, 1), this.adjustWitnessIndexes(t);
  }
  adjustWitnessIndexes(t) {
    this.inputs.filter(Wn).forEach((e) => {
      e.witnessIndex > t && (e.witnessIndex -= 1);
    });
  }
  updatePredicateGasUsed(t) {
    const e = t.filter(Wo);
    this.inputs.filter(Wn).forEach((n) => {
      const s = cg(n), i = e.find(
        (a) => xd(a, new wt(String(s)))
      );
      i && "predicateGasUsed" in i && I(i.predicateGasUsed).gt(0) && (n.predicateGasUsed = i.predicateGasUsed);
    });
  }
  byteLength() {
    return this.toTransactionBytes().byteLength;
  }
  /**
   * @hidden
   *
   * Used internally to update the state of a transaction request.
   *
   * @param state - The state to update.
   */
  updateState(t, e, n) {
    if (!e) {
      this.flag = { state: void 0, transactionId: void 0, summary: void 0 };
      return;
    }
    const s = this.getTransactionId(t);
    this.flag = { state: e, transactionId: s, summary: n };
  }
}, S(Dn, "BaseTransactionRequest"), Dn);
function Li(r, t) {
  const e = r.toTransaction();
  e.type === Ct.Script && (e.receiptsRoot = St), e.inputs = e.inputs.map((i) => {
    const a = ve(i);
    switch (a.type) {
      // Zero out on signing: txPointer, predicateGasUsed
      case xt.Coin:
        return a.txPointer = {
          blockHeight: 0,
          txIndex: 0
        }, a.predicateGasUsed = I(0), a;
      // Zero out on signing: predicateGasUsed
      case xt.Message:
        return a.predicateGasUsed = I(0), a;
      // Zero out on signing: txID, outputIndex, balanceRoot, stateRoot, and txPointer
      case xt.Contract:
        return a.txPointer = {
          blockHeight: 0,
          txIndex: 0
        }, a.txID = St, a.outputIndex = 0, a.balanceRoot = St, a.stateRoot = St, a;
      default:
        return a;
    }
  }), e.outputs = e.outputs.map((i) => {
    const a = ve(i);
    switch (a.type) {
      // Zero out on signing: balanceRoot, stateRoot
      case lt.Contract:
        return a.balanceRoot = St, a.stateRoot = St, a;
      // Zero out on signing: amount
      case lt.Change:
        return a.amount = I(0), a;
      // Zero out on signing: amount, to and assetId
      case lt.Variable:
        return a.to = St, a.amount = I(0), a.assetId = St, a;
      default:
        return a;
    }
  }), e.witnessesCount = 0, e.witnesses = [];
  const n = Rp(t), s = ct([n, new sr().encode(e)]);
  return Xt(s);
}
S(Li, "hashTransaction");
var ri, yo = (ri = class extends ya {
  /**
   * Creates an instance `BlobTransactionRequest`.
   *
   * @param blobTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex: e, blobId: n, ...s }) {
    super(s);
    /** Type of the transaction */
    Q(this, "type", Ct.Blob);
    /** Blob ID */
    Q(this, "blobId");
    /** Witness index of the bytecode to create */
    Q(this, "witnessIndex");
    this.blobId = n, this.witnessIndex = e ?? 0;
  }
  static from(e) {
    return new this(ve(e));
  }
  /**
   * Converts the transaction request to a `TransactionBlob`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const e = this.getBaseTransaction(), { witnessIndex: n, blobId: s } = this;
    return {
      type: Ct.Blob,
      ...e,
      blobId: s,
      witnessIndex: n
    };
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(e) {
    return Li(this, e);
  }
  /**
   * Calculates the metadata gas cost for a blob transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   * @returns metadata gas cost for the blob transaction.
   */
  metadataGas(e) {
    return eg({
      gasCosts: e,
      txBytesSize: this.byteSize(),
      witnessBytesSize: this.witnesses[this.witnessIndex].length
    });
  }
}, S(ri, "BlobTransactionRequest"), ri), A2 = /* @__PURE__ */ S((r) => {
  const t = new Uint8Array(32);
  return t.set(j(r)), t;
}, "getStorageValue"), l2 = /* @__PURE__ */ S((r) => {
  let t, e;
  return Array.isArray(r) ? (t = r[0], e = r[1]) : (t = r.key, e = r.value), {
    key: W(t),
    value: W(A2(e))
  };
}, "storageSlotify"), ni, Rd = (ni = class extends ya {
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({ bytecodeWitnessIndex: e, salt: n, storageSlots: s, ...i }) {
    super(i);
    /** Type of the transaction */
    Q(this, "type", Ct.Create);
    /** Witness index of contract bytecode to create */
    Q(this, "bytecodeWitnessIndex");
    /** Salt */
    Q(this, "salt");
    /** List of storage slots to initialize */
    Q(this, "storageSlots");
    this.bytecodeWitnessIndex = e ?? 0, this.salt = W(n ?? St), this.storageSlots = [...s ?? []];
  }
  static from(e) {
    return new this(ve(e));
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    var i;
    const e = this.getBaseTransaction(), n = this.bytecodeWitnessIndex, s = ((i = this.storageSlots) == null ? void 0 : i.map(l2)) ?? [];
    return {
      type: Ct.Create,
      ...e,
      bytecodeWitnessIndex: n,
      storageSlotsCount: I(s.length),
      salt: this.salt ? W(this.salt) : St,
      storageSlots: s
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (e) => e.type === lt.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(e) {
    return Li(this, e);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(e, n) {
    this.pushOutput({
      type: lt.ContractCreated,
      contractId: e,
      stateRoot: n
    });
  }
  metadataGas(e) {
    return fu({
      contractBytesSize: I(j(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts: e,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
}, S(ni, "CreateTransactionRequest"), ni), s_ = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: j("0x24000000"),
  encodeScriptData: /* @__PURE__ */ S(() => new Uint8Array(0), "encodeScriptData")
}, h2 = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: j("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: /* @__PURE__ */ S(() => new Uint8Array(0), "encodeScriptData")
}, si, Ir = (si = class extends ya {
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script: e, scriptData: n, gasLimit: s, ...i } = {}) {
    super(i);
    /** Type of the transaction */
    Q(this, "type", Ct.Script);
    /** Gas limit for transaction */
    Q(this, "gasLimit");
    /** Script to execute */
    Q(this, "script");
    /** Script input data (parameters) */
    Q(this, "scriptData");
    Q(this, "abis");
    this.gasLimit = I(s), this.script = j(e ?? s_.bytes), this.scriptData = j(n ?? s_.encodeScriptData()), this.abis = i.abis;
  }
  static from(e) {
    return new this(ve(e));
  }
  /**
   * Helper function to estimate and fund the transaction request with a specified account.
   *
   * @param account - The account to fund the transaction.
   * @param params - The parameters for the transaction cost.
   * @returns The current instance of the `ScriptTransactionRequest` funded.
   *
   * @deprecated Use `provider.assembleTx` instead.
   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.
   */
  async estimateAndFund(e, {
    signatureCallback: n,
    quantities: s = [],
    skipAutoConsolidation: i
  } = {}) {
    const a = await e.getTransactionCost(this, { signatureCallback: n, quantities: s });
    return this.maxFee = a.maxFee, this.gasLimit = a.gasUsed, await e.fund(this, a, { skipAutoConsolidation: i }), this;
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const e = j(this.script ?? "0x"), n = j(this.scriptData ?? "0x");
    return {
      type: Ct.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: I(e.length),
      scriptDataLength: I(n.length),
      receiptsRoot: St,
      script: W(e),
      scriptData: W(n)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (e) => e.type === xt.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (e) => e.type === lt.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (e) => e.type === lt.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(e, n) {
    this.scriptData = e.encodeScriptData(n), this.script = e.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(e = 1) {
    let n = e;
    for (; n; )
      this.pushOutput({
        type: lt.Variable
      }), n -= 1;
    return this.outputs.length - 1;
  }
  /**
   * Adds a variable output to the transaction request.
   *
   * @param to - The recipient address as a BytesLike object. Defaults to ZeroBytes32 if not provided.
   * @param amount - The amount to be transferred as a BigNumberish object. Defaults to 0 if not provided.
   * @param assetId - The asset ID as a BytesLike object. Defaults to ZeroBytes32 if not provided.
   */
  addVariableOutput(e, n, s) {
    this.pushOutput({
      type: lt.Variable,
      to: e,
      amount: n,
      assetId: s
    });
  }
  /**
   * Calculates the maximum gas for the transaction.
   *
   * @param chainInfo - The chain information.
   * @param minGas - The minimum gas.
   * @returns the maximum gas.
   */
  calculateMaxGas(e, n) {
    const { consensusParameters: s } = e, {
      feeParameters: { gasPerByte: i },
      txParameters: { maxGasPerTx: a }
    } = s, o = this.toTransaction().witnesses.reduce(
      (d, A) => d + A.dataLength,
      0
    );
    return Ho({
      gasPerByte: i,
      minGas: n,
      witnessesLength: o,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit,
      maxGasPerTx: a
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(e) {
    const n = Zi(e);
    if (this.getContractInputs().find((i) => i.contractId === n.toB256()))
      return this;
    const s = super.pushInput({
      type: xt.Contract,
      contractId: n.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    return this.pushOutput({
      type: lt.Contract,
      inputIndex: s
    }), this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(e) {
    return Li(this, e);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(e, n) {
    const s = new Je(e);
    return this.scriptData = s.functions.main.encodeArguments(n), this;
  }
  metadataGas(e) {
    return gu({
      gasCosts: e,
      txBytesSize: this.byteSize()
    });
  }
}, S(si, "ScriptTransactionRequest"), si), On, i_ = (On = class extends ya {
  /**
   * Creates an instance `UpgradeTransactionRequest`.
   *
   * @param upgradeTransactionRequestLike - The initial values for the instance
   */
  constructor({
    upgradePurpose: e,
    bytecodeWitnessIndex: n,
    ...s
  } = {}) {
    super(s);
    /** The type of transaction */
    Q(this, "type", Ct.Upgrade);
    /** The upgrade purpose */
    Q(this, "upgradePurpose");
    /** Witness index of consensus */
    Q(this, "bytecodeWitnessIndex");
    this.bytecodeWitnessIndex = n ?? 0, this.upgradePurpose = e ?? {
      type: Ke.ConsensusParameters,
      checksum: "0x"
    };
  }
  static from(e) {
    return e instanceof On ? e : new this(ve(e));
  }
  /**
   * Adds a consensus parameters upgrade purpose.
   *
   * @param consensus - The consensus bytecode.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addConsensusParametersUpgradePurpose(e) {
    return this.bytecodeWitnessIndex = this.addWitness(e), this.upgradePurpose = {
      type: Ke.ConsensusParameters,
      checksum: gr(e)
    }, this;
  }
  /**
   * Adds a state transition upgrade purpose.
   *
   * @param bytecodeRoot - The Merkle root of the state transition.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addStateTransitionUpgradePurpose(e) {
    return this.upgradePurpose = {
      type: Ke.StateTransition,
      data: W(e)
    }, this;
  }
  /**
   * Adds an upgrade purpose.
   *
   * @param type - The upgrade purpose type.
   * @param data - The bytecode or merkle root of upgrade purpose
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addUpgradePurpose(e, n) {
    return e === Ke.ConsensusParameters && this.addConsensusParametersUpgradePurpose(n), e === Ke.StateTransition && this.addStateTransitionUpgradePurpose(n), this;
  }
  /**
   * Converts the transaction request to a `TransactionUpgrade`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    let e;
    if (this.upgradePurpose.type === Ke.ConsensusParameters)
      e = {
        type: Ke.ConsensusParameters,
        data: {
          witnessIndex: this.bytecodeWitnessIndex,
          checksum: this.upgradePurpose.checksum
        }
      };
    else if (this.upgradePurpose.type === Ke.StateTransition)
      e = {
        type: Ke.StateTransition,
        data: {
          bytecodeRoot: W(this.upgradePurpose.data)
        }
      };
    else
      throw new x(x.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
    return {
      type: Ct.Upgrade,
      ...super.getBaseTransaction(),
      upgradePurpose: e
    };
  }
  /**
   * Gets the Transaction ID by hashing the transaction
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(e) {
    return Li(this, e);
  }
  /**
   * Calculates the metadata gas cost for an upgrade transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upgrade transaction.
   */
  metadataGas(e) {
    const n = this.byteSize();
    if (this.upgradePurpose.type === Ke.ConsensusParameters) {
      const s = this.bytecodeWitnessIndex, i = this.witnesses[s].length;
      return vd({
        gasCosts: e,
        txBytesSize: n,
        consensusSize: i
      });
    }
    if (this.upgradePurpose.type === Ke.StateTransition)
      return vd({
        gasCosts: e,
        txBytesSize: n
      });
    throw new x(x.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
  }
}, S(On, "UpgradeTransactionRequest"), On), Mn, a_ = (Mn = class extends ya {
  /**
   * Creates an instance `UploadTransactionRequest`.
   *
   * @param uploadTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex: e, subsection: n, ...s } = {}) {
    super(s);
    /** Type of the transaction */
    Q(this, "type", Ct.Upload);
    /** The witness index of the subsection of the bytecode. */
    Q(this, "witnessIndex");
    /** The subsection data. */
    Q(this, "subsection");
    this.witnessIndex = e ?? 0, this.subsection = n ?? {
      proofSet: [],
      root: St,
      subsectionIndex: 0,
      subsectionsNumber: 0
    };
  }
  static from(e) {
    return e instanceof Mn ? e : new this(ve(e));
  }
  /**
   * Adds the subsection.
   *
   * @param subsection - The subsection data.
   */
  addSubsection(e) {
    const { subsection: n, ...s } = e;
    this.subsection = s, this.witnessIndex = this.addWitness(n);
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(e) {
    return Li(this, e);
  }
  /**
   * Converts the transaction request to a `TransactionUpload`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const e = this.getBaseTransaction(), { subsectionIndex: n, subsectionsNumber: s, root: i, proofSet: a } = this.subsection;
    return {
      type: Ct.Upload,
      ...e,
      subsectionIndex: n,
      subsectionsNumber: s,
      root: W(i),
      proofSet: a.map(W),
      witnessIndex: this.witnessIndex,
      proofSetCount: a.length
    };
  }
  /**
   * Calculates the metadata gas cost for an upload transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upload transaction.
   */
  metadataGas(e) {
    return rg({
      gasCosts: e,
      txBytesSize: this.byteSize(),
      subsectionSize: j(this.witnesses[this.witnessIndex]).length,
      subsectionsSize: this.subsection.subsectionsNumber
    });
  }
  /**
   * Calculates the minimum gas for an upload transaction.
   *
   * @param chainInfo - The chain information.
   *
   * @returns the minimum gas for the upload transaction
   */
  calculateMinGas(e) {
    const n = super.calculateMinGas(e), { gasCosts: s } = e.consensusParameters, i = this.witnesses[this.witnessIndex] ?? St;
    return ng({
      gasCosts: s,
      baseMinGas: n.toNumber(),
      subsectionSize: j(i).length
    });
  }
}, S(Mn, "UploadTransactionRequest"), Mn), ii, pS = (ii = class {
}, S(ii, "AbstractScriptRequest"), ii), Oe = /* @__PURE__ */ S((r) => {
  if (r instanceof Ir || r instanceof Rd || r instanceof yo || r instanceof i_ || r instanceof a_)
    return r;
  const { type: t } = r;
  switch (r.type) {
    case Ct.Script:
      return Ir.from(r);
    case Ct.Create:
      return Rd.from(r);
    case Ct.Blob:
      return yo.from(r);
    case Ct.Upgrade:
      return i_.from(r);
    case Ct.Upload:
      return a_.from(r);
    default:
      throw new x(
        L.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${t}.`
      );
  }
}, "transactionRequestify"), An = /* @__PURE__ */ S((r) => r.type === Ct.Script, "isTransactionTypeScript"), _2 = /* @__PURE__ */ S((r) => r.type === Ct.Create, "isTransactionTypeCreate"), fS = /* @__PURE__ */ S((r) => r.type === Ct.Blob, "isTransactionTypeBlob"), gS = /* @__PURE__ */ S((r) => r.type === Ct.Upgrade, "isTransactionTypeUpgrade"), wS = /* @__PURE__ */ S((r) => r.type === Ct.Upload, "isTransactionTypeUpload"), Vi = /* @__PURE__ */ new Map(), ai, o_ = (ai = class {
  constructor(t) {
    Q(this, "ttl");
    if (this.ttl = t, typeof t != "number" || this.ttl <= 0)
      throw new x(
        L.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
  }
  // Add resources to the cache
  set(t, e) {
    const n = this.setupResourcesCache(e);
    Vi.set(t, n);
  }
  unset(t) {
    Vi.delete(t);
  }
  getActiveData(t) {
    const e = { utxos: [], messages: [] }, n = Date.now(), s = [];
    return Vi.forEach((i, a) => {
      if (n - i.timestamp < this.ttl) {
        const d = i.owners.get(t);
        d && (e.utxos.push(...d.utxos), e.messages.push(...d.messages));
      } else
        s.push(a);
    }), s.forEach(this.unset), e.utxos.reverse(), e.messages.reverse(), e;
  }
  isCached(t, e) {
    const n = Date.now();
    let s = !1;
    const i = [];
    for (const [a, o] of Vi.entries())
      if (n - o.timestamp < this.ttl) {
        const A = o.owners.get(t);
        if (A != null && A.utxos.has(e) || A != null && A.messages.has(e)) {
          s = !0;
          break;
        }
      } else
        i.push(a);
    return i.forEach(this.unset), s;
  }
  clear() {
    Vi.clear();
  }
  setupResourcesCache(t) {
    const e = Date.now(), n = {
      owners: /* @__PURE__ */ new Map(),
      timestamp: e
    };
    return t.filter(Wo).forEach((s) => {
      var d, A;
      const { owner: i, key: a, type: o } = this.extractResourceData(s);
      n.owners.has(i) || n.owners.set(i, { utxos: /* @__PURE__ */ new Set(), messages: /* @__PURE__ */ new Set() }), o === "utxo" ? (d = n.owners.get(i)) == null || d.utxos.add(a) : (A = n.owners.get(i)) == null || A.messages.add(a);
    }), n;
  }
  extractResourceData(t) {
    return fr(t) ? { owner: W(t.owner), key: W(t.id), type: "utxo" } : { owner: W(t.recipient), key: W(t.nonce), type: "message" };
  }
}, S(ai, "ResourceCache"), ai), p2 = /* @__PURE__ */ S((r) => {
  var P;
  const {
    gasPrice: t,
    rawPayload: e,
    tip: n,
    consensusParameters: { gasCosts: s, feeParams: i, maxGasPerTx: a }
  } = r, o = I(i.gasPerByte), d = I(i.gasPriceFactor), A = j(e), [p] = new sr().decode(A, 0), { type: g, witnesses: y, inputs: v, policies: N } = p;
  let E = I(0), F = I(0);
  if (g !== Ct.Create && g !== Ct.Script)
    return I(0);
  if (g === Ct.Create) {
    const { bytecodeWitnessIndex: U, storageSlots: z } = p, G = I(j(y[U].data).length);
    E = fu({
      contractBytesSize: G,
      gasCosts: s,
      stateRootSize: z.length || 0,
      txBytesSize: A.length
    });
  } else {
    const { scriptGasLimit: U } = p;
    U && (F = U), E = gu({
      gasCosts: s,
      txBytesSize: A.length
    });
  }
  const k = pu({
    gasCosts: s,
    gasPerByte: I(o),
    inputs: v,
    metadataGas: E,
    txBytesSize: A.length
  }), H = (P = N.find((U) => U.type === Qe.WitnessLimit)) == null ? void 0 : P.data, X = y.reduce((U, z) => U + z.dataLength, 0), D = Ho({
    gasPerByte: o,
    minGas: k,
    witnessesLength: X,
    gasLimit: F,
    witnessLimit: H,
    maxGasPerTx: a
  });
  return on({
    gasPrice: t,
    gas: D,
    priceFactor: d,
    tip: n
  });
}, "calculateTXFeeForSummary"), f2 = /* @__PURE__ */ S(({
  abi: r,
  receipt: t,
  offset: e,
  scriptData: n
}) => {
  var p;
  const [s, i] = new Qo().decode(n, e), o = new Je(r).getFunction(s), d = o.jsonFn.inputs;
  let A;
  if (d.length) {
    const g = n.slice(i), y = o.decodeArguments(g);
    A = d.reduce((v, N, E) => {
      const F = y == null ? void 0 : y[E], k = N.name;
      return k ? {
        ...v,
        // reparse to remove bn
        [k]: JSON.parse(JSON.stringify(F))
      } : v;
    }, {});
  }
  return {
    functionSignature: o.signature,
    functionName: o.name,
    argumentsProvided: A,
    ...(p = t.amount) != null && p.isZero() ? {} : { amount: t.amount, assetId: t.assetId }
  };
}, "getFunctionCall");
function ug(r, t) {
  return r.filter((e) => t.includes(e.type));
}
S(ug, "getInputsByTypes");
function Yo(r, t) {
  return r.filter((e) => e.type === t);
}
S(Yo, "getInputsByType");
function Ag(r) {
  return Yo(r, xt.Coin);
}
S(Ag, "getInputsCoin");
function lg(r) {
  return Yo(r, xt.Message);
}
S(lg, "getInputsMessage");
function mu(r) {
  return ug(r, [xt.Coin, xt.Message]);
}
S(mu, "getInputsCoinAndMessage");
function Sd(r) {
  return r.type === xt.Coin;
}
S(Sd, "isInputCoin");
function hg(r) {
  return Yo(r, xt.Contract);
}
S(hg, "getInputsContract");
function _g(r, t) {
  return Ag(r).find((n) => n.assetId === t);
}
S(_g, "findCoinInput");
function pg(r, t) {
  const e = /* @__PURE__ */ new Map();
  return mu(r).forEach((n) => {
    const s = Sd(n) ? n.assetId : t, i = Sd(n) ? n.owner : n.recipient;
    let a = e.get(s);
    a || (a = /* @__PURE__ */ new Map(), e.set(s, a));
    let o = a.get(i);
    o || (o = new z_(0), a.set(i, o)), a.set(i, o.add(n.amount));
  }), e;
}
S(pg, "aggregateInputsAmountsByAssetAndOwner");
function fg(r) {
  var t;
  return (t = lg(r)) == null ? void 0 : t[0];
}
S(fg, "findMessageInput");
function yu(r, t, e = !1) {
  const n = _g(r, t);
  if (n)
    return n;
  if (e)
    return fg(r);
}
S(yu, "getInputFromAssetId");
function gg(r, t) {
  if (t == null)
    return;
  const e = r == null ? void 0 : r[t];
  if (e) {
    if (e.type !== xt.Contract)
      throw new x(
        L.INVALID_TRANSACTION_INPUT,
        "Contract input should be of type 'contract'."
      );
    return e;
  }
}
S(gg, "getInputContractFromIndex");
function Zo(r) {
  return r.type === xt.Coin ? r.owner.toString() : r.type === xt.Message ? r.recipient.toString() : "";
}
S(Zo, "getInputAccountAddress");
function ki(r, t) {
  return r.filter((e) => e.type === t);
}
S(ki, "getOutputsByType");
function wg(r) {
  return ki(r, lt.ContractCreated);
}
S(wg, "getOutputsContractCreated");
function bu(r) {
  return ki(r, lt.Coin);
}
S(bu, "getOutputsCoin");
function mg(r) {
  return ki(r, lt.Change);
}
S(mg, "getOutputsChange");
function yg(r) {
  return ki(r, lt.Contract);
}
S(yg, "getOutputsContract");
function g2(r) {
  return ki(r, lt.Variable);
}
S(g2, "getOutputsVariable");
var w2 = /* @__PURE__ */ ((r) => (r.Create = "Create", r.Mint = "Mint", r.Script = "Script", r.Upgrade = "Upgrade", r.Upload = "Upload", r.Blob = "Blob", r))(w2 || {}), bg = /* @__PURE__ */ ((r) => (r.submitted = "submitted", r.success = "success", r.squeezedout = "squeezedout", r.failure = "failure", r.preconfirmationSuccess = "preconfirmationSuccess", r.preconfirmationFailure = "preconfirmationFailure", r))(bg || {}), m2 = /* @__PURE__ */ ((r) => (r.payBlockProducer = "Pay network fee to block producer", r.contractCreated = "Contract created", r.transfer = "Transfer asset", r.contractCall = "Contract call", r.receive = "Receive asset", r.withdrawFromFuel = "Withdraw from Fuel", r))(m2 || {}), y2 = /* @__PURE__ */ ((r) => (r[r.contract = 0] = "contract", r[r.account = 1] = "account", r))(y2 || {}), b2 = /* @__PURE__ */ ((r) => (r.ethereum = "ethereum", r.fuel = "fuel", r))(b2 || {});
function Ti(r, t) {
  return (r ?? []).filter((e) => e.type === t);
}
S(Ti, "getReceiptsByType");
function Jo(r) {
  switch (r) {
    case Ct.Mint:
      return "Mint";
    case Ct.Create:
      return "Create";
    case Ct.Script:
      return "Script";
    case Ct.Blob:
      return "Blob";
    case Ct.Upgrade:
      return "Upgrade";
    case Ct.Upload:
      return "Upload";
    default:
      throw new x(
        L.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${r}.`
      );
  }
}
S(Jo, "getTransactionTypeName");
function Jn(r, t) {
  return Jo(r) === t;
}
S(Jn, "isType");
function Iu(r) {
  return Jn(
    r,
    "Mint"
    /* Mint */
  );
}
S(Iu, "isTypeMint");
function jo(r) {
  return Jn(
    r,
    "Create"
    /* Create */
  );
}
S(jo, "isTypeCreate");
function qo(r) {
  return Jn(
    r,
    "Script"
    /* Script */
  );
}
S(qo, "isTypeScript");
function Cu(r) {
  return Jn(
    r,
    "Upgrade"
    /* Upgrade */
  );
}
S(Cu, "isTypeUpgrade");
function Eu(r) {
  return Jn(
    r,
    "Upload"
    /* Upload */
  );
}
S(Eu, "isTypeUpload");
function Bu(r) {
  return Jn(
    r,
    "Blob"
    /* Blob */
  );
}
S(Bu, "isTypeBlob");
function I2(r) {
  return (t) => r.assetId === t.assetId;
}
S(I2, "hasSameAssetId");
function Ig(r) {
  return Ti(r, At.Call);
}
S(Ig, "getReceiptsCall");
function Cg(r) {
  return Ti(r, At.MessageOut);
}
S(Cg, "getReceiptsMessageOut");
function Eg(r, t) {
  const e = r.assetsSent || [], n = t.assetsSent || [], s = /* @__PURE__ */ new Map();
  return e.forEach((i) => {
    s.set(i.assetId, { ...i });
  }), n.forEach((i) => {
    const a = s.get(i.assetId);
    a ? a.amount = I(a.amount).add(i.amount) : s.set(i.assetId, { ...i });
  }), Array.from(s.values());
}
S(Eg, "mergeAssets");
function Bg(r, t) {
  var e, n, s, i, a, o, d, A;
  return r.name === t.name && ((e = r.from) == null ? void 0 : e.address) === ((n = t.from) == null ? void 0 : n.address) && ((s = r.to) == null ? void 0 : s.address) === ((i = t.to) == null ? void 0 : i.address) && ((a = r.from) == null ? void 0 : a.type) === ((o = t.from) == null ? void 0 : o.type) && ((d = r.to) == null ? void 0 : d.type) === ((A = t.to) == null ? void 0 : A.type);
}
S(Bg, "isSameOperation");
function vg(r, t) {
  var e, n;
  return (e = t.assetsSent) != null && e.length ? (n = r.assetsSent) != null && n.length ? Eg(r, t) : t.assetsSent : r.assetsSent;
}
S(vg, "mergeAssetsSent");
function xg(r, t) {
  var e;
  return (e = t.calls) != null && e.length ? [...r.calls || [], ...t.calls] : r.calls;
}
S(xg, "mergeCalls");
function Rg(r, t) {
  var e;
  return {
    ...r,
    assetsSent: vg(r, t),
    calls: xg(r, t),
    receipts: [
      ...r.receipts || [],
      ...((e = t.receipts) == null ? void 0 : e.filter((n) => {
        var s;
        return !((s = r.receipts) != null && s.some((i) => i === n));
      })) || []
    ]
  };
}
S(Rg, "mergeOperations");
function Fi(r, t) {
  const e = r.findIndex((n) => Bg(n, t));
  return e === -1 ? [...r, t] : r.map((n, s) => s === e ? Rg(n, t) : n);
}
S(Fi, "addOperation");
function C2(r) {
  return Ti(r, At.TransferOut);
}
S(C2, "getReceiptsTransferOut");
function Sg({
  inputs: r,
  receipts: t,
  baseAssetId: e
}) {
  return Cg(t).reduce(
    (i, a) => {
      const o = yu(r, e, !0);
      if (o) {
        const d = Zo(o);
        return Fi(i, {
          name: "Withdraw from Fuel",
          from: {
            type: 1,
            address: d
          },
          to: {
            type: 1,
            address: a.recipient.toString(),
            chain: "ethereum"
            /* ethereum */
          },
          assetsSent: [
            {
              amount: a.amount,
              assetId: e
            }
          ],
          receipts: [a]
        });
      }
      return i;
    },
    []
  );
}
S(Sg, "getWithdrawFromFuelOperations");
function Tg(r, t) {
  for (let e = 0; e <= r.length - t.length; e++) {
    let n = !0;
    for (let s = 0; s < t.length; s++)
      if (r[e + s] !== t[s]) {
        n = !1;
        break;
      }
    if (n)
      return e;
  }
  return -1;
}
S(Tg, "findBytesSegmentIndex");
function Fg(r, t, e, n) {
  const s = [], i = t == null ? void 0 : t[r.contractID];
  if (!i || !n)
    return s;
  const a = ct([
    j(e.to),
    // Contract ID (32 bytes)
    nr(e.param1.toHex(), 8),
    // Function selector offset (8 bytes)
    nr(e.param2.toHex(), 8)
    // Function args offset (8 bytes)
  ]), o = Tg(n, a);
  if (!(o !== -1))
    return s;
  const A = o + a.length, p = f2({ abi: i, receipt: e, offset: A, scriptData: n });
  return s.push(p), s;
}
S(Fg, "getContractCalls");
function Ng(r) {
  var t;
  return (t = r.amount) != null && t.isZero() ? void 0 : [
    {
      amount: r.amount,
      assetId: r.assetId
    }
  ];
}
S(Ng, "getAssetsSent");
function Qg(r, t, e, n, s, i) {
  const a = r.assetId === St ? i : r.assetId, o = yu(e, a, a === i);
  if (!o)
    return [];
  const d = Zo(o), A = Fg(t, n, r, s);
  return [
    {
      name: "Contract call",
      from: {
        type: 1,
        address: d
      },
      to: {
        type: 0,
        address: r.to
      },
      assetsSent: Ng(r),
      calls: A,
      receipts: [r]
    }
  ];
}
S(Qg, "processCallReceipt");
function Dg({
  inputs: r,
  outputs: t,
  receipts: e,
  abiMap: n,
  rawPayload: s,
  baseAssetId: i
}) {
  const a = Ig(e);
  return yg(t).flatMap((d) => {
    const A = gg(r, d.inputIndex);
    if (!A)
      return [];
    let p;
    if (s) {
      const [g] = new sr().decode(j(s), 0);
      g.type === Ct.Script && (p = j(g.scriptData));
    }
    return a.filter((g) => g.to === A.contractID).flatMap(
      (g) => Qg(g, A, r, n, p, i)
    );
  });
}
S(Dg, "getContractCallOperations");
function Og(r, t, e) {
  const { to: n, assetId: s, amount: i } = r;
  let { id: a } = r;
  const o = t.some((A) => A.contractID === n) ? 0 : 1;
  if (St === a) {
    const A = e.find((p) => p.assetId === s);
    a = (A == null ? void 0 : A.to) || a;
  }
  return {
    name: "Transfer asset",
    from: {
      type: t.some((A) => A.contractID === a) ? 0 : 1,
      address: a
    },
    to: {
      type: o,
      address: n
    },
    assetsSent: [
      {
        assetId: s.toString(),
        amount: i
      }
    ],
    receipts: [r]
  };
}
S(Og, "extractTransferOperationFromReceipt");
function Mg({
  inputs: r,
  outputs: t,
  receipts: e,
  baseAssetId: n
}) {
  let s = [];
  const i = bu(t), a = hg(r), o = mg(t), d = pg(r, n);
  i.forEach(({ amount: g, assetId: y, to: v }) => {
    const N = d.get(y) || /* @__PURE__ */ new Map();
    let E, F;
    for (const [k, H] of N)
      if (F || (F = k), H.gte(g)) {
        E = k;
        break;
      }
    E = E || F, E && (s = Fi(s, {
      name: "Transfer asset",
      from: {
        type: 1,
        address: E
      },
      to: {
        type: 1,
        address: v
      },
      assetsSent: [{ assetId: y, amount: g }]
    }));
  });
  const A = Ti(
    e,
    At.Transfer
  ), p = Ti(
    e,
    At.TransferOut
  );
  return [...A, ...p].forEach((g) => {
    const y = Og(g, a, o);
    s = Fi(s, y);
  }), s;
}
S(Mg, "getTransferOperations");
function Pg(r) {
  return bu(r).reduce((n, s) => Fi(n, {
    name: "Pay network fee to block producer",
    from: {
      type: 1,
      address: "Network"
    },
    to: {
      type: 1,
      address: s.to.toString()
    },
    assetsSent: [
      {
        assetId: s.assetId.toString(),
        amount: s.amount
      }
    ]
  }), []);
}
S(Pg, "getPayProducerOperations");
function Lg({ inputs: r, outputs: t }) {
  const e = wg(t), n = mu(r)[0], s = Zo(n);
  return e.reduce((a, o) => Fi(a, {
    name: "Contract created",
    from: {
      type: 1,
      address: s
    },
    to: {
      type: 0,
      address: (o == null ? void 0 : o.contractId) || ""
    }
  }), []);
}
S(Lg, "getContractCreatedOperations");
function vu({
  transactionType: r,
  inputs: t,
  outputs: e,
  receipts: n,
  abiMap: s,
  rawPayload: i,
  maxInputs: a,
  baseAssetId: o
}) {
  return jo(r) ? [...Lg({ inputs: t, outputs: e })] : qo(r) ? [
    ...Mg({ inputs: t, outputs: e, receipts: n, baseAssetId: o }),
    ...Dg({
      inputs: t,
      outputs: e,
      receipts: n,
      abiMap: s,
      rawPayload: i,
      baseAssetId: o
    }),
    ...Sg({ inputs: t, receipts: n, baseAssetId: o })
  ] : [...Pg(e)];
}
S(vu, "getOperations");
var mS = /* @__PURE__ */ S((r) => Se(r), "processGqlReceipt"), kg = /* @__PURE__ */ S((r) => {
  const t = [];
  return r.forEach((e) => {
    e.type === At.Mint && t.push({
      subId: e.subId,
      contractId: e.contractId,
      assetId: e.assetId,
      amount: e.val
    });
  }), t;
}, "extractMintedAssetsFromReceipts"), Ug = /* @__PURE__ */ S((r) => {
  const t = [];
  return r.forEach((e) => {
    e.type === At.Burn && t.push({
      subId: e.subId,
      contractId: e.contractId,
      assetId: e.assetId,
      amount: e.val
    });
  }), t;
}, "extractBurnedAssetsFromReceipts"), E2 = /* @__PURE__ */ S((r) => {
  switch (r) {
    case "FailureStatus":
      return "failure";
    case "SuccessStatus":
      return "success";
    case "SubmittedStatus":
      return "submitted";
    case "SqueezedOutStatus":
      return "squeezedout";
    case "PreconfirmationSuccessStatus":
      return "preconfirmationSuccess";
    case "PreconfirmationFailureStatus":
      return "preconfirmationFailure";
    default:
      throw new x(
        L.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${r}.`
      );
  }
}, "getTransactionStatusName"), c_ = /* @__PURE__ */ S((r) => {
  const t = [];
  return r == null || r.forEach(
    ({ utxoId: e, output: n }) => t.push({
      utxoId: e,
      output: Kf(n)
    })
  ), t;
}, "extractResolvedOutputs"), Gg = /* @__PURE__ */ S((r) => {
  var E, F, k, H, X, D;
  let t, e, n, s, i, a, o = [], d, A = !1, p = !1, g = !1, y = !1, v = !1;
  if (r != null && r.type)
    switch (n = E2(r.type), r.type) {
      case "SuccessStatus":
        t = r.time, e = (E = r.block) == null ? void 0 : E.id, p = !0, a = (F = r.receipts) == null ? void 0 : F.map(Se), s = I(r.totalFee), i = I(r.totalGas);
        break;
      case "FailureStatus":
        t = r.time, e = (k = r.block) == null ? void 0 : k.id, A = !0, s = I(r.totalFee), a = (H = r.receipts) == null ? void 0 : H.map(Se), i = I(r.totalGas);
        break;
      case "SubmittedStatus":
        t = r.time, g = !0;
        break;
      case "PreconfirmationSuccessStatus":
        y = !0, s = I(r.totalFee), i = I(r.totalGas), a = (X = r.preconfirmationReceipts) == null ? void 0 : X.map(Se), o = c_(r.resolvedOutputs);
        break;
      case "PreconfirmationFailureStatus":
        v = !0, s = I(r.totalFee), i = I(r.totalGas), a = (D = r.preconfirmationReceipts) == null ? void 0 : D.map(Se), o = c_(r.resolvedOutputs), d = r.reason;
        break;
    }
  return {
    time: t,
    blockId: e,
    status: n,
    totalFee: s,
    totalGas: i,
    receipts: a,
    isStatusFailure: A,
    isStatusSuccess: p,
    isStatusPending: g,
    isStatusPreConfirmationSuccess: y,
    isStatusPreConfirmationFailure: v,
    resolvedOutputs: o,
    errorReason: d
  };
}, "processGraphqlStatus"), zg = /* @__PURE__ */ S((r) => r && "totalFee" in r ? I(r.totalFee) : void 0, "getTotalFeeFromStatus");
function Ui(r) {
  var l, f;
  const {
    id: t,
    receipts: e,
    gasPerByte: n,
    gasPriceFactor: s,
    transaction: i,
    transactionBytes: a,
    gqlTransactionStatus: o,
    abiMap: d = {},
    maxInputs: A,
    gasCosts: p,
    maxGasPerTx: g,
    gasPrice: y,
    baseAssetId: v
  } = r, N = Pi(e), E = W(a), F = vu({
    transactionType: i.type,
    inputs: i.inputs || [],
    outputs: i.outputs || [],
    receipts: e,
    rawPayload: E,
    abiMap: d,
    maxInputs: A,
    baseAssetId: v
  }), k = Jo(i.type), H = I((f = (l = i.policies) == null ? void 0 : l.find((m) => m.type === Qe.Tip)) == null ? void 0 : f.data), { isStatusFailure: X, isStatusPending: D, isStatusSuccess: M, blockId: P, status: U, time: z, totalFee: G } = Gg(o), Y = G ?? p2({
    gasPrice: y,
    rawPayload: E,
    tip: H,
    consensusParameters: {
      gasCosts: p,
      maxGasPerTx: g,
      feeParams: {
        gasPerByte: n,
        gasPriceFactor: s
      }
    }
  }), Z = kg(e), q = Ug(e);
  let R;
  return z && (R = K_.fromTai64(z)), {
    id: t,
    tip: H,
    fee: Y,
    gasUsed: N,
    operations: F,
    type: k,
    blockId: P,
    time: z,
    status: U,
    receipts: e,
    mintedAssets: Z,
    burnedAssets: q,
    isTypeMint: Iu(i.type),
    isTypeCreate: jo(i.type),
    isTypeScript: qo(i.type),
    isTypeUpgrade: Cu(i.type),
    isTypeUpload: Eu(i.type),
    isTypeBlob: Bu(i.type),
    isStatusFailure: X,
    isStatusSuccess: M,
    isStatusPending: D,
    date: R,
    transaction: i
  };
}
S(Ui, "assembleTransactionSummary");
function Xg(r) {
  var G, Y;
  const { id: t, gqlTransactionStatus: e, transactionRequest: n, baseAssetId: s, maxInputs: i, abiMap: a } = r;
  let o, d, A, p, g, y, v;
  const {
    isStatusFailure: N,
    isStatusSuccess: E,
    isStatusPending: F,
    status: k,
    receipts: H,
    resolvedOutputs: X,
    errorReason: D,
    totalFee: M,
    isStatusPreConfirmationFailure: P,
    isStatusPreConfirmationSuccess: U
  } = Gg(e);
  if (H && (A = Pi(H), y = kg(H), v = Ug(H)), n && (g = n.toTransaction(), o = Jo(g.type), p = I((Y = (G = g.policies) == null ? void 0 : G.find((Z) => Z.type === Qe.Tip)) == null ? void 0 : Y.data), H)) {
    const Z = W(new sr().encode(g));
    d = vu({
      transactionType: g.type,
      inputs: g.inputs || [],
      outputs: g.outputs || [],
      receipts: H,
      rawPayload: Z,
      abiMap: a,
      maxInputs: i,
      baseAssetId: s
    });
  }
  return {
    id: t,
    fee: M,
    type: o,
    status: k,
    receipts: H,
    gasUsed: A,
    tip: p,
    isStatusPreConfirmationFailure: P,
    isStatusPreConfirmationSuccess: U,
    isStatusFailure: N,
    isStatusSuccess: E,
    isStatusPending: F,
    ...g && {
      isTypeMint: Iu(g.type),
      isTypeCreate: jo(g.type),
      isTypeScript: qo(g.type),
      isTypeUpgrade: Cu(g.type),
      isTypeUpload: Eu(g.type),
      isTypeBlob: Bu(g.type)
    },
    mintedAssets: y,
    burnedAssets: v,
    resolvedOutputs: X,
    errorReason: D,
    transaction: g,
    operations: d
  };
}
S(Xg, "assemblePreConfirmationTransactionSummary");
function aa(r) {
  const { receipts: t, mainAbi: e, externalAbis: n = {} } = r;
  let s = "";
  if (e.programType === "contract") {
    const i = t.find(
      (a) => a.type === At.Call && a.id === St
    );
    i && (s = i.to);
  }
  return t.reduce(
    ({ logs: i, groupedLogs: a }, o) => {
      if (o.type === At.LogData || o.type === At.Log) {
        const d = o.id === St || s === o.id;
        if (d || n[o.id]) {
          const p = d ? new Je(e) : new Je(n[o.id]), g = o.type === At.Log ? new rt("u64").encode(o.ra) : o.data;
          let y;
          try {
            [y] = p.decodeLog(g, o.rb.toString());
          } catch {
            y = { __decoded: !1, data: g, logId: o.rb.toString() };
          }
          i.push(y), a[o.id] = [...a[o.id] || [], y];
        }
      }
      return { logs: i, groupedLogs: a };
    },
    { logs: [], groupedLogs: {} }
  );
}
S(aa, "getAllDecodedLogs");
var Pn, Td = (Pn = class {
  /**
   * Constructor for `TransactionResponse`.
   */
  constructor(t, e, n, s, i) {
    /** Transaction ID */
    Q(this, "id");
    /** Current provider */
    Q(this, "provider");
    /** Gas used on the transaction */
    Q(this, "gasUsed", I(0));
    /** The graphql Transaction with receipts object. */
    Q(this, "gqlTransaction");
    Q(this, "request");
    Q(this, "status");
    Q(this, "abis");
    Q(this, "submitTxSubscription");
    Q(this, "preConfirmationStatus");
    Q(this, "waitingForStreamData", !1);
    Q(this, "statusResolvers", /* @__PURE__ */ new Map());
    let a, o, d, A;
    typeof t == "object" && "provider" in t && arguments.length === 1 ? (a = t.transactionRequestOrId, o = t.provider, d = t.chainId, A = t.abis, this.submitTxSubscription = t.submitAndAwaitSubscription) : (a = t, o = e, d = n, A = s, this.submitTxSubscription = i), typeof a == "string" ? this.id = a : (this.id = a.getTransactionId(d), this.request = a), this.provider = o, this.abis = A, this.waitForResult = this.waitForResult.bind(this), this.waitForPreConfirmation = this.waitForPreConfirmation.bind(this);
  }
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(t, e, n) {
    const s = await e.getChainId(), i = new Pn(t, e, s, n);
    return await i.fetch(), i;
  }
  applyMalleableSubscriptionFields(t) {
    const e = this.status;
    if (!e)
      return;
    const n = t;
    (e.type === "SuccessStatus" || e.type === "FailureStatus") && (n.inputs = n.inputs.map((s, i) => {
      var a;
      if ("txPointer" in s) {
        const o = (a = e.transaction.inputs) == null ? void 0 : a[i];
        return {
          ...s,
          txPointer: Xn.decodeFromGqlScalar(o.txPointer)
        };
      }
      return s;
    }), n.outputs = e.transaction.outputs.map(Kf), e.transaction.receiptsRoot && (n.receiptsRoot = e.transaction.receiptsRoot));
  }
  async getTransaction() {
    if (this.request) {
      const i = this.request.toTransaction();
      return this.applyMalleableSubscriptionFields(i), {
        tx: i,
        bytes: this.request.toTransactionBytes()
      };
    }
    const t = this.gqlTransaction ?? await this.fetch(), { rawPayload: e } = t, n = j(e), [s] = new sr().decode(n, 0);
    return {
      tx: s,
      bytes: n
    };
  }
  /**
   *
   * NOTE: This method is only called within `getTransactionSummary`, which is invoked after `getTransaction`.
   * Since `getTransaction` only resolves once the transaction has been processed,
   * the status at this point is guaranteed to be either `SuccessStatus` or `FailureStatus`.
   */
  getReceipts() {
    const t = this.getTransactionStatus();
    switch (t == null ? void 0 : t.type) {
      case "SuccessStatus":
      case "FailureStatus":
        return t.receipts.map(Se);
      default:
        return [];
    }
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const t = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!t.transaction) {
      const e = await this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange: n } of e)
        if (n) {
          this.status = n;
          break;
        }
      return this.fetch();
    }
    return this.gqlTransaction = t.transaction, t.transaction;
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(t) {
    const { tx: e, bytes: n } = await this.getTransaction(), { gasPerByte: s, gasPriceFactor: i, gasCosts: a, maxGasPerTx: o } = await this.provider.getGasConfig(), d = this.getTransactionStatus(), p = zg(d) ? I(0) : await this.provider.getLatestGasPrice(), g = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs, y = await this.provider.getBaseAssetId();
    return Ui({
      id: this.id,
      receipts: this.getReceipts(),
      transaction: e,
      transactionBytes: n,
      gqlTransactionStatus: d,
      gasPerByte: s,
      gasPriceFactor: i,
      abiMap: t,
      maxInputs: g,
      gasCosts: a,
      maxGasPerTx: o,
      gasPrice: p,
      baseAssetId: y
    });
  }
  async getPreConfirmationTransactionSummary(t) {
    const e = await this.provider.getBaseAssetId(), n = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
    return Xg({
      id: this.id,
      gqlTransactionStatus: this.preConfirmationStatus || this.status,
      baseAssetId: e,
      maxInputs: n,
      abiMap: t,
      transactionRequest: this.request
    });
  }
  resolveStatus(t) {
    (this.statusResolvers.get(t) || []).forEach((n) => n()), this.statusResolvers.delete(t);
  }
  async waitForStatus(t) {
    return new Promise((e, n) => {
      const s = this.statusResolvers.get(t) || [];
      s.push(() => {
        e();
      }), this.statusResolvers.set(t, s), this.waitForStatusChange().catch(n);
    });
  }
  /**
   * Waits for the status change of the transaction.
   * If the transaction is already in a final state, it will return immediately.
   * If the transaction is not in a final state, it will wait for the status change.
   * If we are already subscribed to the status change, it will return immediately.
   */
  async waitForStatusChange() {
    var n;
    const t = (n = this.status) == null ? void 0 : n.type;
    if (t && (t === "FailureStatus" || t === "SuccessStatus")) {
      this.resolveStatus("preConfirmation"), this.resolveStatus("confirmation");
      return;
    }
    if (this.waitingForStreamData)
      return;
    this.waitingForStreamData = !0;
    const e = this.submitTxSubscription ?? await this.provider.operations.statusChange({
      transactionId: this.id,
      includePreConfirmation: !0
    });
    for await (const s of e) {
      const i = "statusChange" in s ? s.statusChange : s.submitAndAwaitStatus;
      if (this.status = i, i.type === "SqueezedOutStatus")
        throw new x(
          L.TRANSACTION_SQUEEZED_OUT,
          `Transaction Squeezed Out with reason: ${i.reason}`
        );
      if ((i.type === "PreconfirmationSuccessStatus" || i.type === "PreconfirmationFailureStatus") && (this.preConfirmationStatus = i, this.resolveStatus("preConfirmation"), !this.statusResolvers.get("confirmation"))) {
        this.waitingForStreamData = !1;
        break;
      }
      if (i.type === "SuccessStatus" || i.type === "FailureStatus") {
        this.resolveStatus("confirmation"), this.resolveStatus("preConfirmation"), this.waitingForStreamData = !1;
        break;
      }
    }
  }
  async waitForConfirmationStatuses() {
    try {
      await this.waitForStatus("confirmation");
    } catch (t) {
      throw this.unsetResourceCache(), t;
    }
  }
  async waitForPreConfirmationStatuses() {
    try {
      await this.waitForStatus("preConfirmation");
    } catch (t) {
      throw this.unsetResourceCache(), t;
    }
  }
  /**
   * Assembles the result of a transaction by retrieving the transaction summary,
   * decoding logs (if available), and handling transaction failure.
   *
   * This method can be used to obtain the result of a transaction that has just
   * been submitted or one that has already been processed.
   *
   * @template TTransactionType - The type of the transaction.
   * @param contractsAbiMap - The map of contract ABIs.
   * @returns - The assembled transaction result.
   * @throws If the transaction status is a failure.
   */
  async assembleResult(t) {
    const e = await this.getTransactionSummary(t), n = {
      ...e
    };
    let { logs: s, groupedLogs: i } = { logs: [], groupedLogs: {} }, a;
    this.abis && ({ logs: s, groupedLogs: i } = aa({
      receipts: e.receipts,
      mainAbi: this.abis.main,
      externalAbis: this.abis.otherContractsAbis
    }), n.logs = s, n.groupedLogs = i, a = this.abis);
    const { receipts: o } = n, d = this.getTransactionStatus();
    if ((d == null ? void 0 : d.type) === "FailureStatus") {
      const { reason: A } = d;
      throw wu({
        receipts: o,
        statusReason: A,
        logs: s,
        groupedLogs: i,
        abis: a
      });
    }
    return n;
  }
  async assemblePreConfirmationResult(t) {
    const e = await this.getPreConfirmationTransactionSummary(t), n = {
      ...e,
      logs: [],
      groupedLogs: {}
    };
    let { logs: s, groupedLogs: i } = { logs: [], groupedLogs: {} };
    return this.abis && e.receipts && ({ logs: s, groupedLogs: i } = aa({
      receipts: e.receipts,
      mainAbi: this.abis.main,
      externalAbis: this.abis.otherContractsAbis
    }), n.logs = s, n.groupedLogs = i), n;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(t) {
    return await this.waitForConfirmationStatuses(), this.unsetResourceCache(), this.assembleResult(t);
  }
  /**
   * Waits for the transaction's pre-confirmation and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns The pre-confirmed transaction result
   */
  async waitForPreConfirmation(t) {
    return await this.waitForPreConfirmationStatuses(), this.unsetResourceCache(), this.assemblePreConfirmationResult(t);
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(t) {
    return this.waitForResult(t);
  }
  unsetResourceCache() {
    var t;
    (t = this.provider.cache) == null || t.unset(this.id);
  }
  getTransactionStatus() {
    var t;
    return this.status ?? ((t = this.gqlTransaction) == null ? void 0 : t.status);
  }
}, S(Pn, "TransactionResponse"), Pn);
function Hg(r, t, e = {}) {
  let n = "";
  return t.programType === "contract" && (n = r.find(
    (i) => i.type === At.Call && i.id === St
  ).to), r.reduce((s, i) => {
    if (i.type === At.LogData || i.type === At.Log) {
      const a = i.id === St || n === i.id;
      if (a || e[i.id]) {
        const d = a ? new Je(t) : new Je(e[i.id]), A = i.type === At.Log ? new rt("u64").encode(i.ra) : i.data;
        let p;
        try {
          [p] = d.decodeLog(A, i.rb.toString());
        } catch {
          p = { __decoded: !1, data: A, logId: i.rb.toString() };
        }
        s.push(p);
      }
    }
    return s;
  }, []);
}
S(Hg, "getDecodedLogs");
function xu(r, t) {
  const e = r.baseDelay ?? 150;
  switch (r.backoff) {
    case "linear":
      return e * t;
    case "fixed":
      return e;
    case "exponential":
    default:
      return 2 ** (t - 1) * e;
  }
}
S(xu, "getWaitDelay");
function Ru(r, t, e = 0) {
  return t === void 0 ? r : async (...n) => {
    var s;
    try {
      return await r(...n);
    } catch (i) {
      const a = i;
      if (((s = a.cause) == null ? void 0 : s.code) !== "ECONNREFUSED")
        throw a;
      const o = e + 1;
      if (o > t.maxRetries)
        throw a;
      const d = xu(t, o);
      return await Gd(d), Ru(r, t, o)(...n);
    }
  };
}
S(Ru, "autoRetryFetch");
var B2 = /* @__PURE__ */ S(async (r) => {
  var i;
  const { response: t, isSubscription: e } = r;
  let n;
  const s = t.clone();
  if (e) {
    const a = (i = s.body) == null ? void 0 : i.getReader(), { event: o } = await Cd.readEvent(a);
    n = o == null ? void 0 : o.extensions;
  } else
    n = (await s.json()).extensions;
  return {
    extensions: n
  };
}, "parseGraphqlResponse"), es = /* @__PURE__ */ S((r) => {
  const { paginationLimit: t, inputArgs: e = {} } = r, { first: n, last: s, after: i, before: a } = e;
  if (i && a)
    throw new x(
      L.INVALID_INPUT_PARAMETERS,
      'Pagination arguments "after" and "before" cannot be used together'
    );
  if ((n || 0) > t || (s || 0) > t)
    throw new x(
      L.INVALID_INPUT_PARAMETERS,
      `Pagination limit for this query cannot exceed ${t} items`
    );
  if (n && a)
    throw new x(
      L.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "first" with "before" is not supported'
    );
  if (s && i)
    throw new x(
      L.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "last" with "after" is not supported'
    );
  return !n && !s && (e.first = t), e;
}, "validatePaginationArgs"), d_ = 10, u_ = 512, Vg = 60, v2 = 100, x2 = 1e4, R2 = 5, S2 = 2e4, T2 = 1.2, F2 = [
  "submit",
  "submitAndAwaitStatus",
  "produceBlocks"
], st, bo, Wg, Fd = (st = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(t, e = {}) {
    Ce(this, bo);
    Q(this, "operations");
    Q(this, "cache");
    /** @hidden */
    Q(this, "url");
    /** @hidden */
    Q(this, "urlWithoutAuth");
    /** @hidden */
    Q(this, "consensusParametersTimestamp");
    Q(this, "options", {
      timeout: void 0,
      resourceCacheTTL: void 0,
      fetch: void 0,
      retryOptions: void 0,
      headers: void 0,
      cache: void 0
    });
    const { url: n, urlWithoutAuth: s, headers: i } = st.extractBasicAuth(t);
    this.url = n, this.urlWithoutAuth = s, this.url = t;
    const { FUELS: a } = L_, o = { ...i, ...e.headers, Source: `ts-sdk-${a}` };
    this.options = {
      ...this.options,
      ...e,
      headers: o
    }, this.operations = this.createOperations();
    const { resourceCacheTTL: d, cache: A } = this.options;
    if (A) {
      const { consensusParametersTimestamp: p, chain: g, nodeInfo: y } = jx(A);
      this.consensusParametersTimestamp = p, st.chainInfoCache[this.urlWithoutAuth] = g, st.nodeInfoCache[this.urlWithoutAuth] = y;
    }
    Ge(d) ? d !== -1 ? this.cache = new o_(d) : this.cache = void 0 : this.cache = new o_(S2);
  }
  /**
   * @hidden
   * @param url - If provided, clears cache only for given url
   */
  static clearChainAndNodeCaches(t) {
    if (t) {
      delete st.inflightFetchChainAndNodeInfoRequests[t], delete st.chainInfoCache[t], delete st.nodeInfoCache[t], delete st.currentBlockHeightCache[t];
      return;
    }
    st.inflightFetchChainAndNodeInfoRequests = {}, st.nodeInfoCache = {}, st.chainInfoCache = {}, st.currentBlockHeightCache = {};
  }
  static extractOperationName(t) {
    var e;
    return (e = t == null ? void 0 : t.toString().match(/"operationName":"(.+)"/)) == null ? void 0 : e[1];
  }
  static isWriteOperation(t) {
    return F2.includes(this.extractOperationName(t));
  }
  static normalizeUrl(t) {
    return t.replace(/-sub$/, "");
  }
  static hasWriteOperationHappened(t) {
    return Ge(st.currentBlockHeightCache[this.normalizeUrl(t)]);
  }
  /**
   * @hidden
   */
  static getFetchFn(t) {
    const { retryOptions: e, timeout: n, headers: s } = t;
    return Ru(async (...i) => {
      const a = i[0], o = i[1], d = n ? AbortSignal.timeout(n) : void 0;
      let A = {
        ...o,
        signal: d,
        headers: { ...o == null ? void 0 : o.headers, ...s }
      };
      t.requestMiddleware && (A = await t.requestMiddleware(A)), st.ENABLE_RPC_CONSISTENCY && st.hasWriteOperationHappened(a) && st.applyBlockHeight(A, a);
      const p = await st.fetchAndProcessBlockHeight(a, A, t);
      if (p.body === null)
        throw new x(
          L.RESPONSE_BODY_EMPTY,
          "The response from the server is missing the body",
          { timestamp: (/* @__PURE__ */ new Date()).toISOString(), request: o, response: p }
        );
      return p;
    }, e);
  }
  static applyBlockHeight(t, e) {
    var i;
    const n = this.normalizeUrl(e), s = st.currentBlockHeightCache[n] ?? 0;
    t.body = (i = t.body) == null ? void 0 : i.toString().replace(/}$/, `,"extensions":{"required_fuel_block_height":${s}}}`);
  }
  static async fetchAndProcessBlockHeight(t, e, n) {
    const s = /* @__PURE__ */ S(() => n.fetch ? n.fetch(t, e, n) : fetch(t, e), "fetchFn");
    st.isWriteOperation(e.body) && !st.hasWriteOperationHappened(t) && (st.currentBlockHeightCache[st.normalizeUrl(t)] = 0);
    let a = await s();
    if (!st.ENABLE_RPC_CONSISTENCY)
      return a;
    const o = {
      maxRetries: 5,
      baseDelay: 500
    };
    for (let d = o.maxRetries; d > 0; --d) {
      if (a.body) {
        const { extensions: g } = await B2({
          response: a,
          isSubscription: t.endsWith("-sub")
        });
        if (st.setCurrentBlockHeight(t, g == null ? void 0 : g.current_fuel_block_height), !(g != null && g.fuel_block_height_precondition_failed))
          break;
      }
      const A = o.maxRetries - d + 1, p = xu(o, A);
      await Gd(p), a = await s();
    }
    return a;
  }
  static setCurrentBlockHeight(t, e) {
    const n = st.hasWriteOperationHappened(t);
    if (!Ge(e) || !n)
      return;
    const s = st.normalizeUrl(t);
    e > st.currentBlockHeightCache[s] && (st.currentBlockHeightCache[s] = e);
  }
  static extractBasicAuth(t) {
    let e;
    try {
      e = new URL(t);
    } catch (a) {
      throw new x(x.CODES.INVALID_URL, "Invalid URL provided.", { url: t }, a);
    }
    const n = e.username, s = e.password, i = `${e.origin}${e.pathname}`;
    return n && s ? {
      url: t,
      urlWithoutAuth: i,
      headers: { Authorization: `Basic ${btoa(`${n}:${s}`)}` }
    } : { url: t, urlWithoutAuth: t, headers: void 0 };
  }
  /**
   * Initialize Provider async stuff
   */
  async init() {
    return await this.fetchChainAndNodeInfo(), this;
  }
  /**
   * Returns the `chainInfo` for the current network.
   *
   * @returns the chain information configuration.
   */
  async getChain() {
    return await this.init(), st.chainInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns the `nodeInfo` for the current network.
   *
   * @returns the node information configuration.
   */
  async getNode() {
    return await this.init(), st.nodeInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  async getGasConfig() {
    await this.init();
    const {
      txParameters: { maxGasPerTx: t },
      predicateParameters: { maxGasPerPredicate: e },
      feeParameters: { gasPriceFactor: n, gasPerByte: s },
      gasCosts: i
    } = (await this.getChain()).consensusParameters;
    return {
      maxGasPerTx: t,
      maxGasPerPredicate: e,
      gasPriceFactor: n,
      gasPerByte: s,
      gasCosts: i
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   *
   * @param url - The URL to connect to.
   * @param options - Additional options for the provider.
   */
  async connect(t, e) {
    const { url: n, urlWithoutAuth: s, headers: i } = st.extractBasicAuth(t);
    this.url = n, this.urlWithoutAuth = s, this.options = e ?? this.options, this.options = { ...this.options, headers: { ...this.options.headers, ...i } }, this.operations = this.createOperations(), await this.init();
  }
  /**
   * Return the chain and node information.
   * @param ignoreCache - If true, ignores the cache and re-fetch configs.
   * @returns A promise that resolves to the Chain and NodeInfo.
   */
  async fetchChainAndNodeInfo(t = !1) {
    const e = st.nodeInfoCache[this.urlWithoutAuth], n = st.chainInfoCache[this.urlWithoutAuth];
    if (e && n && !t)
      return { nodeInfo: e, chain: n };
    const i = st.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];
    if (i)
      return i.then((o) => (this.consensusParametersTimestamp = o.consensusParametersTimestamp, {
        nodeInfo: st.nodeInfoCache[this.urlWithoutAuth],
        chain: st.chainInfoCache[this.urlWithoutAuth]
      }));
    const a = this.operations.getChainAndNodeInfo().then((o) => ({
      chain: Ed(o.chain),
      nodeInfo: Bd(o.nodeInfo),
      consensusParametersTimestamp: Date.now()
    })).then((o) => (st.setIncompatibleNodeVersionMessage(o.nodeInfo), st.chainInfoCache[this.urlWithoutAuth] = o.chain, st.nodeInfoCache[this.urlWithoutAuth] = o.nodeInfo, this.consensusParametersTimestamp = o.consensusParametersTimestamp, o)).catch((o) => {
      const d = new x(
        x.CODES.CONNECTION_REFUSED,
        "Unable to fetch chain and node info from the network",
        { url: this.urlWithoutAuth },
        o
      );
      throw d.cause = { code: "ECONNREFUSED" }, d;
    }).finally(() => {
      delete st.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];
    });
    return st.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth] = a, st.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth].then((o) => (this.consensusParametersTimestamp = o.consensusParametersTimestamp, {
      nodeInfo: st.nodeInfoCache[this.urlWithoutAuth],
      chain: st.chainInfoCache[this.urlWithoutAuth]
    }));
  }
  /**
   * @hidden
   */
  static setIncompatibleNodeVersionMessage(t) {
    const { isMajorSupported: e, isMinorSupported: n, supportedVersion: s } = P_(t.nodeVersion);
    (!e || !n) && (st.incompatibleNodeVersionMessage = [
      `The Fuel Node that you are trying to connect to is using fuel-core version ${t.nodeVersion}.`,
      `The TS SDK currently supports fuel-core version ${s}.`,
      "Things may not work as expected."
    ].join(`
`), Cd.incompatibleNodeVersionMessage = st.incompatibleNodeVersionMessage);
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   * @hidden
   */
  createOperations() {
    const t = st.getFetchFn(this.options), e = new dv(this.urlWithoutAuth, {
      fetch: /* @__PURE__ */ S((i, a) => t(i.toString(), a || {}, this.options), "fetch"),
      responseMiddleware: /* @__PURE__ */ S((i) => {
        if ("response" in i) {
          const a = i.response;
          qf(
            a.errors,
            st.incompatibleNodeVersionMessage
          );
        }
      }, "responseMiddleware")
    }), n = /* @__PURE__ */ S((i, a) => {
      const o = i.definitions.find((A) => A.kind === "OperationDefinition");
      return (o == null ? void 0 : o.operation) === "subscription" ? Cd.create({
        url: this.urlWithoutAuth,
        query: i,
        fetchFn: /* @__PURE__ */ S((A, p) => t(A, p, this.options), "fetchFn"),
        variables: a,
        operationName: o.name.value,
        onEvent: /* @__PURE__ */ S((A) => {
          var p;
          st.setCurrentBlockHeight(
            this.urlWithoutAuth,
            (p = A.extensions) == null ? void 0 : p.current_fuel_block_height
          );
        }, "onEvent")
      }) : e.request(i, a);
    }, "executeQuery"), s = /* @__PURE__ */ S((i) => ({
      getBlobs(a) {
        const o = a.blobIds.map((g, y) => `$blobId${y}: BlobId!`).join(", "), d = a.blobIds.map((g, y) => `blob${y}: blob(id: $blobId${y}) { id }`).join(`
`), A = a.blobIds.reduce(
          (g, y, v) => (g[`blobId${v}`] = y, g),
          {}
        ), p = $`
          query getBlobs(${o}) {
            ${d}
          }
        `;
        return i(p, A);
      }
    }), "customOperations");
    return { ...jf(n), ...s(n) };
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion: t }
    } = await this.operations.getVersion();
    return t;
  }
  /**
   * Returns the latest block number.
   *
   * @returns A promise that resolves to the latest block number.
   */
  async getBlockNumber() {
    const {
      chain: {
        latestBlock: { height: t }
      }
    } = await this.operations.getLatestBlockHeight();
    return I(t);
  }
  /**
   * Returns the node information for the current provider network.
   *
   * @returns a promise that resolves to the node information.
   */
  async fetchNode() {
    const { nodeInfo: t } = await this.operations.getNodeInfo(), e = Bd(t);
    return st.nodeInfoCache[this.urlWithoutAuth] = e, e;
  }
  /**
   * Returns the chain information for the current provider network.
   *
   * @returns a promise that resolves to the chain information.
   */
  async fetchChain() {
    const { chain: t } = await this.operations.getChain(), e = Ed(t);
    return st.chainInfoCache[this.urlWithoutAuth] = e, e;
  }
  /**
   * Returns the chain ID for the current provider network.
   *
   * @returns A promise that resolves to the chain ID number.
   */
  async getChainId() {
    const {
      consensusParameters: { chainId: t }
    } = await this.getChain();
    return t.toNumber();
  }
  /**
   * Returns the base asset ID for the current provider network.
   *
   * @returns the base asset ID.
   */
  async getBaseAssetId() {
    const t = await this.getChain(), {
      consensusParameters: { baseAssetId: e }
    } = t;
    return e;
  }
  /**
   * Retrieves the details of an asset given its ID.
   *
   * @param assetId - The unique identifier of the asset.
   * @returns A promise that resolves to an object containing the asset details.
   */
  async getAssetDetails(t) {
    const { assetMetadata: e } = await this.getNodeFeatures();
    if (!e)
      throw new x(
        L.UNSUPPORTED_FEATURE,
        "The current node does not supports fetching asset details"
      );
    const { assetDetails: n } = await this.operations.getAssetDetails({ assetId: t });
    if (!n)
      return null;
    const { contractId: s, subId: i, totalSupply: a } = n ?? {};
    return {
      subId: i ?? "",
      contractId: s ?? "",
      totalSupply: I(a)
    };
  }
  /**
   * @hidden
   */
  async validateTransaction(t) {
    const {
      consensusParameters: {
        txParameters: { maxInputs: e, maxOutputs: n }
      }
    } = await this.getChain();
    if (I(t.inputs.length).gt(e))
      throw new x(
        L.MAX_INPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${t.inputs.length}, max inputs: ${e}`
      );
    if (I(t.outputs.length).gt(n))
      throw new x(
        L.MAX_OUTPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${t.outputs.length}, max outputs: ${n}`
      );
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response object.
   */
  async sendTransaction(t, {
    enableAssetBurn: e,
    estimateTxDependencies: n = !0,
    includePreConfirmation: s = !0
  } = {}) {
    const i = Oe(t);
    dg(
      await this.getBaseAssetId(),
      i,
      e
    ), n && await this.estimateTxDependencies(i), await this.validateTransaction(i);
    const a = W(i.toTransactionBytes());
    let o;
    An(i) && (o = i.abis);
    const d = await this.operations.submitAndAwaitStatus({
      encodedTransaction: a,
      includePreConfirmation: !0
    });
    un(this, bo, Wg).call(this, i.inputs, i.getTransactionId(await this.getChainId()));
    const A = await this.getChainId();
    return new Td({
      transactionRequestOrId: i,
      provider: this,
      chainId: A,
      abis: o,
      submitAndAwaitSubscription: d
    });
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider call parameters (optional).
   * @returns A promise that resolves to the call result object.
   */
  async dryRun(t, { utxoValidation: e, estimateTxDependencies: n = !0 } = {}) {
    const s = Oe(t);
    if (n)
      return this.estimateTxDependencies(s);
    const i = W(s.toTransactionBytes()), { dryRun: a } = await this.operations.dryRun({
      encodedTransactions: i,
      utxoValidation: e || !1
    }), [{ receipts: o, status: d }] = a;
    return { receipts: o.map(Se), dryRunStatus: d };
  }
  /**
   * Estimates the gas usage for predicates in a transaction request.
   *
   * @template T - The type of the transaction request object.
   *
   * @param transactionRequest - The transaction request to estimate predicates for.
   * @returns A promise that resolves to the updated transaction request with estimated gas usage for predicates.
   */
  async estimatePredicates(t) {
    if (!t.inputs.some(
      (a) => n_(a) && I(a.predicateGasUsed).isZero()
    ))
      return t;
    const n = W(t.toTransactionBytes()), s = await this.operations.estimatePredicates({
      encodedTransaction: n
    }), { estimatePredicates: i } = s;
    return t = this.parseEstimatePredicatesResponse(
      t,
      i
    ), t;
  }
  /**
   * Estimates the gas price and predicates for a given transaction request and block horizon.
   *
   * @param transactionRequest - The transaction request to estimate predicates and gas price for.
   * @param blockHorizon - The block horizon to use for gas price estimation.
   * @returns A promise that resolves to an object containing the updated transaction
   * request and the estimated gas price.
   */
  async estimatePredicatesAndGasPrice(t, e) {
    if (!t.inputs.some(
      (a) => n_(a) && I(a.predicateGasUsed).isZero()
    )) {
      const a = await this.estimateGasPrice(e);
      return { transactionRequest: t, gasPrice: a };
    }
    const {
      estimateGasPrice: { gasPrice: s },
      estimatePredicates: i
    } = await this.operations.estimatePredicatesAndGasPrice({
      blockHorizon: String(e),
      encodedTransaction: W(t.toTransactionBytes())
    });
    return t = this.parseEstimatePredicatesResponse(
      t,
      i
    ), { transactionRequest: t, gasPrice: I(s) };
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @param gasPrice - The gas price to use for the transaction, if not provided it will be fetched.
   * @returns A promise that resolves to the estimate transaction dependencies.
   */
  async estimateTxDependencies(t, { gasPrice: e } = {}) {
    if (_2(t))
      return {
        rawReceipts: [],
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    let n = [], s = [];
    const i = [];
    let a = 0, o;
    await this.validateTransaction(t);
    const d = e ?? await this.estimateGasPrice(10);
    for (let A = 0; A < d_; A++) {
      const {
        dryRun: [{ receipts: p, status: g }]
      } = await this.operations.dryRun({
        encodedTransactions: [W(t.toTransactionBytes())],
        utxoValidation: !1,
        gasPrice: d.toString()
      });
      n = p, s = p.map(Se), o = g;
      const { missingOutputVariables: y, missingOutputContractIds: v } = r_(s);
      if ((y.length !== 0 || v.length !== 0) && An(t)) {
        a += y.length, t.addVariableOutputs(y.length), v.forEach(({ contractId: F }) => {
          t.addContractInputAndOutput(new wt(F)), i.push(F);
        });
        const { maxFee: E } = await this.estimateTxGasAndFee({
          transactionRequest: t,
          gasPrice: d
        });
        t.maxFee = E;
      } else
        break;
    }
    return {
      rawReceipts: n,
      receipts: s,
      outputVariables: a,
      missingContractIds: i,
      dryRunStatus: o
    };
  }
  /**
   * Dry runs multiple transactions and checks for missing dependencies in batches.
   *
   * Transactions are dry run in batches. After each dry run, transactions requiring
   * further modifications are identified. The method iteratively updates these transactions
   * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @returns A promise that resolves to an array of results for each transaction.
   */
  async estimateMultipleTxDependencies(t) {
    const e = t.map(() => ({
      rawReceipts: [],
      receipts: [],
      outputVariables: 0,
      missingContractIds: [],
      dryRunStatus: void 0
    })), n = ve(t), s = /* @__PURE__ */ new Map();
    n.forEach((o, d) => {
      An(o) && s.set(d, W(o.toTransactionBytes()));
    });
    let i = Array.from(s.keys()), a = 0;
    for (; i.length > 0 && a < d_; ) {
      const o = i.map(
        (p) => s.get(p)
      ), d = await this.operations.dryRun({
        encodedTransactions: o,
        utxoValidation: !1
      }), A = [];
      for (let p = 0; p < d.dryRun.length; p++) {
        const g = i[p], { receipts: y, status: v } = d.dryRun[p], N = e[g];
        N.receipts = y.map(Se), N.dryRunStatus = v;
        const { missingOutputVariables: E, missingOutputContractIds: F } = r_(
          N.receipts
        ), k = E.length > 0 || F.length > 0, H = n[g];
        if (k && An(H)) {
          N.outputVariables += E.length, H.addVariableOutputs(E.length), F.forEach(({ contractId: D }) => {
            H.addContractInputAndOutput(new wt(D)), N.missingContractIds.push(D);
          });
          const { maxFee: X } = await this.estimateTxGasAndFee({
            transactionRequest: H
          });
          H.maxFee = X, s.set(g, W(H.toTransactionBytes())), A.push(g);
        }
      }
      i = A, a += 1;
    }
    return e;
  }
  /**
   * Dry runs multiple transactions.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @param sendTransactionParams - The provider call parameters (optional).
   *
   * @returns A promise that resolves to an array of results for each transaction call.
   */
  async dryRunMultipleTransactions(t, { utxoValidation: e, estimateTxDependencies: n = !0 } = {}) {
    if (n)
      return this.estimateMultipleTxDependencies(t);
    const s = t.map((o) => W(o.toTransactionBytes())), { dryRun: i } = await this.operations.dryRun({
      encodedTransactions: s,
      utxoValidation: e || !1
    });
    return i.map(({ receipts: o, status: d }) => ({ receipts: o.map(Se), dryRunStatus: d }));
  }
  async autoRefetchConfigs() {
    var a;
    if (Date.now() - (this.consensusParametersTimestamp ?? 0) < 6e4)
      return;
    if (!((a = st.chainInfoCache) != null && a[this.urlWithoutAuth])) {
      await this.fetchChainAndNodeInfo(!0);
      return;
    }
    const n = st.chainInfoCache[this.urlWithoutAuth], {
      latestBlock: {
        header: { consensusParametersVersion: s }
      }
    } = n, {
      chain: {
        latestBlock: {
          header: { consensusParametersVersion: i }
        }
      }
    } = await this.operations.getConsensusParametersVersion();
    s !== i && await this.fetchChainAndNodeInfo(!0);
  }
  /**
   * Estimates the transaction gas and fee based on the provided transaction request.
   * @param params - The parameters for estimating the transaction gas and fee.
   * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
   */
  async estimateTxGasAndFee(t) {
    const { transactionRequest: e, gasPrice: n } = t;
    let s = n;
    await this.autoRefetchConfigs();
    const i = await this.getChain(), { gasPriceFactor: a, maxGasPerTx: o } = await this.getGasConfig(), d = e.calculateMinGas(i);
    Ge(s) || (s = await this.estimateGasPrice(10));
    const A = on({
      gasPrice: I(s),
      gas: d,
      priceFactor: a,
      tip: e.tip
    }).add(1);
    let p = I(0);
    An(e) && (p = e.gasLimit, e.gasLimit.eq(0) && (e.gasLimit = d, e.gasLimit = o.sub(
      e.calculateMaxGas(i, d)
    ), p = e.gasLimit));
    const g = e.calculateMaxGas(i, d), y = on({
      gasPrice: I(s),
      gas: g,
      priceFactor: a,
      tip: e.tip
    }).add(1);
    return {
      minGas: d,
      minFee: A,
      maxGas: g,
      maxFee: y,
      gasPrice: s,
      gasLimit: p
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result object.
   */
  async simulate(t, { estimateTxDependencies: e = !0 } = {}) {
    const n = Oe(t);
    if (e)
      return this.estimateTxDependencies(n);
    const s = [W(n.toTransactionBytes())], { dryRun: i } = await this.operations.dryRun({
      encodedTransactions: s,
      utxoValidation: !0
    });
    return { receipts: i.map((o) => {
      const { id: d, receipts: A, status: p } = o, g = A.map(Se);
      return { id: d, receipts: g, status: p };
    })[0].receipts };
  }
  /**
   * @hidden
   *
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.
   */
  async getTransactionCost(t, { signatureCallback: e, gasPrice: n } = {}) {
    const s = ve(Oe(t)), i = s.maxFee.eq(0), a = An(s);
    a && (s.gasLimit = I(0));
    const o = ve(s);
    let d = 0;
    if (e && An(o)) {
      const P = o.witnesses.length;
      await e(o), d = o.witnesses.length - P;
    }
    let A;
    n ? (A = n, await this.estimatePredicates(o)) : { gasPrice: A } = await this.estimatePredicatesAndGasPrice(o, 10), s.updatePredicateGasUsed(o.inputs);
    let { maxFee: p, maxGas: g, minFee: y, minGas: v, gasLimit: N } = await this.estimateTxGasAndFee({
      // Fetches and returns a gas price
      transactionRequest: o,
      gasPrice: A
    }), E = [], F = [], k, H = [], X = 0, D = I(0);
    if (s.maxFee = p, a) {
      if (s.gasLimit = N, e && await e(s), { rawReceipts: E, receipts: F, missingContractIds: H, outputVariables: X, dryRunStatus: k } = await this.estimateTxDependencies(s, { gasPrice: A }), k && "reason" in k)
        throw this.extractDryRunError(s, F, k.reason);
      const { maxGasPerTx: P } = await this.getGasConfig(), U = Pi(F);
      D = I(U.muln(T2)).max(P.sub(v)), s.gasLimit = D, { maxFee: p, maxGas: g, minFee: y, minGas: v } = await this.estimateTxGasAndFee({
        transactionRequest: s,
        gasPrice: A
      });
    }
    const M = {
      gasPrice: A.toString(),
      receipts: E
    };
    return {
      rawReceipts: E,
      receipts: F,
      gasUsed: D,
      gasPrice: A,
      minGas: v,
      maxGas: g,
      minFee: y,
      maxFee: p,
      outputVariables: X,
      missingContractIds: H,
      addedSignatures: d,
      estimatedPredicates: s.inputs,
      dryRunStatus: k,
      updateMaxFee: i,
      transactionSummary: M
    };
  }
  /**
   * Assembles a transaction by completely estimating and funding it.
   *
   * @param params - Parameters used to assemble the transaction.
   *
   * @returns The assembled transaction request, estimated gas price, and receipts
   */
  async assembleTx(t) {
    var D, M, P;
    const {
      request: e,
      reserveGas: n,
      resourcesIdsToIgnore: s,
      feePayerAccount: i,
      blockHorizon: a = 10,
      estimatePredicates: o = !0,
      accountCoinQuantities: d = []
    } = t, A = /* @__PURE__ */ new Set(), p = await this.getBaseAssetId();
    let g = -1, y;
    const v = d.map((U, z) => {
      const { amount: G, assetId: Y, account: Z = i, changeOutputAccount: q } = U, R = q ? q.address.toB256() : Z.address.toB256();
      A.add(Z.address.toB256());
      const u = {
        change: R
      };
      return Y === p && (y = u.change), Z.address.equals(i.address) && (g = z), {
        account: Kh(Z),
        amount: I(G).toString(10),
        assetId: Y,
        changePolicy: u
      };
    });
    g === -1 && (A.add(i.address.toB256()), g = v.push({
      account: Kh(i),
      amount: I(0).toString(10),
      // Since the correct fee amount cannot be determined yet, we can use 0
      assetId: p,
      changePolicy: {
        change: y || i.address.toB256()
      }
    }) - 1);
    const N = await this.adjustResourcesToIgnoreForAddresses(
      Array.from(A),
      s
    ), {
      assembleTx: { status: E, transaction: F, gasPrice: k }
    } = await this.operations.assembleTx({
      tx: W(e.toTransactionBytes()),
      blockHorizon: String(a),
      feeAddressIndex: String(g),
      requiredBalances: v,
      estimatePredicates: o,
      excludeInput: N,
      reserveGas: n ? I(n).toString(10) : void 0
    });
    if (E.type === "DryRunFailureStatus") {
      const U = E.receipts.map(Se);
      throw this.extractDryRunError(e, U, E.reason);
    }
    e.witnesses = F.witnesses || e.witnesses, e.inputs = ((D = F.inputs) == null ? void 0 : D.map(qx)) || e.inputs, e.outputs = ((M = F.outputs) == null ? void 0 : M.map($x)) || e.outputs, (P = F.policies) != null && P.maxFee && (e.maxFee = I(F.policies.maxFee)), e.type === Ct.Script && (e.gasLimit = I(F.scriptGasLimit).add(I(n)));
    const H = E.receipts, X = await this.getChainId();
    return e.updateState(X, "funded", {
      gasPrice: k.toString(),
      receipts: H
    }), {
      assembledRequest: e,
      gasPrice: I(k),
      receipts: E.receipts.map(Se),
      rawReceipts: H
    };
  }
  /**
   * Returns coins for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get (optional).
   * @param paginationArgs - Pagination arguments (optional).
   *
   * @returns A promise that resolves to the coins.
   */
  async getCoins(t, e, n) {
    const s = new wt(t), {
      coins: { edges: i, pageInfo: a }
    } = await this.operations.getCoins({
      ...es({
        paginationLimit: u_,
        inputArgs: n
      }),
      filter: { owner: s.toB256(), assetId: e && W(e) }
    });
    return {
      coins: i.map(({ node: d }) => ({
        id: d.utxoId,
        assetId: d.assetId,
        amount: I(d.amount),
        owner: s,
        blockCreated: I(d.blockCreated),
        txCreatedIdx: I(d.txCreatedIdx)
      })),
      pageInfo: a
    };
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The coin quantities to get.
   * @param resourcesIdsToIgnore - IDs of excluded resources from the selection (optional).
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(t, e, n) {
    const s = new wt(t), i = await this.adjustResourcesToIgnoreForAddresses(
      [s.b256Address],
      n
    ), a = {
      owner: s.toB256(),
      queryPerAsset: e.map(Au).map(({ assetId: A, amount: p, max: g }) => ({
        assetId: W(A),
        amount: (p.eqn(0) ? I(1) : p).toString(10),
        max: g ? g.toString(10) : void 0
      })),
      excludedIds: i
    };
    return (await this.operations.getCoinsToSpend(a)).coinsToSpend.flat().map((A) => {
      switch (A.type) {
        case "MessageCoin":
          return {
            amount: I(A.amount),
            assetId: A.assetId,
            daHeight: I(A.daHeight),
            sender: new wt(A.sender),
            recipient: new wt(A.recipient),
            nonce: A.nonce
          };
        case "Coin":
          return {
            id: A.utxoId,
            amount: I(A.amount),
            assetId: A.assetId,
            owner: s,
            blockCreated: I(A.blockCreated),
            txCreatedIdx: I(A.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((A) => !!A);
  }
  /**
   * Returns an array of blobIds that exist on chain, for a given array of blobIds.
   *
   * @param blobIds - blobIds to check.
   * @returns - A promise that resolves to an array of blobIds that exist on chain.
   */
  async getBlobs(t) {
    const e = await this.operations.getBlobs({ blobIds: t }), n = [];
    return Object.keys(e).forEach((s) => {
      const i = e[s];
      n.push((i == null ? void 0 : i.id) ?? null);
    }), n.filter((s) => s);
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block or null.
   */
  async getBlock(t) {
    let e;
    if (t === "latest") {
      const {
        chain: { latestBlock: o }
      } = await this.operations.getLatestBlock();
      e = o;
    } else {
      const d = typeof t == "string" && zn(t) ? { blockId: t } : { height: I(t).toString(10) };
      e = (await this.operations.getBlock(d)).block;
    }
    if (!e)
      return null;
    const { header: n, height: s, id: i, transactions: a } = e;
    return {
      id: i,
      height: I(s),
      time: n.time,
      header: {
        applicationHash: n.applicationHash,
        daHeight: I(n.daHeight),
        eventInboxRoot: n.eventInboxRoot,
        messageOutboxRoot: n.messageOutboxRoot,
        prevRoot: n.prevRoot,
        stateTransitionBytecodeVersion: n.stateTransitionBytecodeVersion,
        transactionsCount: n.transactionsCount,
        transactionsRoot: n.transactionsRoot
      },
      transactionIds: a.map((o) => o.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(t) {
    const {
      blocks: { edges: e, pageInfo: n }
    } = await this.operations.getBlocks({
      ...es({
        paginationLimit: R2,
        inputArgs: t
      })
    });
    return { blocks: e.map(({ node: i }) => ({
      id: i.id,
      height: I(i.height),
      time: i.header.time,
      header: {
        applicationHash: i.header.applicationHash,
        daHeight: I(i.header.daHeight),
        eventInboxRoot: i.header.eventInboxRoot,
        messageOutboxRoot: i.header.messageOutboxRoot,
        prevRoot: i.header.prevRoot,
        stateTransitionBytecodeVersion: i.header.stateTransitionBytecodeVersion,
        transactionsCount: i.header.transactionsCount,
        transactionsRoot: i.header.transactionsRoot
      },
      transactionIds: i.transactions.map((a) => a.id)
    })), pageInfo: n };
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(t) {
    let e;
    typeof t == "number" ? e = { blockHeight: I(t).toString(10) } : t === "latest" ? e = { blockHeight: (await this.getBlockNumber()).toString() } : typeof t == "string" && zn(t) ? e = { blockId: t } : e = { blockHeight: I(t).toString() };
    const { block: n } = await this.operations.getBlockWithTransactions(e);
    return n ? {
      id: n.id,
      height: I(n.height, 10),
      time: n.header.time,
      header: {
        applicationHash: n.header.applicationHash,
        daHeight: I(n.header.daHeight),
        eventInboxRoot: n.header.eventInboxRoot,
        messageOutboxRoot: n.header.messageOutboxRoot,
        prevRoot: n.header.prevRoot,
        stateTransitionBytecodeVersion: n.header.stateTransitionBytecodeVersion,
        transactionsCount: n.header.transactionsCount,
        transactionsRoot: n.header.transactionsRoot
      },
      transactionIds: n.transactions.map((s) => s.id),
      transactions: n.transactions.map(
        (s) => {
          var i;
          return (i = new sr().decode(j(s.rawPayload), 0)) == null ? void 0 : i[0];
        }
      )
    } : null;
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(t) {
    var n;
    const { transaction: e } = await this.operations.getTransaction({ transactionId: t });
    if (!e)
      return null;
    try {
      return (n = new sr().decode(
        j(e.rawPayload),
        0
      )) == null ? void 0 : n[0];
    } catch (s) {
      if (s instanceof x && s.code === L.UNSUPPORTED_TRANSACTION_TYPE)
        return console.warn("Unsupported transaction type encountered"), null;
      throw s;
    }
  }
  /**
   * Retrieves transactions based on the provided pagination arguments.
   * @param paginationArgs - The pagination arguments for retrieving transactions.
   * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
   */
  async getTransactions(t) {
    const {
      transactions: { edges: e, pageInfo: n }
    } = await this.operations.getTransactions({
      ...es({
        inputArgs: t,
        paginationLimit: Vg
      })
    }), s = new sr();
    return { transactions: e.map(({ node: { rawPayload: a } }) => {
      try {
        return s.decode(j(a), 0)[0];
      } catch (o) {
        if (o instanceof x && o.code === L.UNSUPPORTED_TRANSACTION_TYPE)
          return console.warn("Unsupported transaction type encountered"), null;
        throw o;
      }
    }).filter((a) => a !== null), pageInfo: n };
  }
  /**
   * Fetches a compressed block at the specified height.
   *
   * @param height - The height of the block to fetch.
   * @returns The compressed block if available, otherwise `null`.
   */
  async daCompressedBlock(t) {
    const { daCompressedBlock: e } = await this.operations.daCompressedBlock({
      height: t
    });
    return e || null;
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(t) {
    const { contract: e } = await this.operations.getContract({ contractId: t });
    return e || null;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(t, e) {
    const { contractBalance: n } = await this.operations.getContractBalance({
      contract: new wt(t).toB256(),
      asset: W(e)
    });
    return I(n.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(t, e) {
    const { balance: n } = await this.operations.getBalanceV2({
      owner: new wt(t).toB256(),
      assetId: W(e)
    });
    return I(n.amountU128, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the balances.
   */
  async getBalances(t, e) {
    let n = { first: x2 };
    const { balancesPagination: s } = await this.getNodeFeatures();
    s && (n = es({
      inputArgs: e,
      paginationLimit: v2
    }));
    const {
      balances: { edges: i, pageInfo: a }
    } = await this.operations.getBalancesV2({
      ...n,
      filter: { owner: new wt(t).toB256() },
      supportsPagination: s
    });
    return {
      balances: i.map(({ node: d }) => ({
        assetId: d.assetId,
        amount: I(d.amountU128)
      })),
      ...s ? { pageInfo: a } : {}
    };
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the messages.
   */
  async getMessages(t, e) {
    const {
      messages: { edges: n, pageInfo: s }
    } = await this.operations.getMessages({
      ...es({
        inputArgs: e,
        paginationLimit: u_
      }),
      owner: new wt(t).toB256()
    });
    return {
      messages: n.map(({ node: a }) => ({
        messageId: bn.getMessageId({
          sender: a.sender,
          recipient: a.recipient,
          nonce: a.nonce,
          amount: I(a.amount),
          data: a.data
        }),
        sender: new wt(a.sender),
        recipient: new wt(a.recipient),
        nonce: a.nonce,
        amount: I(a.amount),
        data: bn.decodeData(a.data),
        daHeight: I(a.daHeight)
      })),
      pageInfo: s
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id (optional).
   * @param commitBlockHeight - The commit block height (optional).
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(t, e, n, s) {
    let i = {
      transactionId: t,
      nonce: e
    };
    if (n && s)
      throw new x(
        L.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    n && (i = {
      ...i,
      commitBlockId: n
    }), s && (i = {
      ...i,
      // Convert BN into a number string required on the query
      // This should probably be fixed on the fuel client side
      commitBlockHeight: s.toNumber().toString()
    });
    const a = await this.operations.getMessageProof(i), {
      messageProof: o,
      messageBlockHeader: d,
      commitBlockHeader: A,
      blockProof: p,
      sender: g,
      recipient: y,
      amount: v,
      data: N
    } = a.messageProof;
    return {
      messageProof: {
        proofIndex: I(o.proofIndex),
        proofSet: o.proofSet
      },
      blockProof: {
        proofIndex: I(p.proofIndex),
        proofSet: p.proofSet
      },
      messageBlockHeader: {
        id: d.id,
        daHeight: I(d.daHeight),
        transactionsCount: Number(d.transactionsCount),
        transactionsRoot: d.transactionsRoot,
        height: I(d.height),
        prevRoot: d.prevRoot,
        time: d.time,
        applicationHash: d.applicationHash,
        messageReceiptCount: Number(d.messageReceiptCount),
        messageOutboxRoot: d.messageOutboxRoot,
        consensusParametersVersion: Number(d.consensusParametersVersion),
        eventInboxRoot: d.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(d.stateTransitionBytecodeVersion)
      },
      commitBlockHeader: {
        id: A.id,
        daHeight: I(A.daHeight),
        transactionsCount: Number(A.transactionsCount),
        transactionsRoot: A.transactionsRoot,
        height: I(A.height),
        prevRoot: A.prevRoot,
        time: A.time,
        applicationHash: A.applicationHash,
        messageReceiptCount: Number(A.messageReceiptCount),
        messageOutboxRoot: A.messageOutboxRoot,
        consensusParametersVersion: Number(A.consensusParametersVersion),
        eventInboxRoot: A.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(A.stateTransitionBytecodeVersion)
      },
      sender: new wt(g),
      recipient: new wt(y),
      nonce: e,
      amount: I(v),
      data: N
    };
  }
  /**
   * Get the latest gas price from the node.
   *
   * @returns A promise that resolves to the latest gas price.
   */
  async getLatestGasPrice() {
    const { latestGasPrice: t } = await this.operations.getLatestGasPrice();
    return I(t.gasPrice);
  }
  /**
   * Returns the estimate gas price for the given block horizon.
   *
   * @param blockHorizon - The block horizon to estimate gas price for.
   * @returns A promise that resolves to the estimated gas price.
   */
  async estimateGasPrice(t) {
    const { estimateGasPrice: e } = await this.operations.estimateGasPrice({
      blockHorizon: String(t)
    });
    return I(e.gasPrice);
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(t) {
    return (await this.operations.getMessageStatus({ nonce: t })).messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce.
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(t, e) {
    const { produceBlocks: n } = await this.operations.produceBlocks({
      blocksToProduce: I(t).toString(10),
      startTimestamp: e ? K_.fromUnixMilliseconds(e).toTai64() : void 0
    });
    return I(n);
  }
  /**
   * Check if the given ID is an account.
   *
   * @param id - The ID to check.
   * @returns A promise that resolves to the result of the check.
   */
  async isUserAccount(t) {
    return await this.getAddressType(t) === "Account";
  }
  /**
   * Determines the type of address based on the provided ID.
   *
   * @param id - The ID to be checked.
   * @returns A promise that resolves to a string indicating the type of address.
   */
  async getAddressType(t) {
    const { contract: e, blob: n, transaction: s } = await this.operations.isUserAccount({
      blobId: t,
      contractId: t,
      transactionId: t
    });
    if (e)
      return "Contract";
    if (n)
      return "Blob";
    if (s)
      return "Transaction";
    try {
      if (await this.getAssetDetails(t))
        return "Asset";
    } catch {
    }
    return "Account";
  }
  /**
   * Get the transaction response for the given transaction ID.
   *
   * @param transactionId - The transaction ID to get the response for.
   * @returns A promise that resolves to the transaction response.
   */
  async getTransactionResponse(t) {
    const e = await this.getChainId();
    return new Td({
      transactionRequestOrId: t,
      provider: this,
      chainId: e
    });
  }
  /**
   * Returns Message for given nonce.
   *
   * @param nonce - The nonce of the message to retrieve.
   * @returns A promise that resolves to the Message object or null.
   */
  async getMessageByNonce(t) {
    const { message: e } = await this.operations.getMessageByNonce({ nonce: t });
    return e ? {
      messageId: bn.getMessageId({
        sender: e.sender,
        recipient: e.recipient,
        nonce: t,
        amount: I(e.amount),
        data: e.data
      }),
      sender: new wt(e.sender),
      recipient: new wt(e.recipient),
      nonce: t,
      amount: I(e.amount),
      data: bn.decodeData(e.data),
      daHeight: I(e.daHeight)
    } : null;
  }
  /**
   * Get the relayed transaction for the given transaction ID.
   *
   * @param relayedTransactionId - The relayed transaction ID to get the response for.
   * @returns A promise that resolves to the relayed transaction.
   */
  async getRelayedTransactionStatus(t) {
    const { relayedTransactionStatus: e } = await this.operations.getRelayedTransactionStatus({
      relayedTransactionId: t
    });
    return e || null;
  }
  /**
   * @hidden
   */
  extractDryRunError(t, e, n) {
    let s = [], i = {}, a;
    return t.type === Ct.Script && t.abis && ({ logs: s, groupedLogs: i } = aa({
      receipts: e,
      mainAbi: t.abis.main,
      externalAbis: t.abis.otherContractsAbis
    }), a = t.abis), wu({
      logs: s,
      groupedLogs: i,
      receipts: e,
      statusReason: n,
      abis: a
    });
  }
  /**
   * @hidden
   */
  async getNodeFeatures() {
    const { indexation: t } = await this.getNode();
    return {
      assetMetadata: !!(t != null && t.assetMetadata),
      balancesPagination: !!(t != null && t.balances),
      coinsToSpend: !!(t != null && t.coinsToSpend)
    };
  }
  /**
   * @hidden
   */
  parseEstimatePredicatesResponse(t, { inputs: e }) {
    return e && e.forEach((n, s) => {
      n && "predicateGasUsed" in n && I(n.predicateGasUsed).gt(0) && (t.inputs[s].predicateGasUsed = n.predicateGasUsed);
    }), t;
  }
  /**
   * @hidden
   *
   * This helper adjusts the resources to be excluded for a given set of addresses.
   * Supporting multiple addresses is important because of the `assembleTx` method,
   * which may be invoked with different addresses. It handles both messages and UTXOs,
   * ensuring the total number of inputs does not exceed the maximum allowed by the chain's
   * consensus parameters. The resources specified in the `resourcesIdsToIgnore` parameter have priority
   * over those retrieved from the cache.
   */
  async adjustResourcesToIgnoreForAddresses(t, e) {
    var s, i;
    const n = {
      messages: ((s = e == null ? void 0 : e.messages) == null ? void 0 : s.map((a) => W(a))) || [],
      utxos: ((i = e == null ? void 0 : e.utxos) == null ? void 0 : i.map((a) => W(a))) || []
    };
    if (this.cache) {
      const a = this.cache, o = t.map((p) => a.getActiveData(p)), {
        consensusParameters: {
          txParameters: { maxInputs: d }
        }
      } = await this.getChain(), A = d.toNumber();
      for (let p = 0; p < o.length; p++) {
        let g = n.utxos.length + n.messages.length;
        if (g >= A || (n.utxos = [...n.utxos, ...o[p].utxos.slice(0, A - g)], g = n.utxos.length + n.messages.length, g >= A))
          break;
        n.messages = [...n.messages, ...o[p].messages.slice(0, A - g)];
      }
    }
    return n;
  }
}, bo = new WeakSet(), /**
 * @hidden
 */
Wg = function(t, e) {
  this.cache && this.cache.set(e, t);
}, S(st, "Provider"), /**
 * Governs whether to include the required block height in the request body
 * for block-sensitive operations like when submitting a transaction.
 *
 * This ensures that the operation is executed at the correct block height,
 * regardless of which node in the network the request is routed to.
 *
 * `true` by default.
 */
Q(st, "ENABLE_RPC_CONSISTENCY", !0), /** @hidden */
Q(st, "inflightFetchChainAndNodeInfoRequests", {}), /** @hidden */
Q(st, "chainInfoCache", {}), /** @hidden */
Q(st, "nodeInfoCache", {}), /** @hidden */
Q(st, "currentBlockHeightCache", {}), /** @hidden */
Q(st, "incompatibleNodeVersionMessage", ""), st);
async function N2(r) {
  const { id: t, provider: e, abiMap: n } = r, { transaction: s } = await e.operations.getTransactionWithReceipts({
    transactionId: t
  });
  if (!s)
    throw new x(
      L.TRANSACTION_NOT_FOUND,
      `Transaction not found for given id: ${t}.`
    );
  const [i] = new sr().decode(
    j(s.rawPayload),
    0
  );
  let a = [];
  s != null && s.status && "receipts" in s.status && (a = s.status.receipts);
  const o = a.map(Se), {
    consensusParameters: {
      feeParameters: { gasPerByte: d, gasPriceFactor: A },
      txParameters: { maxInputs: p, maxGasPerTx: g },
      gasCosts: y
    }
  } = await e.getChain(), N = zg(s.status) ? I(0) : await e.getLatestGasPrice(), E = await e.getBaseAssetId();
  return {
    ...Ui({
      id: s.id,
      receipts: o,
      transaction: i,
      transactionBytes: j(s.rawPayload),
      gqlTransactionStatus: s.status,
      gasPerByte: I(d),
      gasPriceFactor: I(A),
      abiMap: n,
      maxInputs: p,
      gasCosts: y,
      maxGasPerTx: g,
      gasPrice: N,
      baseAssetId: E
    })
  };
}
S(N2, "getTransactionSummary");
async function Q2(r) {
  const { provider: t, transactionRequest: e, abiMap: n } = r, { receipts: s } = await t.dryRun(e), { gasPerByte: i, gasPriceFactor: a, gasCosts: o, maxGasPerTx: d } = await t.getGasConfig(), A = (await t.getChain()).consensusParameters.txParameters.maxInputs, p = e.toTransaction(), g = e.toTransactionBytes(), y = await t.getLatestGasPrice(), v = await t.getBaseAssetId();
  return Ui({
    id: e.getTransactionId(await t.getChainId()),
    receipts: s,
    transaction: p,
    transactionBytes: g,
    abiMap: n,
    gasPerByte: i,
    gasPriceFactor: a,
    maxInputs: A,
    gasCosts: o,
    maxGasPerTx: d,
    gasPrice: y,
    baseAssetId: v
  });
}
S(Q2, "getTransactionSummaryFromRequest");
async function D2(r) {
  const { filters: t, provider: e, abiMap: n } = r, { owner: s, ...i } = t, a = es({
    inputArgs: i,
    paginationLimit: Vg
  }), { transactionsByOwner: o } = await e.operations.getTransactionsByOwner({
    ...a,
    owner: s
  }), { edges: d, pageInfo: A } = o, {
    consensusParameters: {
      feeParameters: { gasPerByte: p, gasPriceFactor: g },
      txParameters: { maxInputs: y, maxGasPerTx: v },
      gasCosts: N
    }
  } = await e.getChain(), E = await e.getLatestGasPrice(), F = await e.getBaseAssetId();
  return {
    transactions: d.map((H) => {
      const { node: X } = H, { id: D, rawPayload: M, status: P } = X, [U] = new sr().decode(j(M), 0);
      let z = [];
      X != null && X.status && "receipts" in X.status && (z = X.status.receipts);
      const G = z.map(Se);
      return {
        ...Ui({
          id: D,
          receipts: G,
          transaction: U,
          transactionBytes: j(M),
          gqlTransactionStatus: P,
          abiMap: n,
          gasPerByte: p,
          gasPriceFactor: g,
          maxInputs: y,
          gasCosts: N,
          maxGasPerTx: v,
          gasPrice: E,
          baseAssetId: F
        })
      };
    }),
    pageInfo: A
  };
}
S(D2, "getTransactionsSummaries");
var yS = /* @__PURE__ */ S(async (r) => {
  const { provider: t, transactionSummary: e } = r, { id: n, transactionBytes: s, gasPrice: i, receipts: a } = e, {
    consensusParameters: {
      baseAssetId: o,
      txParameters: { maxInputs: d, maxGasPerTx: A },
      feeParameters: { gasPriceFactor: p, gasPerByte: g },
      gasCosts: y
    }
  } = await t.getChain(), v = j(s), [N] = new sr().decode(v, 0);
  return Ui({
    id: n,
    transaction: N,
    transactionBytes: v,
    receipts: a.map(Se),
    gasPrice: I(i),
    // From chain
    baseAssetId: o,
    maxInputs: d,
    gasCosts: y,
    maxGasPerTx: A,
    gasPerByte: g,
    gasPriceFactor: p
  });
}, "assembleTransactionSummaryFromJson"), bS = /* @__PURE__ */ S(async (r) => {
  const { id: t, status: e, abis: n, request: s, provider: i, gqlTransaction: a, preConfirmationStatus: o } = r;
  return {
    id: t,
    status: e,
    abis: n,
    requestJson: s ? JSON.stringify(s.toJSON()) : void 0,
    providerUrl: i.url,
    providerCache: await $f(i),
    gqlTransaction: a,
    preConfirmationStatus: o
  };
}, "serializeTransactionResponseJson"), IS = /* @__PURE__ */ S((r) => {
  const {
    id: t,
    abis: e,
    status: n,
    providerUrl: s,
    requestJson: i,
    providerCache: a,
    gqlTransaction: o,
    preConfirmationStatus: d
  } = r, A = new Fd(s, { cache: a }), { chainId: p } = a.chain.consensusParameters, g = new Td({
    transactionRequestOrId: t,
    provider: A,
    chainId: Number(p),
    abis: e
  });
  return i && (g.request = Oe(JSON.parse(i))), g.status = n, g.gqlTransaction = o, g.preConfirmationStatus = d, g;
}, "deserializeTransactionResponseJson"), oi, O2 = (oi = class {
}, S(oi, "AbstractAccount"), oi), M2 = [L.MAX_COINS_REACHED], Nd = /* @__PURE__ */ S(async (r) => {
  const { error: t, account: e, skipAutoConsolidation: n = !1 } = r;
  if (n)
    return !1;
  const s = x.parse(t);
  if (M2.includes(s.code)) {
    const { assetId: i, owner: a } = s.metadata;
    return e.startConsolidation({
      owner: a,
      assetId: i
    });
  }
  return !1;
}, "consolidateCoinsIfRequired"), Jc = /* @__PURE__ */ S(async (r, t) => {
  var i;
  const e = [];
  let n = !0, s;
  for (; n; ) {
    const { coins: a, pageInfo: o } = await r.getCoins(t, { after: s });
    e.push(...a), s = (i = a.pop()) == null ? void 0 : i.id, n = o.hasNextPage;
  }
  return { coins: e };
}, "getAllCoins"), A_ = /* @__PURE__ */ S(({ coins: r }) => r.sort((t, e) => e.amount.cmp(t.amount)), "sortCoins"), P2 = /* @__PURE__ */ S((r) => {
  const { transactionId: t, outputs: e, baseAssetId: n } = r, s = e.findIndex(
    (o) => o.type === lt.Change && o.assetId === n
  );
  if (s === -1)
    throw new x(L.UNKNOWN, "No change output found");
  const i = e[s], a = Number(s).toString().padStart(4, "0");
  return {
    id: `${t}${a}`,
    assetId: i.assetId,
    amount: i.amount,
    owner: new wt(i.to),
    blockCreated: I(0),
    txCreatedIdx: I(0)
  };
}, "createOuputCoin"), L2 = /* @__PURE__ */ S(async ({
  account: r,
  assetId: t
}) => {
  const e = await r.provider.getChain(), n = e.consensusParameters.chainId.toNumber(), s = await r.provider.estimateGasPrice(10), i = e.consensusParameters.txParameters.maxInputs.toNumber(), a = await r.provider.getBaseAssetId(), o = t === a, d = i, A = i;
  let p = [], g = [];
  if (o) {
    const E = await Jc(r, a).then(A_);
    p = E.slice(0, A), g = E.slice(A);
  } else
    p = await Jc(r, a).then(A_).then((E) => E.slice(0, A)), g = await Jc(r, t).then(({ coins: E }) => E);
  if (p.length === 0)
    throw new x(
      L.INSUFFICIENT_FUNDS,
      `Insufficient funds to consolidate.
	Asset ID: ${a}
	Owner: ${r.address.toB256()}`
    );
  const v = [
    ...Dh(d, p),
    // We leave one coin for the funding coin
    ...Dh(d - 1, g)
  ].map((E) => {
    const F = new Ir({
      scriptData: "0x"
    });
    return F.addResources(E), F;
  }), N = /* @__PURE__ */ S(async (E = {}) => {
    var H;
    const F = [];
    let k;
    for (let X = 0; X < v.length; X++) {
      let D = v[X];
      const M = X + 1;
      if (k) {
        const G = P2({
          transactionId: k.transactionId,
          outputs: k.outputs,
          baseAssetId: a
        });
        D.addResource(G);
      }
      "populateTransactionPredicateData" in r && typeof r.populateTransactionPredicateData == "function" && (D = r.populateTransactionPredicateData(D), D = await r.provider.estimatePredicates(D));
      const P = on({
        gasPrice: s,
        gas: D.calculateMinGas(e),
        priceFactor: e.consensusParameters.feeParameters.gasPriceFactor,
        tip: D.tip
      });
      D.maxFee = P, D.gasLimit = I(1e3), (H = E.onTransactionStart) == null || H.call(E, {
        tx: D,
        step: M,
        assetId: t,
        transactionId: D.getTransactionId(n)
      });
      const U = await r.sendTransaction(D), z = await U.waitForResult();
      F.push(z), k = {
        transactionId: U.id,
        outputs: z.transaction.outputs
      };
    }
    return {
      txResponses: F,
      errors: []
    };
  }, "submitAll");
  return {
    txs: v,
    totalFeeCost: v.reduce((E, F) => E.add(F.maxFee), I(0)),
    submitAll: N
  };
}, "consolidateCoins"), k2 = /* @__PURE__ */ S((r) => {
  const t = new rt("u64");
  return r.reduce((e, n) => {
    const { assetId: s, amount: i, contractId: a } = n, o = t.encode(i), d = ct([new wt(a).toBytes(), o, j(s)]);
    return ct([e, d]);
  }, new Uint8Array());
}, "formatTransferToContractScriptData"), U2 = /* @__PURE__ */ S(async (r) => {
  const t = k2(r);
  await Io();
  let e = new Uint8Array();
  return r.forEach((n, s) => {
    const i = (Ad + ht + na) * s;
    e = ct([
      e,
      // Load ScriptData into register 0x10.
      x_(16, 0, S_.ScriptData).to_bytes(),
      // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.
      Er(17, 16, i).to_bytes(),
      // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.
      Er(18, 17, Ad).to_bytes(),
      // Load word to the amount at 0x12 into register 0x13.
      ea(19, 18, 0).to_bytes(),
      // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.
      Er(20, 18, ht).to_bytes(),
      // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.
      B_(17, 19, 20).to_bytes()
    ]);
  }), e = ct([e, Pd(1).to_bytes()]), { script: e, scriptData: t };
}, "assembleTransferToContractScript"), l_ = /* @__PURE__ */ S((r, t) => {
  const e = Math.ceil(r.length / t), n = [];
  for (let s = 0; s < e; s += 1) {
    const i = s * t, a = (s + 1) * t;
    n.push(r.slice(i, a));
  }
  return n;
}, "splitCoinsIntoBatches"), G2 = 5, ci, $o = (ci = class extends O2 {
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   * @param connector - A FuelConnector instance (optional).
   */
  constructor(e, n, s) {
    super();
    /**
     * The address associated with the account.
     */
    Q(this, "address");
    /**
     * The provider used to interact with the network.
     */
    Q(this, "_provider");
    /**
     * The connector for use with external wallets
     */
    Q(this, "_connector");
    /**
     * Prepares a function to submit all transactions either sequentially or in parallel.
     *
     * @param params - The parameters for preparing the submitAll callback.
     *
     * @returns A callback that, when called, submits all transactions and returns their results and any errors encountered.
     */
    Q(this, "prepareSubmitAll", /* @__PURE__ */ S((e) => {
      const { txs: n, mode: s = "sequential" } = e;
      return async () => {
        const i = [], a = [];
        if (s === "sequential")
          for (const o of n)
            try {
              const A = await (await this.sendTransaction(o)).waitForResult();
              i.push(A);
            } catch (d) {
              a.push(d);
            }
        else
          (await Promise.allSettled(
            n.map(async (d) => (await this.sendTransaction(d)).waitForResult())
          )).forEach((d) => {
            d.status === "fulfilled" ? i.push(d.value) : a.push(d.reason);
          });
        return { txResponses: i, errors: a };
      };
    }, "prepareSubmitAll"));
    this._provider = n, this._connector = s, this.address = new wt(e);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider)
      throw new x(L.MISSING_PROVIDER, "Provider not set");
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(e) {
    this._provider = e;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(e) {
    return this._provider = e, this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - Quantities of resources to be obtained.
   * @param resourcesIdsToIgnore - IDs of resources to be excluded from the query (optional).
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(e, n, { skipAutoConsolidation: s } = {}) {
    const i = /* @__PURE__ */ S(() => this.provider.getResourcesToSpend(this.address, e, n), "getResourcesToSpend");
    try {
      return await i();
    } catch (a) {
      if (!await Nd({
        error: a,
        account: this,
        skipAutoConsolidation: s
      }))
        throw a;
      return await i();
    }
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve (optional).
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(e, n) {
    return this.provider.getCoins(this.address, e, n);
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages(e) {
    return this.provider.getMessages(this.address, e);
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for (optional).
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(e) {
    const n = e ?? await this.provider.getBaseAssetId();
    return await this.provider.getBalance(this.address, n);
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    return this.provider.getBalances(this.address);
  }
  /**
   * Funds a transaction request by adding the necessary resources.
   *
   * @typeParam T - The type of the TransactionRequest.
   * @param request - The transaction request to fund.
   * @param params - The estimated transaction parameters.
   * @returns A promise that resolves to the funded transaction request.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.
   */
  async fund(e, n, { skipAutoConsolidation: s } = {}) {
    var P;
    const {
      addedSignatures: i,
      estimatedPredicates: a,
      requiredQuantities: o,
      updateMaxFee: d,
      gasPrice: A,
      transactionSummary: p
    } = n, g = await this.provider.getChainId(), y = e.maxFee, v = await this.provider.getBaseAssetId(), N = ((P = o.find((U) => U.assetId === v)) == null ? void 0 : P.amount) || I(0), E = B1({
      amount: I(y),
      assetId: v,
      coinQuantities: o
    }), F = {};
    E.forEach(({ amount: U, assetId: z }) => {
      F[z] = {
        required: U,
        owned: I(0)
      };
    }), e.inputs.filter(Wn).forEach((U) => {
      const G = fr(U) ? String(U.assetId) : v;
      F[G] && (F[G].owned = F[G].owned.add(U.amount));
    });
    let k = [];
    Object.entries(F).forEach(([U, { owned: z, required: G }]) => {
      z.lt(G) && k.push({
        assetId: U,
        amount: G.sub(z)
      });
    });
    let H = k.length > 0, X = 0;
    for (; H && X < G2; ) {
      const U = await this.getResourcesToSpend(
        k,
        c2(e.inputs, this.address),
        { skipAutoConsolidation: s }
      );
      e.addResources(U), e.updatePredicateGasUsed(a);
      const z = ve(e);
      if (i && Array.from({ length: i }).forEach(
        () => z.addEmptyWitness()
      ), !d) {
        H = !1;
        break;
      }
      const { maxFee: G } = await this.provider.estimateTxGasAndFee({
        transactionRequest: z,
        gasPrice: A
      }), Y = o2(
        e.inputs.filter(Wn),
        v,
        v
      ), Z = N.add(G);
      Y.gt(Z) ? H = !1 : k = [
        {
          amount: Z.sub(Y),
          assetId: v
        }
      ], X += 1;
    }
    if (H)
      throw new x(
        L.INSUFFICIENT_FUNDS,
        `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`
      );
    e.updateState(g, "funded", p), await this.provider.validateTransaction(e), e.updatePredicateGasUsed(a);
    const D = ve(e);
    if (i && Array.from({ length: i }).forEach(() => D.addEmptyWitness()), !d)
      return e;
    const { maxFee: M } = await this.provider.estimateTxGasAndFee({
      transactionRequest: D,
      gasPrice: A
    });
    return e.maxFee = M, e;
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(e, n, s, i = {}, { skipAutoConsolidation: a } = {}) {
    let o = new Ir(i);
    o = this.addTransfer(o, {
      destination: e,
      amount: n,
      assetId: s || await this.provider.getBaseAssetId()
    });
    const { gasPrice: d, transactionRequest: A } = await this.assembleTx({
      transactionRequest: o,
      skipAutoConsolidation: a
    });
    return o = await is({
      gasPrice: d,
      provider: this.provider,
      transactionRequest: A,
      setGasLimit: i == null ? void 0 : i.gasLimit,
      setMaxFee: i == null ? void 0 : i.maxFee
    }), o;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(e, n, s, i = {}, { skipAutoConsolidation: a } = {}) {
    const o = await this.createTransfer(e, n, s, i, {
      skipAutoConsolidation: a
    });
    return this.sendTransaction(o, { estimateTxDependencies: !1 });
  }
  /**
   * Transfers multiple amounts of a token to multiple recipients.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @param txParams - Optional transaction parameters.
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
   */
  async batchTransfer(e, n = {}, { skipAutoConsolidation: s } = {}) {
    let i = new Ir(n);
    i = this.addBatchTransfer(i, e);
    const { gasPrice: a, transactionRequest: o } = await this.assembleTx({
      transactionRequest: i,
      skipAutoConsolidation: s
    });
    return i = await is({
      gasPrice: a,
      provider: this.provider,
      transactionRequest: o,
      setGasLimit: n == null ? void 0 : n.gasLimit,
      setMaxFee: n == null ? void 0 : n.maxFee
    }), this.sendTransaction(i, { estimateTxDependencies: !1 });
  }
  /**
   * Adds a transfer to the given transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - The object representing the transfer to be made.
   * @returns The updated transaction request with the added transfer.
   */
  addTransfer(e, n) {
    const { destination: s, amount: i, assetId: a } = n;
    return this.validateTransferAmount(i), e.addCoinOutput(new wt(s), i, a), e;
  }
  /**
   * Adds multiple transfers to a script transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The updated script transaction request.
   */
  addBatchTransfer(e, n) {
    return n.forEach(({ destination: s, amount: i, assetId: a }) => {
      this.addTransfer(e, {
        destination: s,
        amount: i,
        assetId: a
      });
    }), e;
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(e, n, s, i = {}, { skipAutoConsolidation: a } = {}) {
    return this.batchTransferToContracts([{ amount: n, assetId: s, contractId: e }], i, {
      skipAutoConsolidation: a
    });
  }
  async batchTransferToContracts(e, n = {}, { skipAutoConsolidation: s } = {}) {
    let i = new Ir({
      ...n
    });
    const a = [], o = await this.provider.getBaseAssetId(), d = e.map((v) => {
      const N = I(v.amount), E = new wt(v.contractId), F = v.assetId ? W(v.assetId) : o;
      if (N.lte(0))
        throw new x(
          L.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      return i.addContractInputAndOutput(E), a.push({ amount: N, assetId: F }), {
        amount: N,
        contractId: E.toB256(),
        assetId: F
      };
    }), { script: A, scriptData: p } = await U2(d);
    i.script = A, i.scriptData = p;
    const { gasPrice: g, transactionRequest: y } = await this.assembleTx({
      transactionRequest: i,
      quantities: a,
      skipAutoConsolidation: s
    });
    return i = await is({
      gasPrice: g,
      provider: this.provider,
      transactionRequest: y,
      setGasLimit: n == null ? void 0 : n.gasLimit,
      setMaxFee: n == null ? void 0 : n.maxFee
    }), this.sendTransaction(i);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The transaction parameters (optional).
   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(e, n, s = {}, { skipAutoConsolidation: i } = {}) {
    const a = new wt(e), o = j(
      "0x".concat(a.toHexString().substring(2).padStart(64, "0"))
    ), d = j(
      "0x".concat(I(n).toHex().substring(2).padStart(16, "0"))
    ), p = { script: new Uint8Array([
      ...j(h2.bytes),
      ...o,
      ...d
    ]), ...s }, g = await this.provider.getBaseAssetId();
    let y = new Ir(p);
    const v = [{ amount: I(n), assetId: g }], { gasPrice: N, transactionRequest: E } = await this.assembleTx({
      transactionRequest: y,
      quantities: v,
      skipAutoConsolidation: i
    });
    return y = await is({
      gasPrice: N,
      provider: this.provider,
      transactionRequest: E,
      setGasLimit: s == null ? void 0 : s.gasLimit,
      setMaxFee: s == null ? void 0 : s.maxFee
    }), this.sendTransaction(y);
  }
  /**
   * Start the consolidation process
   *
   * @param owner - The B256 address of the owner.
   * @param assetId - The asset ID that requires consolidation.
   */
  async startConsolidation(e) {
    if (this._connector)
      return await this._connector.startConsolidation(e), !1;
    const { owner: n, assetId: s } = e;
    if (n !== this.address.toB256())
      return !1;
    const { submitAll: i } = await L2({ account: this, assetId: s });
    return await i(), !0;
  }
  /**
   * Consolidates base asset UTXOs into fewer, larger ones.
   *
   * Retrieves a limited number of base asset coins (as defined by `Provider.RESOURCES_PAGE_SIZE_LIMIT`),
   * assembles consolidation transactions, and submits them to the network.
   *
   * Note: This method currently supports only the base asset.
   *
   * @param params - The parameters for coin consolidation, including the asset ID, mode, and output number.
   * @returns A promise that resolves to the response of the submitted transactions.
   * @throws Will throw an error if the asset is not a base asset as non-base asset consolidation is not implemented.
   */
  async consolidateCoins(e) {
    const { assetId: n } = e, { coins: s } = await this.getCoins(n), a = await this.provider.getBaseAssetId() === n;
    let o;
    const d = {
      assetId: n,
      coins: s,
      mode: e.mode,
      outputNum: e.outputNum
    };
    return a ? { submitAll: o } = await this.assembleBaseAssetConsolidationTxs(d) : { submitAll: o } = await this.assembleNonBaseAssetConsolidationTxs(d), o();
  }
  /**
   * Assembles transactions for consolidating base asset coins into fewer UTXOs.
   *
   * This method splits the provided coins into batches and creates transaction requests
   * to consolidate them. It calculates the necessary fee and sets up the transactions
   * to be submitted either in parallel (default) or sequentially.
   *
   * @param params - The parameters for assembling base asset consolidation transactions.
   *
   * @returns An object containing the assembled transactions, the total fee cost, and a callback to submit all transactions.
   */
  async assembleBaseAssetConsolidationTxs(e) {
    const { coins: n, mode: s = "parallel", outputNum: i = 1 } = e, a = await this.provider.getBaseAssetId();
    this.validateConsolidationTxsCoins(n, a);
    const o = await this.provider.getChain(), d = o.consensusParameters.txParameters.maxInputs.toNumber();
    let A = I(0);
    const p = [], g = l_(n, d), y = await this.provider.estimateGasPrice(10), v = i > 1;
    g.filter((E) => E.length > 1).forEach((E) => {
      const F = new Ir({
        script: "0x"
      });
      F.addResources(E), v && Array.from({ length: i - 1 }).forEach(() => {
        F.addCoinOutput(this.address, 0, a);
      });
      const k = F.calculateMinGas(o), H = on({
        gasPrice: y,
        gas: k,
        priceFactor: o.consensusParameters.feeParameters.gasPriceFactor,
        tip: F.tip
      });
      if (F.maxFee = H, v) {
        const D = F.inputs.filter(fr).reduce((M, P) => M.add(P.amount), I(0)).div(i + 1);
        F.outputs.forEach((M) => {
          M.type === lt.Coin && (M.amount = D);
        });
      }
      A = A.add(H), p.push(F);
    });
    const N = this.prepareSubmitAll({ txs: p, mode: s });
    return { txs: p, totalFeeCost: A, submitAll: N };
  }
  async assembleNonBaseAssetConsolidationTxs(e) {
    const { assetId: n, coins: s, mode: i = "parallel", outputNum: a = 1 } = e;
    this.validateConsolidationTxsCoins(s, n);
    const o = await this.provider.getChain(), d = o.consensusParameters.txParameters.maxInputs.toNumber(), A = o.consensusParameters.baseAssetId, { coins: p } = await this.provider.getCoins(this.address, A);
    let g = I(0);
    const y = [], v = await this.provider.estimateGasPrice(10), N = a > 1, E = l_(s, d);
    E.filter((k) => k.length > 1).forEach((k) => {
      const H = new Ir({
        script: "0x"
      });
      H.addResources(k), N && Array.from({ length: a - 1 }).forEach(() => {
        H.addCoinOutput(this.address, 0, n);
      });
      const X = H.calculateMinGas(o), D = on({
        gasPrice: v,
        gas: X,
        priceFactor: o.consensusParameters.feeParameters.gasPriceFactor,
        tip: H.tip
      });
      if (H.maxFee = D, N) {
        const Z = H.inputs.filter(fr).reduce((q, R) => q.add(R.amount), I(0)).div(a + 1);
        H.outputs.forEach((q) => {
          q.type === lt.Coin && (q.amount = Z);
        });
      }
      g = g.add(D);
      const M = [];
      let P = I(0);
      for (; P.lt(D); ) {
        const Y = p.pop();
        if (!Y)
          break;
        M.push(Y), P = P.add(Y.amount);
      }
      const { inputs: U } = H;
      H.inputs = U.slice(0, d - M.length);
      const z = k.slice(d - M.length);
      H.addResources(M);
      const G = E[E.length - 1];
      G.push(...z), G.length > d && E.push(G.slice(d)), y.push(H);
    });
    const F = this.prepareSubmitAll({ txs: y, mode: i });
    return { txs: y, totalFeeCost: g, submitAll: F };
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   *
   * @deprecated Use provider.assembleTx instead
   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.
   */
  async getTransactionCost(e, { signatureCallback: n, quantities: s = [], gasPrice: i } = {}) {
    const a = ve(Oe(e)), o = await this.provider.getBaseAssetId(), d = a.getCoinOutputsQuantities(), A = za(d, s), p = [{ assetId: o, amount: I("100000000000000000") }], g = /* @__PURE__ */ S((N) => a.inputs.find((E) => E.type === xt.Coin ? E.assetId === N : og(E) ? o === N : !1), "findAssetInput"), y = /* @__PURE__ */ S((N, E) => {
      const F = g(N), k = E;
      F && "amount" in F ? F.amount = k : a.addResources(
        this.generateFakeResources([
          {
            amount: E,
            assetId: N
          }
        ])
      );
    }, "updateAssetInput");
    return za(A, p).forEach(
      ({ amount: N, assetId: E }) => y(E, N)
    ), {
      ...await this.provider.getTransactionCost(a, {
        signatureCallback: n,
        gasPrice: i
      }),
      requiredQuantities: A
    };
  }
  /**
   * Sign a message from the account via the connector.
   *
   * @param message - the message to sign.
   * @returns a promise that resolves to the signature.
   *
   * @hidden
   */
  async signMessage(e) {
    if (!this._connector)
      throw new x(L.MISSING_CONNECTOR, "A connector is required to sign messages.");
    return this._connector.signMessage(this.address.toString(), e);
  }
  /**
   * Signs a transaction from the account via the connector..
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature of the transaction.
   */
  async signTransaction(e, n = {}) {
    if (!this._connector)
      throw new x(
        L.MISSING_CONNECTOR,
        "A connector is required to sign transactions."
      );
    const s = Oe(e), { transactionRequest: i, connectorsSendTxParams: a } = await this.setTransactionStateForConnectors({
      transactionRequest: s,
      connectorOptions: n
    });
    return this._connector.signTransaction(
      this.address.toString(),
      i,
      a
    );
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(e, { estimateTxDependencies: n = !0, ...s } = {}) {
    const i = Oe(e);
    if (this._connector) {
      const a = await this.setTransactionStateForConnectors({
        transactionRequest: i,
        connectorOptions: s
      }), o = await this._connector.sendTransaction(
        this.address.toString(),
        a.transactionRequest,
        a.connectorsSendTxParams
      );
      return typeof o == "string" ? this.provider.getTransactionResponse(o) : o;
    }
    return n && await this.provider.estimateTxDependencies(i), this.provider.sendTransaction(i, {
      estimateTxDependencies: !1
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(e, { estimateTxDependencies: n = !0 } = {}) {
    const s = Oe(e);
    return n && await this.provider.estimateTxDependencies(s), this.provider.simulate(s, { estimateTxDependencies: !1 });
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(e) {
    return e.map((n) => ({
      id: W(ir(lo)),
      owner: this.address,
      blockCreated: I(1),
      txCreatedIdx: I(1),
      ...n
    }));
  }
  /** @hidden */
  async prepareTransactionForSend(e) {
    const { transactionId: n } = e.flag;
    if (!Ge(n))
      return e;
    const s = await this.provider.getChainId(), i = e.getTransactionId(s);
    return n !== i && e.updateState(s), e;
  }
  /** @hidden */
  async prepareTransactionSummary(e) {
    const n = await this.provider.getChainId();
    return Ge(e.flag.summary) ? {
      ...e.flag.summary,
      id: e.getTransactionId(n),
      transactionBytes: W(e.toTransactionBytes())
    } : void 0;
  }
  /** @hidden * */
  async assembleTx(e) {
    const { transactionRequest: n, quantities: s = [], skipAutoConsolidation: i } = e, a = n.outputs.filter((d) => d.type === lt.Coin).map(({ amount: d, assetId: A }) => ({ assetId: String(A), amount: I(d) }));
    n.gasLimit = I(0), n.maxFee = I(0);
    const o = /* @__PURE__ */ S(async () => {
      const { assembledRequest: d, gasPrice: A } = await this.provider.assembleTx({
        request: n,
        accountCoinQuantities: za(a, s),
        feePayerAccount: this
      });
      return { transactionRequest: d, gasPrice: A };
    }, "assembleTx");
    try {
      return await o();
    } catch (d) {
      if (!await Nd({
        error: d,
        account: this,
        skipAutoConsolidation: i
      }))
        throw d;
      return await o();
    }
  }
  /** @hidden * */
  validateTransferAmount(e) {
    if (I(e).lte(0))
      throw new x(
        L.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
  }
  /** @hidden * */
  validateConsolidationTxsCoins(e, n) {
    if (e.length <= 1)
      throw new x(L.NO_COINS_TO_CONSOLIDATE, "No coins to consolidate.");
    if (!e.every((s) => s.assetId === n))
      throw new x(
        L.COINS_ASSET_ID_MISMATCH,
        "All coins to consolidate must be from the same asset id."
      );
  }
  /** @hidden * */
  async setTransactionStateForConnectors(e) {
    const { transactionRequest: n, connectorOptions: s } = e, { onBeforeSend: i, skipCustomFee: a = !1 } = s, o = await this.prepareTransactionForSend(n), d = {
      onBeforeSend: i,
      skipCustomFee: a,
      provider: {
        url: this.provider.url,
        cache: await $f(this.provider)
      },
      transactionState: n.flag.state,
      transactionSummary: await this.prepareTransactionSummary(n)
    };
    return { transactionRequest: o, connectorsSendTxParams: d };
  }
}, S(ci, "Account"), ci), Ln, oa = (Ln = class {
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(t) {
    Q(this, "address");
    Q(this, "publicKey");
    Q(this, "compressedPublicKey");
    Q(this, "privateKey");
    typeof t == "string" && t.match(/^[0-9a-f]*$/i) && t.length === 64 && (t = `0x${t}`);
    const e = nr(t, 32);
    this.privateKey = W(e), this.publicKey = W(jr.getPublicKey(e, !1).slice(1)), this.compressedPublicKey = W(jr.getPublicKey(e, !0)), this.address = new wt(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(t) {
    const e = jr.sign(j(t), j(this.privateKey)), n = nr(`0x${e.r.toString(16)}`, 32), s = nr(`0x${e.s.toString(16)}`, 32);
    return s[0] |= (e.recovery || 0) << 7, W(ct([n, s]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(t) {
    const e = jr.ProjectivePoint.fromHex(j(this.compressedPublicKey)), n = jr.ProjectivePoint.fromHex(j(t));
    return `0x${e.add(n).toHex(!0)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(t, e) {
    const n = j(e), s = n.slice(0, 32), i = n.slice(32, 64), a = (i[0] & 128) >> 7;
    i[0] &= 127;
    const d = new jr.Signature(BigInt(W(s)), BigInt(W(i))).addRecoveryBit(
      a
    ).recoverPublicKey(j(t)).toRawBytes(!1).slice(1);
    return W(d);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(t, e) {
    return new wt(Ln.recoverPublicKey(t, e));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(t) {
    return t ? gr(ct([ir(32), j(t)])) : ir(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(t) {
    const e = jr.ProjectivePoint.fromHex(j(t));
    return W(e.toRawBytes(!1).slice(1));
  }
}, S(Ln, "Signer"), Ln), h_ = 13, __ = 8, p_ = 1, jc = 32, z2 = 16, f_ = /* @__PURE__ */ S((r) => /^0x/.test(r) ? r.slice(2) : r, "removeHexPrefix");
async function Yg(r, t, e) {
  const n = wn(f_(r), "hex"), s = new wt(t), i = ir(jc), a = Bp({
    password: wn(e),
    salt: i,
    dklen: jc,
    n: 2 ** h_,
    r: __,
    p: p_
  }), o = ir(z2), d = await cE(n, a, o), A = Uint8Array.from([...a.subarray(16, 32), ...d]), p = vp(A), g = Yi(p, "hex"), y = {
    id: AE(),
    version: 3,
    address: f_(s.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac: g,
      cipherparams: { iv: Yi(o, "hex") },
      ciphertext: Yi(d, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: jc,
        n: 2 ** h_,
        p: p_,
        r: __,
        salt: Yi(i, "hex")
      }
    }
  };
  return JSON.stringify(y);
}
S(Yg, "encryptKeystoreWallet");
async function Zg(r, t) {
  const e = JSON.parse(r), {
    crypto: {
      mac: n,
      ciphertext: s,
      cipherparams: { iv: i },
      kdfparams: { dklen: a, n: o, r: d, p: A, salt: p }
    }
  } = e, g = wn(s, "hex"), y = wn(i, "hex"), v = wn(p, "hex"), N = wn(t), E = Bp({
    password: N,
    salt: v,
    n: o,
    p: A,
    r: d,
    dklen: a
  }), F = Uint8Array.from([...E.subarray(16, 32), ...g]), k = vp(F), H = Yi(k, "hex");
  if (n !== H)
    throw new x(
      L.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  const X = await oE(g, E, y);
  return W(X);
}
S(Zg, "decryptKeystoreWallet");
var xn, X2 = (xn = class extends $o {
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(e, n) {
    const s = new oa(e);
    super(s.address, n);
    /**
     * A function that returns the wallet's signer.
     */
    Q(this, "signer");
    this.signer = () => s;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(e) {
    const n = await this.signer().sign(Sp(e));
    return W(n);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(e) {
    const n = Oe(e), s = await this.provider.getChainId(), i = n.getTransactionId(s), a = await this.signer().sign(i);
    return W(a);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(e) {
    const n = Oe(e), s = await this.signTransaction(n);
    return n.updateWitnessByOwner(this.address, s), n;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(e, { estimateTxDependencies: n = !1, enableAssetBurn: s } = {}) {
    const i = Oe(e);
    return dg(
      await this.provider.getBaseAssetId(),
      i,
      s
    ), n && await this.provider.estimateTxDependencies(i), this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(i),
      { estimateTxDependencies: !1, enableAssetBurn: s }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(e, { estimateTxDependencies: n = !0 } = {}) {
    const s = Oe(e);
    return n && await this.provider.estimateTxDependencies(s), this.provider.dryRun(
      await this.populateTransactionWitnessesSignature(s),
      {
        utxoValidation: !0,
        estimateTxDependencies: !1
      }
    );
  }
  /**
   * Encrypts an unlocked wallet with a password.
   *
   * @param password - the password to encrypt the wallet with.
   * @returns - the encrypted wallet.
   */
  async encrypt(e) {
    return Yg(this.privateKey, this.address, e);
  }
}, S(xn, "BaseWalletUnlocked"), /**
 * Default HDWallet path.
 */
Q(xn, "defaultPath", "m/44'/1179993420'/0'/0/0"), xn), Ta = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
], H2 = /* @__PURE__ */ ((r) => (r.english = "english", r))(H2 || {});
function Jg(r) {
  return (1 << r) - 1;
}
S(Jg, "getLowerMask");
function Su(r) {
  return (1 << r) - 1 << 8 - r;
}
S(Su, "getUpperMask");
function Xa(r) {
  return Array.isArray(r) ? r : r.split(/\s+/);
}
S(Xa, "getWords");
function jg(r) {
  return Array.isArray(r) ? r.join(" ") : r;
}
S(jg, "getPhrase");
function qg(r) {
  const t = [0];
  let e = 11;
  for (let i = 0; i < r.length; i += 1)
    e > 8 ? (t[t.length - 1] <<= 8, t[t.length - 1] |= r[i], e -= 8) : (t[t.length - 1] <<= e, t[t.length - 1] |= r[i] >> 8 - e, t.push(r[i] & Jg(8 - e)), e += 3);
  const n = r.length / 4, s = j(Xt(r))[0] & Su(n);
  return t[t.length - 1] <<= n, t[t.length - 1] |= s >> 8 - n, t;
}
S(qg, "entropyToMnemonicIndices");
function $g(r, t) {
  const e = Math.ceil(11 * r.length / 8), n = j(new Uint8Array(e));
  let s = 0;
  for (let A = 0; A < r.length; A += 1) {
    const p = t.indexOf(r[A].normalize("NFKD"));
    if (p === -1)
      throw new x(
        L.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${r[A]}' is not found in the provided wordlist.`
      );
    for (let g = 0; g < 11; g += 1)
      p & 1 << 10 - g && (n[s >> 3] |= 1 << 7 - s % 8), s += 1;
  }
  const i = 32 * r.length / 3, a = r.length / 3, o = Su(a);
  if ((j(Xt(n.slice(0, i / 8)))[0] & o) !== (n[n.length - 1] & o))
    throw new x(
      L.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  return n.slice(0, i / 8);
}
S($g, "mnemonicWordsToEntropy");
var V2 = pr("Bitcoin seed"), W2 = "0x0488ade4", Y2 = "0x04358394", g_ = [12, 15, 18, 21, 24];
function Qd(r) {
  if (r.length !== 2048)
    throw new x(
      L.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${r.length}.`
    );
}
S(Qd, "assertWordList");
function Kg(r) {
  if (r.length % 4 !== 0 || r.length < 16 || r.length > 32)
    throw new x(
      L.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${r.length} bytes.`
    );
}
S(Kg, "assertEntropy");
function Ha(r) {
  if (!g_.includes(r.length)) {
    const t = `Invalid mnemonic size. Expected one of [${g_.join(
      ", "
    )}] words, but got ${r.length}.`;
    throw new x(L.INVALID_MNEMONIC, t);
  }
}
S(Ha, "assertMnemonic");
var He, Z2 = (He = class {
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(t = Ta) {
    Q(this, "wordlist");
    this.wordlist = t, Qd(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(t) {
    return He.mnemonicToEntropy(t, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(t) {
    return He.entropyToMnemonic(t, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(t, e = Ta) {
    const n = Xa(t);
    return Ha(n), W($g(n, e));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(t, e = Ta) {
    const n = j(t);
    return Qd(e), Kg(n), qg(n).map((s) => e[s]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(t, e = "") {
    Ha(Xa(t));
    const n = pr(jg(t)), s = pr(`mnemonic${e}`);
    return dE(n, s, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(t, e = "") {
    const n = He.mnemonicToSeed(t, e);
    return He.masterKeysFromSeed(n);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(t) {
    const e = Xa(t);
    let n = 0;
    try {
      Ha(e);
    } catch {
      return !1;
    }
    for (; n < e.length; ) {
      if (He.binarySearch(e[n]) === !1)
        return !1;
      n += 1;
    }
    return !0;
  }
  static binarySearch(t) {
    const e = Ta;
    let n = 0, s = e.length - 1;
    for (; n <= s; ) {
      const i = Math.floor((n + s) / 2);
      if (e[i] === t)
        return !0;
      t < e[i] ? s = i - 1 : n = i + 1;
    }
    return !1;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(t) {
    const e = j(t);
    if (e.length < 16 || e.length > 64)
      throw new x(
        L.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${e.length} bytes.`
      );
    return j(xp("sha512", V2, e));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(t, e = !1) {
    const n = He.masterKeysFromSeed(t), s = j(e ? Y2 : W2), i = "0x00", a = "0x00000000", o = "0x00000000", d = n.slice(32), A = n.slice(0, 32), p = ct([
      s,
      i,
      a,
      o,
      d,
      ct(["0x00", A])
    ]), g = xo(Xt(Xt(p)), 0, 4);
    return zd(ct([p, g]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(t = 32, e = "") {
    const n = e ? Xt(ct([ir(t), j(e)])) : ir(t);
    return He.entropyToMnemonic(n);
  }
}, S(He, "Mnemonic"), He), Tu = Z2, tw = 2147483648, ew = W("0x0488ade4"), Fu = W("0x0488b21e"), rw = W("0x04358394"), Nu = W("0x043587cf");
function Dd(r) {
  return zd(ct([r, xo(Xt(Xt(r)), 0, 4)]));
}
S(Dd, "base58check");
function nw(r = !1, t = !1) {
  return r ? t ? Nu : Fu : t ? rw : ew;
}
S(nw, "getExtendedKeyPrefix");
function sw(r) {
  return [Fu, Nu].includes(W(r.slice(0, 4)));
}
S(sw, "isPublicExtendedKey");
function iw(r) {
  return [ew, rw, Fu, Nu].includes(
    W(r.slice(0, 4))
  );
}
S(iw, "isValidExtendedKey");
function aw(r, t = 0) {
  const e = r.split("/");
  if (e.length === 0 || e[0] === "m" && t !== 0)
    throw new x(L.HD_WALLET_ERROR, `invalid path - ${r}`);
  return e[0] === "m" && e.shift(), e.map(
    (n) => ~n.indexOf("'") ? parseInt(n, 10) + tw : parseInt(n, 10)
  );
}
S(aw, "parsePath");
var _r, J2 = (_r = class {
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(t) {
    Q(this, "depth", 0);
    Q(this, "index", 0);
    Q(this, "fingerprint", W("0x00000000"));
    Q(this, "parentFingerprint", W("0x00000000"));
    Q(this, "privateKey");
    Q(this, "publicKey");
    Q(this, "chainCode");
    if (t.privateKey) {
      const e = new oa(t.privateKey);
      this.publicKey = W(e.compressedPublicKey), this.privateKey = W(t.privateKey);
    } else {
      if (!t.publicKey)
        throw new x(
          L.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      this.publicKey = W(t.publicKey);
    }
    this.parentFingerprint = t.parentFingerprint || this.parentFingerprint, this.fingerprint = xo(uE(Xt(this.publicKey)), 0, 4), this.depth = t.depth || this.depth, this.index = t.index || this.index, this.chainCode = t.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(t) {
    const e = this.privateKey && j(this.privateKey), n = j(this.publicKey), s = j(this.chainCode), i = new Uint8Array(37);
    if (t & tw) {
      if (!e)
        throw new x(
          L.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      i.set(e, 1);
    } else
      i.set(j(this.publicKey));
    i.set(nr(t, 4), 33);
    const a = j(xp("sha512", s, i)), o = a.slice(0, 32), d = a.slice(32);
    if (e) {
      const y = I(o).add(e).mod("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141").toBytes(32);
      return new _r({
        privateKey: y,
        chainCode: d,
        index: t,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const p = new oa(W(o)).addPoint(n);
    return new _r({
      publicKey: p,
      chainCode: d,
      index: t,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(t) {
    return aw(t, this.depth).reduce((n, s) => n.deriveIndex(s), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(t = !1, e = !1) {
    if (this.depth >= 256)
      throw new x(
        L.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    const n = nw(this.privateKey == null || t, e), s = W(Uint8Array.from([this.depth])), i = this.parentFingerprint, a = Co(this.index, 4), o = this.chainCode, d = this.privateKey != null && !t ? ct(["0x00", this.privateKey]) : this.publicKey, A = j(ct([n, s, i, a, o, d]));
    return Dd(A);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(t) {
    const e = Tu.masterKeysFromSeed(t);
    return new _r({
      chainCode: j(e.slice(32)),
      privateKey: j(e.slice(0, 32))
    });
  }
  static fromExtendedKey(t) {
    const e = W(nr(rp(t))), n = j(e), s = Dd(n.slice(0, 78)) === t;
    if (n.length !== 82 || !iw(n))
      throw new x(L.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    if (!s)
      throw new x(L.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    const i = n[4], a = W(n.slice(5, 9)), o = parseInt(W(n.slice(9, 13)).substring(2), 16), d = W(n.slice(13, 45)), A = n.slice(45, 78);
    if (i === 0 && a !== "0x00000000" || i === 0 && o !== 0)
      throw new x(
        L.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    if (sw(n)) {
      if (A[0] !== 3)
        throw new x(L.HD_WALLET_ERROR, "Invalid public extended key.");
      return new _r({
        publicKey: A,
        chainCode: d,
        index: o,
        depth: i,
        parentFingerprint: a
      });
    }
    if (A[0] !== 0)
      throw new x(L.HD_WALLET_ERROR, "Invalid private extended key.");
    return new _r({
      privateKey: A.slice(1),
      chainCode: d,
      index: o,
      depth: i,
      parentFingerprint: a
    });
  }
}, S(_r, "HDWallet"), _r), qc = J2, di, ow = (di = class extends $o {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(t) {
    return new pn(t, this._provider);
  }
}, S(di, "WalletLocked"), di), Ve, pn = (Ve = class extends X2 {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    return this.signer = () => new oa("0x00"), new ow(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(t) {
    const e = oa.generatePrivateKey(t == null ? void 0 : t.entropy);
    return new Ve(e, t == null ? void 0 : t.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(t, e, n) {
    const i = qc.fromSeed(t).derivePath(e || Ve.defaultPath);
    return new Ve(i.privateKey, n);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(t, e, n, s) {
    const i = Tu.mnemonicToSeed(t, n), o = qc.fromSeed(i).derivePath(e || Ve.defaultPath);
    return new Ve(o.privateKey, s);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(t, e) {
    const n = qc.fromExtendedKey(t);
    return new Ve(n.privateKey, e);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(t, e, n) {
    const s = await Zg(t, e);
    return new Ve(s, n);
  }
}, S(Ve, "WalletUnlocked"), Ve), Ar, er = (Ar = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(t, e) {
    return new ow(t, e);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(t, e) {
    return new pn(t, e);
  }
}, S(Ar, "Wallet"), /**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
Q(Ar, "generate", pn.generate), /**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @returns An unlocked wallet instance.
 */
Q(Ar, "fromSeed", pn.fromSeed), /**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @returns An unlocked wallet instance.
 */
Q(Ar, "fromMnemonic", pn.fromMnemonic), /**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
Q(Ar, "fromExtendedKey", pn.fromExtendedKey), /**
 * Create a Wallet Unlocked from an encrypted JSON.
 *
 * @param jsonWallet - The encrypted JSON keystore.
 * @param password - The password to decrypt the JSON.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
Q(Ar, "fromEncryptedJson", pn.fromEncryptedJson), Ar), ui, j2 = (ui = class {
  constructor() {
    Q(this, "storage", /* @__PURE__ */ new Map());
  }
  async getItem(t) {
    return await this.storage.get(t);
  }
  async setItem(t, e) {
    await this.storage.set(t, e);
  }
  async removeItem(t) {
    await this.storage.delete(t);
  }
  async clear() {
    await this.storage.clear();
  }
}, S(ui, "MemoryStorage"), ui), Rn, $r, q2 = (Rn = class {
  constructor(t) {
    Ce(this, $r);
    Q(this, "pathKey", "{}");
    Q(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
    Q(this, "numberOfAccounts", 0);
    Gt(this, $r, t.secret || Tu.generate()), this.rootPath = t.rootPath || this.rootPath, this.numberOfAccounts = t.numberOfAccounts || 1;
  }
  getDerivePath(t) {
    return this.rootPath.includes(this.pathKey) ? this.rootPath.replace(this.pathKey, String(t)) : `${this.rootPath}/${t}`;
  }
  serialize() {
    return {
      secret: _t(this, $r),
      rootPath: this.rootPath,
      numberOfAccounts: this.numberOfAccounts
    };
  }
  getAccounts() {
    const t = [];
    let e = 0;
    do {
      const n = er.fromMnemonic(_t(this, $r), this.getDerivePath(e));
      t.push({
        publicKey: n.publicKey,
        address: n.address
      }), e += 1;
    } while (e < this.numberOfAccounts);
    return t;
  }
  addAccount() {
    this.numberOfAccounts += 1;
    const t = er.fromMnemonic(_t(this, $r), this.getDerivePath(this.numberOfAccounts - 1));
    return {
      publicKey: t.publicKey,
      address: t.address
    };
  }
  exportAccount(t) {
    let e = 0;
    const n = new wt(t);
    do {
      const s = er.fromMnemonic(_t(this, $r), this.getDerivePath(e));
      if (s.address.equals(n))
        return s.privateKey;
      e += 1;
    } while (e < this.numberOfAccounts);
    throw new x(
      L.WALLET_MANAGER_ERROR,
      `Account with address '${t}' not found in derived wallets.`
    );
  }
  getWallet(t) {
    const e = this.exportAccount(t);
    return er.fromPrivateKey(e);
  }
}, $r = new WeakMap(), S(Rn, "MnemonicVault"), Q(Rn, "type", "mnemonic"), Rn), Sn, kr, $2 = (Sn = class {
  /**
   * If privateKey vault is initialized with a secretKey, it creates
   * one account with the fallowing secret
   */
  constructor(t = {}) {
    Ce(this, kr, []);
    t.secret ? Gt(this, kr, [t.secret]) : Gt(this, kr, t.accounts || [er.generate().privateKey]);
  }
  serialize() {
    return {
      accounts: _t(this, kr)
    };
  }
  getPublicAccount(t) {
    const e = er.fromPrivateKey(t);
    return {
      address: e.address,
      publicKey: e.publicKey
    };
  }
  getAccounts() {
    return _t(this, kr).map((t) => this.getPublicAccount(t));
  }
  addAccount() {
    const t = er.generate();
    return _t(this, kr).push(t.privateKey), this.getPublicAccount(t.privateKey);
  }
  exportAccount(t) {
    const e = new wt(t), n = _t(this, kr).find(
      (s) => er.fromPrivateKey(s).address.equals(e)
    );
    if (!n)
      throw new x(
        L.WALLET_MANAGER_ERROR,
        `No private key found for address '${t}'.`
      );
    return n;
  }
  getWallet(t) {
    const e = this.exportAccount(t);
    return er.fromPrivateKey(e);
  }
}, kr = new WeakMap(), S(Sn, "PrivateKeyVault"), Q(Sn, "type", "privateKey"), Sn), Mr = {
  invalid_vault_type: "The provided Vault type is invalid.",
  address_not_found: "No private key found for address the specified wallet address.",
  vault_not_found: "The specified vault was not found.",
  wallet_not_unlocked: "The wallet is currently locked."
};
function yr(r, t) {
  if (!r)
    throw new x(L.WALLET_MANAGER_ERROR, t);
}
S(yr, "assert");
var en, Pe, Kr, lr, Ni, cw, dw, CS = (en = class extends vf.EventEmitter {
  constructor(e) {
    super();
    Ce(this, Ni);
    /**
     * Storage
     *
     * Persistent encrypted data. `The default storage works only on memory`.
     */
    Q(this, "storage", new j2());
    /* Key name passed to the storage */
    Q(this, "STORAGE_KEY", "WalletManager");
    // `This variables are only accessible from inside the class`
    Ce(this, Pe, []);
    Ce(this, Kr, "");
    Ce(this, lr, !0);
    this.storage = (e == null ? void 0 : e.storage) || this.storage;
  }
  get isLocked() {
    return _t(this, lr);
  }
  /**
   * Return the vault serialized object containing all the privateKeys,
   * the format of the return depends on the Vault type.
   */
  exportVault(e) {
    yr(!_t(this, lr), Mr.wallet_not_unlocked);
    const n = _t(this, Pe).find((s, i) => i === e);
    return yr(n, Mr.vault_not_found), n.vault.serialize();
  }
  /**
   * List all vaults on the Wallet Manager, this function not return secret's
   */
  getVaults() {
    return _t(this, Pe).map((e, n) => ({
      title: e.title,
      type: e.type,
      vaultId: n
    }));
  }
  /**
   * List all accounts on the Wallet Manager not vault information is revealed
   */
  getAccounts() {
    return _t(this, Pe).flatMap(
      (e, n) => e.vault.getAccounts().map((s) => ({ ...s, vaultId: n }))
    );
  }
  /**
   * Create a Wallet instance for the specific account
   */
  getWallet(e) {
    const n = new wt(e), s = _t(this, Pe).find(
      (i) => i.vault.getAccounts().find((a) => a.address.equals(n))
    );
    return yr(s, Mr.address_not_found), s.vault.getWallet(n);
  }
  /**
   * Export specific account privateKey
   */
  exportPrivateKey(e) {
    const n = new wt(e);
    yr(!_t(this, lr), Mr.wallet_not_unlocked);
    const s = _t(this, Pe).find(
      (i) => i.vault.getAccounts().find((a) => a.address.equals(n))
    );
    return yr(s, Mr.address_not_found), s.vault.exportAccount(n);
  }
  /**
   * Add account to a selected vault or on the first vault as default.
   * If not vaults are adds it will return error
   */
  async addAccount(e) {
    await this.loadState();
    const n = _t(this, Pe)[(e == null ? void 0 : e.vaultId) || 0];
    await yr(n, Mr.vault_not_found);
    const s = n.vault.addAccount();
    return await this.saveState(), s;
  }
  /**
   * Remove vault by index, by remove the vault you also remove all accounts
   * created by the vault.
   */
  async removeVault(e) {
    _t(this, Pe).splice(e, 1), await this.saveState();
  }
  /**
   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
   * didn't found it will throw.
   */
  async addVault(e) {
    await this.loadState();
    const n = this.getVaultClass(e.type), s = new n(e);
    Gt(this, Pe, _t(this, Pe).concat({
      title: e.title,
      type: e.type,
      vault: s
    })), await this.saveState();
  }
  /**
   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
   * secrets.
   */
  lock() {
    Gt(this, lr, !0), Gt(this, Pe, []), Gt(this, Kr, ""), this.emit("lock");
  }
  /**
   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
   * Vaults with secrets are not unlocked or instantiated on this moment.
   */
  async unlock(e) {
    Gt(this, Kr, e), Gt(this, lr, !1);
    try {
      await this.loadState(), this.emit("unlock");
    } catch (n) {
      throw await this.lock(), n;
    }
  }
  /**
   * Update WalletManager encryption passphrase
   */
  async updatePassphrase(e, n) {
    const s = _t(this, lr);
    await this.unlock(e), Gt(this, Kr, n), await this.saveState(), await this.loadState(), s && await this.lock();
  }
  /**
   * Retrieve and decrypt WalletManager state from storage
   */
  async loadState() {
    await yr(!_t(this, lr), Mr.wallet_not_unlocked);
    const e = await this.storage.getItem(this.STORAGE_KEY);
    if (e) {
      const n = await iE(_t(this, Kr), JSON.parse(e));
      Gt(this, Pe, un(this, Ni, dw).call(this, n.vaults));
    }
  }
  /**
   * Store encrypted WalletManager state on storage
   */
  async saveState() {
    await yr(!_t(this, lr), Mr.wallet_not_unlocked);
    const e = await aE(_t(this, Kr), {
      vaults: un(this, Ni, cw).call(this, _t(this, Pe))
    });
    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(e)), this.emit("update");
  }
  /**
   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
   */
  getVaultClass(e) {
    const n = en.Vaults.find((s) => s.type === e);
    return yr(n, Mr.invalid_vault_type), n;
  }
}, Pe = new WeakMap(), Kr = new WeakMap(), lr = new WeakMap(), Ni = new WeakSet(), /**
 * Serialize all vaults to store
 *
 * `This is only accessible from inside the class`
 */
cw = function(e) {
  return e.map(({ title: n, type: s, vault: i }) => ({
    title: n,
    type: s,
    data: i.serialize()
  }));
}, /**
 * Deserialize all vaults to state
 *
 * `This is only accessible from inside the class`
 */
dw = function(e) {
  return e.map(({ title: n, type: s, data: i }) => {
    const a = this.getVaultClass(s);
    return {
      title: n,
      type: s,
      vault: new a(i)
    };
  });
}, S(en, "WalletManager"), /**
 * Vaults
 *
 * Vaults are responsible to store secret keys and return an `Wallet` instance,
 * to interact with the network.
 *
 * Each vault has access to its own state
 *
 */
Q(en, "Vaults", [q2, $2]), en), Tn, ES = (Tn = class {
  constructor(t) {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
  serialize() {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
  getAccounts() {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
  addAccount() {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
  exportAccount(t) {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
  getWallet(t) {
    throw new x(L.NOT_IMPLEMENTED, "Not implemented.");
  }
}, S(Tn, "Vault"), Q(Tn, "type"), Tn), Ai, BS = (Ai = class {
}, S(Ai, "StorageAbstract"), Ai), K2 = 32, Ne = 16, $e = 17, Kn = 18, tR = 8, eR = 8, rR = 16;
function uw(r) {
  const [t] = new rt("u64").decode(r, eR);
  return t.toNumber();
}
S(uw, "getBytecodeDataOffset");
function Ko(r) {
  const [t] = new rt("u64").decode(r, rR);
  return t.toNumber();
}
S(Ko, "getBytecodeConfigurableOffset");
function Aw(r) {
  const t = Ko(r), e = r.slice(0, t);
  return Xt(e);
}
S(Aw, "getBytecodeId");
function nR(r) {
  const t = uw(r), e = r.slice(0, t);
  return Xt(e);
}
S(nR, "getLegacyBlobId");
function lw(r, t) {
  const { RegId: e, Instruction: n } = Q_, s = e.pc().to_u8(), i = e.sp().to_u8(), a = e.is().to_u8(), o = /* @__PURE__ */ S((E) => [
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    gn(Ne, s),
    // hold the address of the blob ID.
    Er(
      Ne,
      Ne,
      E * n.size()
    ),
    // The code is going to be loaded from the current value of SP onwards, save
    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
    gn($e, i),
    // REG_GENERAL_USE to hold the size of the blob.
    Ja(Kn, Ne),
    // Push the blob contents onto the stack.
    qi(Ne, 0, Kn, 1),
    // Move on to the data section length
    Er(Ne, Ne, K2),
    // load the size of the data section into REG_GENERAL_USE
    ea(Kn, Ne, 0),
    // after we have read the length of the data section, we move the pointer to the actual
    // data by skipping WORD_SIZE bytes.
    Er(Ne, Ne, tR),
    // load the data section of the executable
    qi(Ne, 0, Kn, 2),
    // Jump into the memory where the contract is loaded.
    // What follows is called _jmp_mem by the sway compiler.
    // Subtract the address contained in IS because jmp will add it back.
    Wa($e, $e, a),
    // jmp will multiply by 4, so we need to divide to cancel that out.
    Za($e, $e, 4),
    // Jump to the start of the contract we loaded.
    Ya($e)
  ], "getInstructions"), d = /* @__PURE__ */ S((E) => [
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    gn(Ne, s),
    // hold the address of the blob ID.
    Er(
      Ne,
      Ne,
      E * n.size()
    ),
    // The code is going to be loaded from the current value of SP onwards, save
    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
    gn($e, i),
    // REG_GENERAL_USE to hold the size of the blob.
    Ja(Kn, Ne),
    // Push the blob contents onto the stack.
    qi(Ne, 0, Kn, 1),
    // Jump into the memory where the contract is loaded.
    // What follows is called _jmp_mem by the sway compiler.
    // Subtract the address contained in IS because jmp will add it back.
    Wa($e, $e, a),
    // jmp will multiply by 4, so we need to divide to cancel that out.
    Za($e, $e, 4),
    // Jump to the start of the contract we loaded.
    Ya($e)
  ], "getInstructionsNoDataSection"), A = Ko(r);
  if (r.length < A)
    throw new Error(
      `Data section offset is out of bounds, offset: ${A}, binary length: ${r.length}`
    );
  const p = r.slice(A);
  if (p.length > 0) {
    const E = o(0).length;
    if (E > 65535)
      throw new Error("Too many instructions, exceeding u16::MAX.");
    const F = new Uint8Array(
      o(E).flatMap(
        (M) => Array.from(M.to_bytes())
      )
    ), k = new Uint8Array(t), H = new Uint8Array(8);
    new DataView(H.buffer).setBigUint64(0, BigInt(p.length), !1);
    const D = new Uint8Array([
      ...F,
      ...k,
      ...H
    ]);
    return {
      loaderBytecode: ct([D, p]),
      blobOffset: D.length
    };
  }
  const g = d(0).length;
  if (g > 65535)
    throw new Error("Too many instructions, exceeding u16::MAX.");
  const y = new Uint8Array(
    d(g).flatMap(
      (E) => Array.from(E.to_bytes())
    )
  ), v = new Uint8Array(t);
  return { loaderBytecode: new Uint8Array([...y, ...v]) };
}
S(lw, "getPredicateScriptLoaderInstructions");
async function hw(r, t) {
  const { assembledRequest: e } = await r.provider.assembleTx({
    request: t,
    feePayerAccount: r,
    accountCoinQuantities: []
  });
  return e;
}
S(hw, "fundBlobTx");
function _w(r, t) {
  const { configurables: e } = r, n = [];
  return e.forEach((s) => {
    n.push({ ...s, offset: s.offset - t });
  }), { ...r, configurables: n };
}
S(_w, "adjustConfigurableOffsets");
async function Qu({
  deployer: r,
  bytecode: t,
  abi: e,
  loaderInstanceCallback: n
}) {
  const s = Aw(j(t)), i = Ko(j(t)), a = t.slice(0, i), o = new yo({
    blobId: s,
    witnessIndex: 0,
    witnesses: [a]
  }), { loaderBytecode: d, blobOffset: A } = lw(
    j(t),
    j(s)
  ), p = a.length - (A || 0), g = _w(e, p), y = (await r.provider.getBlobs([s])).length > 0, v = n(d, g);
  if (y)
    return {
      waitForResult: /* @__PURE__ */ S(() => Promise.resolve(v), "waitForResult"),
      blobId: s
    };
  const N = await hw(r, o);
  return {
    waitForResult: /* @__PURE__ */ S(async () => {
      try {
        if ((await (await r.sendTransaction(N)).waitForResult()).status !== "success")
          throw new Error();
      } catch {
        throw new x(L.TRANSACTION_FAILED, "Failed to deploy predicate chunk");
      }
      return v;
    }, "waitForResult"),
    blobId: s
  };
}
S(Qu, "deployScriptOrPredicate");
var sR = /* @__PURE__ */ S((r) => {
  const e = j(r), n = j_(e, 16384), s = uu(n.map((a) => W(a)));
  return gr(ct(["0x4655454C", s]));
}, "getPredicateRoot"), Cr, vS = (Cr = class extends $o {
  /**
   * Creates an instance of the Predicate class.
   *
   * @param bytecode - The bytecode of the predicate.
   * @param abi - The JSON ABI of the predicate.
   * @param provider - The provider used to interact with the blockchain.
   * @param data - The predicate input data (optional).
   * @param configurableConstants - Optional configurable constants for the predicate.
   */
  constructor({
    bytecode: e,
    abi: n,
    provider: s,
    data: i,
    configurableConstants: a
  }) {
    const { predicateBytes: o, predicateInterface: d } = Cr.processPredicateData(
      e,
      n,
      a
    ), A = new wt(sR(o));
    super(A, s);
    Q(this, "bytes");
    Q(this, "predicateData", []);
    Q(this, "interface");
    Q(this, "initialBytecode");
    Q(this, "configurableConstants");
    this.initialBytecode = j(e), this.bytes = o, this.interface = d, this.configurableConstants = a, i !== void 0 && i.length > 0 && (this.predicateData = i);
  }
  /**
   * Populates the transaction data with predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns The transaction request with predicate data.
   */
  populateTransactionPredicateData(e) {
    const n = Oe(e), s = this.getIndexFromPlaceholderWitness(n);
    return s !== -1 && n.removeWitness(s), n.inputs.filter(Wo).forEach((i) => {
      xd(i, this.address) && (i.predicate = W(this.bytes), i.predicateData = W(this.getPredicateData()), i.witnessIndex = 0);
    }), n;
  }
  /**
   * Sends a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the transaction response.
   */
  sendTransaction(e) {
    const n = Oe(e);
    return super.sendTransaction(n, { estimateTxDependencies: !1 });
  }
  /**
   * Simulates a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the call result.
   */
  simulateTransaction(e) {
    const n = Oe(e);
    return super.simulateTransaction(n, { estimateTxDependencies: !1 });
  }
  /**
   * Retrieves the properly encoded predicate data.
   *
   * @returns A Uint8Array containing the encoded predicate data. If no predicate data is available, returns an empty Uint8Array.
   */
  getPredicateData() {
    var n;
    if (!this.predicateData.length)
      return new Uint8Array();
    const e = (n = this.interface) == null ? void 0 : n.functions.main;
    return (e == null ? void 0 : e.encodeArguments(this.predicateData)) || new Uint8Array();
  }
  /**
   * Creates a new Predicate instance from an existing Predicate instance.
   * @param overrides - The data and configurable constants to override.
   * @returns A new Predicate instance with the same bytecode, ABI and provider but with the ability to set the data and configurable constants.
   */
  toNewInstance(e = {}) {
    return new Cr({
      bytecode: this.initialBytecode,
      abi: this.interface.jsonAbi,
      provider: this.provider,
      data: e.data ?? this.predicateData,
      configurableConstants: e.configurableConstants ?? this.configurableConstants
    });
  }
  /**
   * Sets the predicate data.
   *
   * @param data - The data to be set for the predicate.
   */
  setData(e) {
    this.predicateData = e;
  }
  /**
   * Processes the predicate data and returns the altered bytecode and interface.
   *
   * @param bytes - The bytes of the predicate.
   * @param jsonAbi - The JSON ABI of the predicate.
   * @param configurableConstants - Optional configurable constants for the predicate.
   * @returns An object containing the new predicate bytes and interface.
   */
  static processPredicateData(e, n, s) {
    let i = j(e);
    const a = new Je(n);
    if (a.functions.main === void 0)
      throw new x(
        L.ABI_MAIN_METHOD_MISSING,
        'Cannot use ABI without "main" function.'
      );
    return s && Object.keys(s).length && (i = Cr.setConfigurableConstants(
      i,
      s,
      a
    )), {
      predicateBytes: i,
      predicateInterface: a
    };
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param resourcesIdsToIgnore - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(e, n) {
    return (await this.provider.getResourcesToSpend(
      this.address,
      e,
      n
    )).map((i) => ({
      ...i,
      predicate: W(this.bytes),
      predicateData: W(this.getPredicateData())
    }));
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(e) {
    return super.generateFakeResources(e).map((n) => ({
      ...n,
      predicate: W(this.bytes),
      predicateData: W(this.getPredicateData())
    }));
  }
  /**
   * Sets the configurable constants for the predicate.
   *
   * @param bytes - The bytes of the predicate.
   * @param configurableConstants - Configurable constants to be set.
   * @param abiInterface - The ABI interface of the predicate.
   * @returns The mutated bytes with the configurable constants set.
   */
  static setConfigurableConstants(e, n, s) {
    const i = e;
    try {
      if (Object.keys(s.configurables).length === 0)
        throw new x(
          L.INVALID_CONFIGURABLE_CONSTANTS,
          "Predicate has no configurable constants to be set"
        );
      Object.entries(n).forEach(([a, o]) => {
        if (!(s != null && s.configurables[a]))
          throw new x(
            L.CONFIGURABLE_NOT_FOUND,
            `No configurable constant named '${a}' found in the Predicate`
          );
        const { offset: d } = s.configurables[a], A = s.encodeConfigurable(a, o);
        i.set(A, d);
      });
    } catch (a) {
      throw new x(
        L.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${a.message}.`
      );
    }
    return i;
  }
  /**
   * Returns the index of the witness placeholder that was added to this predicate.
   * If no witness placeholder was added, it returns -1.
   * @param request - The transaction request.
   * @returns The index of the witness placeholder, or -1 if there is no witness placeholder.
   */
  getIndexFromPlaceholderWitness(e) {
    var a;
    const n = e.inputs.filter(Wn).filter((o) => xd(o, this.address));
    let s = -1;
    const i = n.find((o) => !o.predicate);
    return i && (s = i.witnessIndex, n.every((d) => !d.predicate) || (a = n[0]) != null && a.predicate && (s = -1)), s;
  }
  /**
   *
   * @param account - The account used to pay the deployment costs.
   * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate
   * once the blob deployment transaction finishes.
   *
   * The returned loader predicate will have the same configurable constants
   * as the original predicate which was used to generate the loader predicate.
   */
  async deploy(e) {
    return Qu({
      deployer: e,
      abi: this.interface.jsonAbi,
      bytecode: this.bytes,
      loaderInstanceCallback: /* @__PURE__ */ S((n, s) => new Cr({
        bytecode: n,
        abi: s,
        provider: this.provider,
        data: this.predicateData
      }), "loaderInstanceCallback")
    });
  }
}, S(Cr, "Predicate"), Cr), pw = /* @__PURE__ */ ((r) => (r.ping = "ping", r.version = "version", r.connect = "connect", r.disconnect = "disconnect", r.isConnected = "isConnected", r.accounts = "accounts", r.currentAccount = "currentAccount", r.signTransaction = "signTransaction", r.signMessage = "signMessage", r.sendTransaction = "sendTransaction", r.assets = "assets", r.addAsset = "addAsset", r.addAssets = "addAssets", r.networks = "networks", r.currentNetwork = "currentNetwork", r.addNetwork = "addNetwork", r.selectNetwork = "selectNetwork", r.addABI = "addABI", r.getABI = "getABI", r.hasABI = "hasABI", r.startConsolidation = "startConsolidation", r))(pw || {}), Du = /* @__PURE__ */ ((r) => (r.connectors = "connectors", r.currentConnector = "currentConnector", r.connection = "connection", r.accounts = "accounts", r.currentAccount = "currentAccount", r.networks = "networks", r.currentNetwork = "currentNetwork", r.assets = "assets", r.abis = "abis", r.consolidateCoins = "consolidateCoins", r))(Du || {}), fw = "FuelConnector", li, iR = (li = class {
  constructor(t) {
    Q(this, "storage");
    this.storage = t;
  }
  async setItem(t, e) {
    this.storage.setItem(t, e);
  }
  async getItem(t) {
    return this.storage.getItem(t);
  }
  async removeItem(t) {
    this.storage.removeItem(t);
  }
  async clear() {
    this.storage.clear();
  }
}, S(li, "LocalStorage"), li), hi, aR = (hi = class extends vf.EventEmitter {
  constructor() {
    super(...arguments);
    Q(this, "name", "");
    Q(this, "metadata", {});
    Q(this, "connected", !1);
    Q(this, "installed", !1);
    Q(this, "external", !0);
    Q(this, "events", Du);
  }
  /**
   * Should return true if the connector is loaded
   * in less then one second.
   *
   * @returns Always true.
   */
  async ping() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current version of the connector
   * and the network version that is compatible.
   *
   * @returns boolean - connection status.
   */
  async version() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return true if the connector is connected
   * to any of the accounts available.
   *
   * @returns The connection status.
   */
  async isConnected() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the accounts authorized for the
   * current connection.
   *
   * @returns The accounts addresses strings
   */
  async accounts() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the connection process and return
   * true if the account authorize the connection.
   *
   * and return false if the user reject the connection.
   *
   * @emits accounts
   * @returns boolean - connection status.
   */
  async connect() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should disconnect the current connection and
   * return false if the disconnection was successful.
   *
   * @emits assets connection
   * @returns The connection status.
   */
  async disconnect() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the sign message process and return
   * the signed message.
   *
   * @param address - The address to sign the message
   * @param message - The message to sign all text will be treated as text utf-8
   *
   * @returns Message signature
   */
  async signMessage(e, n) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the sign transaction process and return
   * the signed transaction.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to sign
   *
   * @returns Transaction signature
   */
  async signTransaction(e, n, s) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the send transaction process and return
   * the transaction id submitted to the network.
   *
   * If the network is not available for the connection
   * it should throw an error to avoid the transaction
   * to be sent to the wrong network and lost.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to send
   * @param params - Optional parameters to send the transaction
   * @returns The transaction id or transaction response
   */
  async sendTransaction(e, n, s) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current account selected inside the connector, if the account
   * is authorized for the connection.
   *
   * If the account is not authorized it should return null.
   *
   * @returns The current account selected otherwise null.
   */
  async currentAccount() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the assets metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param assets - The assets to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAssets(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the asset metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param asset - The asset to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAsset(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the assets added to the connector. If a connection is already established.
   *
   * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
   */
  async assets() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the add network process and return true if the network was added successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param networkUrl - The URL of the network to be added.
   * @returns Return true if the network was added successfully
   */
  async addNetwork(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the select network process and return true if the network has change successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param network - The network to be selected.
   * @returns Return true if the network was added successfully
   */
  async selectNetwork(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the networks available from the connector. If the connection is already established.
   *
   * @returns Return all the networks added to the connector.
   */
  async networks() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current network selected inside the connector. Even if the connection is not established.
   *
   * @returns Return the current network selected inside the connector.
   */
  async currentNetwork() {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the ABI to the connector and return true if the ABI was added successfully.
   *
   * @param contractId - The contract id to add the ABI.
   * @param abi - The JSON ABI that represents a contract.
   * @returns Return true if the ABI was added successfully.
   */
  async addABI(e, n) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the ABI.
   * @returns The ABI if it exists, otherwise return null.
   */
  async getABI(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the abi
   * @returns Returns true if the abi exists or false if not.
   */
  async hasABI(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Start the consolidation of coins process
   *
   * @param owner - The B256 address of the owner.
   * @param assetId - The asset ID that requires consolidation.
   */
  async startConsolidation(e) {
    throw new x(x.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Event listener for the connector.
   *
   * @param eventName - The event name to listen
   * @param listener - The listener function
   */
  on(e, n) {
    return super.on(e, n), this;
  }
}, S(hi, "FuelConnector"), hi);
function gw(r, { cache: t, cacheTime: e, key: n }) {
  return async (...s) => {
    var a, o, d;
    if (t[n] && ((a = t[n]) != null && a.value))
      return (o = t[n]) == null ? void 0 : o.value;
    clearTimeout((d = t[n]) == null ? void 0 : d.timeout);
    const i = await r(...s);
    return t[n] = {
      timeout: Number(
        setTimeout(() => {
          t[n] = null;
        }, e)
      ),
      value: i
    }, i;
  };
}
S(gw, "cacheFor");
function oR(r) {
  window.dispatchEvent(
    new CustomEvent(fw, {
      detail: r
    })
  );
}
S(oR, "dispatchFuelConnectorEvent");
function ww() {
  const r = {};
  return r.promise = new Promise((t, e) => {
    r.reject = e, r.resolve = t;
  }), r;
}
S(ww, "deferPromise");
async function ji(r, t = 1050) {
  const e = new Promise((n, s) => {
    setTimeout(() => {
      s(new x(x.CODES.TIMEOUT_EXCEEDED, "Promise timed out"));
    }, t);
  });
  return Promise.race([e, r]);
}
S(ji, "withTimeout");
var cR = 2e3, dR = 5e3, { warn: uR } = console, rr, xS = (rr = class extends aR {
  constructor(e = rr.defaultConfig) {
    super();
    Q(this, "_storage", null);
    Q(this, "_connectors", []);
    Q(this, "_targetObject", null);
    Q(this, "_unsubscribes", []);
    Q(this, "_targetUnsubscribe", /* @__PURE__ */ S(() => {
    }, "_targetUnsubscribe"));
    Q(this, "_pingCache", {});
    Q(this, "_currentConnector");
    Q(this, "_initializationPromise", null);
    /**
     * Setup a listener for the FuelConnector event and add the connector
     * to the list of new connectors.
     */
    Q(this, "setupConnectorListener", /* @__PURE__ */ S(() => {
      const { _targetObject: e } = this, n = fw;
      if (e != null && e.on)
        return e.on(n, this.addConnector), () => {
          var s;
          (s = e.off) == null || s.call(e, n, this.addConnector);
        };
      if (e != null && e.addEventListener) {
        const s = /* @__PURE__ */ S((i) => {
          this.addConnector(i.detail);
        }, "handler");
        return e.addEventListener(n, s), () => {
          var i;
          (i = e.removeEventListener) == null || i.call(e, n, s);
        };
      }
      return () => {
      };
    }, "setupConnectorListener"));
    /**
     * Add a new connector to the list of connectors.
     */
    Q(this, "addConnector", /* @__PURE__ */ S(async (e) => {
      this.getConnector(e) || this._connectors.push(e), await this.fetchConnectorStatus(e), this.emit(this.events.connectors, this._connectors), this._currentConnector || await this.selectConnector(e.name, {
        emitEvents: !1
      });
    }, "addConnector"));
    Q(this, "triggerConnectorEvents", /* @__PURE__ */ S(async () => {
      const [e, n, s] = await Promise.all([
        this.isConnected(),
        this.networks(),
        this.currentNetwork()
      ]);
      if (this.emit(this.events.connection, e), this.emit(this.events.networks, n), this.emit(this.events.currentNetwork, s), e) {
        const [i, a] = await Promise.all([
          this.accounts(),
          this.currentAccount()
        ]);
        this.emit(this.events.accounts, i), this.emit(this.events.currentAccount, a);
      }
    }, "triggerConnectorEvents"));
    /**
     * Get a connector from the list of connectors.
     */
    Q(this, "getConnector", /* @__PURE__ */ S((e) => this._connectors.find((n) => {
      const s = typeof e == "string" ? e : e.name;
      return n.name === s || n === e;
    }) || null, "getConnector"));
    this.setMaxListeners(1e3), this._connectors = e.connectors ?? [], this._targetObject = this.getTargetObject(e.targetObject), this._storage = e.storage === void 0 ? this.getStorage() : e.storage, this.setupMethods(), this._initializationPromise = this.initialize();
  }
  async initialize() {
    try {
      const e = this.setDefaultConnector();
      this._targetUnsubscribe = this.setupConnectorListener(), await e;
    } catch {
      throw new x(L.INVALID_PROVIDER, "Error initializing Fuel Connector");
    }
  }
  async init() {
    return await this._initializationPromise, this;
  }
  /**
   * Return the target object to listen for global events.
   */
  getTargetObject(e) {
    return e || (typeof window < "u" ? window : typeof document < "u" ? document : null);
  }
  /**
   * Return the storage used.
   */
  getStorage() {
    if (typeof window < "u")
      return new iR(window.localStorage);
  }
  /**
   * Setup the default connector from the storage.
   */
  async setDefaultConnector() {
    var n, s;
    const e = await ((n = this._storage) == null ? void 0 : n.getItem(rr.STORAGE_KEY)) || ((s = this._connectors[0]) == null ? void 0 : s.name);
    if (e)
      return this.selectConnector(e, {
        emitEvents: !1
      });
  }
  /**
   * Start listener for all the events of the current
   * connector and emit them to the Fuel instance
   */
  setupConnectorEvents(e) {
    if (!this._currentConnector)
      return;
    const n = this._currentConnector;
    this._unsubscribes.map((s) => s()), this._unsubscribes = e.map((s) => {
      const i = /* @__PURE__ */ S((...a) => this.emit(s, ...a), "handler");
      return n.on(s, i), () => n.off(s, i);
    });
  }
  /**
   * Call method from the current connector.
   */
  async callMethod(e, ...n) {
    const s = await this.hasConnector();
    if (await this.pingConnector(), !this._currentConnector || !s)
      throw new x(
        L.MISSING_CONNECTOR,
        `No connector selected for calling ${e}. Use hasConnector before executing other methods.`
      );
    if (typeof this._currentConnector[e] == "function")
      return this._currentConnector[e](...n);
  }
  /**
   * Create a method for each method proxy that is available on the Common interface
   * and call the method from the current connector.
   */
  setupMethods() {
    Object.values(pw).forEach((e) => {
      this[e] = async (...n) => this.callMethod(e, ...n);
    });
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status.
   */
  async fetchConnectorStatus(e) {
    const n = Date.now(), [s, i] = await Promise.allSettled([
      ji(e.isConnected()),
      ji(this.pingConnector(e))
    ]);
    return n < (e._latestUpdate || 0) || (e._latestUpdate = Date.now(), e.installed = i.status === "fulfilled" && i.value, e.connected = s.status === "fulfilled" && s.value), {
      installed: e.installed,
      connected: e.connected
    };
  }
  /**
   * Fetch the status of all connectors and set the installed and connected
   * status.
   */
  async fetchConnectorsStatus() {
    return Promise.all(
      this._connectors.map(async (e) => this.fetchConnectorStatus(e))
    );
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status. If no connector is provided it will ping the current connector.
   */
  async pingConnector(e) {
    const n = e || this._currentConnector;
    if (!n)
      return !1;
    try {
      return await gw(async () => ji(n.ping()), {
        key: n.name,
        cache: this._pingCache,
        cacheTime: dR
      })();
    } catch {
      throw new x(L.INVALID_PROVIDER, "Current connector is not available.");
    }
  }
  /**
   * Return the list of connectors with the status of installed and connected.
   */
  async connectors() {
    return await this.fetchConnectorsStatus(), this._connectors;
  }
  /**
   * Set the current connector to be used.
   */
  async selectConnector(e, n = {
    emitEvents: !0
  }) {
    var a, o;
    const s = this.getConnector(e);
    if (!s)
      return !1;
    if (((a = this._currentConnector) == null ? void 0 : a.name) === e)
      return !0;
    const { installed: i } = await this.fetchConnectorStatus(s);
    return i ? (this._currentConnector = s, this.emit(this.events.currentConnector, s), this.setupConnectorEvents(Object.values(Du)), await ((o = this._storage) == null ? void 0 : o.setItem(rr.STORAGE_KEY, s.name)), n.emitEvents && this.triggerConnectorEvents(), !0) : !1;
  }
  /**
   * Return the current selected connector.
   */
  currentConnector() {
    return this._currentConnector;
  }
  /**
   * Return true if any connector is available.
   */
  async hasConnector() {
    if (this._currentConnector)
      return !0;
    const e = ww();
    return this.once(this.events.currentConnector, () => {
      e.resolve(!0);
    }), ji(e.promise, cR).then(() => !0).catch(() => !1);
  }
  async hasWallet() {
    return this.hasConnector();
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   *
   * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.
   */
  async getProvider(e) {
    return uR(
      "getProvider is deprecated and is going to be removed in the future, use getWallet instead."
    ), this._getProvider(e);
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   */
  async _getProvider(e) {
    let n;
    if (e && "getTransactionResponse" in e)
      n = e;
    else if (e && "chainId" in e && "url" in e)
      n = new Fd(e.url);
    else {
      if (e)
        throw new x(L.INVALID_PROVIDER, "Provider is not valid.");
      {
        const s = await this.currentNetwork();
        n = new Fd(s.url);
      }
    }
    return n;
  }
  /**
   * Return a Fuel Wallet Locked instance with extends features to work with
   * connectors.
   */
  async getWallet(e, n) {
    const s = await this._getProvider(n);
    return new $o(e, s, this);
  }
  /**
   * Remove all open listeners this is useful when you want to
   * remove the Fuel instance and avoid memory leaks.
   */
  unsubscribe() {
    this._unsubscribes.map((e) => e()), this._targetUnsubscribe(), this.removeAllListeners();
  }
  /**
   * Clean all the data from the storage.
   */
  async clean() {
    var e;
    await ((e = this._storage) == null ? void 0 : e.removeItem(rr.STORAGE_KEY));
  }
  /**
   * Removes all listeners and cleans the storage.
   */
  async destroy() {
    this.unsubscribe(), await this.clean();
  }
}, S(rr, "Fuel"), Q(rr, "STORAGE_KEY", "fuel-current-connector"), Q(rr, "defaultConfig", {}), rr), AR = Object.defineProperty, Et = (r, t) => AR(r, "name", { value: t, configurable: !0 }), _i, mw = (_i = class {
}, Et(_i, "AbstractProgram"), _i), pi, RS = (pi = class extends mw {
}, Et(pi, "AbstractContract"), pi);
function Od(r, t) {
  if (!r)
    throw new x(L.TRANSACTION_ERROR, t);
}
Et(Od, "assert");
function ba(r) {
  return r.reduce((t, e, n) => {
    const { program: s, externalAbis: i } = e.getCallConfig();
    return n === 0 ? (t.main = s.interface.jsonAbi, t.otherContractsAbis = {}) : t.otherContractsAbis[s.id.toB256()] = s.interface.jsonAbi, t.otherContractsAbis = { ...t.otherContractsAbis, ...i }, t;
  }, {});
}
Et(ba, "getAbisFromAllCalls");
var SS = /* @__PURE__ */ Et((r, t, e) => {
  if (!t)
    return [];
  const { main: n, otherContractsAbis: s } = ba(e);
  return Hg(r, n, s);
}, "getResultLogs"), Ou = /* @__PURE__ */ Et((r) => {
  const { receipts: t, mainCallConfig: e, functionScopes: n } = r;
  if (!e)
    return { logs: [], groupedLogs: {} };
  const { main: s, otherContractsAbis: i } = ba(n);
  return aa({ receipts: t, mainAbi: s, externalAbis: i });
}, "getAllResultLogs"), br, fi, Mu = (fi = class {
  constructor(...t) {
    Ce(this, br);
    Gt(this, br, t || []);
  }
  entries() {
    return _t(this, br);
  }
  push(...t) {
    _t(this, br).push(...t);
  }
  concat(t) {
    return _t(this, br).concat(t);
  }
  extend(t) {
    _t(this, br).push(...t);
  }
  toBytes() {
    return ct(
      _t(this, br).reduce((t, e) => (t.push(e.to_bytes()), t), [])
    );
  }
  toHex() {
    return W(this.toBytes());
  }
  toString() {
    return `Program:
${JSON.stringify(_t(this, br), null, 2)}`;
  }
  byteLength() {
    return this.toBytes().byteLength;
  }
}, br = new WeakMap(), Et(fi, "InstructionSet"), fi), lR = /* @__PURE__ */ Et((r) => Mp + Op({ maxInputs: r }), "calculateScriptDataBaseOffset");
function yw(r) {
  const t = [...r.receipts];
  let e, n;
  if (t.forEach((i) => {
    i.type === At.ScriptResult ? e = i : (i.type === At.Return || i.type === At.ReturnData || i.type === At.Revert) && (n = i);
  }), !e || !n)
    throw new x(L.SCRIPT_REVERTED, "Transaction reverted.");
  return {
    code: e.result,
    gasUsed: e.gasUsed,
    receipts: t,
    scriptResultReceipt: e,
    returnReceipt: n,
    callResult: r
  };
}
Et(yw, "callResultToScriptResult");
function tc(r) {
  var a;
  const { callResult: t, scriptResultDecoder: e, logs: n = [], groupedLogs: s = {}, abis: i } = r;
  try {
    const o = yw(t);
    return e(o);
  } catch (o) {
    if (o.code === L.SCRIPT_REVERTED) {
      const d = (a = t == null ? void 0 : t.dryRunStatus) == null ? void 0 : a.reason;
      throw wu({
        logs: n,
        groupedLogs: s,
        receipts: t.receipts,
        statusReason: d,
        abis: i
      });
    }
    throw o;
  }
}
Et(tc, "decodeCallResult");
function bw(r) {
  const { callResult: t, call: e, logs: n = [], groupedLogs: s = {}, abis: i } = r;
  return tc({
    callResult: t,
    scriptResultDecoder: /* @__PURE__ */ Et((a) => {
      if (a.returnReceipt.type === At.Revert)
        throw new x(
          L.SCRIPT_REVERTED,
          `Script Reverted. Logs: ${JSON.stringify(n)}`
        );
      if (a.returnReceipt.type !== At.Return && a.returnReceipt.type !== At.ReturnData) {
        const { type: d } = a.returnReceipt;
        throw new x(
          L.SCRIPT_REVERTED,
          `Script Return Type [${d}] Invalid. Logs: ${JSON.stringify({
            logs: n,
            groupedLogs: s,
            receipt: a.returnReceipt
          })}`
        );
      }
      let o;
      return a.returnReceipt.type === At.Return && (o = a.returnReceipt.val), a.returnReceipt.type === At.ReturnData && (o = e.func.decodeOutput(a.returnReceipt.data)[0]), o;
    }, "scriptResultDecoder"),
    logs: n,
    groupedLogs: s,
    abis: i
  });
}
Et(bw, "callResultToInvocationResult");
var kn, Pu = (kn = class {
  /**
   * Creates an instance of the ScriptRequest class.
   *
   * @param bytes - The bytes of the script.
   * @param scriptDataEncoder - The script data encoder function.
   * @param scriptResultDecoder - The script result decoder function.
   */
  constructor(t, e, n) {
    /**
     * The bytes of the script.
     */
    Q(this, "bytes");
    /**
     * A function to encode the script data.
     */
    Q(this, "scriptDataEncoder");
    /**
     * A function to decode the script result.
     */
    Q(this, "scriptResultDecoder");
    this.bytes = j(t), this.scriptDataEncoder = e, this.scriptResultDecoder = n;
  }
  /**
   * Gets the script data offset for the given bytes.
   *
   * @param byteLength - The byte length of the script.
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  static getScriptDataOffsetWithScriptBytes(t, e) {
    return Op({ maxInputs: e }) + Mp + t;
  }
  /**
   * Gets the script data offset.
   *
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  getScriptDataOffset(t) {
    return kn.getScriptDataOffsetWithScriptBytes(this.bytes.length, t);
  }
  /**
   * Encodes the data for a script call.
   *
   * @param data - The script data.
   * @returns The encoded data.
   */
  encodeScriptData(t) {
    const e = this.scriptDataEncoder(t);
    return ArrayBuffer.isView(e) ? e : (this.bytes = j(e.script), e.data);
  }
  decodeCallResult(t, e, n, s) {
    let i, a, o, d;
    return typeof t == "object" && "callResult" in t ? (i = t.callResult, a = t.logs ?? [], o = t.groupedLogs ?? {}, d = t.abis) : (i = t, a = e ?? [], o = n ?? {}, d = s), tc({
      callResult: i,
      scriptResultDecoder: this.scriptResultDecoder,
      logs: a,
      groupedLogs: o,
      abis: d
    });
  }
}, Et(kn, "ScriptRequest"), kn), Iw = {
  assetIdOffset: 0,
  amountOffset: 0,
  gasForwardedOffset: 0,
  callDataOffset: 0
}, hR = St, Cw = /* @__PURE__ */ Et(({
  callDataOffset: r,
  gasForwardedOffset: t,
  amountOffset: e,
  assetIdOffset: n
}) => {
  const s = new Mu(
    rs(16, r),
    rs(17, e),
    ea(17, 17, 0),
    rs(18, n)
  );
  return t ? s.push(
    rs(19, t),
    ea(19, 19, 0),
    Kc(16, 17, 18, 19)
  ) : s.push(Kc(16, 17, 18, h.cgas().to_u8())), s;
}, "getSingleCallInstructions");
function Md(r) {
  if (!r.length)
    return new Uint8Array();
  const t = new Mu();
  for (let e = 0; e < r.length; e += 1)
    t.extend(Cw(r[e]).entries());
  return t.push(Pd(1)), t.toBytes();
}
Et(Md, "getInstructions");
var _R = /* @__PURE__ */ Et((r) => r === At.Return || r === At.ReturnData, "isReturnType"), pR = /* @__PURE__ */ Et((r, t) => r.find(
  ({ type: e, id: n, to: s }) => e === At.Call && n === hR && s === t
), "getMainCallReceipt"), fR = /* @__PURE__ */ Et((r) => (t) => {
  if (Ur(t.code) !== 0)
    throw new x(L.SCRIPT_REVERTED, "Transaction reverted.");
  const e = pR(
    t.receipts,
    r.toB256()
  ), n = I(e == null ? void 0 : e.is);
  return t.receipts.filter(({ type: i }) => _R(i)).flatMap((i) => n.eq(I(i.is)) ? i.type === At.Return ? [new rt("u64").encode(i.val)] : i.type === At.ReturnData ? [j(i.data)] : [new Uint8Array()] : []);
}, "scriptResultDecoder"), gR = /* @__PURE__ */ Et((r) => {
  const { contractId: t, ...e } = r;
  return tc({
    ...e,
    scriptResultDecoder: fR(t)
  });
}, "decodeContractCallScriptResult"), wR = /* @__PURE__ */ Et((r) => r.reduce(
  (t, e) => {
    const n = { ...Iw };
    return e.gas && (n.gasForwardedOffset = 1), t + Cw(n).byteLength();
  },
  V.size()
  // placeholder for single RET instruction which is added later
), "getCallInstructionsLength"), mR = /* @__PURE__ */ Et((r, t) => new Pu(
  // Script to call the contract, start with stub size matching length of calls
  Md(new Array(r.length).fill(Iw)),
  (e) => {
    var v;
    const n = e.length;
    if (n === 0)
      return { data: new Uint8Array(), script: new Uint8Array() };
    const s = wR(e), i = (8 - s % 8) % 8, a = s + i, o = lR(t.toNumber()) + a, d = [];
    let A = o;
    const p = [];
    for (let N = 0; N < n; N += 1) {
      const E = e[N], F = A, k = F + ht, H = k + na, X = H + Ad + ht + ht, D = X + E.fnSelectorBytes.byteLength, M = j(E.data);
      let P = 0;
      p.push(new rt("u64").encode(E.amount || 0)), p.push(new ot().encode(((v = E.assetId) == null ? void 0 : v.toString()) || St)), p.push(E.contractId.toBytes()), p.push(new rt("u64").encode(X)), p.push(new rt("u64").encode(D)), p.push(E.fnSelectorBytes), p.push(M), E.gas && (p.push(new rt("u64").encode(E.gas)), P = D + M.byteLength);
      const U = {
        amountOffset: F,
        assetIdOffset: k,
        gasForwardedOffset: P,
        callDataOffset: H
      };
      d.push(U), A = o + ct(p).byteLength;
    }
    const g = Md(d);
    return { data: ct(p), script: g };
  },
  () => [new Uint8Array()]
), "getContractCallScript");
function ec(r, t, e, n, s, i) {
  var E;
  let a, o, d, A, p, g;
  typeof r == "object" && !Array.isArray(r) ? (a = r.functionScopes, o = r.receipts, d = r.isMultiCall, A = r.logs ?? [], p = r.groupedLogs ?? {}, g = r.abis) : (a = r, o = t, d = e, A = n ?? [], p = s ?? {}, g = i);
  const y = (E = a[0]) == null ? void 0 : E.getCallConfig();
  if (a.length === 1 && y && "bytes" in y.program)
    return bw({
      callResult: { receipts: o },
      call: y,
      logs: A,
      groupedLogs: p,
      abis: g
    });
  const N = gR({
    callResult: { receipts: o },
    contractId: (y == null ? void 0 : y.program).id,
    logs: A,
    groupedLogs: p,
    abis: g
  }).map((F, k) => {
    var X;
    const { func: H } = a[k].getCallConfig();
    return (X = H.decodeOutput(F)) == null ? void 0 : X[0];
  });
  return d ? N : N == null ? void 0 : N[0];
}
Et(ec, "extractInvocationResult");
var yR = /* @__PURE__ */ Et(async (r) => {
  var k;
  const { funcScope: t, isMultiCall: e, program: n, transactionResponse: s } = r, i = await s.waitForResult(), { receipts: a } = i, o = Array.isArray(t) ? t : [t], d = (k = o[0]) == null ? void 0 : k.getCallConfig(), { main: A, otherContractsAbis: p } = ba(o), g = { main: A, otherContractsAbis: p }, { logs: y, groupedLogs: v } = Ou({ receipts: a, mainCallConfig: d, functionScopes: o }), N = ec(
    o,
    a,
    e,
    y,
    v,
    g
  ), E = Pi(a);
  return {
    isMultiCall: e,
    functionScopes: o,
    value: N,
    program: n,
    transactionResult: i,
    transactionResponse: s,
    transactionId: s.id,
    logs: y,
    groupedLogs: v,
    gasUsed: E
  };
}, "buildFunctionResult"), bR = /* @__PURE__ */ Et(async (r) => {
  var N;
  const { funcScope: t, isMultiCall: e, program: n, transactionResponse: s } = r, i = await s.waitForPreConfirmation(), { receipts: a } = i, o = Array.isArray(t) ? t : [t], d = (N = o[0]) == null ? void 0 : N.getCallConfig();
  let A, p, g, y;
  return a && ({ logs: A, groupedLogs: p } = Ou({ receipts: a, mainCallConfig: d, functionScopes: o }), y = ec(o, a, e, A, p), g = Pi(a)), {
    isMultiCall: e,
    functionScopes: o,
    program: n,
    transactionResult: i,
    transactionResponse: s,
    transactionId: s.id,
    logs: A,
    groupedLogs: p,
    gasUsed: g,
    value: y
  };
}, "buildPreConfirmationFunctionResult"), $c = /* @__PURE__ */ Et((r) => {
  var y;
  const { funcScopes: t, callResult: e, isMultiCall: n } = r, { receipts: s } = e, i = Array.isArray(t) ? t : [t], a = (y = i[0]) == null ? void 0 : y.getCallConfig(), { logs: o, groupedLogs: d } = Ou({ receipts: s, mainCallConfig: a, functionScopes: i }), A = ec(
    i,
    s,
    n,
    o,
    d
  ), p = Pi(s);
  return {
    functionScopes: i,
    callResult: e,
    isMultiCall: n,
    gasUsed: p,
    value: A
  };
}, "buildDryRunResult");
function Ew(r) {
  const { program: t, args: e, forward: n, func: s, callParameters: i, externalAbis: a } = r.getCallConfig(), o = s.encodeArguments(e);
  return {
    contractId: t.id,
    fnSelectorBytes: s.selectorBytes,
    data: o,
    assetId: n == null ? void 0 : n.assetId,
    amount: n == null ? void 0 : n.amount,
    gas: i == null ? void 0 : i.gasLimit,
    externalContractsAbis: a
  };
}
Et(Ew, "createContractCall");
var gi, Bw = (gi = class {
  /**
   * Constructs an instance of BaseInvocationScope.
   *
   * @param program - The abstract program to be invoked.
   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
   */
  constructor(t, e) {
    Q(this, "transactionRequest");
    Q(this, "program");
    Q(this, "functionInvocationScopes", []);
    Q(this, "txParameters");
    Q(this, "assembleTxParameters");
    Q(this, "requiredCoins", []);
    Q(this, "isMultiCall", !1);
    Q(this, "hasCallParamsGasLimit", !1);
    // flag to check if any of the callParams has gasLimit set
    Q(this, "externalAbis", {});
    /**
     * @deprecated - Should be removed with `addSigners`
     */
    Q(this, "addSignersCallback");
    this.program = t, this.isMultiCall = e, this.transactionRequest = new Ir();
  }
  /**
   * Getter for the contract calls.
   *
   * @returns An array of contract calls.
   */
  get calls() {
    return this.functionInvocationScopes.map((t) => Ew(t));
  }
  /**
   * Updates the script request with the current contract calls.
   */
  async updateScriptRequest() {
    const t = this.getProvider(), {
      consensusParameters: {
        txParameters: { maxInputs: e }
      }
    } = await t.getChain(), n = mR(this.functionInvocationScopes, e);
    this.transactionRequest.setScript(n, this.calls);
  }
  /**
   * Updates the transaction request with the current input/output.
   */
  updateContractInputAndOutput() {
    this.calls.forEach((e) => {
      e.contractId && this.transactionRequest.addContractInputAndOutput(e.contractId), e.externalContractsAbis && Object.keys(e.externalContractsAbis).forEach(
        (n) => this.transactionRequest.addContractInputAndOutput(new wt(n))
      );
    });
  }
  /**
   * Gets the required coins for the transaction.
   *
   * @returns An array of required coin quantities.
   */
  getRequiredCoins() {
    return this.calls.map((e) => ({
      assetId: String(e.assetId),
      amount: I(e.amount || 0)
    })).filter(({ assetId: e, amount: n }) => e && !I(n).isZero());
  }
  /**
   * Updates the required coins for the transaction.
   */
  updateRequiredCoins() {
    const t = this.getRequiredCoins(), e = /* @__PURE__ */ Et((n, { assetId: s, amount: i }) => {
      var o;
      const a = ((o = n.get(s)) == null ? void 0 : o.amount) || I(0);
      return n.set(s, {
        assetId: String(s),
        amount: a.add(i)
      });
    }, "reduceForwardCoins");
    this.requiredCoins = Array.from(
      t.reduce(e, /* @__PURE__ */ new Map()).values()
    );
  }
  /**
   * Adds a single call to the invocation scope.
   *
   * @param funcScope - The function scope to add.
   * @returns The current instance of the class.
   */
  addCall(t) {
    return this.addCalls([t]), this;
  }
  /**
   * Adds multiple calls to the invocation scope.
   *
   * @param funcScopes - An array of function scopes to add.
   * @returns The current instance of the class.
   */
  addCalls(t) {
    return this.functionInvocationScopes.push(...t), this.updateContractInputAndOutput(), this.updateRequiredCoins(), this;
  }
  /**
   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
   */
  async prepareTransaction() {
    await Io(), await this.updateScriptRequest(), this.updateRequiredCoins(), this.checkGasLimitTotal(), this.transactionRequest.type === Ct.Script && (this.transactionRequest.abis = ba(this.functionInvocationScopes));
  }
  /**
   * Checks if the total gas limit is within the acceptable range.
   */
  checkGasLimitTotal() {
    const t = this.calls.reduce((e, n) => e.add(n.gas || 0), I(0));
    if (this.transactionRequest.gasLimit.eq(0))
      this.transactionRequest.gasLimit = t;
    else if (t.gt(this.transactionRequest.gasLimit))
      throw new x(
        L.TRANSACTION_ERROR,
        "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
      );
  }
  /**
   * Gets the transaction cost for dry running the transaction.
   *
   * @returns The transaction cost details.
   *
   * @deprecated Use contract.fundWithRequiredCoins instead
   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.
   */
  async getTransactionCost() {
    const t = ve(await this.getTransactionRequest());
    return (this.program.account ?? er.generate({ provider: this.getProvider() })).getTransactionCost(t, {
      quantities: this.getRequiredCoins(),
      signatureCallback: this.addSignersCallback
    });
  }
  /**
   * Funds the transaction request with the required coins and returns it.
   *
   * @returns The transaction request.
   */
  async fundWithRequiredCoins({
    skipAutoConsolidation: t
  } = {}) {
    let e = await this.getTransactionRequest();
    e = ve(e);
    let { feePayerAccount: n, accountCoinQuantities: s, ...i } = this.assembleTxParameters ?? {};
    e.maxFee = I(0), e.gasLimit = I(0);
    const a = this.getProvider(), o = this.program.account ?? er.generate({ provider: a }), d = await a.getBaseAssetId();
    if (n || (n = o), !s) {
      const p = e.outputs.filter((g) => g.type === lt.Coin).map(({ amount: g, assetId: y }) => ({ assetId: String(y), amount: I(g) }));
      s = za(p, this.requiredCoins), s.length || s.push({ assetId: d, amount: I(0) });
    }
    const A = /* @__PURE__ */ Et(async () => {
      var y, v;
      const { assembledRequest: p, gasPrice: g } = await a.assembleTx({
        request: e,
        feePayerAccount: n,
        accountCoinQuantities: s,
        ...i
      });
      return await is({
        gasPrice: g,
        provider: a,
        transactionRequest: p,
        setGasLimit: (y = this.txParameters) == null ? void 0 : y.gasLimit,
        setMaxFee: (v = this.txParameters) == null ? void 0 : v.maxFee
      }), p;
    }, "assembleTx");
    try {
      return await A();
    } catch (p) {
      if (!await Nd({
        error: p,
        account: o,
        skipAutoConsolidation: t
      }))
        throw p;
      return await A();
    }
  }
  /**
   * @deprecated - Should be removed with `addSigners`
   */
  async legacyFundWithRequiredCoins({
    skipAutoConsolidation: t
  } = {}) {
    var d;
    let e = await this.getTransactionRequest();
    e = ve(e);
    const n = await this.getTransactionCost(), { gasUsed: s, missingContractIds: i, outputVariables: a, maxFee: o } = n;
    return this.setDefaultTxParams(e, s, o), i.forEach((A) => {
      e.addContractInputAndOutput(new wt(A));
    }), e.addVariableOutputs(a), await ((d = this.program.account) == null ? void 0 : d.fund(e, n, { skipAutoConsolidation: t })), this.addSignersCallback && await this.addSignersCallback(e), e;
  }
  /**
   * Sets the transaction parameters.
   *
   * @param txParams - The transaction parameters to set.
   * @returns The current instance of the class.
   */
  txParams(t) {
    var n;
    this.txParameters = t;
    const e = this.transactionRequest;
    return e.tip = I(t.tip || e.tip), e.gasLimit = I(t.gasLimit || e.gasLimit), e.maxFee = t.maxFee ? I(t.maxFee) : e.maxFee, e.witnessLimit = t.witnessLimit ? I(t.witnessLimit) : e.witnessLimit, e.maturity = t.maturity || e.maturity, e.expiration = t.expiration || e.expiration, e.addVariableOutputs(((n = this.txParameters) == null ? void 0 : n.variableOutputs) || 0), this;
  }
  /**
   * Sets the transaction parameters.
   *
   * @param assembleTxParams - The assembleTx parameters to set when invoking the `provider.assembleTx` method.
   * @returns The current instance of the class.
   */
  assembleTxParams(t) {
    return this.assembleTxParameters = t, this;
  }
  /**
   * Adds contracts to the invocation scope.
   *
   * @param contracts - An array of contracts to add.
   * @returns The current instance of the class.
   */
  addContracts(t) {
    return t.forEach((e) => {
      typeof e == "string" ? this.transactionRequest.addContractInputAndOutput(new wt(e)) : (this.transactionRequest.addContractInputAndOutput(e.id), this.externalAbis[e.id.toB256()] = e.interface.jsonAbi);
    }), this;
  }
  /**
   * Adds an asset transfer to an Account on the contract call transaction request.
   *
   * @param transferParams - The object representing the transfer to be made.
   * @returns The current instance of the class.
   */
  addTransfer(t) {
    const { amount: e, destination: n, assetId: s } = t;
    return this.transactionRequest = this.transactionRequest.addCoinOutput(
      new wt(n),
      e,
      s
    ), this;
  }
  /**
   * Adds multiple transfers to the contract call transaction request.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The current instance of the class.
   */
  addBatchTransfer(t) {
    return t.forEach(({ destination: e, amount: n, assetId: s }) => {
      this.transactionRequest = this.transactionRequest.addCoinOutput(
        new wt(e),
        n,
        s
      );
    }), this;
  }
  /**
   * Adds signers to the transaction request.
   *
   * @param signers - The signers to add.
   * @returns The current instance of the class.
   *
   * @deprecated This method is deprecated and will be removed in a future versions.
   * All signatures should be manually added to the transaction request witnesses. If your
   * Sway program relies on in-code signature validation, visit this guide:
   * https://docs.fuel.network/docs/fuels-ts/cookbook/sway-script-with-signature-validation/
   */
  addSigners(t) {
    return this.addSignersCallback = (e) => e.addAccountWitnesses(t), this;
  }
  /**
   * Prepares and returns the transaction request object.
   *
   * @returns The prepared transaction request.
   */
  async getTransactionRequest() {
    return await this.prepareTransaction(), this.transactionRequest;
  }
  /**
   * Sets the transaction request. Useful when you have used `getTransactionRequest` or
   * `fundWithRequiredCoins` from the scope to apply customizations to the transaction request.
   *
   * @param request - The transaction request to set.
   * @returns The current instance of the class.
   */
  fromRequest(t) {
    return this.transactionRequest = t, this;
  }
  /**
   * Submits the contract call transaction and returns a promise that resolves to an object
   * containing the transaction ID and a function to wait for the result. The promise will resolve
   * as soon as the transaction is submitted to the node.
   *
   * @param params - Optional parameters for the call.
   * - `skipAssembleTx`: A boolean indicating whether to skip assembling the transaction. This is useful
   *   when customizations were made to the transaction request using the `assembleTx` method.
   *
   * @returns A promise that resolves to an object containing:
   * - `transactionId`: The ID of the submitted transaction.
   * - `waitForResult`: A function that waits for the transaction result.
   * - `waitForPreConfirmation`: A function that waits for the transaction pre-confirmation.
   * @template T - The type of the return value.
   */
  async call(t) {
    Od(this.program.account, "Wallet is required!");
    let e = await this.getTransactionRequest();
    const n = t == null ? void 0 : t.skipAssembleTx, s = t == null ? void 0 : t.skipAutoConsolidation;
    n || (this.addSignersCallback ? e = await this.legacyFundWithRequiredCoins({ skipAutoConsolidation: s }) : e = await this.fundWithRequiredCoins({ skipAutoConsolidation: s }));
    const i = await this.program.account.sendTransaction(e, {
      estimateTxDependencies: !1
    });
    return {
      transactionId: i.id,
      waitForResult: /* @__PURE__ */ Et(async () => yR({
        funcScope: this.functionInvocationScopes,
        isMultiCall: this.isMultiCall,
        program: this.program,
        transactionResponse: i
      }), "waitForResult"),
      waitForPreConfirmation: /* @__PURE__ */ Et(async () => bR({
        funcScope: this.functionInvocationScopes,
        isMultiCall: this.isMultiCall,
        program: this.program,
        transactionResponse: i
      }), "waitForPreConfirmation")
    };
  }
  /**
   * Simulates a transaction.
   *
   * @returns The result of the invocation call.
   */
  async simulate() {
    if (Od(this.program.account, "Wallet is required!"), !("populateTransactionWitnessesSignature" in this.program.account))
      throw new x(
        L.ABI_MAIN_METHOD_MISSING,
        "An unlocked wallet is required to simulate a contract call."
      );
    const t = await this.fundWithRequiredCoins(), e = await this.program.account.simulateTransaction(t, {
      estimateTxDependencies: !1
    });
    return $c({
      funcScopes: this.functionInvocationScopes,
      callResult: e,
      isMultiCall: this.isMultiCall
    });
  }
  /**
   * Executes a transaction in dry run mode.
   *
   * @returns The result of the invocation call.
   *
   * @deprecated Use .get instead
   */
  async dryRun() {
    const { receipts: t } = await this.getTransactionCost(), e = {
      receipts: t
    };
    return $c({
      funcScopes: this.functionInvocationScopes,
      callResult: e,
      isMultiCall: this.isMultiCall
    });
  }
  async get() {
    let t = await this.getTransactionRequest();
    t = ve(t), t.maxFee = I(0), t.gasLimit = I(0), t.inputs = t.inputs.filter((p) => p.type !== xt.Coin);
    const e = this.getProvider(), n = this.program.account ?? er.generate({ provider: e }), s = await e.getBaseAssetId(), i = t.outputs.filter((p) => p.type === lt.Coin).map(({ amount: p, assetId: g }) => ({ assetId: String(g), amount: I(p) })).concat(this.requiredCoins), a = n.generateFakeResources(i), o = a.find((p) => p.assetId === s), d = I("1000000000000000");
    if (o)
      o.amount = o.amount.add(d);
    else {
      const [p] = n.generateFakeResources([
        { assetId: s, amount: d }
      ]);
      a.push(p);
    }
    t.addResources(a);
    const { receipts: A } = await e.assembleTx({
      request: t,
      feePayerAccount: n
    });
    return $c({
      funcScopes: this.functionInvocationScopes,
      callResult: { receipts: A },
      isMultiCall: this.isMultiCall
    });
  }
  getProvider() {
    return this.program.provider;
  }
  /**
   * In case the gasLimit is *not* set by the user, this method sets a default value.
   */
  setDefaultTxParams(t, e, n) {
    var d, A;
    const s = Ge((d = this.txParameters) == null ? void 0 : d.gasLimit) || this.hasCallParamsGasLimit, i = Ge((A = this.txParameters) == null ? void 0 : A.maxFee), { gasLimit: a, maxFee: o } = t;
    if (!s)
      t.gasLimit = e;
    else if (a.lt(e))
      throw new x(
        L.GAS_LIMIT_TOO_LOW,
        `Gas limit '${a}' is lower than the required: '${e}'.`
      );
    if (!i)
      t.maxFee = n;
    else if (n.gt(o))
      throw new x(
        L.MAX_FEE_TOO_LOW,
        `Max fee '${o}' is lower than the required: '${n}'.`
      );
  }
}, Et(gi, "BaseInvocationScope"), gi), wi, vw = (wi = class extends Bw {
  /**
   * Constructs an instance of FunctionInvocationScope.
   *
   * @param program - The program.
   * @param func - The function fragment.
   * @param args - The arguments.
   */
  constructor(e, n, s) {
    super(e, !1);
    Q(this, "func");
    Q(this, "callParameters");
    Q(this, "forward");
    Q(this, "args");
    this.func = n, this.args = s || [], this.setArguments(...s), super.addCall(this);
  }
  /**
   * Gets the call configuration.
   *
   * @returns The call configuration.
   */
  getCallConfig() {
    return {
      func: this.func,
      program: this.program,
      callParameters: this.callParameters,
      txParameters: this.txParameters,
      forward: this.forward,
      args: this.args,
      externalAbis: this.externalAbis
    };
  }
  /**
   * Sets the arguments for the function invocation.
   *
   * @param args - The arguments.
   * @returns The instance of FunctionInvocationScope.
   */
  setArguments(...e) {
    return this.args = e || [], this;
  }
  /**
   * Sets the call parameters for the function invocation.
   *
   * @param callParams - The call parameters.
   * @returns The instance of FunctionInvocationScope.
   * @throws If the function is not payable and forward is set.
   */
  callParams(e) {
    if (!this.hasCallParamsGasLimit && (e == null ? void 0 : e.gasLimit) !== void 0 && (this.hasCallParamsGasLimit = !0), this.callParameters = e, e != null && e.forward) {
      if (!this.func.attributes.find((n) => n.name === "payable"))
        throw new x(
          L.TRANSACTION_ERROR,
          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
        );
      this.forward = Au(e.forward);
    }
    return this.setArguments(...this.args), this.updateRequiredCoins(), this;
  }
}, Et(wi, "FunctionInvocationScope"), wi), mi, IR = (mi = class extends Bw {
  /**
   * Constructs an instance of MultiCallInvocationScope.
   *
   * @param contract - The contract.
   * @param funcScopes - An array of function invocation scopes.
   */
  constructor(t, e) {
    super(t, !0), this.addCalls(e);
  }
  /**
   * Adds a single function invocation scope to the multi-call invocation scope.
   *
   * @param funcScope - The function invocation scope.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCall(t) {
    return super.addCalls([t]);
  }
  /**
   * Adds multiple function invocation scopes to the multi-call invocation scope.
   *
   * @param funcScopes - An array of function invocation scopes.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCalls(t) {
    return super.addCalls(t);
  }
}, Et(mi, "MultiCallInvocationScope"), mi), yi, Va = (yi = class {
  /**
   * Creates an instance of the Contract class.
   *
   * @param id - The contract's address.
   * @param abi - The contract's ABI (JSON ABI or Interface instance).
   * @param accountOrProvider - The account or provider for interaction.
   */
  constructor(t, e, n) {
    /**
     * The unique contract identifier.
     */
    Q(this, "id");
    /**
     * The provider for interacting with the contract.
     */
    Q(this, "provider");
    /**
     * The contract's ABI interface.
     */
    Q(this, "interface");
    /**
     * The account associated with the contract, if available.
     */
    Q(this, "account");
    /**
     * A collection of functions available on the contract.
     */
    Q(this, "functions", {});
    this.interface = e instanceof Je ? e : new Je(e), this.id = new wt(t), n && "provider" in n ? (this.provider = n.provider, this.account = n) : (this.provider = n, this.account = null), Object.keys(this.interface.functions).forEach((s) => {
      const i = this.interface.getFunction(s);
      Object.defineProperty(this.functions, i.name, {
        value: this.buildFunction(i),
        writable: !1
      });
    });
  }
  /**
   * Build a function invocation scope for the provided function fragment.
   *
   * @param func - The function fragment to build a scope for.
   * @returns A function that creates a FunctionInvocationScope.
   */
  buildFunction(t) {
    return (() => {
      const e = /* @__PURE__ */ Et((...n) => new vw(this, t, n), "funcInvocationScopeCreator");
      return Object.defineProperty(e, "isReadOnly", {
        value: /* @__PURE__ */ Et(() => t.isReadOnly(), "value"),
        writable: !1
      }), e;
    })();
  }
  /**
   * Create a multi-call invocation scope for the provided function invocation scopes.
   *
   * @param calls - An array of FunctionInvocationScopes to execute in a batch.
   * @returns A MultiCallInvocationScope instance.
   */
  multiCall(t) {
    return new IR(this, t);
  }
  /**
   * Get the balance for a given asset ID for this contract.
   *
   * @param assetId - The specified asset ID.
   * @returns The balance of the contract for the specified asset.
   */
  getBalance(t) {
    return this.provider.getContractBalance(this.id, t);
  }
}, Et(yi, "Contract"), yi), CR = Object.defineProperty, ta = (r, t) => CR(r, "name", { value: t, configurable: !0 }), bi, ER = (bi = class extends vw {
  constructor() {
    super(...arguments);
    Q(this, "scriptRequest");
  }
  async updateScriptRequest() {
    this.scriptRequest || await this.buildScriptRequest(), this.transactionRequest.setScript(this.scriptRequest, this.args);
  }
  async buildScriptRequest() {
    const e = this.program.bytes;
    if (!await this.program.provider.getChain())
      throw new x(
        x.CODES.CHAIN_INFO_CACHE_EMPTY,
        "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `new Provider()`"
      );
    this.scriptRequest = new Pu(
      e,
      (s) => this.func.encodeArguments(s),
      () => []
    );
  }
}, ta(bi, "ScriptInvocationScope"), bi), Ii, BR = (Ii = class extends mw {
}, ta(Ii, "AbstractScript"), Ii), Un, TS = (Un = class extends BR {
  /**
   * Create a new instance of the Script class.
   *
   * @param bytecode - The compiled bytecode of the script.
   * @param abi - The ABI interface for the script.
   * @param account - The account associated with the script.
   */
  constructor(e, n, s) {
    super();
    /**
     * The compiled bytecode of the script.
     */
    Q(this, "bytes");
    /**
     * The ABI interface for the script.
     */
    Q(this, "interface");
    /**
     * The account associated with the script.
     */
    Q(this, "account");
    /**
     * The script request object.
     */
    Q(this, "script");
    /**
     * The provider used for interacting with the network.
     */
    Q(this, "provider");
    /**
     * Functions that can be invoked within the script.
     */
    Q(this, "functions");
    this.bytes = j(e), this.interface = new Je(n), this.provider = s.provider, this.account = s, this.functions = {
      main: /* @__PURE__ */ ta((...i) => new ER(this, this.interface.getFunction("main"), i), "main")
    };
  }
  /**
   * Set the configurable constants of the script.
   *
   * @param configurables - An object containing the configurable constants and their values.
   * @throws Will throw an error if the script has no configurable constants to be set or if an invalid constant is provided.
   * @returns This instance of the `Script`.
   */
  setConfigurableConstants(e) {
    try {
      if (!Object.keys(this.interface.configurables).length)
        throw new x(
          x.CODES.INVALID_CONFIGURABLE_CONSTANTS,
          "The script does not have configurable constants to be set"
        );
      Object.entries(e).forEach(([n, s]) => {
        if (!this.interface.configurables[n])
          throw new x(
            x.CODES.CONFIGURABLE_NOT_FOUND,
            `The script does not have a configurable constant named: '${n}'`
          );
        const { offset: i } = this.interface.configurables[n], a = this.interface.encodeConfigurable(n, s);
        this.bytes.set(a, i);
      });
    } catch (n) {
      throw new x(
        x.CODES.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${n.message}.`
      );
    }
    return this;
  }
  /**
   *
   * @param account - The account used to pay the deployment costs.
   * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate
   * once the blob deployment transaction finishes.
   *
   * The returned loader script will have the same configurable constants
   * as the original script which was used to generate the loader script.
   */
  deploy(e) {
    return Qu({
      deployer: e,
      abi: this.interface.jsonAbi,
      bytecode: this.bytes,
      loaderInstanceCallback: /* @__PURE__ */ ta((n, s) => new Un(n, s, this.account), "loaderInstanceCallback")
    });
  }
}, ta(Un, "Script"), Un);
new Pu(
  /*
    Opcode::RET(REG_ZERO)
    Opcode::NOOP
  */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  "0x24000000",
  () => new Uint8Array(0),
  () => {
  }
);
var FS = "https://devnet.fuel.network/v1/graphql", NS = "https://testnet.fuel.network/v1/graphql", vR = Object.defineProperty, tr = (r, t) => vR(r, "name", { value: t, configurable: !0 }), xR = /* @__PURE__ */ tr((r) => {
  const { RegId: t, Instruction: e } = Q_, n = 12, s = r.length, i = Xr, a = ct(r.map((d) => j(d))), o = new Mu(
    // 1. load the blob contents into memory
    // find the start of the hardcoded blob ids, which are located after the code ends
    gn(16, t.pc().to_u8()),
    // 0x10 to hold the address of the current blob id
    Er(16, 16, n * e.size()),
    // The contract is going to be loaded from the current value of SP onwards, save
    // the location into 0x16 so we can jump into it later on
    gn(22, t.sp().to_u8()),
    // loop counter
    rs(19, s),
    // LOOP starts here
    // 0x11 to hold the size of the current blob
    Ja(17, 16),
    // push the blob contents onto the stack
    qi(16, 0, 17, 1),
    // move on to the next blob
    Er(16, 16, i),
    // decrement the loop counter
    v_(19, 19, 1),
    // Jump backwards (3+1) instructions if the counter has not reached 0
    R_(19, t.zero().to_u8(), 3),
    // Jump into the memory where the contract is loaded
    // what follows is called _jmp_mem by the sway compiler
    // subtract the address contained in IS because jmp will add it back
    Wa(22, 22, t.is().to_u8()),
    // jmp will multiply by 4 so we need to divide to cancel that out
    Za(22, 22, 4),
    // jump to the start of the contract we loaded
    Ya(22)
  ).toBytes();
  return ct([o, a]);
}, "getLoaderInstructions"), RR = /* @__PURE__ */ tr((r, t) => {
  const e = [];
  for (let n = 0, s = 0; n < r.length; n += t, s++) {
    let i = r.slice(n, n + t), a = i.length;
    a % ht !== 0 && (i = ct([i, new Uint8Array(t - i.length)]), a = i.length), e.push({ id: s, size: a, bytecode: i });
  }
  return e;
}, "getContractChunks"), SR = /* @__PURE__ */ tr((r) => {
  const e = j(r), n = j_(e, 16384);
  return uu(n.map((s) => W(s)));
}, "getContractRoot"), TR = /* @__PURE__ */ tr((r) => {
  const t = new p1();
  return r.forEach(({ key: e, value: n }) => t.update(Xt(e), n)), t.root;
}, "getContractStorageRoot"), FR = /* @__PURE__ */ tr((r, t, e) => {
  const n = SR(j(r));
  return Xt(ct(["0x4655454C", t, n, e]));
}, "getContractId"), w_ = /* @__PURE__ */ tr((r) => W(r.startsWith("0x") ? r : `0x${r}`), "hexlifyWithPrefix"), m_ = 0.95, Gn, NR = (Gn = class {
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(t, e, n = null, s = []) {
    Q(this, "bytecode");
    Q(this, "interface");
    Q(this, "provider");
    Q(this, "account");
    Q(this, "storageSlots");
    this.bytecode = j(t), e instanceof Je ? this.interface = e : this.interface = new Je(e), n && "provider" in n ? (this.provider = n.provider, this.account = n) : (this.provider = n, this.account = null), this.storageSlots = s;
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(t) {
    return new Gn(this.bytecode, this.interface, t);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(t) {
    const e = ((t == null ? void 0 : t.storageSlots) ?? []).concat(this.storageSlots).map(({ key: d, value: A }) => ({
      key: w_(d),
      value: w_(A)
    })).filter((d, A, p) => p.findIndex((g) => g.key === d.key) === A).sort(({ key: d }, { key: A }) => d.localeCompare(A)), n = {
      salt: ir(32),
      ...t ?? {},
      storageSlots: e
    };
    if (!this.provider)
      throw new x(
        L.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    t != null && t.configurableConstants && this.setConfigurableConstants(t.configurableConstants);
    const s = (t == null ? void 0 : t.bytecode) || this.bytecode, i = n.stateRoot || TR(n.storageSlots), a = FR(s, n.salt, i), o = new Rd({
      bytecodeWitnessIndex: 0,
      witnesses: [s],
      ...n
    });
    return o.addContractCreatedOutput(a, i), {
      contractId: a,
      transactionRequest: o
    };
  }
  async assembleTx(t, e = {}) {
    const n = this.getAccount(), { maxFee: s } = e;
    t.maxFee = I(0);
    const { gasPrice: i, assembledRequest: a } = await n.provider.assembleTx({
      request: t,
      feePayerAccount: n,
      accountCoinQuantities: []
    });
    return t = await is({
      gasPrice: i,
      provider: n.provider,
      transactionRequest: a,
      setMaxFee: s
    }), t;
  }
  /**
   * Deploy a contract of any length with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deploy(t = {}) {
    const e = this.getAccount(), { consensusParameters: n } = await e.provider.getChain(), s = n.contractParameters.contractMaxSize.toNumber();
    return this.bytecode.length > s ? this.deployAsBlobTx(t) : this.deployAsCreateTx(t);
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsCreateTx(t = {}) {
    const e = this.getAccount(), { consensusParameters: n } = await e.provider.getChain(), s = n.contractParameters.contractMaxSize.toNumber();
    if (this.bytecode.length > s)
      throw new x(
        L.CONTRACT_SIZE_EXCEEDS_LIMIT,
        "Contract bytecode is too large. Please use `deployAsBlobTx` instead."
      );
    const { contractId: i, transactionRequest: a } = await this.prepareDeploy(t), o = await e.sendTransaction(a);
    return {
      contractId: i,
      waitForResult: /* @__PURE__ */ tr(async () => {
        const p = await o.waitForResult();
        return { contract: new Va(i, this.interface, e), transactionResult: p };
      }, "waitForResult"),
      waitForPreConfirmation: /* @__PURE__ */ tr(async () => {
        const p = await o.waitForPreConfirmation();
        return { contract: new Va(i, this.interface, e), transactionResult: p };
      }, "waitForPreConfirmation"),
      waitForTransactionId: /* @__PURE__ */ tr(() => Promise.resolve(o.id), "waitForTransactionId")
    };
  }
  /**
   * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsBlobTx(t = {
    chunkSizeMultiplier: m_
  }) {
    const e = this.getAccount(), { configurableConstants: n, chunkSizeMultiplier: s } = t;
    n && this.setConfigurableConstants(n);
    const i = await this.getMaxChunkSize(t, s), a = RR(j(this.bytecode), i).map((P) => {
      const U = this.blobTransactionRequest({
        ...t,
        bytecode: P.bytecode
      });
      return {
        ...P,
        transactionRequest: U,
        blobId: U.blobId
      };
    }), o = a.map(({ blobId: P }) => P), d = xR(o), { contractId: A, transactionRequest: p } = this.createTransactionRequest({
      bytecode: d,
      ...t
    }), g = [...new Set(o)], y = await e.provider.getBlobs(g), v = g.filter((P) => !y.includes(P));
    let N = I(0);
    const E = await e.provider.getChain(), F = await e.provider.estimateGasPrice(10), k = E.consensusParameters.feeParameters.gasPriceFactor;
    for (const { transactionRequest: P, blobId: U } of a) {
      if (v.includes(U)) {
        const Y = P.calculateMinGas(E), Z = on({
          gasPrice: F,
          gas: Y,
          priceFactor: k,
          tip: P.tip
        }).add(1);
        N = N.add(Z);
      }
      const z = p.calculateMinGas(E), G = on({
        gasPrice: F,
        gas: z,
        priceFactor: k,
        tip: p.tip
      }).add(1);
      N = N.add(G);
    }
    if (N.gt(await e.getBalance()))
      throw new x(L.FUNDS_TOO_LOW, "Insufficient balance to deploy contract.");
    let H;
    const X = new Promise((P) => {
      H = P;
    });
    return { waitForResult: /* @__PURE__ */ tr(async () => {
      const P = [];
      for (const { blobId: Y, transactionRequest: Z } of a)
        if (!P.includes(Y) && v.includes(Y)) {
          const q = await this.assembleTx(Z, t);
          let R;
          try {
            R = await (await e.sendTransaction(q)).waitForResult();
          } catch (u) {
            if (u.message.indexOf(`BlobId is already taken ${Y}`) > -1) {
              P.push(Y);
              continue;
            }
            throw new x(L.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          }
          if (!R.status || R.status !== bg.success)
            throw new x(L.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          P.push(Y);
        }
      await this.assembleTx(p, t), H(p.getTransactionId(await e.provider.getChainId()));
      const z = await (await e.sendTransaction(p)).waitForResult();
      return { contract: new Va(A, this.interface, e), transactionResult: z };
    }, "waitForResult"), contractId: A, waitForTransactionId: /* @__PURE__ */ tr(() => X, "waitForTransactionId") };
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(t) {
    try {
      if (!Object.keys(this.interface.configurables).length)
        throw new x(
          L.CONFIGURABLE_NOT_FOUND,
          "Contract does not have configurables to be set"
        );
      Object.entries(t).forEach(([n, s]) => {
        if (!this.interface.configurables[n])
          throw new x(
            L.CONFIGURABLE_NOT_FOUND,
            `Contract does not have a configurable named: '${n}'`
          );
        const { offset: i } = this.interface.configurables[n], a = this.interface.encodeConfigurable(n, s), o = j(this.bytecode);
        o.set(a, i), this.bytecode = o;
      });
    } catch (e) {
      throw new x(
        L.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${e.message}.`
      );
    }
  }
  getAccount() {
    if (!this.account)
      throw new x(L.ACCOUNT_REQUIRED, "Account not assigned to contract.");
    return this.account;
  }
  async prepareDeploy(t) {
    const { configurableConstants: e } = t;
    e && this.setConfigurableConstants(e);
    const { contractId: n, transactionRequest: s } = this.createTransactionRequest(t);
    return await this.assembleTx(s, t), {
      contractId: n,
      transactionRequest: s
    };
  }
  /**
   * Create a blob transaction request, used for deploying contract chunks.
   *
   * @param options - options for creating a blob transaction request.
   * @returns a populated BlobTransactionRequest.
   */
  blobTransactionRequest(t) {
    const { bytecode: e } = t;
    return new yo({
      blobId: gr(e),
      witnessIndex: 0,
      witnesses: [e],
      ...t
    });
  }
  /**
   * Get the maximum chunk size for deploying a contract by chunks.
   */
  async getMaxChunkSize(t, e = m_) {
    if (e < 0 || e > 1)
      throw new x(
        L.INVALID_CHUNK_SIZE_MULTIPLIER,
        "Chunk size multiplier must be between 0 and 1"
      );
    const n = this.getAccount(), { consensusParameters: s } = await n.provider.getChain(), i = s.contractParameters.contractMaxSize.toNumber(), a = s.txParameters.maxSize.toNumber(), o = 64e3, d = a < i ? a : i, A = d < o ? d : o, p = this.blobTransactionRequest({
      ...t,
      bytecode: ir(32)
    }).addResources(
      n.generateFakeResources([
        { assetId: await n.provider.getBaseAssetId(), amount: I(1) }
      ])
    ), g = (A - p.byteLength() - ht) * e;
    return Math.round(g / ht) * ht;
  }
}, tr(Gn, "ContractFactory"), Gn), QS = 9, DS = 3, OS = 9, MS = 9, PS = 18, LS = 15, kS = 12, US = 9, QR = Object.defineProperty, xw = (r, t) => QR(r, "name", { value: t, configurable: !0 }), y_ = {
  programType: "contract",
  specVersion: "1",
  encodingVersion: "1",
  concreteTypes: [
    {
      type: "()",
      concreteTypeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
    },
    {
      type: "enum standards::src5::AccessError",
      concreteTypeId: "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d",
      metadataTypeId: 1
    },
    {
      type: "enum standards::src5::State",
      concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      metadataTypeId: 2
    },
    {
      type: "enum std::option::Option<struct std::contract_id::ContractId>",
      concreteTypeId: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      metadataTypeId: 4,
      typeArguments: [
        "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
      ]
    },
    {
      type: "enum sway_libs::ownership::errors::InitializationError",
      concreteTypeId: "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893",
      metadataTypeId: 5
    },
    {
      type: "enum sway_libs::upgradability::errors::SetProxyOwnerError",
      concreteTypeId: "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74",
      metadataTypeId: 6
    },
    {
      type: "str",
      concreteTypeId: "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
    },
    {
      type: "struct std::contract_id::ContractId",
      concreteTypeId: "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54",
      metadataTypeId: 9
    },
    {
      type: "struct sway_libs::upgradability::events::ProxyOwnerSet",
      concreteTypeId: "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247",
      metadataTypeId: 10
    },
    {
      type: "struct sway_libs::upgradability::events::ProxyTargetSet",
      concreteTypeId: "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8",
      metadataTypeId: 11
    }
  ],
  metadataTypes: [
    {
      type: "b256",
      metadataTypeId: 0
    },
    {
      type: "enum standards::src5::AccessError",
      metadataTypeId: 1,
      components: [
        {
          name: "NotOwner",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      type: "enum standards::src5::State",
      metadataTypeId: 2,
      components: [
        {
          name: "Uninitialized",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        },
        {
          name: "Initialized",
          typeId: 3
        },
        {
          name: "Revoked",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      type: "enum std::identity::Identity",
      metadataTypeId: 3,
      components: [
        {
          name: "Address",
          typeId: 8
        },
        {
          name: "ContractId",
          typeId: 9
        }
      ]
    },
    {
      type: "enum std::option::Option",
      metadataTypeId: 4,
      components: [
        {
          name: "None",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        },
        {
          name: "Some",
          typeId: 7
        }
      ],
      typeParameters: [7]
    },
    {
      type: "enum sway_libs::ownership::errors::InitializationError",
      metadataTypeId: 5,
      components: [
        {
          name: "CannotReinitialized",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      type: "enum sway_libs::upgradability::errors::SetProxyOwnerError",
      metadataTypeId: 6,
      components: [
        {
          name: "CannotUninitialize",
          typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      type: "generic T",
      metadataTypeId: 7
    },
    {
      type: "struct std::address::Address",
      metadataTypeId: 8,
      components: [
        {
          name: "bits",
          typeId: 0
        }
      ]
    },
    {
      type: "struct std::contract_id::ContractId",
      metadataTypeId: 9,
      components: [
        {
          name: "bits",
          typeId: 0
        }
      ]
    },
    {
      type: "struct sway_libs::upgradability::events::ProxyOwnerSet",
      metadataTypeId: 10,
      components: [
        {
          name: "new_proxy_owner",
          typeId: 2
        }
      ]
    },
    {
      type: "struct sway_libs::upgradability::events::ProxyTargetSet",
      metadataTypeId: 11,
      components: [
        {
          name: "new_target",
          typeId: 9
        }
      ]
    }
  ],
  functions: [
    {
      inputs: [],
      name: "proxy_target",
      output: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      attributes: [
        {
          name: "doc-comment",
          arguments: [" Returns the target contract of the proxy contract."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Returns"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " * [Option<ContractId>] - The new proxy contract to which all fallback calls will be passed or `None`."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Number of Storage Accesses"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * Reads: `1`"]
        },
        {
          name: "storage",
          arguments: ["read"]
        }
      ]
    },
    {
      inputs: [
        {
          name: "new_target",
          concreteTypeId: "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
        }
      ],
      name: "set_proxy_target",
      output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      attributes: [
        {
          name: "doc-comment",
          arguments: [" Change the target contract of the proxy contract."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Additional Information"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" This method can only be called by the `proxy_owner`."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Arguments"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " * `new_target`: [ContractId] - The new proxy contract to which all fallback calls will be passed."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Reverts"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * When not called by `proxy_owner`."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Number of Storage Accesses"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * Reads: `1`"]
        },
        {
          name: "doc-comment",
          arguments: [" * Write: `1`"]
        },
        {
          name: "storage",
          arguments: ["read", "write"]
        }
      ]
    },
    {
      inputs: [],
      name: "proxy_owner",
      output: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      attributes: [
        {
          name: "doc-comment",
          arguments: [" Returns the owner of the proxy contract."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Returns"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " * [State] - Represents the state of ownership for this contract."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Number of Storage Accesses"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * Reads: `1`"]
        },
        {
          name: "storage",
          arguments: ["read"]
        }
      ]
    },
    {
      inputs: [],
      name: "initialize_proxy",
      output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      attributes: [
        {
          name: "doc-comment",
          arguments: [" Initializes the proxy contract."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Additional Information"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " This method sets the storage values using the values of the configurable constants `INITIAL_TARGET` and `INITIAL_OWNER`."
          ]
        },
        {
          name: "doc-comment",
          arguments: [
            " This then allows methods that write to storage to be called."
          ]
        },
        {
          name: "doc-comment",
          arguments: [" This method can only be called once."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Reverts"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " * When `storage::SRC14.proxy_owner` is not [State::Uninitialized]."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Number of Storage Accesses"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * Writes: `2`"]
        },
        {
          name: "storage",
          arguments: ["write"]
        }
      ]
    },
    {
      inputs: [
        {
          name: "new_proxy_owner",
          concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c"
        }
      ],
      name: "set_proxy_owner",
      output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      attributes: [
        {
          name: "doc-comment",
          arguments: [" Changes proxy ownership to the passed State."]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Additional Information"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " This method can be used to transfer ownership between Identities or to revoke ownership."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Arguments"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [
            " * `new_proxy_owner`: [State] - The new state of the proxy ownership."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Reverts"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * When the sender is not the current proxy owner."]
        },
        {
          name: "doc-comment",
          arguments: [
            " * When the new state of the proxy ownership is [State::Uninitialized]."
          ]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" # Number of Storage Accesses"]
        },
        {
          name: "doc-comment",
          arguments: [""]
        },
        {
          name: "doc-comment",
          arguments: [" * Reads: `1`"]
        },
        {
          name: "doc-comment",
          arguments: [" * Writes: `1`"]
        },
        {
          name: "storage",
          arguments: ["write"]
        }
      ]
    }
  ],
  loggedTypes: [
    {
      logId: "4571204900286667806",
      concreteTypeId: "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d"
    },
    {
      logId: "2151606668983994881",
      concreteTypeId: "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8"
    },
    {
      logId: "2161305517876418151",
      concreteTypeId: "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893"
    },
    {
      logId: "4354576968059844266",
      concreteTypeId: "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74"
    },
    {
      logId: "10870989709723147660",
      concreteTypeId: "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247"
    },
    {
      logId: "10098701174489624218",
      concreteTypeId: "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
    }
  ],
  messagesTypes: [],
  configurables: [
    {
      name: "INITIAL_TARGET",
      concreteTypeId: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      offset: 13368
    },
    {
      name: "INITIAL_OWNER",
      concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      offset: 13320
    }
  ]
}, DR = [
  {
    key: "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd55",
    value: "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    key: "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd56",
    value: "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    key: "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea754",
    value: "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    key: "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea755",
    value: "0000000000000000000000000000000000000000000000000000000000000000"
  }
], tn, b_ = (tn = class extends Va {
  constructor(t, e) {
    super(t, y_, e);
  }
}, xw(tn, "Src14OwnedProxy"), Q(tn, "abi", y_), Q(tn, "storageSlots", DR), tn), I_ = JI(
  "H4sIAAAAAAAAA9Vbe3Abx3lfgCAFvayz+TAFSjaUUjJkRwosUQ4ly9IhIATSEM2DSVpUGBhg64c0cSyIlVQ5tsccN001aSZlHcdlO06GrtOp6z4GAB+C7T7YR2bUiTtlZhxbTeMWmiatFAst60YZqm6j/r5v93DHw4GOJ84f0QznFne73+5+j9/32FVgISxOCOEV/K/Dn7o259GuXRO/JcSQ8c6CML4nwkZJF8HFnWLovZLXeK/kOyG89+JbGN9C+BZe+q2uEfRE4LIBGiv1VHThdi0i5gJdGTHa7TW0WNNY4JLmoFfXE4jPi3T5ep/q112j337Vr8WIF3PV373nAol5YfTls6OG8Id6m9E3+DG0tVB5F96/onG7b0akejWh9XaMpWNhYcSnL44exPv49JzLnNtoTtDMpMvaR0FvmxHPaaPd6B/rGDMSxRCP7WmaMxJ5I10Wt47qYg2etxnR/CJ/i7Tj29nuSr/42Tlux3yYLygC36+aMxiIzotTuuck+LeD+If9hoxEIQS6MdDX8DxgRAudNvrzNvql96Hvl/TFJdDfaaPfDbo9oL8az7tBf8hGf8GiXxTL0/cuKPpPg36Hjf4R0O1V678H9E9b9IuaRX+m9X3on1f0HwD9XTb6Z0A3Cfrr8LwX9Ccs+jOWnOIzkm+16c8p+juXvl/9f0Z0GnonHP19CeqfigmR6hGeVER4jb5Z7FH7a+jL32Atf2tEp84ELoUxV9XYQzQWOnVO6pRvzIi+AhugdTehPVtpV8/r/TyPTcxWdIv246CfIf3dHNGEES0GjXihRHSq9+z5slrHBOYLy3XkJ7nN6zg7brar17F6c0AXYjP+lr5fNWW+x/4nqsc1PK3mHLLmLGatOaddxtSxboHPsGHF6/7Zc6MDGJNs1o347CJ4/i/pcrgEvl/AvOcCl3Teb+CCk5b/tmq5zVyE3P4cNP4C4/8S40+7y63uklr7GUtuReKXktuMfxm5tSq5ST10lVvdu6bcoON3KB0PGokpjTAq8H1nf8/vME4lcoRlQann+TFux9rnHLTfgQ2QzuCbbw57PgJcDIZ660lOYab/PejIBez77aq1vyH3nfdjfDePjxaL3I5gzmh+Pn1Z22P0Cr+kuRnYOTuEdjfhMeQziXYoFKsXkq9OPVxxCnbrH+3C2Eg75Dnt5geO0V5TPeBNr+ZJxTTowNkh6EAwlKzXoaunIb//hA4sQJb/ZcSnFqUO0J6ctPyHXXRgHuNeBY3XoAN/Bj08X0MHjigd6LZ0oPCSKXfIbX0qnhtMJXL3dXh891q2MA0ZOmmt/JaiFcR48If1qZPb0haOuNjCtiW2kBTe1CDah9U+0oXiaAbjUy0C6/A1xjRxqktsT0VzhxojQge+ebHGwB28pkLRiAi/EX8lyHyMgY/xmUnwYBp8nEmX9VkjMW0ELpLukS059c/7lotMNJtMwqD1b6D17+DtRcgEOFRLJit+6JQJYgoN6wG+G/l0OVOAXKbAk87ARYll1bbtnXKRaxFzn8U68BSvYDywwU2u3neVLM7bbDtj2fb0Ym3b9mxStl3xN9W27X3PtO2vCHHzc34zXhKTgeikCMTHRSAxJgJ9JWH052CP5h6dcZgI8B4jAnGOWIv1HjGiuU6JD851iTbqC7sKh8o+yCOX5XZ02mr3+PTAD4V4htZxNSwmsK7fxvruXhS0zhXmOuUasb5ESaTB38AVzHc1aPZfofo/Ze3Lc5HHDGNfh0qw+6q1fZL40QjdOdUt7sZTx3M1/Li3MdJEfthzB2JKrHMB6/RChjch1jpjrhnjd5PfAu40utCOUkzY2BsUpw6KGxt7gkRb0kvkzmHMesR2uuRx2Dm2i2XZB5s08TESlLgWoXgyn8EaQ6HedoqhbwC9bPqyuA7vgzXohVkGhLtl4CbRonZ0Ghhs0TIiGvkO2D3Fl9inTvtsIswtcjvG89WDHzrmg83ivfKf/P1wE2SSgRzB96uGKZenlFwq+iblWJL40RMkDBEUN2u9u0Q6Aru4gtjoqubUA7u+ZphGAnKFrpKtMW/KhPM5ndtxxNrqvRZDPM5xCPhJ+A7d4yfpHeaC3mVc9M4+H3x/lX1ka9nHSSH+2GYfrZgXtrhUP9AnyrqXhO4ZogUYqQMjpX4A16EfKzEHYgCao4r+J1ievGfSDciN2tEZWtcEyzPZZMoqCFn5+H0XvWcbPMftSJfVtmxwwYUXdVWyw94CV/BnyanOaa/gm2b2Z9wq+8YC0VxlLObSbONN+91vG29YfAcNwjXob+CdXLV+98Fe+pEfDaAP4jHCeEefWwL9ZI+78AcdMwTZ5QbYWJhzM9gYYbJjzK2Krr4M3U0c//RDt7hPvVsfznu2JjuMwBWd9m3YcGv/B+CbZxm+fYh8rzsXOITx/ZBzdOHjMgbMXwQtituADYiTONajGCxvWHEb7LYqbhMPKfzvlvg/NcZtxv9Cd6Udz8MnuuUHvqwt1pHzRwuUE9A4Fz/oOy79YIH8oBmPIp6nfMvN54tBRf+IlQtMEQ6qXGAqo74Beym2yl2PmOYG+t3WA9w7KPxtPR1jW7pBuzsLbJ7K7O7xzcN3NJDfgO3BZxTO23zGdYQHsG/KNf1tsQ5diyHeTMA+D5IdYr0xxLDURvxsHwteE35hXe2ob+SGVSylfFQ+KOOoKRm7ESaTXQ8SxhmQOWR6VXfqnN3WupdiXJblz3FUuV6H7/Nh3SEzPgbGdIf6pqFPYdKnbhfa12x+2MLPYdCGL8Yawbcm4l9I62mnusTN6ll/s3z61qea5jAfeHRC534x/KZ+8ll/M56w35zpI7EmrLWDeEE1CenfIANT9g6575R6Aru1dFnlOFV9Q8ofS9/C+UqecAO8QJ6RyMs19LBvzr7Y63uB7IJ1BjqK71m8H8f7SV4b6xJ8bDRntRO5jLWOnMyfUD8A35vS5Wwzy/0wyZL9KzC64l+vKX6vs8lSt+Mm4T/+6vHXAH+0gv2gigWYZ3GSo0Zy1G24tK46nhLjLn7wNHSklbARa2wNleFT4oypreyDh3MNqUO5FbAZ8lF+LdksmpMxHT7PQ/4J77xtg4NiywCYvPEBPTCUFVryAT2dhO/W0R9xGPvDcmYlYvBVWP9qrL+V6UfY32e4jbwO/VspXlE+fdzmx8wYxM4jpe+kiz5h2W+uFXF6Hb3Dk/kGGWFfLKMw+NYaSkyT/mH+9jmFp9D/Cp6afLPbFvI1Sx6Yw+A1S50l2hSbEF61ks6m+nL1sGWN/A7yFr/Rq/vBY9QVKZ/B3rm21GXV8qTsjnz4PsVjs2H/PNktchCOSRx5xXa2jzTHyeFQClg1nA8D47YcBz4Bo6j+cx68HKY8H+8fOt5NeZFpu2RDs0XLhmaGpM06/XHdE7LOCrsxx/WofJ/G9SAOYgwlGzpLORRjOHKjuxzr/W/269H8ONa0g2p4JmZSXNAC3mLN7ci9QqgD6Oa3VDRfrzB3DfD3DNqUI9hy2akh7O3T+DuGuuWQGVdBz9eCb7rE5yL5FunH4lN+zD+i1i1tn8ZR/MZx91mKq8kPUCyHmtL0S2bu6tjPd5SPJblCR4qEm5r0sVMU33Ebaxamz6DaO35/Vu1hFdqP2b7V0TfKeRojPs7XtaSuI+6MEW2su5KfgietDppPKJoRtB930HzCheYnZT7suq+vK99MMlD58BTlHKrOkfM76J+20Yf/RV32skiCp1TXMWVxI+Regoz2jsQ+EYHeTaBWAd63YJ4Z5LCuddl/VjUuo9KXfDS1Y1vw3qIPmYVtMtuFvRVr7O0zam+qpk97m6Y4w9wb9rGEr19SfKV9ZbCvg1h7ybGvIvb1ceyrDt9O2/bVWmNfL6l9Bd33ZdG37ws6QLVaVR8iG5mi2HCJjQS6eK2eQBfXfr5CY1CDq9iZrG25+doKX6geq+I9qrHPEu+xlgbCINTV3Hy6937l08flfqjvzEVuR4gPs5W9uceagmurWPfDdMYBXsbB5wTbYWXdUxR78t4hkwUlo1a0R13wYFzZ/GnL5gtk89C7Qg7P+4xelddzjq/wS557vGTm31jXKkULOIrzoMvaR4EZ5C/8CjMqfRn3VIwI7CLd4pgW63tPrU/Fi9OaWhvFKXJvsYzM/3mfM7LOETlB9TiV5z/A8bYL3zg+MvdPeSTe3YQzBML8f8J4lcdW1VPvUzVdqj2a9k28NuuYbYgbsqhjHqc6Jn5vIL5K3PCg5kQ6ZWG3ev/oM+SrKvGRx4yPbPm8p1TxxxTj0t7gD+Fbw1bcD9/UJTI1cHOD+t2EdovJV9s3wXqP8yz6bsMkE6c2mO9UP9gJ8yxK80q54BnTwvjzq9hQ+rVIkORO+sfxKugYKh9Y41jHLer3BrQ/4lg/favYKNeQQEvOi2dMC8l5cQ5jxcYUb1AOpM6uqmLkAGHJMrRs8a06H6hNawXRknENZGXlFmY9omasW6lxmTEu5nghOh1UMY5bfGvPexdteW+nzHuR61p5r8opeQ+o/9TOe08q3bblvaRPZt57xJb3XqxhUwWXvDdXO+8VXHems1Rb3gvfUzPv3eeS99r0H3jzwfLecSvvzVPOgTOjwiL22WnLe7nu6ZL3EnaZeS/VGSnvrYwFvU5uSz1PO/LeTpX3Up1c1iIJt6y8d/GnyE3DP2FuGv4wc1PozuhPmpui75M/T7lpla2q/MXFLt1qjr73qzkGoiUxgjqqqunX2+uqhLXQQ8Za9b1Bfa/47JEuTx31AY16uS7hrJPZ68LIoaz9OGq07ZRjNCd9c5TrNsrntpGIF/VHrj0G8dTxbAIfyBdQzkE1I1lb70esSfkdxhEekm+C7TRQX+SEK+zfIXuq4aOG2UX7Ixqo+WrIXbV6/qbqm1Sz5n7JDrOfhj5ezFfH3xQ97hPrYvxFP8qBSX/pnopZJxizycsNkxEPLJFziDCZ6o9LbRc1AZsOgG7IRQ/sdHE/pRrrHTWM4PI1DJu9Uz5LfKT4IQnMg79ifGWsz827nXdDrgXyTWwbZR5Ddwh4jPO8GH1zCmMXuD/OlEF30rRj51nmSeF73XYW63IXIj+vvpmY7Acmr6yNyfn53T0dhDcW3vYhRxqi857YmDwPBy7E8/N3xnzjsv6/xH7NuokNL71WTT4NvBy24iclX4opvmCLmW6kNvqQjo8tjY8RE1BthfYWz1GM6a3lr8CbF1zOZo+RDgHD6O6BjI8SeaqPUB0I/g9nNHxuDJrV9Gaqz40R/w2QLtSTn2lQe6Fza2o7zq1zYfY7/QUaI8+a+/OoUwW3wj5vBTbehvkn5fzI/6rn/3b1/MDqyrk17jOUg3tA607Q2gtaiBNqnVuLAy68CdnWaJ2H96MuUw5uAd1bQBe5W+6MPMt2XeOPXdZI9T5zjROgtRO0OkBrF2jBZmqucaPLGtdRrGDTgSG5Fjf51/P5tn18OqWJdCroSaegN1ey0F3o5tWM0/fYdFfI8+Cl9ctWaz/QQaplRsxaJp+VGdymPGA4twq1TIrp11AdXIv59OZYM/sXrmXCj7QNDuiqlimolskx1KcI42JzqGsKbiebKXYIaoj/if+obV6P2uYNqG020jm6rbZJd1a4tsn+2HxPbVqTdX6J89ZKrdPct73+uMRPAQNCzrMu8PcA+atUMixSg2FPqjfstdmzXe9x11BHHdbAXb3wGtDSLJlV0fwSywz+DndE5F2IQzncxQuvBY3rsF/IP4fzMvjtqrimvk+dWfOZ3zL+x4zpbBjvteIMC+NxT4vxmvDTxHjcBXHDeO9tDoynOLgGxnu3qhxW9pcYz3dE3THe+zUXjKe43sT40gfE+JILxo8B48MK4zEHY3zJwnjwZ5nzefhI1IoRb8UXdmsxDZiawx0g5z5WrKZarPTtFK9TjV5bCb1sw3MV363j+jR/O8/9UDfHeuncGvEI67c6l8N5bDVebFe1Kds5HuxT3SujGo/7fTTRoPwY6tmV2M3tTF/FEuy/KI7gengYdxICB6lgnRTPoha8Q4d8dKFvge6nN8I29KwIRurEvYhF78Y7GW9U3VWwxxvFKswZ5lhdCx0GD/rhryyf8wvKz9yv2g7bk/dFlsqhoYPthM8ouIZR4jbH9nxWQDhBcTvdeeUzC2DYuhTOyimnQx95V1jyl843TJmNm++hf42UE9HdaIV5VNOzMC/ZpW8Br0IbB0RggDFP3kdEvUiLDQicZzTzfWfUAVDLaWL68EvAP5ozByxpAR7cqO5KkK2a/oDupgL/2EaoLiTfo61s0vyG8wK33KgB90QqOa6qL+H+oFVf2oy9bcKaPkL1JZVPtqraxQTnTYy9aC+5LwKZLn+2pGIkyBr662I737HbDseflNPLGgV8WNVZkh3bcFcLdBGrVmORb4fCLcRjzD+ZS+B+OOfV0v4kJsD+3M5YQOPv+F6KvLO3AxiwhzAglVi4U+sJ4mxqYa/WG55L9S/chXrbHPA8C6wJhgabxzDXDUbMCPHv2OYxo0sPc/45BOzsGRwzDuFeOsWe6CvnBoOXYuMlFQdiPO7IXxZtqs4J3nfNGd068A41mMqdzgLdtwe+bXa904la4OdULbIFtRO6B9MFvqk7V1V9v6l0hWogpq5U7kBDV7ZDV4LQlU32WiSwFHfWKjhj6oJNXnXynBFxskM33yS9xJrWgkeEj3TGD/mg3rSsfOpvN+WjZPQpyGifxGlVVyNb7kPewPUAxlnEjqBVuVvr3Lvfo7CW7sJDVoQFU6Sf8Hmw1XjhTKWdKJCv4bW6+07PBcddbr5H6ND/keq71Pg/BZW71HRfP9iLOOEeYEKftG/3u9Sof2ypvm+Zp9pEJ2jsxvg9GN/tdt8S6zDv0VIOp2Su7l5KmX8MMm+DzDfwPVqpS83QJdJNA7pUuQPm0GM+h7DO4/iOlTqDWwiD5nrQDCzVI+iJFbsu55P31/bJ/oWfpU+GbDln+qA+GePeruWTf1b/sqPHTj+WPjEy+vCD9N+CxC8/eCJtf/f49NCf/NW3Wo/vXP/7r06u2ub76pu9W1viT24589bR7LmJvx+UfY/9yqMPjjK9o48ePXF05JGjn31QkrHoyT4bv7vq7RduWeV5nf8J7/7s9hd3bXj+pmv8T4jXHnvm8eZ/3Py1F1vevVzY+uQj536t9cwfPn167vdK+wIrb/qDgQMjjzzyiyO/9OnY6Oix0T17BniR9xw70S+XL764+Zt3fP7A9t/N/+ZE57Nf/vrLvkvPvzZ7cNOb//qZYwfLl18+uv/V/5j8h4eu+8Ku/xk+uePbe3/06xf23ZVr+sG7/m8Uv9HxR0fvemvl2vu9D6f3bfzxUz/47sbnHn7u7V/9ja6rX/3i3kfH/9To/dHLkms7/1c+d7yuns+r50H5vF19335ePtvfkM8W9X3lEfn0qff1n1PPDvV8Vj7rJuXT88b/AzdExjYINgAA"
), rn, GS = (rn = class extends NR {
  constructor(t) {
    super(
      I_,
      b_.abi,
      t,
      b_.storageSlots
    );
  }
  static deploy(t, e = {}) {
    return new rn(t).deploy(e);
  }
}, xw(rn, "Src14OwnedProxyFactory"), Q(rn, "bytecode", I_), rn);
export {
  na as ASSET_ID_LEN,
  O2 as AbstractAccount,
  RS as AbstractContract,
  mw as AbstractProgram,
  pS as AbstractScriptRequest,
  $o as Account,
  wt as Address,
  y2 as AddressType,
  mt as ArrayCoder,
  ot as B256Coder,
  OE as B512Coder,
  v2 as BALANCES_PAGE_SIZE_LIMIT,
  R2 as BLOCKS_PAGE_SIZE_LIMIT,
  z_ as BN,
  Xr as BYTES_32,
  ya as BaseTransactionRequest,
  X2 as BaseWalletUnlocked,
  rt as BigNumberCoder,
  yo as BlobTransactionRequest,
  PE as BooleanCoder,
  Mt as ByteArrayCoder,
  LE as ByteCoder,
  at as CHAIN_IDS,
  Ad as CONTRACT_ID_LEN,
  JR as CONTRACT_MAX_SIZE,
  b2 as ChainName,
  lS as ChangeOutputCollisionError,
  yt as Coder,
  tI as Commands,
  Va as Contract,
  NR as ContractFactory,
  Rd as CreateTransactionRequest,
  MS as DECIMAL_FUEL,
  US as DECIMAL_GWEI,
  LS as DECIMAL_KWEI,
  kS as DECIMAL_MWEI,
  PS as DECIMAL_WEI,
  OS as DEFAULT_DECIMAL_UNITS,
  DS as DEFAULT_MIN_PRECISION,
  QS as DEFAULT_PRECISION,
  S2 as DEFAULT_RESOURCE_CACHE_TTL,
  FS as DEVNET_NETWORK_URL,
  K_ as DateTime,
  Bi as ENCODING_V1,
  ZR as EmptyRoot,
  Pp as EnumCoder,
  L as ErrorCode,
  hf as FAILED_ASSERT_EQ_SIGNAL,
  pf as FAILED_ASSERT_NE_SIGNAL,
  _f as FAILED_ASSERT_SIGNAL,
  lf as FAILED_REQUIRE_SIGNAL,
  nu as FAILED_TRANSFER_TO_ADDRESS_SIGNAL,
  xS as Fuel,
  Q_ as FuelAsm,
  aR as FuelConnector,
  fw as FuelConnectorEventType,
  Du as FuelConnectorEventTypes,
  pw as FuelConnectorMethods,
  x as FuelError,
  vw as FunctionInvocationScope,
  T2 as GAS_USED_MODIFIER,
  qc as HDWallet,
  XR as INPUT_COIN_FIXED_SIZE,
  Rr as InputCoder,
  bh as InputCoinCoder,
  ho as InputContractCoder,
  bn as InputMessageCoder,
  xt as InputType,
  Mu as InstructionSet,
  Je as Interface,
  H2 as Language,
  iR as LocalStorage,
  eS as MAX_PREDICATE_DATA_LENGTH,
  tS as MAX_PREDICATE_LENGTH,
  $R as MAX_SCRIPT_DATA_LENGTH,
  qR as MAX_SCRIPT_LENGTH,
  KR as MAX_STATIC_CONTRACTS,
  jR as MAX_WITNESSES,
  g_ as MNEMONIC_SIZES,
  j2 as MemoryStorage,
  Tu as Mnemonic,
  q2 as MnemonicVault,
  IR as MultiCallInvocationScope,
  x2 as NON_PAGINATED_BALANCES_SIZE,
  a2 as NoWitnessAtIndexError,
  hS as NoWitnessByOwnerError,
  K as NumberCoder,
  m2 as OperationName,
  Gp as OptionCoder,
  Ch as OutputChangeCoder,
  Sr as OutputCoder,
  Ih as OutputCoinCoder,
  _o as OutputContractCoder,
  Bh as OutputContractCreatedCoder,
  lt as OutputType,
  Eh as OutputVariableCoder,
  Iv as PANIC_DOC_URL,
  bv as PANIC_REASONS,
  Tr as PoliciesCoder,
  Qe as PolicyType,
  vS as Predicate,
  $2 as PrivateKeyVault,
  Fd as Provider,
  u_ as RESOURCES_PAGE_SIZE_LIMIT,
  yv as REVERT_WITH_LOG_SIGNAL,
  UE as RawSliceCoder,
  At as ReceiptType,
  Mp as SCRIPT_FIXED_SIZE,
  TS as Script,
  Pu as ScriptRequest,
  Ir as ScriptTransactionRequest,
  oa as Signer,
  b_ as Src14OwnedProxy,
  GS as Src14OwnedProxyFactory,
  Qo as StdStringCoder,
  BS as StorageAbstract,
  vh as StorageSlotCoder,
  GE as StrSliceCoder,
  zE as StringCoder,
  Do as StructCoder,
  Cv as SwaySignalErrors,
  NS as TESTNET_NETWORK_URL,
  Vg as TRANSACTIONS_PAGE_SIZE_LIMIT,
  Qh as TransactionBlobCoder,
  sr as TransactionCoder,
  Sh as TransactionCreateCoder,
  Th as TransactionMintCoder,
  Td as TransactionResponse,
  Rh as TransactionScriptCoder,
  bg as TransactionStatus,
  Ct as TransactionType,
  w2 as TransactionTypeName,
  Fh as TransactionUpgradeCoder,
  Nh as TransactionUploadCoder,
  zp as TupleCoder,
  Xn as TxPointerCoder,
  lo as UTXO_ID_LEN,
  xh as UpgradePurposeCoder,
  Ke as UpgradePurposeTypeEnum,
  i_ as UpgradeTransactionRequest,
  a_ as UploadTransactionRequest,
  YR as UtxoIdCoder,
  ES as Vault,
  XE as VecCoder,
  ht as WORD_SIZE,
  er as Wallet,
  ow as WalletLocked,
  CS as WalletManager,
  pn as WalletUnlocked,
  Fr as WitnessCoder,
  St as ZeroBytes32,
  B1 as addAmountToCoinQuantities,
  Fi as addOperation,
  Zi as addressify,
  pg as aggregateInputsAmountsByAssetAndOwner,
  j as arrayify,
  n2 as assemblePanicError,
  Xg as assemblePreConfirmationTransactionSummary,
  uS as assembleReceiptByType,
  i2 as assembleRevertError,
  s2 as assembleSignalErrorMessage,
  Ui as assembleTransactionSummary,
  yS as assembleTransactionSummaryFromJson,
  U2 as assembleTransferToContractScript,
  Od as assert,
  So as assertUnreachable,
  sS as assets,
  I as bn,
  wn as bufferFromString,
  AS as buildBlockExplorerUrl,
  $c as buildDryRunResult,
  yR as buildFunctionResult,
  bR as buildPreConfirmationFunctionResult,
  gw as cacheFor,
  _S as cacheRequestInputsResources,
  c2 as cacheRequestInputsResourcesFromOwner,
  on as calculateGasFee,
  eg as calculateMetadataGasForTxBlob,
  fu as calculateMetadataGasForTxCreate,
  gu as calculateMetadataGasForTxScript,
  vd as calculateMetadataGasForTxUpgrade,
  rg as calculateMetadataGasForTxUpload,
  ng as calculateMinGasForTxUpload,
  p2 as calculateTXFeeForSummary,
  Op as calculateVmTxMemory,
  PR as capitalizeString,
  j_ as chunkAndPadBytes,
  Au as coinQuantityfy,
  GR as compressBytecode,
  xp as computeHmac,
  ct as concat,
  vo as concatBytes,
  L2 as consolidateCoins,
  Nd as consolidateCoinsIfRequired,
  VR as createAssetId,
  MR as createConfig,
  xo as dataSlice,
  rp as decodeBase58,
  HR as decodeScriptData,
  JI as decompressBytecode,
  iE as decrypt,
  oE as decryptJsonWalletData,
  UR as defaultConsensusKey,
  kR as defaultSnapshotConfigs,
  ww as deferPromise,
  Qu as deployScriptOrPredicate,
  Ed as deserializeChain,
  qx as deserializeInput,
  Bd as deserializeNodeInfo,
  $x as deserializeOutput,
  Kf as deserializeProcessedTxOutput,
  jx as deserializeProviderCache,
  Se as deserializeReceipt,
  IS as deserializeTransactionResponseJson,
  oR as dispatchFuelConnectorEvent,
  zd as encodeBase58,
  aE as encrypt,
  cE as encryptJsonWalletData,
  Ta as english,
  Ug as extractBurnedAssetsFromReceipts,
  ec as extractInvocationResult,
  kg as extractMintedAssetsFromReceipts,
  c_ as extractResolvedOutputs,
  wu as extractTxError,
  gI as format,
  fI as formatUnits,
  rB as fromDynamicInputToB256,
  eB as fromEvmAddressToB256,
  Yp as fromPublicKeyToB256,
  I1 as fuelAssetsBaseUrl,
  tg as gasUsedByInputs,
  ba as getAbisFromAllCalls,
  Jc as getAllCoins,
  aa as getAllDecodedLogs,
  Ou as getAllResultLogs,
  o2 as getAssetAmountInRequestInputs,
  iS as getAssetById,
  rS as getAssetEth,
  nS as getAssetFuel,
  w1 as getAssetNetwork,
  Qf as getAssetWithNetwork,
  aS as getAssetsByOwner,
  d2 as getBurnableAssetCount,
  Ko as getBytecodeConfigurableOffset,
  uw as getBytecodeDataOffset,
  Aw as getBytecodeId,
  Dg as getContractCallOperations,
  Lg as getContractCreatedOperations,
  FR as getContractId,
  SR as getContractRoot,
  TR as getContractStorageRoot,
  Hg as getDecodedLogs,
  g1 as getDefaultChainId,
  Pi as getGasUsedFromReceipts,
  Zo as getInputAccountAddress,
  gg as getInputContractFromIndex,
  yu as getInputFromAssetId,
  Yo as getInputsByType,
  ug as getInputsByTypes,
  Ag as getInputsCoin,
  mu as getInputsCoinAndMessage,
  hg as getInputsContract,
  lg as getInputsMessage,
  nR as getLegacyBlobId,
  Ho as getMaxGas,
  WR as getMessageId,
  pu as getMinGas,
  hd as getMintedAssetId,
  vu as getOperations,
  ki as getOutputsByType,
  mg as getOutputsChange,
  bu as getOutputsCoin,
  yg as getOutputsContract,
  wg as getOutputsContractCreated,
  g2 as getOutputsVariable,
  Pg as getPayProducerOperations,
  Jp as getPolicyTypesArray,
  sR as getPredicateRoot,
  $E as getRandomB256,
  Ti as getReceiptsByType,
  Ig as getReceiptsCall,
  Cg as getReceiptsMessageOut,
  C2 as getReceiptsTransferOut,
  r_ as getReceiptsWithMissingData,
  cg as getRequestInputResourceOwner,
  SS as getResultLogs,
  zg as getTotalFeeFromStatus,
  E2 as getTransactionStatusName,
  N2 as getTransactionSummary,
  Q2 as getTransactionSummaryFromRequest,
  Jo as getTransactionTypeName,
  D2 as getTransactionsSummaries,
  Mg as getTransferOperations,
  Sg as getWithdrawFromFuelOperations,
  I2 as hasSameAssetId,
  gr as hash,
  Sp as hashMessage,
  W as hexlify,
  w_ as hexlifyWithPrefix,
  Vx as inputify,
  Oa as isAddress,
  zn as isB256,
  Yx as isCoin,
  Ge as isDefined,
  Po as isEvmAddress,
  Sd as isInputCoin,
  dS as isMessage,
  e_ as isMessageCoin,
  n_ as isPredicate,
  Kd as isPublicKey,
  oS as isRawCoin,
  cS as isRawMessage,
  fr as isRequestInputCoin,
  Wo as isRequestInputCoinOrMessage,
  Vo as isRequestInputMessage,
  og as isRequestInputMessageWithoutData,
  Wn as isRequestInputResource,
  xd as isRequestInputResourceFromOwner,
  fS as isTransactionTypeBlob,
  _2 as isTransactionTypeCreate,
  An as isTransactionTypeScript,
  gS as isTransactionTypeUpgrade,
  wS as isTransactionTypeUpload,
  Jn as isType,
  Bu as isTypeBlob,
  jo as isTypeCreate,
  Iu as isTypeMint,
  qo as isTypeScript,
  Cu as isTypeUpgrade,
  Eu as isTypeUpload,
  vp as keccak256,
  zR as keyFromPassword,
  wI as max,
  za as mergeQuantities,
  mI as multiply,
  Wp as normalizeB256,
  sg as normalizeJSON,
  LR as normalizeString,
  Wx as outputify,
  tB as padFirst12BytesOfEvmAddress,
  dE as pbkdf2,
  mS as processGqlReceipt,
  Gg as processGraphqlStatus,
  ir as randomBytes,
  AE as randomUUID,
  C1 as rawAssets,
  Kh as resolveAccountForAssembleTxParams,
  De as resolveGasDependentCosts,
  Of as resolveIconPaths,
  s_ as returnZeroScript,
  uE as ripemd160,
  Bp as scrypt,
  Zx as serializeChain,
  Jx as serializeNodeInfo,
  $f as serializeProviderCache,
  bS as serializeTransactionResponseJson,
  is as setAndValidateGasAndFeeForAssembledTx,
  Xt as sha256,
  Gd as sleep,
  sB as sortPolicies,
  Yi as stringFromBuffer,
  KE as toB256AddressEvm,
  nr as toBytes,
  pI as toFixed,
  Co as toHex,
  Ur as toNumber,
  pr as toUtf8Bytes,
  Ro as toUtf8String,
  Oe as transactionRequestify,
  Rp as uint64ToBytesBE,
  Df as urlJoin,
  dg as validateTransactionForAssetBurn,
  ji as withTimeout,
  h2 as withdrawScript
};
//# sourceMappingURL=browser.mjs.map
