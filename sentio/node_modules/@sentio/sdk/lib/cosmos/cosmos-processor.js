import { CosmosProcessorState } from './types.js';
import { CosmosContext } from './context.js';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
export class CosmosProcessor {
    config;
    callHandlers = [];
    constructor(config) {
        this.config = config;
        return proxyProcessor(this);
    }
    static bind(config) {
        const processor = new CosmosProcessor(config);
        CosmosProcessorState.INSTANCE.addValue(processor);
        return processor;
    }
    onLogEvent(logFilters, handler, handlerOptions) {
        const filter = Array.isArray(logFilters) ? logFilters : [logFilters];
        const callHandler = {
            handlerName: getHandlerName(),
            handler: async (call) => {
                const transaction = call.transaction;
                const ctx = new CosmosContext(this.config.chainId, this.config.address, transaction);
                for (const log of transaction.logs) {
                    const event = log.events.filter((e) => filter.includes(e.type));
                    for (const e of event) {
                        await handler(log, e, ctx);
                    }
                }
                return ctx.stopAndGetResult();
            },
            logConfig: {
                logFilters: filter
            },
            partitionHandler: async (call) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const transaction = call.transaction;
                    return p(transaction);
                }
                return p;
            }
        };
        this.callHandlers.push(callHandler);
        return this;
    }
}
//# sourceMappingURL=cosmos-processor.js.map