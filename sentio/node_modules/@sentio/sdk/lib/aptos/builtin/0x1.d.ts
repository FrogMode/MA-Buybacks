import { CallFilter, MoveFetchConfig, EventFilter } from "@sentio/sdk/move";
import { HandlerOptions } from "@sentio/sdk";
import { AptosBindOptions, AptosBaseProcessor, TypedFunctionPayload, AptosContext } from "@sentio/sdk/aptos";
import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId } from "@aptos-labs/ts-sdk";
export declare namespace acl {
    interface ACL {
        list: MoveAddressType[];
    }
    namespace ACL {
        const TYPE_QNAME = "0x1::acl::ACL";
        function type(): TypeDescriptor<ACL>;
    }
    namespace entry { }
    namespace view { }
}
export declare class any$ extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): any$;
    onEventAny(func: (event: any$.AnyInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, any$.AnyInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): any$;
}
export declare namespace any$ {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::any::Any";
        function type(): TypeDescriptor<Any>;
    }
    type AnyInstance = TypedEventInstance<Any> & {
        data_decoded: Any;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace cmp {
    interface Ordering {
    }
    namespace Ordering {
        const TYPE_QNAME = "0x1::cmp::Ordering";
        function type(): TypeDescriptor<Ordering>;
    }
    namespace entry { }
    namespace view { }
}
export declare class dkg extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): dkg;
    onEventDKGStartEvent(func: (event: dkg.DKGStartEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, dkg.DKGStartEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): dkg;
}
export declare namespace dkg {
    interface DKGSessionMetadata {
        dealer_epoch: bigint;
        randomness_config: randomness_config.RandomnessConfig;
        dealer_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
        target_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
    }
    namespace DKGSessionMetadata {
        const TYPE_QNAME = "0x1::dkg::DKGSessionMetadata";
        function type(): TypeDescriptor<DKGSessionMetadata>;
    }
    interface DKGSessionState {
        metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
        transcript: string;
    }
    namespace DKGSessionState {
        const TYPE_QNAME = "0x1::dkg::DKGSessionState";
        function type(): TypeDescriptor<DKGSessionState>;
    }
    interface DKGStartEvent {
        session_metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
    }
    namespace DKGStartEvent {
        const TYPE_QNAME = "0x1::dkg::DKGStartEvent";
        function type(): TypeDescriptor<DKGStartEvent>;
    }
    type DKGStartEventInstance = TypedEventInstance<DKGStartEvent> & {
        data_decoded: DKGStartEvent;
        type_arguments: [];
    };
    interface DKGState {
        last_completed: option.Option<dkg.DKGSessionState>;
        in_progress: option.Option<dkg.DKGSessionState>;
    }
    namespace DKGState {
        const TYPE_QNAME = "0x1::dkg::DKGState";
        function type(): TypeDescriptor<DKGState>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace mem {
    namespace entry { }
    namespace view { }
}
export declare class code extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): code;
    onEntryPublishPackageTxn(func: (call: code.PublishPackageTxnPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, code.PublishPackageTxnPayload>): code;
    onEventPublishPackage(func: (event: code.PublishPackageInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, code.PublishPackageInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): code;
}
export declare namespace code {
    interface AllowedDep {
        account: MoveAddressType;
        module_name: string;
    }
    namespace AllowedDep {
        const TYPE_QNAME = "0x1::code::AllowedDep";
        function type(): TypeDescriptor<AllowedDep>;
    }
    interface CodePublishingPermission {
        dummy_field: boolean;
    }
    namespace CodePublishingPermission {
        const TYPE_QNAME = "0x1::code::CodePublishingPermission";
        function type(): TypeDescriptor<CodePublishingPermission>;
    }
    interface ModuleMetadata {
        name: string;
        source: string;
        source_map: string;
        extension: option.Option<copyable_any.Any>;
    }
    namespace ModuleMetadata {
        const TYPE_QNAME = "0x1::code::ModuleMetadata";
        function type(): TypeDescriptor<ModuleMetadata>;
    }
    interface PackageDep {
        account: MoveAddressType;
        package_name: string;
    }
    namespace PackageDep {
        const TYPE_QNAME = "0x1::code::PackageDep";
        function type(): TypeDescriptor<PackageDep>;
    }
    interface PackageMetadata {
        name: string;
        upgrade_policy: code.UpgradePolicy;
        upgrade_number: bigint;
        source_digest: string;
        manifest: string;
        modules: code.ModuleMetadata[];
        deps: code.PackageDep[];
        extension: option.Option<copyable_any.Any>;
    }
    namespace PackageMetadata {
        const TYPE_QNAME = "0x1::code::PackageMetadata";
        function type(): TypeDescriptor<PackageMetadata>;
    }
    interface PackageRegistry {
        packages: code.PackageMetadata[];
    }
    namespace PackageRegistry {
        const TYPE_QNAME = "0x1::code::PackageRegistry";
        function type(): TypeDescriptor<PackageRegistry>;
    }
    interface PublishPackage {
        code_address: MoveAddressType;
        is_upgrade: boolean;
    }
    namespace PublishPackage {
        const TYPE_QNAME = "0x1::code::PublishPackage";
        function type(): TypeDescriptor<PublishPackage>;
    }
    type PublishPackageInstance = TypedEventInstance<PublishPackage> & {
        data_decoded: PublishPackage;
        type_arguments: [];
    };
    interface UpgradePolicy {
        policy: number;
    }
    namespace UpgradePolicy {
        const TYPE_QNAME = "0x1::code::UpgradePolicy";
        function type(): TypeDescriptor<UpgradePolicy>;
    }
    namespace entry {
        function publishPackageTxn(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface PublishPackageTxnPayload extends TypedFunctionPayload<[string, string[]]> {
        arguments_decoded: [string, string[]];
        type_arguments: [];
    }
}
export declare class coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): coin;
    onEntryTransfer(func: (call: coin.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.TransferPayload>): coin;
    onEntryCreateCoinConversionMap(func: (call: coin.CreateCoinConversionMapPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CreateCoinConversionMapPayload>): coin;
    onEntryCreatePairing(func: (call: coin.CreatePairingPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CreatePairingPayload>): coin;
    onEntryFreezeCoinStore(func: (call: coin.FreezeCoinStorePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.FreezeCoinStorePayload>): coin;
    onEntryMigrateCoinStoreToFungibleStore(func: (call: coin.MigrateCoinStoreToFungibleStorePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.MigrateCoinStoreToFungibleStorePayload>): coin;
    onEntryMigrateToFungibleStore(func: (call: coin.MigrateToFungibleStorePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.MigrateToFungibleStorePayload>): coin;
    onEntryUnfreezeCoinStore(func: (call: coin.UnfreezeCoinStorePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.UnfreezeCoinStorePayload>): coin;
    onEntryUpgradeSupply(func: (call: coin.UpgradeSupplyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.UpgradeSupplyPayload>): coin;
    onEventDepositEvent(func: (event: coin.DepositEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.DepositEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventWithdrawEvent(func: (event: coin.WithdrawEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.WithdrawEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventCoinDeposit(func: (event: coin.CoinDepositInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CoinDepositInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventCoinEventHandleDeletion(func: (event: coin.CoinEventHandleDeletionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CoinEventHandleDeletionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventCoinStoreDeletion(func: (event: coin.CoinStoreDeletionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CoinStoreDeletionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventCoinWithdraw(func: (event: coin.CoinWithdrawInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.CoinWithdrawInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
    onEventPairCreation(func: (event: coin.PairCreationInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, coin.PairCreationInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): coin;
}
export declare namespace coin {
    interface Deposit<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::coin::Deposit";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Deposit<T0>>;
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::coin::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    type DepositEventInstance = TypedEventInstance<DepositEvent> & {
        data_decoded: DepositEvent;
        type_arguments: [];
    };
    interface Withdraw<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::coin::Withdraw";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Withdraw<T0>>;
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::coin::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    type WithdrawEventInstance = TypedEventInstance<WithdrawEvent> & {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    };
    interface AggregatableCoin<T0> {
        value: aggregator.Aggregator;
    }
    namespace AggregatableCoin {
        const TYPE_QNAME = "0x1::coin::AggregatableCoin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatableCoin<T0>>;
    }
    interface BurnCapability<T0> {
        dummy_field: boolean;
    }
    namespace BurnCapability {
        const TYPE_QNAME = "0x1::coin::BurnCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BurnCapability<T0>>;
    }
    interface BurnRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace BurnRefReceipt {
        const TYPE_QNAME = "0x1::coin::BurnRefReceipt";
        function type(): TypeDescriptor<BurnRefReceipt>;
    }
    interface Coin<T0> {
        value: bigint;
    }
    namespace Coin {
        const TYPE_QNAME = "0x1::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinConversionMap {
        coin_to_fungible_asset_map: table.Table<type_info.TypeInfo, object$.Object<fungible_asset.Metadata>>;
    }
    namespace CoinConversionMap {
        const TYPE_QNAME = "0x1::coin::CoinConversionMap";
        function type(): TypeDescriptor<CoinConversionMap>;
    }
    interface CoinDeposit {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinDeposit {
        const TYPE_QNAME = "0x1::coin::CoinDeposit";
        function type(): TypeDescriptor<CoinDeposit>;
    }
    type CoinDepositInstance = TypedEventInstance<CoinDeposit> & {
        data_decoded: CoinDeposit;
        type_arguments: [];
    };
    interface CoinEventHandleDeletion {
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinEventHandleDeletion {
        const TYPE_QNAME = "0x1::coin::CoinEventHandleDeletion";
        function type(): TypeDescriptor<CoinEventHandleDeletion>;
    }
    type CoinEventHandleDeletionInstance = TypedEventInstance<CoinEventHandleDeletion> & {
        data_decoded: CoinEventHandleDeletion;
        type_arguments: [];
    };
    interface CoinInfo<T0> {
        name: string;
        symbol: string;
        decimals: number;
        supply: option.Option<optional_aggregator.OptionalAggregator>;
    }
    namespace CoinInfo {
        const TYPE_QNAME = "0x1::coin::CoinInfo";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinInfo<T0>>;
    }
    interface CoinStore<T0> {
        coin: coin.Coin<T0>;
        frozen: boolean;
        deposit_events: event.EventHandle<coin.DepositEvent>;
        withdraw_events: event.EventHandle<coin.WithdrawEvent>;
    }
    namespace CoinStore {
        const TYPE_QNAME = "0x1::coin::CoinStore";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinStore<T0>>;
    }
    interface CoinStoreDeletion {
        coin_type: string;
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinStoreDeletion {
        const TYPE_QNAME = "0x1::coin::CoinStoreDeletion";
        function type(): TypeDescriptor<CoinStoreDeletion>;
    }
    type CoinStoreDeletionInstance = TypedEventInstance<CoinStoreDeletion> & {
        data_decoded: CoinStoreDeletion;
        type_arguments: [];
    };
    interface CoinWithdraw {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinWithdraw {
        const TYPE_QNAME = "0x1::coin::CoinWithdraw";
        function type(): TypeDescriptor<CoinWithdraw>;
    }
    type CoinWithdrawInstance = TypedEventInstance<CoinWithdraw> & {
        data_decoded: CoinWithdraw;
        type_arguments: [];
    };
    interface FreezeCapability<T0> {
        dummy_field: boolean;
    }
    namespace FreezeCapability {
        const TYPE_QNAME = "0x1::coin::FreezeCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<FreezeCapability<T0>>;
    }
    interface MigrationFlag {
        dummy_field: boolean;
    }
    namespace MigrationFlag {
        const TYPE_QNAME = "0x1::coin::MigrationFlag";
        function type(): TypeDescriptor<MigrationFlag>;
    }
    interface MintCapability<T0> {
        dummy_field: boolean;
    }
    namespace MintCapability {
        const TYPE_QNAME = "0x1::coin::MintCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<MintCapability<T0>>;
    }
    interface MintRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MintRefReceipt {
        const TYPE_QNAME = "0x1::coin::MintRefReceipt";
        function type(): TypeDescriptor<MintRefReceipt>;
    }
    interface PairCreation {
        coin_type: type_info.TypeInfo;
        fungible_asset_metadata_address: MoveAddressType;
    }
    namespace PairCreation {
        const TYPE_QNAME = "0x1::coin::PairCreation";
        function type(): TypeDescriptor<PairCreation>;
    }
    type PairCreationInstance = TypedEventInstance<PairCreation> & {
        data_decoded: PairCreation;
        type_arguments: [];
    };
    interface PairedCoinType {
        type: type_info.TypeInfo;
    }
    namespace PairedCoinType {
        const TYPE_QNAME = "0x1::coin::PairedCoinType";
        function type(): TypeDescriptor<PairedCoinType>;
    }
    interface PairedFungibleAssetRefs {
        mint_ref_opt: option.Option<fungible_asset.MintRef>;
        transfer_ref_opt: option.Option<fungible_asset.TransferRef>;
        burn_ref_opt: option.Option<fungible_asset.BurnRef>;
    }
    namespace PairedFungibleAssetRefs {
        const TYPE_QNAME = "0x1::coin::PairedFungibleAssetRefs";
        function type(): TypeDescriptor<PairedFungibleAssetRefs>;
    }
    interface SupplyConfig {
        allow_upgrades: boolean;
    }
    namespace SupplyConfig {
        const TYPE_QNAME = "0x1::coin::SupplyConfig";
        function type(): TypeDescriptor<SupplyConfig>;
    }
    interface TransferRefReceipt {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace TransferRefReceipt {
        const TYPE_QNAME = "0x1::coin::TransferRefReceipt";
        function type(): TypeDescriptor<TransferRefReceipt>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createCoinConversionMap(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createPairing<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function freezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function migrateCoinStoreToFungibleStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function migrateToFungibleStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unfreezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeSupply<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
        function symbol$<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[number]>;
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function coinSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function isAccountRegistered<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isCoinInitialized<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function isCoinStoreFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function pairedBurnRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function pairedCoin(client: Aptos, request: {
            functionArguments: [object$.Object<fungible_asset.Metadata>];
        }, version?: bigint): Promise<[option.Option<type_info.TypeInfo>]>;
        function pairedMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<object$.Object<fungible_asset.Metadata>>]>;
        function pairedMintRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
        function pairedTransferRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface CreateCoinConversionMapPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface CreatePairingPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
    interface FreezeCoinStorePayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [string];
    }
    interface MigrateCoinStoreToFungibleStorePayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [string];
    }
    interface MigrateToFungibleStorePayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
    interface UnfreezeCoinStorePayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [string];
    }
    interface UpgradeSupplyPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
}
export declare class guid extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): guid;
    onEventGUID(func: (event: guid.GUIDInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, guid.GUIDInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): guid;
}
export declare namespace guid {
    interface GUID {
        id: guid.ID;
    }
    namespace GUID {
        const TYPE_QNAME = "0x1::guid::GUID";
        function type(): TypeDescriptor<GUID>;
    }
    type GUIDInstance = TypedEventInstance<GUID> & {
        data_decoded: GUID;
        type_arguments: [];
    };
    interface ID {
        creation_num: bigint;
        addr: MoveAddressType;
    }
    namespace ID {
        const TYPE_QNAME = "0x1::guid::ID";
        function type(): TypeDescriptor<ID>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace hash {
    namespace entry { }
    namespace view { }
}
export declare class jwks extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): jwks;
    onEntryUpdateFederatedJwkSet(func: (call: jwks.UpdateFederatedJwkSetPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, jwks.UpdateFederatedJwkSetPayload>): jwks;
    onEventObservedJWKsUpdated(func: (event: jwks.ObservedJWKsUpdatedInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, jwks.ObservedJWKsUpdatedInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): jwks;
}
export declare namespace jwks {
    interface AllProvidersJWKs {
        entries: jwks.ProviderJWKs[];
    }
    namespace AllProvidersJWKs {
        const TYPE_QNAME = "0x1::jwks::AllProvidersJWKs";
        function type(): TypeDescriptor<AllProvidersJWKs>;
    }
    interface FederatedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace FederatedJWKs {
        const TYPE_QNAME = "0x1::jwks::FederatedJWKs";
        function type(): TypeDescriptor<FederatedJWKs>;
    }
    interface JWK {
        variant: copyable_any.Any;
    }
    namespace JWK {
        const TYPE_QNAME = "0x1::jwks::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwks::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface ObservedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKs {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKs";
        function type(): TypeDescriptor<ObservedJWKs>;
    }
    interface ObservedJWKsUpdated {
        epoch: bigint;
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKsUpdated {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKsUpdated";
        function type(): TypeDescriptor<ObservedJWKsUpdated>;
    }
    type ObservedJWKsUpdatedInstance = TypedEventInstance<ObservedJWKsUpdated> & {
        data_decoded: ObservedJWKsUpdated;
        type_arguments: [];
    };
    interface Patch {
        variant: copyable_any.Any;
    }
    namespace Patch {
        const TYPE_QNAME = "0x1::jwks::Patch";
        function type(): TypeDescriptor<Patch>;
    }
    interface PatchRemoveAll {
        dummy_field: boolean;
    }
    namespace PatchRemoveAll {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveAll";
        function type(): TypeDescriptor<PatchRemoveAll>;
    }
    interface PatchRemoveIssuer {
        issuer: string;
    }
    namespace PatchRemoveIssuer {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveIssuer";
        function type(): TypeDescriptor<PatchRemoveIssuer>;
    }
    interface PatchRemoveJWK {
        issuer: string;
        jwk_id: string;
    }
    namespace PatchRemoveJWK {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveJWK";
        function type(): TypeDescriptor<PatchRemoveJWK>;
    }
    interface PatchUpsertJWK {
        issuer: string;
        jwk: jwks.JWK;
    }
    namespace PatchUpsertJWK {
        const TYPE_QNAME = "0x1::jwks::PatchUpsertJWK";
        function type(): TypeDescriptor<PatchUpsertJWK>;
    }
    interface PatchedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace PatchedJWKs {
        const TYPE_QNAME = "0x1::jwks::PatchedJWKs";
        function type(): TypeDescriptor<PatchedJWKs>;
    }
    interface Patches {
        patches: jwks.Patch[];
    }
    namespace Patches {
        const TYPE_QNAME = "0x1::jwks::Patches";
        function type(): TypeDescriptor<Patches>;
    }
    interface ProviderJWKs {
        issuer: string;
        version: bigint;
        jwks: jwks.JWK[];
    }
    namespace ProviderJWKs {
        const TYPE_QNAME = "0x1::jwks::ProviderJWKs";
        function type(): TypeDescriptor<ProviderJWKs>;
    }
    interface RSA_JWK {
        kid: string;
        kty: string;
        alg: string;
        e: string;
        n: string;
    }
    namespace RSA_JWK {
        const TYPE_QNAME = "0x1::jwks::RSA_JWK";
        function type(): TypeDescriptor<RSA_JWK>;
    }
    interface SupportedOIDCProviders {
        providers: jwks.OIDCProvider[];
    }
    namespace SupportedOIDCProviders {
        const TYPE_QNAME = "0x1::jwks::SupportedOIDCProviders";
        function type(): TypeDescriptor<SupportedOIDCProviders>;
    }
    interface UnsupportedJWK {
        id: string;
        payload: string;
    }
    namespace UnsupportedJWK {
        const TYPE_QNAME = "0x1::jwks::UnsupportedJWK";
        function type(): TypeDescriptor<UnsupportedJWK>;
    }
    namespace entry {
        function updateFederatedJwkSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[], string[], string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface UpdateFederatedJwkSetPayload extends TypedFunctionPayload<[
        string,
        string[],
        string[],
        string[],
        string[]
    ]> {
        arguments_decoded: [string, string[], string[], string[], string[]];
        type_arguments: [];
    }
}
export declare namespace util {
    namespace entry { }
    namespace view { }
}
export declare class block extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): block;
    onEventNewBlock(func: (event: block.NewBlockInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, block.NewBlockInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): block;
    onEventNewBlockEvent(func: (event: block.NewBlockEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, block.NewBlockEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): block;
    onEventUpdateEpochInterval(func: (event: block.UpdateEpochIntervalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, block.UpdateEpochIntervalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): block;
    onEventUpdateEpochIntervalEvent(func: (event: block.UpdateEpochIntervalEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, block.UpdateEpochIntervalEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): block;
}
export declare namespace block {
    interface BlockResource {
        height: bigint;
        epoch_interval: bigint;
        new_block_events: event.EventHandle<block.NewBlockEvent>;
        update_epoch_interval_events: event.EventHandle<block.UpdateEpochIntervalEvent>;
    }
    namespace BlockResource {
        const TYPE_QNAME = "0x1::block::BlockResource";
        function type(): TypeDescriptor<BlockResource>;
    }
    interface CommitHistory {
        max_capacity: number;
        next_idx: number;
        table: table_with_length.TableWithLength<number, block.NewBlockEvent>;
    }
    namespace CommitHistory {
        const TYPE_QNAME = "0x1::block::CommitHistory";
        function type(): TypeDescriptor<CommitHistory>;
    }
    interface NewBlock {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlock {
        const TYPE_QNAME = "0x1::block::NewBlock";
        function type(): TypeDescriptor<NewBlock>;
    }
    type NewBlockInstance = TypedEventInstance<NewBlock> & {
        data_decoded: NewBlock;
        type_arguments: [];
    };
    interface NewBlockEvent {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlockEvent {
        const TYPE_QNAME = "0x1::block::NewBlockEvent";
        function type(): TypeDescriptor<NewBlockEvent>;
    }
    type NewBlockEventInstance = TypedEventInstance<NewBlockEvent> & {
        data_decoded: NewBlockEvent;
        type_arguments: [];
    };
    interface UpdateEpochInterval {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochInterval {
        const TYPE_QNAME = "0x1::block::UpdateEpochInterval";
        function type(): TypeDescriptor<UpdateEpochInterval>;
    }
    type UpdateEpochIntervalInstance = TypedEventInstance<UpdateEpochInterval> & {
        data_decoded: UpdateEpochInterval;
        type_arguments: [];
    };
    interface UpdateEpochIntervalEvent {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochIntervalEvent {
        const TYPE_QNAME = "0x1::block::UpdateEpochIntervalEvent";
        function type(): TypeDescriptor<UpdateEpochIntervalEvent>;
    }
    type UpdateEpochIntervalEventInstance = TypedEventInstance<UpdateEpochIntervalEvent> & {
        data_decoded: UpdateEpochIntervalEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view {
        function getCurrentBlockHeight(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getEpochIntervalSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace debug {
    namespace entry { }
    namespace view { }
}
export declare namespace error {
    namespace entry { }
    namespace view { }
}
export declare namespace event {
    interface EventHandle<T0> {
        counter: bigint;
        guid: guid.GUID;
    }
    namespace EventHandle {
        const TYPE_QNAME = "0x1::event::EventHandle";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<EventHandle<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare class stake extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): stake;
    onEntryWithdraw(func: (call: stake.WithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.WithdrawPayload>): stake;
    onEntryAddStake(func: (call: stake.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.AddStakePayload>): stake;
    onEntryIncreaseLockup(func: (call: stake.IncreaseLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.IncreaseLockupPayload>): stake;
    onEntryInitializeStakeOwner(func: (call: stake.InitializeStakeOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.InitializeStakeOwnerPayload>): stake;
    onEntryInitializeValidator(func: (call: stake.InitializeValidatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.InitializeValidatorPayload>): stake;
    onEntryJoinValidatorSet(func: (call: stake.JoinValidatorSetPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.JoinValidatorSetPayload>): stake;
    onEntryLeaveValidatorSet(func: (call: stake.LeaveValidatorSetPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.LeaveValidatorSetPayload>): stake;
    onEntryReactivateStake(func: (call: stake.ReactivateStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.ReactivateStakePayload>): stake;
    onEntryRotateConsensusKey(func: (call: stake.RotateConsensusKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.RotateConsensusKeyPayload>): stake;
    onEntrySetDelegatedVoter(func: (call: stake.SetDelegatedVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.SetDelegatedVoterPayload>): stake;
    onEntrySetOperator(func: (call: stake.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.SetOperatorPayload>): stake;
    onEntryUnlock(func: (call: stake.UnlockPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UnlockPayload>): stake;
    onEntryUpdateNetworkAndFullnodeAddresses(func: (call: stake.UpdateNetworkAndFullnodeAddressesPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UpdateNetworkAndFullnodeAddressesPayload>): stake;
    onEventAddStake(func: (event: stake.AddStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.AddStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventAddStakeEvent(func: (event: stake.AddStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.AddStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventDistributeRewards(func: (event: stake.DistributeRewardsInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.DistributeRewardsInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventDistributeRewardsEvent(func: (event: stake.DistributeRewardsEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.DistributeRewardsEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventDistributeTransactionFee(func: (event: stake.DistributeTransactionFeeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.DistributeTransactionFeeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventIncreaseLockup(func: (event: stake.IncreaseLockupInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.IncreaseLockupInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventIncreaseLockupEvent(func: (event: stake.IncreaseLockupEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.IncreaseLockupEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventIndividualValidatorPerformance(func: (event: stake.IndividualValidatorPerformanceInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.IndividualValidatorPerformanceInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventJoinValidatorSet(func: (event: stake.JoinValidatorSetInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.JoinValidatorSetInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventJoinValidatorSetEvent(func: (event: stake.JoinValidatorSetEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.JoinValidatorSetEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventLeaveValidatorSet(func: (event: stake.LeaveValidatorSetInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.LeaveValidatorSetInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventLeaveValidatorSetEvent(func: (event: stake.LeaveValidatorSetEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.LeaveValidatorSetEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventReactivateStake(func: (event: stake.ReactivateStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.ReactivateStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventReactivateStakeEvent(func: (event: stake.ReactivateStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.ReactivateStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventRegisterValidatorCandidate(func: (event: stake.RegisterValidatorCandidateInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.RegisterValidatorCandidateInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventRegisterValidatorCandidateEvent(func: (event: stake.RegisterValidatorCandidateEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.RegisterValidatorCandidateEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventRotateConsensusKey(func: (event: stake.RotateConsensusKeyInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.RotateConsensusKeyInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventRotateConsensusKeyEvent(func: (event: stake.RotateConsensusKeyEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.RotateConsensusKeyEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventSetOperator(func: (event: stake.SetOperatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.SetOperatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventSetOperatorEvent(func: (event: stake.SetOperatorEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.SetOperatorEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventUnlockStake(func: (event: stake.UnlockStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UnlockStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventUnlockStakeEvent(func: (event: stake.UnlockStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UnlockStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventUpdateNetworkAndFullnodeAddresses(func: (event: stake.UpdateNetworkAndFullnodeAddressesInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UpdateNetworkAndFullnodeAddressesInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventUpdateNetworkAndFullnodeAddressesEvent(func: (event: stake.UpdateNetworkAndFullnodeAddressesEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.UpdateNetworkAndFullnodeAddressesEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventWithdrawStake(func: (event: stake.WithdrawStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.WithdrawStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
    onEventWithdrawStakeEvent(func: (event: stake.WithdrawStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, stake.WithdrawStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): stake;
}
export declare namespace stake {
    interface AddStake {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::stake::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::stake::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface AllowedValidators {
        accounts: MoveAddressType[];
    }
    namespace AllowedValidators {
        const TYPE_QNAME = "0x1::stake::AllowedValidators";
        function type(): TypeDescriptor<AllowedValidators>;
    }
    interface AptosCoinCapabilities {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::stake::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface DistributeRewards {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewards {
        const TYPE_QNAME = "0x1::stake::DistributeRewards";
        function type(): TypeDescriptor<DistributeRewards>;
    }
    type DistributeRewardsInstance = TypedEventInstance<DistributeRewards> & {
        data_decoded: DistributeRewards;
        type_arguments: [];
    };
    interface DistributeRewardsEvent {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewardsEvent {
        const TYPE_QNAME = "0x1::stake::DistributeRewardsEvent";
        function type(): TypeDescriptor<DistributeRewardsEvent>;
    }
    type DistributeRewardsEventInstance = TypedEventInstance<DistributeRewardsEvent> & {
        data_decoded: DistributeRewardsEvent;
        type_arguments: [];
    };
    interface DistributeTransactionFee {
        pool_address: MoveAddressType;
        fee_amount: bigint;
    }
    namespace DistributeTransactionFee {
        const TYPE_QNAME = "0x1::stake::DistributeTransactionFee";
        function type(): TypeDescriptor<DistributeTransactionFee>;
    }
    type DistributeTransactionFeeInstance = TypedEventInstance<DistributeTransactionFee> & {
        data_decoded: DistributeTransactionFee;
        type_arguments: [];
    };
    interface IncreaseLockup {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockup {
        const TYPE_QNAME = "0x1::stake::IncreaseLockup";
        function type(): TypeDescriptor<IncreaseLockup>;
    }
    type IncreaseLockupInstance = TypedEventInstance<IncreaseLockup> & {
        data_decoded: IncreaseLockup;
        type_arguments: [];
    };
    interface IncreaseLockupEvent {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockupEvent {
        const TYPE_QNAME = "0x1::stake::IncreaseLockupEvent";
        function type(): TypeDescriptor<IncreaseLockupEvent>;
    }
    type IncreaseLockupEventInstance = TypedEventInstance<IncreaseLockupEvent> & {
        data_decoded: IncreaseLockupEvent;
        type_arguments: [];
    };
    interface IndividualValidatorPerformance {
        successful_proposals: bigint;
        failed_proposals: bigint;
    }
    namespace IndividualValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::IndividualValidatorPerformance";
        function type(): TypeDescriptor<IndividualValidatorPerformance>;
    }
    type IndividualValidatorPerformanceInstance = TypedEventInstance<IndividualValidatorPerformance> & {
        data_decoded: IndividualValidatorPerformance;
        type_arguments: [];
    };
    interface JoinValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSet {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSet";
        function type(): TypeDescriptor<JoinValidatorSet>;
    }
    type JoinValidatorSetInstance = TypedEventInstance<JoinValidatorSet> & {
        data_decoded: JoinValidatorSet;
        type_arguments: [];
    };
    interface JoinValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSetEvent";
        function type(): TypeDescriptor<JoinValidatorSetEvent>;
    }
    type JoinValidatorSetEventInstance = TypedEventInstance<JoinValidatorSetEvent> & {
        data_decoded: JoinValidatorSetEvent;
        type_arguments: [];
    };
    interface LeaveValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSet {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSet";
        function type(): TypeDescriptor<LeaveValidatorSet>;
    }
    type LeaveValidatorSetInstance = TypedEventInstance<LeaveValidatorSet> & {
        data_decoded: LeaveValidatorSet;
        type_arguments: [];
    };
    interface LeaveValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSetEvent";
        function type(): TypeDescriptor<LeaveValidatorSetEvent>;
    }
    type LeaveValidatorSetEventInstance = TypedEventInstance<LeaveValidatorSetEvent> & {
        data_decoded: LeaveValidatorSetEvent;
        type_arguments: [];
    };
    interface OwnerCapability {
        pool_address: MoveAddressType;
    }
    namespace OwnerCapability {
        const TYPE_QNAME = "0x1::stake::OwnerCapability";
        function type(): TypeDescriptor<OwnerCapability>;
    }
    interface PendingTransactionFee {
        pending_fee_by_validator: big_ordered_map.BigOrderedMap<bigint, aggregator_v2.Aggregator<bigint>>;
    }
    namespace PendingTransactionFee {
        const TYPE_QNAME = "0x1::stake::PendingTransactionFee";
        function type(): TypeDescriptor<PendingTransactionFee>;
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::stake::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    type ReactivateStakeInstance = TypedEventInstance<ReactivateStake> & {
        data_decoded: ReactivateStake;
        type_arguments: [];
    };
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::stake::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    type ReactivateStakeEventInstance = TypedEventInstance<ReactivateStakeEvent> & {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    };
    interface RegisterValidatorCandidate {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidate {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidate";
        function type(): TypeDescriptor<RegisterValidatorCandidate>;
    }
    type RegisterValidatorCandidateInstance = TypedEventInstance<RegisterValidatorCandidate> & {
        data_decoded: RegisterValidatorCandidate;
        type_arguments: [];
    };
    interface RegisterValidatorCandidateEvent {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidateEvent {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidateEvent";
        function type(): TypeDescriptor<RegisterValidatorCandidateEvent>;
    }
    type RegisterValidatorCandidateEventInstance = TypedEventInstance<RegisterValidatorCandidateEvent> & {
        data_decoded: RegisterValidatorCandidateEvent;
        type_arguments: [];
    };
    interface RotateConsensusKey {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKey {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKey";
        function type(): TypeDescriptor<RotateConsensusKey>;
    }
    type RotateConsensusKeyInstance = TypedEventInstance<RotateConsensusKey> & {
        data_decoded: RotateConsensusKey;
        type_arguments: [];
    };
    interface RotateConsensusKeyEvent {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKeyEvent {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKeyEvent";
        function type(): TypeDescriptor<RotateConsensusKeyEvent>;
    }
    type RotateConsensusKeyEventInstance = TypedEventInstance<RotateConsensusKeyEvent> & {
        data_decoded: RotateConsensusKeyEvent;
        type_arguments: [];
    };
    interface SetOperator {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperator {
        const TYPE_QNAME = "0x1::stake::SetOperator";
        function type(): TypeDescriptor<SetOperator>;
    }
    type SetOperatorInstance = TypedEventInstance<SetOperator> & {
        data_decoded: SetOperator;
        type_arguments: [];
    };
    interface SetOperatorEvent {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperatorEvent {
        const TYPE_QNAME = "0x1::stake::SetOperatorEvent";
        function type(): TypeDescriptor<SetOperatorEvent>;
    }
    type SetOperatorEventInstance = TypedEventInstance<SetOperatorEvent> & {
        data_decoded: SetOperatorEvent;
        type_arguments: [];
    };
    interface StakeManagementPermission {
        dummy_field: boolean;
    }
    namespace StakeManagementPermission {
        const TYPE_QNAME = "0x1::stake::StakeManagementPermission";
        function type(): TypeDescriptor<StakeManagementPermission>;
    }
    interface StakePool {
        active: coin.Coin<aptos_coin.AptosCoin>;
        inactive: coin.Coin<aptos_coin.AptosCoin>;
        pending_active: coin.Coin<aptos_coin.AptosCoin>;
        pending_inactive: coin.Coin<aptos_coin.AptosCoin>;
        locked_until_secs: bigint;
        operator_address: MoveAddressType;
        delegated_voter: MoveAddressType;
        initialize_validator_events: event.EventHandle<stake.RegisterValidatorCandidateEvent>;
        set_operator_events: event.EventHandle<stake.SetOperatorEvent>;
        add_stake_events: event.EventHandle<stake.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<stake.ReactivateStakeEvent>;
        rotate_consensus_key_events: event.EventHandle<stake.RotateConsensusKeyEvent>;
        update_network_and_fullnode_addresses_events: event.EventHandle<stake.UpdateNetworkAndFullnodeAddressesEvent>;
        increase_lockup_events: event.EventHandle<stake.IncreaseLockupEvent>;
        join_validator_set_events: event.EventHandle<stake.JoinValidatorSetEvent>;
        distribute_rewards_events: event.EventHandle<stake.DistributeRewardsEvent>;
        unlock_stake_events: event.EventHandle<stake.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<stake.WithdrawStakeEvent>;
        leave_validator_set_events: event.EventHandle<stake.LeaveValidatorSetEvent>;
    }
    namespace StakePool {
        const TYPE_QNAME = "0x1::stake::StakePool";
        function type(): TypeDescriptor<StakePool>;
    }
    interface TransactionFeeConfig {
    }
    namespace TransactionFeeConfig {
        const TYPE_QNAME = "0x1::stake::TransactionFeeConfig";
        function type(): TypeDescriptor<TransactionFeeConfig>;
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::stake::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::stake::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface UpdateNetworkAndFullnodeAddresses {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddresses {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddresses";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddresses>;
    }
    type UpdateNetworkAndFullnodeAddressesInstance = TypedEventInstance<UpdateNetworkAndFullnodeAddresses> & {
        data_decoded: UpdateNetworkAndFullnodeAddresses;
        type_arguments: [];
    };
    interface UpdateNetworkAndFullnodeAddressesEvent {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddressesEvent {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddressesEvent";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddressesEvent>;
    }
    type UpdateNetworkAndFullnodeAddressesEventInstance = TypedEventInstance<UpdateNetworkAndFullnodeAddressesEvent> & {
        data_decoded: UpdateNetworkAndFullnodeAddressesEvent;
        type_arguments: [];
    };
    interface ValidatorConfig {
        consensus_pubkey: string;
        network_addresses: string;
        fullnode_addresses: string;
        validator_index: bigint;
    }
    namespace ValidatorConfig {
        const TYPE_QNAME = "0x1::stake::ValidatorConfig";
        function type(): TypeDescriptor<ValidatorConfig>;
    }
    interface ValidatorFees {
        fees_table: table.Table<MoveAddressType, coin.Coin<aptos_coin.AptosCoin>>;
    }
    namespace ValidatorFees {
        const TYPE_QNAME = "0x1::stake::ValidatorFees";
        function type(): TypeDescriptor<ValidatorFees>;
    }
    interface ValidatorInfo {
        addr: MoveAddressType;
        voting_power: bigint;
        config: stake.ValidatorConfig;
    }
    namespace ValidatorInfo {
        const TYPE_QNAME = "0x1::stake::ValidatorInfo";
        function type(): TypeDescriptor<ValidatorInfo>;
    }
    interface ValidatorPerformance {
        validators: stake.IndividualValidatorPerformance[];
    }
    namespace ValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::ValidatorPerformance";
        function type(): TypeDescriptor<ValidatorPerformance>;
    }
    interface ValidatorSet {
        consensus_scheme: number;
        active_validators: stake.ValidatorInfo[];
        pending_inactive: stake.ValidatorInfo[];
        pending_active: stake.ValidatorInfo[];
        total_voting_power: bigint;
        total_joining_power: bigint;
    }
    namespace ValidatorSet {
        const TYPE_QNAME = "0x1::stake::ValidatorSet";
        function type(): TypeDescriptor<ValidatorSet>;
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::stake::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    type WithdrawStakeInstance = TypedEventInstance<WithdrawStake> & {
        data_decoded: WithdrawStake;
        type_arguments: [];
    };
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::stake::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    type WithdrawStakeEventInstance = TypedEventInstance<WithdrawStakeEvent> & {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    };
    namespace entry {
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function increaseLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeStakeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeValidator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function joinValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function leaveValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateConsensusKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateNetworkAndFullnodeAddresses(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getCurrentEpochProposalCounts(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function getCurrentEpochVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegatedVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getPendingTransactionFee(client: Aptos, version?: bigint): Promise<[bigint[]]>;
        function getRemainingLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getValidatorConfig(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string, string, string]>;
        function getValidatorIndex(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getValidatorState(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface WithdrawPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface AddStakePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface IncreaseLockupPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface InitializeStakeOwnerPayload extends TypedFunctionPayload<[bigint, MoveAddressType, MoveAddressType]> {
        arguments_decoded: [bigint, MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface InitializeValidatorPayload extends TypedFunctionPayload<[string, string, string, string]> {
        arguments_decoded: [string, string, string, string];
        type_arguments: [];
    }
    interface JoinValidatorSetPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface LeaveValidatorSetPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface ReactivateStakePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface RotateConsensusKeyPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface SetDelegatedVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddressesPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
}
export declare namespace table {
    interface Box<T0> {
        val: T0;
    }
    namespace Box {
        const TYPE_QNAME = "0x1::table::Box";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Box<T0>>;
    }
    interface Table<T0, T1> {
        handle: MoveAddressType;
    }
    namespace Table {
        const TYPE_QNAME = "0x1::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace base16 {
    namespace entry { }
    namespace view { }
}
export declare namespace math64 {
    namespace entry { }
    namespace view { }
}
export declare class object$ extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): object$;
    onEntryBurn(func: (call: object$.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.BurnPayload>): object$;
    onEntryTransfer(func: (call: object$.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferPayload>): object$;
    onEntryTransferCall(func: (call: object$.TransferCallPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferCallPayload>): object$;
    onEntryTransferToObject(func: (call: object$.TransferToObjectPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferToObjectPayload>): object$;
    onEntryUnburn(func: (call: object$.UnburnPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.UnburnPayload>): object$;
    onEventDeleteRef(func: (event: object$.DeleteRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.DeleteRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
    onEventDeriveRef(func: (event: object$.DeriveRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.DeriveRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
    onEventExtendRef(func: (event: object$.ExtendRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.ExtendRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
    onEventTransfer(func: (event: object$.TransferInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
    onEventTransferEvent(func: (event: object$.TransferEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
    onEventTransferRef(func: (event: object$.TransferRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object$.TransferRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object$;
}
export declare namespace object$ {
    interface ConstructorRef {
        self: MoveAddressType;
        can_delete: boolean;
    }
    namespace ConstructorRef {
        const TYPE_QNAME = "0x1::object::ConstructorRef";
        function type(): TypeDescriptor<ConstructorRef>;
    }
    interface DeleteRef {
        self: MoveAddressType;
    }
    namespace DeleteRef {
        const TYPE_QNAME = "0x1::object::DeleteRef";
        function type(): TypeDescriptor<DeleteRef>;
    }
    type DeleteRefInstance = TypedEventInstance<DeleteRef> & {
        data_decoded: DeleteRef;
        type_arguments: [];
    };
    interface DeriveRef {
        self: MoveAddressType;
    }
    namespace DeriveRef {
        const TYPE_QNAME = "0x1::object::DeriveRef";
        function type(): TypeDescriptor<DeriveRef>;
    }
    type DeriveRefInstance = TypedEventInstance<DeriveRef> & {
        data_decoded: DeriveRef;
        type_arguments: [];
    };
    interface ExtendRef {
        self: MoveAddressType;
    }
    namespace ExtendRef {
        const TYPE_QNAME = "0x1::object::ExtendRef";
        function type(): TypeDescriptor<ExtendRef>;
    }
    type ExtendRefInstance = TypedEventInstance<ExtendRef> & {
        data_decoded: ExtendRef;
        type_arguments: [];
    };
    interface LinearTransferRef {
        self: MoveAddressType;
        owner: MoveAddressType;
    }
    namespace LinearTransferRef {
        const TYPE_QNAME = "0x1::object::LinearTransferRef";
        function type(): TypeDescriptor<LinearTransferRef>;
    }
    type Object<T> = MoveAddressType;
    namespace Object {
        const TYPE_QNAME = "0x1::object::Object";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Object<T0>>;
    }
    interface ObjectCore {
        guid_creation_num: bigint;
        owner: MoveAddressType;
        allow_ungated_transfer: boolean;
        transfer_events: event.EventHandle<object$.TransferEvent>;
    }
    namespace ObjectCore {
        const TYPE_QNAME = "0x1::object::ObjectCore";
        function type(): TypeDescriptor<ObjectCore>;
    }
    interface ObjectGroup {
        dummy_field: boolean;
    }
    namespace ObjectGroup {
        const TYPE_QNAME = "0x1::object::ObjectGroup";
        function type(): TypeDescriptor<ObjectGroup>;
    }
    interface TombStone {
        original_owner: MoveAddressType;
    }
    namespace TombStone {
        const TYPE_QNAME = "0x1::object::TombStone";
        function type(): TypeDescriptor<TombStone>;
    }
    interface Transfer {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace Transfer {
        const TYPE_QNAME = "0x1::object::Transfer";
        function type(): TypeDescriptor<Transfer>;
    }
    type TransferInstance = TypedEventInstance<Transfer> & {
        data_decoded: Transfer;
        type_arguments: [];
    };
    interface TransferEvent {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace TransferEvent {
        const TYPE_QNAME = "0x1::object::TransferEvent";
        function type(): TypeDescriptor<TransferEvent>;
    }
    type TransferEventInstance = TypedEventInstance<TransferEvent> & {
        data_decoded: TransferEvent;
        type_arguments: [];
    };
    interface TransferPermission {
        object: MoveAddressType;
    }
    namespace TransferPermission {
        const TYPE_QNAME = "0x1::object::TransferPermission";
        function type(): TypeDescriptor<TransferPermission>;
    }
    interface TransferRef {
        self: MoveAddressType;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::object::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    type TransferRefInstance = TypedEventInstance<TransferRef> & {
        data_decoded: TransferRef;
        type_arguments: [];
    };
    interface Untransferable {
        dummy_field: boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::object::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    namespace entry {
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferToObject<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T1>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unburn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function owner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function isBurnt<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isOwner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function owns<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function rootOwner<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[object$.Object<T0>]> {
        arguments_decoded: [object$.Object<T0>];
        type_arguments: [string];
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[object$.Object<T0>, MoveAddressType]> {
        arguments_decoded: [object$.Object<T0>, MoveAddressType];
        type_arguments: [string];
    }
    interface TransferCallPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface TransferToObjectPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[object$.Object<T0>, object$.Object<T1>]> {
        arguments_decoded: [object$.Object<T0>, object$.Object<T1>];
        type_arguments: [string, string];
    }
    interface UnburnPayload<T0 = any> extends TypedFunctionPayload<[object$.Object<T0>]> {
        arguments_decoded: [object$.Object<T0>];
        type_arguments: [string];
    }
}
export declare namespace option {
    interface Option<T0> {
        vec: T0[];
    }
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace signer {
    namespace entry { }
    namespace view { }
}
export declare namespace string$ {
    interface String {
        bytes: string;
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace vector {
    namespace entry { }
    namespace view { }
}
export declare class voting extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): voting;
    onEventCreateProposal(func: (event: voting.CreateProposalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.CreateProposalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventCreateProposalEvent(func: (event: voting.CreateProposalEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.CreateProposalEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventRegisterForum(func: (event: voting.RegisterForumInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.RegisterForumInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventRegisterForumEvent(func: (event: voting.RegisterForumEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.RegisterForumEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventResolveProposal(func: (event: voting.ResolveProposalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.ResolveProposalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventVote(func: (event: voting.VoteInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.VoteInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
    onEventVoteEvent(func: (event: voting.VoteEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, voting.VoteEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): voting;
}
export declare namespace voting {
    interface CreateProposal {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::voting::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::voting::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Proposal<T0> {
        proposer: MoveAddressType;
        execution_content: option.Option<T0>;
        metadata: simple_map.SimpleMap<string, string>;
        creation_time_secs: bigint;
        execution_hash: string;
        min_vote_threshold: bigint;
        expiration_secs: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        yes_votes: bigint;
        no_votes: bigint;
        is_resolved: boolean;
        resolution_time_secs: bigint;
    }
    namespace Proposal {
        const TYPE_QNAME = "0x1::voting::Proposal";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Proposal<T0>>;
    }
    interface RegisterForum {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForum {
        const TYPE_QNAME = "0x1::voting::RegisterForum";
        function type(): TypeDescriptor<RegisterForum>;
    }
    type RegisterForumInstance = TypedEventInstance<RegisterForum> & {
        data_decoded: RegisterForum;
        type_arguments: [];
    };
    interface RegisterForumEvent {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForumEvent {
        const TYPE_QNAME = "0x1::voting::RegisterForumEvent";
        function type(): TypeDescriptor<RegisterForumEvent>;
    }
    type RegisterForumEventInstance = TypedEventInstance<RegisterForumEvent> & {
        data_decoded: RegisterForumEvent;
        type_arguments: [];
    };
    interface ResolveProposal {
        proposal_id: bigint;
        yes_votes: bigint;
        no_votes: bigint;
        resolved_early: boolean;
    }
    namespace ResolveProposal {
        const TYPE_QNAME = "0x1::voting::ResolveProposal";
        function type(): TypeDescriptor<ResolveProposal>;
    }
    type ResolveProposalInstance = TypedEventInstance<ResolveProposal> & {
        data_decoded: ResolveProposal;
        type_arguments: [];
    };
    interface Vote {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::voting::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::voting::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface VotePermission {
        dummy_field: boolean;
    }
    namespace VotePermission {
        const TYPE_QNAME = "0x1::voting::VotePermission";
        function type(): TypeDescriptor<VotePermission>;
    }
    interface VotingEvents {
        create_proposal_events: event.EventHandle<voting.CreateProposalEvent>;
        register_forum_events: event.EventHandle<voting.RegisterForumEvent>;
        resolve_proposal_events: event.EventHandle<voting.ResolveProposal>;
        vote_events: event.EventHandle<voting.VoteEvent>;
    }
    namespace VotingEvents {
        const TYPE_QNAME = "0x1::voting::VotingEvents";
        function type(): TypeDescriptor<VotingEvents>;
    }
    interface VotingForum<T0> {
        proposals: table.Table<bigint, voting.Proposal<T0>>;
        events: voting.VotingEvents;
        next_proposal_id: bigint;
    }
    namespace VotingForum {
        const TYPE_QNAME = "0x1::voting::VotingForum";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VotingForum<T0>>;
    }
    namespace entry { }
    namespace view {
        function getEarlyResolutionVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function getExecutionHash<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[string]>;
        function getMinVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalCreationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalExpirationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function getProposalMetadataValue<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint, string];
        }, version?: bigint): Promise<[string]>;
        function getProposalState<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposer<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getResolutionTimeSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getVotes<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function isMultiStepProposalInExecution<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isResolved<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isVotingClosed<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function nextProposalId<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare class account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): account;
    onEntryOfferRotationCapability(func: (call: account.OfferRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.OfferRotationCapabilityPayload>): account;
    onEntryOfferSignerCapability(func: (call: account.OfferSignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.OfferSignerCapabilityPayload>): account;
    onEntryRevokeAnyRotationCapability(func: (call: account.RevokeAnyRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RevokeAnyRotationCapabilityPayload>): account;
    onEntryRevokeAnySignerCapability(func: (call: account.RevokeAnySignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RevokeAnySignerCapabilityPayload>): account;
    onEntryRevokeRotationCapability(func: (call: account.RevokeRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RevokeRotationCapabilityPayload>): account;
    onEntryRevokeSignerCapability(func: (call: account.RevokeSignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RevokeSignerCapabilityPayload>): account;
    onEntryRotateAuthenticationKey(func: (call: account.RotateAuthenticationKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RotateAuthenticationKeyPayload>): account;
    onEntryRotateAuthenticationKeyCall(func: (call: account.RotateAuthenticationKeyCallPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RotateAuthenticationKeyCallPayload>): account;
    onEntryRotateAuthenticationKeyFromPublicKey(func: (call: account.RotateAuthenticationKeyFromPublicKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RotateAuthenticationKeyFromPublicKeyPayload>): account;
    onEntryRotateAuthenticationKeyWithRotationCapability(func: (call: account.RotateAuthenticationKeyWithRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RotateAuthenticationKeyWithRotationCapabilityPayload>): account;
    onEntrySetOriginatingAddress(func: (call: account.SetOriginatingAddressPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.SetOriginatingAddressPayload>): account;
    onEntryUpsertEd25519BackupKeyOnKeylessAccount(func: (call: account.UpsertEd25519BackupKeyOnKeylessAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account.UpsertEd25519BackupKeyOnKeylessAccountPayload>): account;
    onEventCoinRegister(func: (event: account.CoinRegisterInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.CoinRegisterInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventCoinRegisterEvent(func: (event: account.CoinRegisterEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.CoinRegisterEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventKeyRotation(func: (event: account.KeyRotationInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.KeyRotationInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventKeyRotationEvent(func: (event: account.KeyRotationEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.KeyRotationEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventKeyRotationToPublicKey(func: (event: account.KeyRotationToPublicKeyInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.KeyRotationToPublicKeyInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventRotationCapability(func: (event: account.RotationCapabilityInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.RotationCapabilityInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
    onEventSignerCapability(func: (event: account.SignerCapabilityInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account.SignerCapabilityInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account;
}
export declare namespace account {
    interface Account {
        authentication_key: string;
        sequence_number: bigint;
        guid_creation_num: bigint;
        coin_register_events: event.EventHandle<account.CoinRegisterEvent>;
        key_rotation_events: event.EventHandle<account.KeyRotationEvent>;
        rotation_capability_offer: account.CapabilityOffer<account.RotationCapability>;
        signer_capability_offer: account.CapabilityOffer<account.SignerCapability>;
    }
    namespace Account {
        const TYPE_QNAME = "0x1::account::Account";
        function type(): TypeDescriptor<Account>;
    }
    interface AccountPermission {
    }
    namespace AccountPermission {
        const TYPE_QNAME = "0x1::account::AccountPermission";
        function type(): TypeDescriptor<AccountPermission>;
    }
    interface CapabilityOffer<T0> {
        for: option.Option<MoveAddressType>;
    }
    namespace CapabilityOffer {
        const TYPE_QNAME = "0x1::account::CapabilityOffer";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapabilityOffer<T0>>;
    }
    interface CoinRegister {
        account: MoveAddressType;
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegister {
        const TYPE_QNAME = "0x1::account::CoinRegister";
        function type(): TypeDescriptor<CoinRegister>;
    }
    type CoinRegisterInstance = TypedEventInstance<CoinRegister> & {
        data_decoded: CoinRegister;
        type_arguments: [];
    };
    interface CoinRegisterEvent {
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegisterEvent {
        const TYPE_QNAME = "0x1::account::CoinRegisterEvent";
        function type(): TypeDescriptor<CoinRegisterEvent>;
    }
    type CoinRegisterEventInstance = TypedEventInstance<CoinRegisterEvent> & {
        data_decoded: CoinRegisterEvent;
        type_arguments: [];
    };
    interface KeyRotation {
        account: MoveAddressType;
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotation {
        const TYPE_QNAME = "0x1::account::KeyRotation";
        function type(): TypeDescriptor<KeyRotation>;
    }
    type KeyRotationInstance = TypedEventInstance<KeyRotation> & {
        data_decoded: KeyRotation;
        type_arguments: [];
    };
    interface KeyRotationEvent {
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotationEvent {
        const TYPE_QNAME = "0x1::account::KeyRotationEvent";
        function type(): TypeDescriptor<KeyRotationEvent>;
    }
    type KeyRotationEventInstance = TypedEventInstance<KeyRotationEvent> & {
        data_decoded: KeyRotationEvent;
        type_arguments: [];
    };
    interface KeyRotationToPublicKey {
        account: MoveAddressType;
        verified_public_key_bit_map: string;
        public_key_scheme: number;
        public_key: string;
        old_auth_key: string;
        new_auth_key: string;
    }
    namespace KeyRotationToPublicKey {
        const TYPE_QNAME = "0x1::account::KeyRotationToPublicKey";
        function type(): TypeDescriptor<KeyRotationToPublicKey>;
    }
    type KeyRotationToPublicKeyInstance = TypedEventInstance<KeyRotationToPublicKey> & {
        data_decoded: KeyRotationToPublicKey;
        type_arguments: [];
    };
    interface OriginatingAddress {
        address_map: table.Table<MoveAddressType, MoveAddressType>;
    }
    namespace OriginatingAddress {
        const TYPE_QNAME = "0x1::account::OriginatingAddress";
        function type(): TypeDescriptor<OriginatingAddress>;
    }
    interface RotationCapability {
        account: MoveAddressType;
    }
    namespace RotationCapability {
        const TYPE_QNAME = "0x1::account::RotationCapability";
        function type(): TypeDescriptor<RotationCapability>;
    }
    type RotationCapabilityInstance = TypedEventInstance<RotationCapability> & {
        data_decoded: RotationCapability;
        type_arguments: [];
    };
    interface RotationCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallenge>;
    }
    interface RotationCapabilityOfferProofChallengeV2 {
        chain_id: number;
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallengeV2>;
    }
    interface RotationProofChallenge {
        sequence_number: bigint;
        originator: MoveAddressType;
        current_auth_key: MoveAddressType;
        new_public_key: string;
    }
    namespace RotationProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationProofChallenge";
        function type(): TypeDescriptor<RotationProofChallenge>;
    }
    interface SignerCapability {
        account: MoveAddressType;
    }
    namespace SignerCapability {
        const TYPE_QNAME = "0x1::account::SignerCapability";
        function type(): TypeDescriptor<SignerCapability>;
    }
    type SignerCapabilityInstance = TypedEventInstance<SignerCapability> & {
        data_decoded: SignerCapability;
        type_arguments: [];
    };
    interface SignerCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallenge>;
    }
    interface SignerCapabilityOfferProofChallengeV2 {
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallengeV2>;
    }
    namespace entry {
        function offerRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function offerSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnyRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnySignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [number, string, number, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyFromPublicKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [number, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyWithRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, number, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOriginatingAddress(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upsertEd25519BackupKeyOnKeylessAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function existsAt(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getAuthenticationKey(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string]>;
        function getGuidNextCreationNum(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getRotationCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getSignerCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function isRotationCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function isSignerCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function originatingAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<MoveAddressType>]>;
    }
    interface OfferRotationCapabilityPayload extends TypedFunctionPayload<[string, number, string, MoveAddressType]> {
        arguments_decoded: [string, number, string, MoveAddressType];
        type_arguments: [];
    }
    interface OfferSignerCapabilityPayload extends TypedFunctionPayload<[string, number, string, MoveAddressType]> {
        arguments_decoded: [string, number, string, MoveAddressType];
        type_arguments: [];
    }
    interface RevokeAnyRotationCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RevokeAnySignerCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RevokeRotationCapabilityPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RevokeSignerCapabilityPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyPayload extends TypedFunctionPayload<[
        number,
        string,
        number,
        string,
        string,
        string
    ]> {
        arguments_decoded: [number, string, number, string, string, string];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyCallPayload extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyFromPublicKeyPayload extends TypedFunctionPayload<[number, string]> {
        arguments_decoded: [number, string];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyWithRotationCapabilityPayload extends TypedFunctionPayload<[MoveAddressType, number, string, string]> {
        arguments_decoded: [MoveAddressType, number, string, string];
        type_arguments: [];
    }
    interface SetOriginatingAddressPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface UpsertEd25519BackupKeyOnKeylessAccountPayload extends TypedFunctionPayload<[string, string, string]> {
        arguments_decoded: [string, string, string];
        type_arguments: [];
    }
}
export declare namespace ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignedMessage<T0> {
        type_info: type_info.TypeInfo;
        inner: T0;
    }
    namespace SignedMessage {
        const TYPE_QNAME = "0x1::ed25519::SignedMessage";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SignedMessage<T0>>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace genesis {
    interface AccountMap {
        account_address: MoveAddressType;
        balance: bigint;
    }
    namespace AccountMap {
        const TYPE_QNAME = "0x1::genesis::AccountMap";
        function type(): TypeDescriptor<AccountMap>;
    }
    interface EmployeeAccountMap {
        accounts: MoveAddressType[];
        validator: genesis.ValidatorConfigurationWithCommission;
        vesting_schedule_numerator: bigint[];
        vesting_schedule_denominator: bigint;
        beneficiary_resetter: MoveAddressType;
    }
    namespace EmployeeAccountMap {
        const TYPE_QNAME = "0x1::genesis::EmployeeAccountMap";
        function type(): TypeDescriptor<EmployeeAccountMap>;
    }
    interface ValidatorConfiguration {
        owner_address: MoveAddressType;
        operator_address: MoveAddressType;
        voter_address: MoveAddressType;
        stake_amount: bigint;
        consensus_pubkey: string;
        proof_of_possession: string;
        network_addresses: string;
        full_node_network_addresses: string;
    }
    namespace ValidatorConfiguration {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfiguration";
        function type(): TypeDescriptor<ValidatorConfiguration>;
    }
    interface ValidatorConfigurationWithCommission {
        validator_config: genesis.ValidatorConfiguration;
        commission_percentage: bigint;
        join_during_genesis: boolean;
    }
    namespace ValidatorConfigurationWithCommission {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfigurationWithCommission";
        function type(): TypeDescriptor<ValidatorConfigurationWithCommission>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace keyless {
    interface PublicKey {
        iss: string;
        idc: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::keyless::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math128 {
    namespace entry { }
    namespace view { }
}
export declare class version extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): version;
    onEntrySetForNextEpoch(func: (call: version.SetForNextEpochPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, version.SetForNextEpochPayload>): version;
    onEntrySetVersion(func: (call: version.SetVersionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, version.SetVersionPayload>): version;
}
export declare namespace version {
    interface SetVersionCapability {
        dummy_field: boolean;
    }
    namespace SetVersionCapability {
        const TYPE_QNAME = "0x1::version::SetVersionCapability";
        function type(): TypeDescriptor<SetVersionCapability>;
    }
    interface Version {
        major: bigint;
    }
    namespace Version {
        const TYPE_QNAME = "0x1::version::Version";
        function type(): TypeDescriptor<Version>;
    }
    namespace entry {
        function setForNextEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVersion(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface SetForNextEpochPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface SetVersionPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
}
export declare class vesting extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): vesting;
    onEntrySetBeneficiaryForOperator(func: (call: vesting.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetBeneficiaryForOperatorPayload>): vesting;
    onEntryUpdateCommissionPercentage(func: (call: vesting.UpdateCommissionPercentagePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateCommissionPercentagePayload>): vesting;
    onEntryDistribute(func: (call: vesting.DistributePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.DistributePayload>): vesting;
    onEntryResetLockup(func: (call: vesting.ResetLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.ResetLockupPayload>): vesting;
    onEntryUnlockRewards(func: (call: vesting.UnlockRewardsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UnlockRewardsPayload>): vesting;
    onEntryUpdateVoter(func: (call: vesting.UpdateVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateVoterPayload>): vesting;
    onEntryAdminWithdraw(func: (call: vesting.AdminWithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.AdminWithdrawPayload>): vesting;
    onEntryDistributeMany(func: (call: vesting.DistributeManyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.DistributeManyPayload>): vesting;
    onEntryResetBeneficiary(func: (call: vesting.ResetBeneficiaryPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.ResetBeneficiaryPayload>): vesting;
    onEntrySetBeneficiary(func: (call: vesting.SetBeneficiaryPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetBeneficiaryPayload>): vesting;
    onEntrySetBeneficiaryResetter(func: (call: vesting.SetBeneficiaryResetterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetBeneficiaryResetterPayload>): vesting;
    onEntrySetManagementRole(func: (call: vesting.SetManagementRolePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetManagementRolePayload>): vesting;
    onEntryTerminateVestingContract(func: (call: vesting.TerminateVestingContractPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.TerminateVestingContractPayload>): vesting;
    onEntryUnlockRewardsMany(func: (call: vesting.UnlockRewardsManyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UnlockRewardsManyPayload>): vesting;
    onEntryUpdateOperator(func: (call: vesting.UpdateOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateOperatorPayload>): vesting;
    onEntryUpdateOperatorWithSameCommission(func: (call: vesting.UpdateOperatorWithSameCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateOperatorWithSameCommissionPayload>): vesting;
    onEntryVest(func: (call: vesting.VestPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.VestPayload>): vesting;
    onEntryVestMany(func: (call: vesting.VestManyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.VestManyPayload>): vesting;
    onEventDistribute(func: (event: vesting.DistributeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.DistributeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventDistributeEvent(func: (event: vesting.DistributeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.DistributeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventResetLockup(func: (event: vesting.ResetLockupInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.ResetLockupInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventResetLockupEvent(func: (event: vesting.ResetLockupEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.ResetLockupEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUpdateVoter(func: (event: vesting.UpdateVoterInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateVoterInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUpdateVoterEvent(func: (event: vesting.UpdateVoterEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateVoterEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventAdminWithdraw(func: (event: vesting.AdminWithdrawInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.AdminWithdrawInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventAdminWithdrawEvent(func: (event: vesting.AdminWithdrawEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.AdminWithdrawEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventCreateVestingContract(func: (event: vesting.CreateVestingContractInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.CreateVestingContractInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventCreateVestingContractEvent(func: (event: vesting.CreateVestingContractEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.CreateVestingContractEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventSetBeneficiary(func: (event: vesting.SetBeneficiaryInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetBeneficiaryInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventSetBeneficiaryEvent(func: (event: vesting.SetBeneficiaryEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.SetBeneficiaryEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventTerminate(func: (event: vesting.TerminateInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.TerminateInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventTerminateEvent(func: (event: vesting.TerminateEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.TerminateEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUnlockRewards(func: (event: vesting.UnlockRewardsInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UnlockRewardsInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUnlockRewardsEvent(func: (event: vesting.UnlockRewardsEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UnlockRewardsEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUpdateOperator(func: (event: vesting.UpdateOperatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateOperatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventUpdateOperatorEvent(func: (event: vesting.UpdateOperatorEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.UpdateOperatorEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventVest(func: (event: vesting.VestInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.VestInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
    onEventVestEvent(func: (event: vesting.VestEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, vesting.VestEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): vesting;
}
export declare namespace vesting {
    interface Distribute {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::vesting::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    type DistributeInstance = TypedEventInstance<Distribute> & {
        data_decoded: Distribute;
        type_arguments: [];
    };
    interface DistributeEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::vesting::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    type DistributeEventInstance = TypedEventInstance<DistributeEvent> & {
        data_decoded: DistributeEvent;
        type_arguments: [];
    };
    interface ResetLockup {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::vesting::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    type ResetLockupInstance = TypedEventInstance<ResetLockup> & {
        data_decoded: ResetLockup;
        type_arguments: [];
    };
    interface ResetLockupEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::vesting::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    type ResetLockupEventInstance = TypedEventInstance<ResetLockupEvent> & {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    };
    interface UpdateVoter {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::vesting::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    type UpdateVoterInstance = TypedEventInstance<UpdateVoter> & {
        data_decoded: UpdateVoter;
        type_arguments: [];
    };
    interface UpdateVoterEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    type UpdateVoterEventInstance = TypedEventInstance<UpdateVoterEvent> & {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    };
    interface AdminStore {
        vesting_contracts: MoveAddressType[];
        nonce: bigint;
        create_events: event.EventHandle<vesting.CreateVestingContractEvent>;
    }
    namespace AdminStore {
        const TYPE_QNAME = "0x1::vesting::AdminStore";
        function type(): TypeDescriptor<AdminStore>;
    }
    interface AdminWithdraw {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdraw {
        const TYPE_QNAME = "0x1::vesting::AdminWithdraw";
        function type(): TypeDescriptor<AdminWithdraw>;
    }
    type AdminWithdrawInstance = TypedEventInstance<AdminWithdraw> & {
        data_decoded: AdminWithdraw;
        type_arguments: [];
    };
    interface AdminWithdrawEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdrawEvent {
        const TYPE_QNAME = "0x1::vesting::AdminWithdrawEvent";
        function type(): TypeDescriptor<AdminWithdrawEvent>;
    }
    type AdminWithdrawEventInstance = TypedEventInstance<AdminWithdrawEvent> & {
        data_decoded: AdminWithdrawEvent;
        type_arguments: [];
    };
    interface CreateVestingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContract {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContract";
        function type(): TypeDescriptor<CreateVestingContract>;
    }
    type CreateVestingContractInstance = TypedEventInstance<CreateVestingContract> & {
        data_decoded: CreateVestingContract;
        type_arguments: [];
    };
    interface CreateVestingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContractEvent {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContractEvent";
        function type(): TypeDescriptor<CreateVestingContractEvent>;
    }
    type CreateVestingContractEventInstance = TypedEventInstance<CreateVestingContractEvent> & {
        data_decoded: CreateVestingContractEvent;
        type_arguments: [];
    };
    interface SetBeneficiary {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiary {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiary";
        function type(): TypeDescriptor<SetBeneficiary>;
    }
    type SetBeneficiaryInstance = TypedEventInstance<SetBeneficiary> & {
        data_decoded: SetBeneficiary;
        type_arguments: [];
    };
    interface SetBeneficiaryEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryEvent {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiaryEvent";
        function type(): TypeDescriptor<SetBeneficiaryEvent>;
    }
    type SetBeneficiaryEventInstance = TypedEventInstance<SetBeneficiaryEvent> & {
        data_decoded: SetBeneficiaryEvent;
        type_arguments: [];
    };
    interface StakingInfo {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        voter: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace StakingInfo {
        const TYPE_QNAME = "0x1::vesting::StakingInfo";
        function type(): TypeDescriptor<StakingInfo>;
    }
    interface Terminate {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace Terminate {
        const TYPE_QNAME = "0x1::vesting::Terminate";
        function type(): TypeDescriptor<Terminate>;
    }
    type TerminateInstance = TypedEventInstance<Terminate> & {
        data_decoded: Terminate;
        type_arguments: [];
    };
    interface TerminateEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace TerminateEvent {
        const TYPE_QNAME = "0x1::vesting::TerminateEvent";
        function type(): TypeDescriptor<TerminateEvent>;
    }
    type TerminateEventInstance = TypedEventInstance<TerminateEvent> & {
        data_decoded: TerminateEvent;
        type_arguments: [];
    };
    interface UnlockRewards {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewards {
        const TYPE_QNAME = "0x1::vesting::UnlockRewards";
        function type(): TypeDescriptor<UnlockRewards>;
    }
    type UnlockRewardsInstance = TypedEventInstance<UnlockRewards> & {
        data_decoded: UnlockRewards;
        type_arguments: [];
    };
    interface UnlockRewardsEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewardsEvent {
        const TYPE_QNAME = "0x1::vesting::UnlockRewardsEvent";
        function type(): TypeDescriptor<UnlockRewardsEvent>;
    }
    type UnlockRewardsEventInstance = TypedEventInstance<UnlockRewardsEvent> & {
        data_decoded: UnlockRewardsEvent;
        type_arguments: [];
    };
    interface UpdateOperator {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperator {
        const TYPE_QNAME = "0x1::vesting::UpdateOperator";
        function type(): TypeDescriptor<UpdateOperator>;
    }
    type UpdateOperatorInstance = TypedEventInstance<UpdateOperator> & {
        data_decoded: UpdateOperator;
        type_arguments: [];
    };
    interface UpdateOperatorEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperatorEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateOperatorEvent";
        function type(): TypeDescriptor<UpdateOperatorEvent>;
    }
    type UpdateOperatorEventInstance = TypedEventInstance<UpdateOperatorEvent> & {
        data_decoded: UpdateOperatorEvent;
        type_arguments: [];
    };
    interface Vest {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace Vest {
        const TYPE_QNAME = "0x1::vesting::Vest";
        function type(): TypeDescriptor<Vest>;
    }
    type VestInstance = TypedEventInstance<Vest> & {
        data_decoded: Vest;
        type_arguments: [];
    };
    interface VestEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace VestEvent {
        const TYPE_QNAME = "0x1::vesting::VestEvent";
        function type(): TypeDescriptor<VestEvent>;
    }
    type VestEventInstance = TypedEventInstance<VestEvent> & {
        data_decoded: VestEvent;
        type_arguments: [];
    };
    interface VestPermission {
        dummy_field: boolean;
    }
    namespace VestPermission {
        const TYPE_QNAME = "0x1::vesting::VestPermission";
        function type(): TypeDescriptor<VestPermission>;
    }
    interface VestingAccountManagement {
        roles: simple_map.SimpleMap<string, MoveAddressType>;
    }
    namespace VestingAccountManagement {
        const TYPE_QNAME = "0x1::vesting::VestingAccountManagement";
        function type(): TypeDescriptor<VestingAccountManagement>;
    }
    interface VestingContract {
        state: bigint;
        admin: MoveAddressType;
        grant_pool: pool_u64.Pool;
        beneficiaries: simple_map.SimpleMap<MoveAddressType, MoveAddressType>;
        vesting_schedule: vesting.VestingSchedule;
        withdrawal_address: MoveAddressType;
        staking: vesting.StakingInfo;
        remaining_grant: bigint;
        signer_cap: account.SignerCapability;
        update_operator_events: event.EventHandle<vesting.UpdateOperatorEvent>;
        update_voter_events: event.EventHandle<vesting.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<vesting.ResetLockupEvent>;
        set_beneficiary_events: event.EventHandle<vesting.SetBeneficiaryEvent>;
        unlock_rewards_events: event.EventHandle<vesting.UnlockRewardsEvent>;
        vest_events: event.EventHandle<vesting.VestEvent>;
        distribute_events: event.EventHandle<vesting.DistributeEvent>;
        terminate_events: event.EventHandle<vesting.TerminateEvent>;
        admin_withdraw_events: event.EventHandle<vesting.AdminWithdrawEvent>;
    }
    namespace VestingContract {
        const TYPE_QNAME = "0x1::vesting::VestingContract";
        function type(): TypeDescriptor<VestingContract>;
    }
    interface VestingSchedule {
        schedule: fixed_point32.FixedPoint32[];
        start_timestamp_secs: bigint;
        period_duration: bigint;
        last_vested_period: bigint;
    }
    namespace VestingSchedule {
        const TYPE_QNAME = "0x1::vesting::VestingSchedule";
        function type(): TypeDescriptor<VestingSchedule>;
    }
    namespace entry {
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function adminWithdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distributeMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryResetter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setManagementRole(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function terminateVestingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewardsMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vest(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vestMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function operator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function voter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function shareholder(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function beneficiary(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function shareholders(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function accumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function vestingSchedule(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[vesting.VestingSchedule]>;
        function periodDurationSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function remainingGrant(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function totalAccumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function vestingContracts(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function vestingStartSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UpdateCommissionPercentagePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface DistributePayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface ResetLockupPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UpdateVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface AdminWithdrawPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface DistributeManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface ResetBeneficiaryPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType,
        MoveAddressType
    ]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryResetterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetManagementRolePayload extends TypedFunctionPayload<[MoveAddressType, string, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, string, MoveAddressType];
        type_arguments: [];
    }
    interface TerminateVestingContractPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface UpdateOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateOperatorWithSameCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface VestPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface VestManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
}
export declare namespace bls12381 {
    interface AggrOrMultiSignature {
        bytes: string;
    }
    namespace AggrOrMultiSignature {
        const TYPE_QNAME = "0x1::bls12381::AggrOrMultiSignature";
        function type(): TypeDescriptor<AggrOrMultiSignature>;
    }
    interface AggrPublicKeysWithPoP {
        bytes: string;
    }
    namespace AggrPublicKeysWithPoP {
        const TYPE_QNAME = "0x1::bls12381::AggrPublicKeysWithPoP";
        function type(): TypeDescriptor<AggrPublicKeysWithPoP>;
    }
    interface ProofOfPossession {
        bytes: string;
    }
    namespace ProofOfPossession {
        const TYPE_QNAME = "0x1::bls12381::ProofOfPossession";
        function type(): TypeDescriptor<ProofOfPossession>;
    }
    interface PublicKey {
        bytes: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::bls12381::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    interface PublicKeyWithPoP {
        bytes: string;
    }
    namespace PublicKeyWithPoP {
        const TYPE_QNAME = "0x1::bls12381::PublicKeyWithPoP";
        function type(): TypeDescriptor<PublicKeyWithPoP>;
    }
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::bls12381::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_id {
    interface ChainId {
        id: number;
    }
    namespace ChainId {
        const TYPE_QNAME = "0x1::chain_id::ChainId";
        function type(): TypeDescriptor<ChainId>;
    }
    namespace entry { }
    namespace view {
        function get(client: Aptos, version?: bigint): Promise<[number]>;
    }
}
export declare namespace features {
    interface Features {
        features: string;
    }
    namespace Features {
        const TYPE_QNAME = "0x1::features::Features";
        function type(): TypeDescriptor<Features>;
    }
    interface PendingFeatures {
        features: string;
    }
    namespace PendingFeatures {
        const TYPE_QNAME = "0x1::features::PendingFeatures";
        function type(): TypeDescriptor<PendingFeatures>;
    }
    namespace entry { }
    namespace view {
        function isEnabled(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace from_bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace pool_u64 {
    interface Pool {
        shareholders_limit: bigint;
        total_coins: bigint;
        total_shares: bigint;
        shares: simple_map.SimpleMap<MoveAddressType, bigint>;
        shareholders: MoveAddressType[];
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace auth_data {
    interface AbstractionAuthData {
    }
    namespace AbstractionAuthData {
        const TYPE_QNAME = "0x1::auth_data::AbstractionAuthData";
        function type(): TypeDescriptor<AbstractionAuthData>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multi_key {
    interface MultiKey {
        public_keys: single_key.AnyPublicKey[];
        signatures_required: number;
    }
    namespace MultiKey {
        const TYPE_QNAME = "0x1::multi_key::MultiKey";
        function type(): TypeDescriptor<MultiKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace secp256k1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256k1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    interface ECDSASignature {
        bytes: string;
    }
    namespace ECDSASignature {
        const TYPE_QNAME = "0x1::secp256k1::ECDSASignature";
        function type(): TypeDescriptor<ECDSASignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace secp256r1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256r1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace timestamp {
    interface CurrentTimeMicroseconds {
        microseconds: bigint;
    }
    namespace CurrentTimeMicroseconds {
        const TYPE_QNAME = "0x1::timestamp::CurrentTimeMicroseconds";
        function type(): TypeDescriptor<CurrentTimeMicroseconds>;
    }
    namespace entry { }
    namespace view {
        function nowMicroseconds(client: Aptos, version?: bigint): Promise<[bigint]>;
        function nowSeconds(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace type_info {
    interface TypeInfo {
        account_address: MoveAddressType;
        module_name: string;
        struct_name: string;
    }
    namespace TypeInfo {
        const TYPE_QNAME = "0x1::type_info::TypeInfo";
        function type(): TypeDescriptor<TypeInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator {
    interface Aggregator {
        handle: MoveAddressType;
        key: MoveAddressType;
        limit: bigint;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator::Aggregator";
        function type(): TypeDescriptor<Aggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare class aptos_coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_coin;
    onEntryMint(func: (call: aptos_coin.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_coin.MintPayload>): aptos_coin;
    onEntryClaimMintCapability(func: (call: aptos_coin.ClaimMintCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_coin.ClaimMintCapabilityPayload>): aptos_coin;
    onEntryDelegateMintCapability(func: (call: aptos_coin.DelegateMintCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_coin.DelegateMintCapabilityPayload>): aptos_coin;
}
export declare namespace aptos_coin {
    interface AptosCoin {
        dummy_field: boolean;
    }
    namespace AptosCoin {
        const TYPE_QNAME = "0x1::aptos_coin::AptosCoin";
        function type(): TypeDescriptor<AptosCoin>;
    }
    interface DelegatedMintCapability {
        to: MoveAddressType;
    }
    namespace DelegatedMintCapability {
        const TYPE_QNAME = "0x1::aptos_coin::DelegatedMintCapability";
        function type(): TypeDescriptor<DelegatedMintCapability>;
    }
    interface Delegations {
        inner: aptos_coin.DelegatedMintCapability[];
    }
    namespace Delegations {
        const TYPE_QNAME = "0x1::aptos_coin::Delegations";
        function type(): TypeDescriptor<Delegations>;
    }
    interface MintCapStore {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace MintCapStore {
        const TYPE_QNAME = "0x1::aptos_coin::MintCapStore";
        function type(): TypeDescriptor<MintCapStore>;
    }
    namespace entry {
        function mint(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function claimMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface MintPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface ClaimMintCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface DelegateMintCapabilityPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
}
export declare namespace aptos_hash {
    namespace entry { }
    namespace view { }
}
export declare class bcs_stream extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): bcs_stream;
    onEntryDeserializeU256Entry(func: (call: bcs_stream.DeserializeU256EntryPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, bcs_stream.DeserializeU256EntryPayload>): bcs_stream;
}
export declare namespace bcs_stream {
    interface BCSStream {
        data: string;
        cur: bigint;
    }
    namespace BCSStream {
        const TYPE_QNAME = "0x1::bcs_stream::BCSStream";
        function type(): TypeDescriptor<BCSStream>;
    }
    namespace entry {
        function deserializeU256Entry(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface DeserializeU256EntryPayload extends TypedFunctionPayload<[string, bigint]> {
        arguments_decoded: [string, bigint];
        type_arguments: [];
    }
}
export declare namespace big_vector {
    interface BigVector<T0> {
        buckets: table_with_length.TableWithLength<bigint, T0[]>;
        end_index: bigint;
        bucket_size: bigint;
    }
    namespace BigVector {
        const TYPE_QNAME = "0x1::big_vector::BigVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BigVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace capability {
    interface Cap<T0> {
        root: MoveAddressType;
    }
    namespace Cap {
        const TYPE_QNAME = "0x1::capability::Cap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Cap<T0>>;
    }
    interface CapDelegateState<T0> {
        root: MoveAddressType;
    }
    namespace CapDelegateState {
        const TYPE_QNAME = "0x1::capability::CapDelegateState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapDelegateState<T0>>;
    }
    interface CapState<T0> {
        delegates: MoveAddressType[];
    }
    namespace CapState {
        const TYPE_QNAME = "0x1::capability::CapState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapState<T0>>;
    }
    interface LinearCap<T0> {
        root: MoveAddressType;
    }
    namespace LinearCap {
        const TYPE_QNAME = "0x1::capability::LinearCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<LinearCap<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace comparator {
    interface Result {
        inner: number;
    }
    namespace Result {
        const TYPE_QNAME = "0x1::comparator::Result";
        function type(): TypeDescriptor<Result>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math_fixed {
    namespace entry { }
    namespace view { }
}
export declare class randomness extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): randomness;
    onEventRandomnessGeneratedEvent(func: (event: randomness.RandomnessGeneratedEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, randomness.RandomnessGeneratedEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): randomness;
}
export declare namespace randomness {
    interface PerBlockRandomness {
        epoch: bigint;
        round: bigint;
        seed: option.Option<string>;
    }
    namespace PerBlockRandomness {
        const TYPE_QNAME = "0x1::randomness::PerBlockRandomness";
        function type(): TypeDescriptor<PerBlockRandomness>;
    }
    interface RandomnessGeneratedEvent {
        dummy_field: boolean;
    }
    namespace RandomnessGeneratedEvent {
        const TYPE_QNAME = "0x1::randomness::RandomnessGeneratedEvent";
        function type(): TypeDescriptor<RandomnessGeneratedEvent>;
    }
    type RandomnessGeneratedEventInstance = TypedEventInstance<RandomnessGeneratedEvent> & {
        data_decoded: RandomnessGeneratedEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace simple_map {
    interface Element<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::simple_map::Element";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Element<T0, T1>>;
    }
    interface SimpleMap<T0, T1> {
        data: simple_map.Element<T0, T1>[];
    }
    namespace SimpleMap {
        const TYPE_QNAME = "0x1::simple_map::SimpleMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SimpleMap<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace single_key {
    interface AnyPublicKey {
    }
    namespace AnyPublicKey {
        const TYPE_QNAME = "0x1::single_key::AnyPublicKey";
        function type(): TypeDescriptor<AnyPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ordered_map {
    interface Entry<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::ordered_map::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface IteratorPtr {
    }
    namespace IteratorPtr {
        const TYPE_QNAME = "0x1::ordered_map::IteratorPtr";
        function type(): TypeDescriptor<IteratorPtr>;
    }
    interface OrderedMap<T0, T1> {
    }
    namespace OrderedMap {
        const TYPE_QNAME = "0x1::ordered_map::OrderedMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<OrderedMap<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_table {
    interface Entry<T0, T1> {
        hash: bigint;
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::smart_table::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface SmartTable<T0, T1> {
        buckets: table_with_length.TableWithLength<bigint, smart_table.Entry<T0, T1>[]>;
        num_buckets: bigint;
        level: number;
        size: bigint;
        split_load_threshold: number;
        target_bucket_size: bigint;
    }
    namespace SmartTable {
        const TYPE_QNAME = "0x1::smart_table::SmartTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SmartTable<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace storage_gas {
    interface GasCurve {
        min_gas: bigint;
        max_gas: bigint;
        points: storage_gas.Point[];
    }
    namespace GasCurve {
        const TYPE_QNAME = "0x1::storage_gas::GasCurve";
        function type(): TypeDescriptor<GasCurve>;
    }
    interface Point {
        x: bigint;
        y: bigint;
    }
    namespace Point {
        const TYPE_QNAME = "0x1::storage_gas::Point";
        function type(): TypeDescriptor<Point>;
    }
    interface StorageGas {
        per_item_read: bigint;
        per_item_create: bigint;
        per_item_write: bigint;
        per_byte_read: bigint;
        per_byte_create: bigint;
        per_byte_write: bigint;
    }
    namespace StorageGas {
        const TYPE_QNAME = "0x1::storage_gas::StorageGas";
        function type(): TypeDescriptor<StorageGas>;
    }
    interface StorageGasConfig {
        item_config: storage_gas.UsageGasConfig;
        byte_config: storage_gas.UsageGasConfig;
    }
    namespace StorageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::StorageGasConfig";
        function type(): TypeDescriptor<StorageGasConfig>;
    }
    interface UsageGasConfig {
        target_usage: bigint;
        read_curve: storage_gas.GasCurve;
        create_curve: storage_gas.GasCurve;
        write_curve: storage_gas.GasCurve;
    }
    namespace UsageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::UsageGasConfig";
        function type(): TypeDescriptor<UsageGasConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_status {
    interface GenesisEndMarker {
        dummy_field: boolean;
    }
    namespace GenesisEndMarker {
        const TYPE_QNAME = "0x1::chain_status::GenesisEndMarker";
        function type(): TypeDescriptor<GenesisEndMarker>;
    }
    namespace entry { }
    namespace view {
        function isGenesis(client: Aptos, version?: bigint): Promise<[boolean]>;
        function isOperating(client: Aptos, version?: bigint): Promise<[boolean]>;
    }
}
export declare namespace copyable_any {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::copyable_any::Any";
        function type(): TypeDescriptor<Any>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace gas_schedule {
    interface GasEntry {
        key: string;
        val: bigint;
    }
    namespace GasEntry {
        const TYPE_QNAME = "0x1::gas_schedule::GasEntry";
        function type(): TypeDescriptor<GasEntry>;
    }
    interface GasSchedule {
        entries: gas_schedule.GasEntry[];
    }
    namespace GasSchedule {
        const TYPE_QNAME = "0x1::gas_schedule::GasSchedule";
        function type(): TypeDescriptor<GasSchedule>;
    }
    interface GasScheduleV2 {
        feature_version: bigint;
        entries: gas_schedule.GasEntry[];
    }
    namespace GasScheduleV2 {
        const TYPE_QNAME = "0x1::gas_schedule::GasScheduleV2";
        function type(): TypeDescriptor<GasScheduleV2>;
    }
    namespace entry { }
    namespace view { }
}
export declare class managed_coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): managed_coin;
    onEntryInitialize(func: (call: managed_coin.InitializePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, managed_coin.InitializePayload>): managed_coin;
    onEntryBurn(func: (call: managed_coin.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, managed_coin.BurnPayload>): managed_coin;
    onEntryMint(func: (call: managed_coin.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, managed_coin.MintPayload>): managed_coin;
    onEntryRegister(func: (call: managed_coin.RegisterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, managed_coin.RegisterPayload>): managed_coin;
    onEntryDestroyCaps(func: (call: managed_coin.DestroyCapsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, managed_coin.DestroyCapsPayload>): managed_coin;
}
export declare namespace managed_coin {
    interface Capabilities<T0> {
        burn_cap: coin.BurnCapability<T0>;
        freeze_cap: coin.FreezeCapability<T0>;
        mint_cap: coin.MintCapability<T0>;
    }
    namespace Capabilities {
        const TYPE_QNAME = "0x1::managed_coin::Capabilities";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Capabilities<T0>>;
    }
    namespace entry {
        function initialize<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [string, string, number, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function register<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function destroyCaps<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface InitializePayload<T0 = any> extends TypedFunctionPayload<[string, string, number, boolean]> {
        arguments_decoded: [string, string, number, boolean];
        type_arguments: [string];
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [string];
    }
    interface MintPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface RegisterPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
    interface DestroyCapsPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
}
export declare namespace math_fixed64 {
    namespace entry { }
    namespace view { }
}
export declare namespace rate_limiter {
    interface RateLimiter {
    }
    namespace RateLimiter {
        const TYPE_QNAME = "0x1::rate_limiter::RateLimiter";
        function type(): TypeDescriptor<RateLimiter>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255 {
    interface CompressedRistretto {
        data: string;
    }
    namespace CompressedRistretto {
        const TYPE_QNAME = "0x1::ristretto255::CompressedRistretto";
        function type(): TypeDescriptor<CompressedRistretto>;
    }
    interface RistrettoPoint {
        handle: bigint;
    }
    namespace RistrettoPoint {
        const TYPE_QNAME = "0x1::ristretto255::RistrettoPoint";
        function type(): TypeDescriptor<RistrettoPoint>;
    }
    interface Scalar {
        data: string;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x1::ristretto255::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_vector {
    interface SmartVector<T0> {
        inline_vec: T0[];
        big_vec: option.Option<big_vector.BigVector<T0>>;
        inline_capacity: option.Option<bigint>;
        bucket_size: option.Option<bigint>;
    }
    namespace SmartVector {
        const TYPE_QNAME = "0x1::smart_vector::SmartVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SmartVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace string_utils {
    interface Cons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace Cons {
        const TYPE_QNAME = "0x1::string_utils::Cons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Cons<T0, T1>>;
    }
    interface FakeCons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace FakeCons {
        const TYPE_QNAME = "0x1::string_utils::FakeCons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<FakeCons<T0, T1>>;
    }
    interface NIL {
        dummy_field: boolean;
    }
    namespace NIL {
        const TYPE_QNAME = "0x1::string_utils::NIL";
        function type(): TypeDescriptor<NIL>;
    }
    namespace entry { }
    namespace view { }
}
export declare class aggregator_v2 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aggregator_v2;
    onEventAggregator(func: (event: aggregator_v2.AggregatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aggregator_v2.AggregatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aggregator_v2;
    onEventAggregatorSnapshot(func: (event: aggregator_v2.AggregatorSnapshotInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aggregator_v2.AggregatorSnapshotInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aggregator_v2;
    onEventDerivedStringSnapshot(func: (event: aggregator_v2.DerivedStringSnapshotInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aggregator_v2.DerivedStringSnapshotInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aggregator_v2;
}
export declare namespace aggregator_v2 {
    interface Aggregator<T0> {
        value: T0;
        max_value: T0;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator_v2::Aggregator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Aggregator<T0>>;
    }
    type AggregatorInstance = TypedEventInstance<Aggregator<any>> & {
        data_decoded: Aggregator<any>;
        type_arguments: [string];
    };
    interface AggregatorSnapshot<T0> {
        value: T0;
    }
    namespace AggregatorSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::AggregatorSnapshot";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatorSnapshot<T0>>;
    }
    type AggregatorSnapshotInstance = TypedEventInstance<AggregatorSnapshot<any>> & {
        data_decoded: AggregatorSnapshot<any>;
        type_arguments: [string];
    };
    interface DerivedStringSnapshot {
        value: string;
        padding: string;
    }
    namespace DerivedStringSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::DerivedStringSnapshot";
        function type(): TypeDescriptor<DerivedStringSnapshot>;
    }
    type DerivedStringSnapshotInstance = TypedEventInstance<DerivedStringSnapshot> & {
        data_decoded: DerivedStringSnapshot;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare class aptos_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_account;
    onEntryCreateAccount(func: (call: aptos_account.CreateAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.CreateAccountPayload>): aptos_account;
    onEntryTransfer(func: (call: aptos_account.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.TransferPayload>): aptos_account;
    onEntryBatchTransfer(func: (call: aptos_account.BatchTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.BatchTransferPayload>): aptos_account;
    onEntryBatchTransferCoins(func: (call: aptos_account.BatchTransferCoinsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.BatchTransferCoinsPayload>): aptos_account;
    onEntryBatchTransferFungibleAssets(func: (call: aptos_account.BatchTransferFungibleAssetsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.BatchTransferFungibleAssetsPayload>): aptos_account;
    onEntryFungibleTransferOnly(func: (call: aptos_account.FungibleTransferOnlyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.FungibleTransferOnlyPayload>): aptos_account;
    onEntrySetAllowDirectCoinTransfers(func: (call: aptos_account.SetAllowDirectCoinTransfersPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.SetAllowDirectCoinTransfersPayload>): aptos_account;
    onEntryTransferCoins(func: (call: aptos_account.TransferCoinsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.TransferCoinsPayload>): aptos_account;
    onEntryTransferFungibleAssets(func: (call: aptos_account.TransferFungibleAssetsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.TransferFungibleAssetsPayload>): aptos_account;
    onEventDirectCoinTransferConfigUpdated(func: (event: aptos_account.DirectCoinTransferConfigUpdatedInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.DirectCoinTransferConfigUpdatedInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_account;
    onEventDirectCoinTransferConfigUpdatedEvent(func: (event: aptos_account.DirectCoinTransferConfigUpdatedEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_account.DirectCoinTransferConfigUpdatedEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_account;
}
export declare namespace aptos_account {
    interface DirectCoinTransferConfigUpdated {
        account: MoveAddressType;
        new_allow_direct_transfers: boolean;
    }
    namespace DirectCoinTransferConfigUpdated {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdated";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdated>;
    }
    type DirectCoinTransferConfigUpdatedInstance = TypedEventInstance<DirectCoinTransferConfigUpdated> & {
        data_decoded: DirectCoinTransferConfigUpdated;
        type_arguments: [];
    };
    interface DirectCoinTransferConfigUpdatedEvent {
        new_allow_direct_transfers: boolean;
    }
    namespace DirectCoinTransferConfigUpdatedEvent {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdatedEvent";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdatedEvent>;
    }
    type DirectCoinTransferConfigUpdatedEventInstance = TypedEventInstance<DirectCoinTransferConfigUpdatedEvent> & {
        data_decoded: DirectCoinTransferConfigUpdatedEvent;
        type_arguments: [];
    };
    interface DirectTransferConfig {
        allow_arbitrary_coin_transfers: boolean;
        update_coin_transfer_events: event.EventHandle<aptos_account.DirectCoinTransferConfigUpdatedEvent>;
    }
    namespace DirectTransferConfig {
        const TYPE_QNAME = "0x1::aptos_account::DirectTransferConfig";
        function type(): TypeDescriptor<DirectTransferConfig>;
    }
    namespace entry {
        function createAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransferFungibleAssets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                object$.Object<fungible_asset.Metadata>,
                MoveAddressType[],
                bigint[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function fungibleTransferOnly(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setAllowDirectCoinTransfers(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferFungibleAssets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                object$.Object<fungible_asset.Metadata>,
                MoveAddressType,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function canReceiveDirectCoinTransfers(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface CreateAccountPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface TransferPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface BatchTransferPayload extends TypedFunctionPayload<[MoveAddressType[], bigint[]]> {
        arguments_decoded: [MoveAddressType[], bigint[]];
        type_arguments: [];
    }
    interface BatchTransferCoinsPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType[], bigint[]]> {
        arguments_decoded: [MoveAddressType[], bigint[]];
        type_arguments: [string];
    }
    interface BatchTransferFungibleAssetsPayload extends TypedFunctionPayload<[
        object$.Object<fungible_asset.Metadata>,
        MoveAddressType[],
        bigint[]
    ]> {
        arguments_decoded: [
            object$.Object<fungible_asset.Metadata>,
            MoveAddressType[],
            bigint[]
        ];
        type_arguments: [];
    }
    interface FungibleTransferOnlyPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface SetAllowDirectCoinTransfersPayload extends TypedFunctionPayload<[boolean]> {
        arguments_decoded: [boolean];
        type_arguments: [];
    }
    interface TransferCoinsPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface TransferFungibleAssetsPayload extends TypedFunctionPayload<[
        object$.Object<fungible_asset.Metadata>,
        MoveAddressType,
        bigint
    ]> {
        arguments_decoded: [
            object$.Object<fungible_asset.Metadata>,
            MoveAddressType,
            bigint
        ];
        type_arguments: [];
    }
}
export declare namespace bn254_algebra {
    interface FormatFq12LscLsb {
        dummy_field: boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bn254_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bn254_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bn254_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bn254_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface FormatFqLsb {
        dummy_field: boolean;
    }
    namespace FormatFqLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqLsb";
        function type(): TypeDescriptor<FormatFqLsb>;
    }
    interface FormatFqMsb {
        dummy_field: boolean;
    }
    namespace FormatFqMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqMsb";
        function type(): TypeDescriptor<FormatFqMsb>;
    }
    interface Fq {
        dummy_field: boolean;
    }
    namespace Fq {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq";
        function type(): TypeDescriptor<Fq>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace config_buffer {
    interface PendingConfigs {
        configs: simple_map.SimpleMap<string, any$.Any>;
    }
    namespace PendingConfigs {
        const TYPE_QNAME = "0x1::config_buffer::PendingConfigs";
        function type(): TypeDescriptor<PendingConfigs>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace create_signer {
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point64 {
    interface FixedPoint64 {
        value: bigint;
    }
    namespace FixedPoint64 {
        const TYPE_QNAME = "0x1::fixed_point64::FixedPoint64";
        function type(): TypeDescriptor<FixedPoint64>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace function_info {
    interface FunctionInfo {
        module_address: MoveAddressType;
        module_name: string;
        function_name: string;
    }
    namespace FunctionInfo {
        const TYPE_QNAME = "0x1::function_info::FunctionInfo";
        function type(): TypeDescriptor<FunctionInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multi_ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::multi_ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare class staking_proxy extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): staking_proxy;
    onEntrySetOperator(func: (call: staking_proxy.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetOperatorPayload>): staking_proxy;
    onEntrySetStakePoolOperator(func: (call: staking_proxy.SetStakePoolOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetStakePoolOperatorPayload>): staking_proxy;
    onEntrySetStakePoolVoter(func: (call: staking_proxy.SetStakePoolVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetStakePoolVoterPayload>): staking_proxy;
    onEntrySetStakingContractOperator(func: (call: staking_proxy.SetStakingContractOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetStakingContractOperatorPayload>): staking_proxy;
    onEntrySetStakingContractVoter(func: (call: staking_proxy.SetStakingContractVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetStakingContractVoterPayload>): staking_proxy;
    onEntrySetVestingContractOperator(func: (call: staking_proxy.SetVestingContractOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetVestingContractOperatorPayload>): staking_proxy;
    onEntrySetVestingContractVoter(func: (call: staking_proxy.SetVestingContractVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetVestingContractVoterPayload>): staking_proxy;
    onEntrySetVoter(func: (call: staking_proxy.SetVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_proxy.SetVoterPayload>): staking_proxy;
}
export declare namespace staking_proxy {
    interface StakeProxyPermission {
        dummy_field: boolean;
    }
    namespace StakeProxyPermission {
        const TYPE_QNAME = "0x1::staking_proxy::StakeProxyPermission";
        function type(): TypeDescriptor<StakeProxyPermission>;
    }
    namespace entry {
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetStakePoolOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetStakePoolVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetStakingContractOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetStakingContractVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVestingContractOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVestingContractVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
}
export declare namespace state_storage {
    interface GasParameter {
        usage: state_storage.Usage;
    }
    namespace GasParameter {
        const TYPE_QNAME = "0x1::state_storage::GasParameter";
        function type(): TypeDescriptor<GasParameter>;
    }
    interface StateStorageUsage {
        epoch: bigint;
        usage: state_storage.Usage;
    }
    namespace StateStorageUsage {
        const TYPE_QNAME = "0x1::state_storage::StateStorageUsage";
        function type(): TypeDescriptor<StateStorageUsage>;
    }
    interface Usage {
        items: bigint;
        bytes: bigint;
    }
    namespace Usage {
        const TYPE_QNAME = "0x1::state_storage::Usage";
        function type(): TypeDescriptor<Usage>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace crypto_algebra {
    interface Element<T0> {
        handle: bigint;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::crypto_algebra::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare class fungible_asset extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): fungible_asset;
    onEntryTransfer(func: (call: fungible_asset.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.TransferPayload>): fungible_asset;
    onEntryUpgradeStoreToConcurrent(func: (call: fungible_asset.UpgradeStoreToConcurrentPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.UpgradeStoreToConcurrentPayload>): fungible_asset;
    onEventTransferRef(func: (event: fungible_asset.TransferRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.TransferRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventBurnRef(func: (event: fungible_asset.BurnRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.BurnRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventDeposit(func: (event: fungible_asset.DepositInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.DepositInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventDepositEvent(func: (event: fungible_asset.DepositEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.DepositEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventFrozen(func: (event: fungible_asset.FrozenInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.FrozenInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventFrozenEvent(func: (event: fungible_asset.FrozenEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.FrozenEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventFungibleStoreDeletion(func: (event: fungible_asset.FungibleStoreDeletionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.FungibleStoreDeletionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventMintRef(func: (event: fungible_asset.MintRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.MintRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventMutateMetadataRef(func: (event: fungible_asset.MutateMetadataRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.MutateMetadataRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventRawBalanceRef(func: (event: fungible_asset.RawBalanceRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.RawBalanceRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventRawSupplyRef(func: (event: fungible_asset.RawSupplyRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.RawSupplyRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventWithdraw(func: (event: fungible_asset.WithdrawInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.WithdrawInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
    onEventWithdrawEvent(func: (event: fungible_asset.WithdrawEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, fungible_asset.WithdrawEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): fungible_asset;
}
export declare namespace fungible_asset {
    interface TransferRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::fungible_asset::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    type TransferRefInstance = TypedEventInstance<TransferRef> & {
        data_decoded: TransferRef;
        type_arguments: [];
    };
    interface Untransferable {
        dummy_field: boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::fungible_asset::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    interface BurnRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x1::fungible_asset::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    type BurnRefInstance = TypedEventInstance<BurnRef> & {
        data_decoded: BurnRef;
        type_arguments: [];
    };
    interface ConcurrentFungibleBalance {
        balance: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentFungibleBalance {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentFungibleBalance";
        function type(): TypeDescriptor<ConcurrentFungibleBalance>;
    }
    interface ConcurrentSupply {
        current: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface Deposit {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::fungible_asset::Deposit";
        function type(): TypeDescriptor<Deposit>;
    }
    type DepositInstance = TypedEventInstance<Deposit> & {
        data_decoded: Deposit;
        type_arguments: [];
    };
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::fungible_asset::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    type DepositEventInstance = TypedEventInstance<DepositEvent> & {
        data_decoded: DepositEvent;
        type_arguments: [];
    };
    interface DeriveSupply {
        dispatch_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DeriveSupply {
        const TYPE_QNAME = "0x1::fungible_asset::DeriveSupply";
        function type(): TypeDescriptor<DeriveSupply>;
    }
    interface DispatchFunctionStore {
        withdraw_function: option.Option<function_info.FunctionInfo>;
        deposit_function: option.Option<function_info.FunctionInfo>;
        derived_balance_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DispatchFunctionStore {
        const TYPE_QNAME = "0x1::fungible_asset::DispatchFunctionStore";
        function type(): TypeDescriptor<DispatchFunctionStore>;
    }
    interface Frozen {
        store: MoveAddressType;
        frozen: boolean;
    }
    namespace Frozen {
        const TYPE_QNAME = "0x1::fungible_asset::Frozen";
        function type(): TypeDescriptor<Frozen>;
    }
    type FrozenInstance = TypedEventInstance<Frozen> & {
        data_decoded: Frozen;
        type_arguments: [];
    };
    interface FrozenEvent {
        frozen: boolean;
    }
    namespace FrozenEvent {
        const TYPE_QNAME = "0x1::fungible_asset::FrozenEvent";
        function type(): TypeDescriptor<FrozenEvent>;
    }
    type FrozenEventInstance = TypedEventInstance<FrozenEvent> & {
        data_decoded: FrozenEvent;
        type_arguments: [];
    };
    interface FungibleAsset {
        metadata: object$.Object<fungible_asset.Metadata>;
        amount: bigint;
    }
    namespace FungibleAsset {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAsset";
        function type(): TypeDescriptor<FungibleAsset>;
    }
    interface FungibleAssetEvents {
        deposit_events: event.EventHandle<fungible_asset.DepositEvent>;
        withdraw_events: event.EventHandle<fungible_asset.WithdrawEvent>;
        frozen_events: event.EventHandle<fungible_asset.FrozenEvent>;
    }
    namespace FungibleAssetEvents {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAssetEvents";
        function type(): TypeDescriptor<FungibleAssetEvents>;
    }
    interface FungibleStore {
        metadata: object$.Object<fungible_asset.Metadata>;
        balance: bigint;
        frozen: boolean;
    }
    namespace FungibleStore {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStore";
        function type(): TypeDescriptor<FungibleStore>;
    }
    interface FungibleStoreDeletion {
        store: MoveAddressType;
        owner: MoveAddressType;
        metadata: MoveAddressType;
    }
    namespace FungibleStoreDeletion {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStoreDeletion";
        function type(): TypeDescriptor<FungibleStoreDeletion>;
    }
    type FungibleStoreDeletionInstance = TypedEventInstance<FungibleStoreDeletion> & {
        data_decoded: FungibleStoreDeletion;
        type_arguments: [];
    };
    interface Metadata {
        name: string;
        symbol: string;
        decimals: number;
        icon_uri: string;
        project_uri: string;
    }
    namespace Metadata {
        const TYPE_QNAME = "0x1::fungible_asset::Metadata";
        function type(): TypeDescriptor<Metadata>;
    }
    interface MintRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MintRef {
        const TYPE_QNAME = "0x1::fungible_asset::MintRef";
        function type(): TypeDescriptor<MintRef>;
    }
    type MintRefInstance = TypedEventInstance<MintRef> & {
        data_decoded: MintRef;
        type_arguments: [];
    };
    interface MutateMetadataRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace MutateMetadataRef {
        const TYPE_QNAME = "0x1::fungible_asset::MutateMetadataRef";
        function type(): TypeDescriptor<MutateMetadataRef>;
    }
    type MutateMetadataRefInstance = TypedEventInstance<MutateMetadataRef> & {
        data_decoded: MutateMetadataRef;
        type_arguments: [];
    };
    interface RawBalanceRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace RawBalanceRef {
        const TYPE_QNAME = "0x1::fungible_asset::RawBalanceRef";
        function type(): TypeDescriptor<RawBalanceRef>;
    }
    type RawBalanceRefInstance = TypedEventInstance<RawBalanceRef> & {
        data_decoded: RawBalanceRef;
        type_arguments: [];
    };
    interface RawSupplyRef {
        metadata: object$.Object<fungible_asset.Metadata>;
    }
    namespace RawSupplyRef {
        const TYPE_QNAME = "0x1::fungible_asset::RawSupplyRef";
        function type(): TypeDescriptor<RawSupplyRef>;
    }
    type RawSupplyRefInstance = TypedEventInstance<RawSupplyRef> & {
        data_decoded: RawSupplyRef;
        type_arguments: [];
    };
    interface Supply {
        current: bigint;
        maximum: option.Option<bigint>;
    }
    namespace Supply {
        const TYPE_QNAME = "0x1::fungible_asset::Supply";
        function type(): TypeDescriptor<Supply>;
    }
    interface Withdraw {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::fungible_asset::Withdraw";
        function type(): TypeDescriptor<Withdraw>;
    }
    type WithdrawInstance = TypedEventInstance<Withdraw> & {
        data_decoded: Withdraw;
        type_arguments: [];
    };
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    type WithdrawEventInstance = TypedEventInstance<WithdrawEvent> & {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    };
    interface WithdrawPermission {
    }
    namespace WithdrawPermission {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawPermission";
        function type(): TypeDescriptor<WithdrawPermission>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeStoreToConcurrent<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function symbol$<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[number]>;
        function iconUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function projectUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function metadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[fungible_asset.Metadata]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isStoreDispatchable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function maximum<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function storeExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function storeMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[object$.Object<fungible_asset.Metadata>]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object$.Object<T0>,
        object$.Object<T0>,
        bigint
    ]> {
        arguments_decoded: [object$.Object<T0>, object$.Object<T0>, bigint];
        type_arguments: [string];
    }
    interface UpgradeStoreToConcurrentPayload<T0 = any> extends TypedFunctionPayload<[object$.Object<T0>]> {
        arguments_decoded: [object$.Object<T0>];
        type_arguments: [string];
    }
}
export declare namespace staking_config {
    interface StakingConfig {
        minimum_stake: bigint;
        maximum_stake: bigint;
        recurring_lockup_duration_secs: bigint;
        allow_validator_set_change: boolean;
        rewards_rate: bigint;
        rewards_rate_denominator: bigint;
        voting_power_increase_limit: bigint;
    }
    namespace StakingConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingConfig";
        function type(): TypeDescriptor<StakingConfig>;
    }
    interface StakingRewardsConfig {
        rewards_rate: fixed_point64.FixedPoint64;
        min_rewards_rate: fixed_point64.FixedPoint64;
        rewards_rate_period_in_secs: bigint;
        last_rewards_rate_period_start_in_secs: bigint;
        rewards_rate_decrease_rate: fixed_point64.FixedPoint64;
    }
    namespace StakingRewardsConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingRewardsConfig";
        function type(): TypeDescriptor<StakingRewardsConfig>;
    }
    namespace entry { }
    namespace view {
        function rewardRate(client: Aptos, version?: bigint): Promise<[bigint, bigint]>;
    }
}
export declare namespace big_ordered_map {
    interface IteratorPtr<T0> {
    }
    namespace IteratorPtr {
        const TYPE_QNAME = "0x1::big_ordered_map::IteratorPtr";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<IteratorPtr<T0>>;
    }
    interface BigOrderedMap<T0, T1> {
    }
    namespace BigOrderedMap {
        const TYPE_QNAME = "0x1::big_ordered_map::BigOrderedMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<BigOrderedMap<T0, T1>>;
    }
    interface Child<T0> {
    }
    namespace Child {
        const TYPE_QNAME = "0x1::big_ordered_map::Child";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Child<T0>>;
    }
    interface Node<T0, T1> {
    }
    namespace Node {
        const TYPE_QNAME = "0x1::big_ordered_map::Node";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Node<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare class delegation_pool extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): delegation_pool;
    onEntryWithdraw(func: (call: delegation_pool.WithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.WithdrawPayload>): delegation_pool;
    onEntryCreateProposal(func: (call: delegation_pool.CreateProposalPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.CreateProposalPayload>): delegation_pool;
    onEntryVote(func: (call: delegation_pool.VotePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.VotePayload>): delegation_pool;
    onEntryAddStake(func: (call: delegation_pool.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.AddStakePayload>): delegation_pool;
    onEntryReactivateStake(func: (call: delegation_pool.ReactivateStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.ReactivateStakePayload>): delegation_pool;
    onEntrySetDelegatedVoter(func: (call: delegation_pool.SetDelegatedVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.SetDelegatedVoterPayload>): delegation_pool;
    onEntrySetOperator(func: (call: delegation_pool.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.SetOperatorPayload>): delegation_pool;
    onEntryUnlock(func: (call: delegation_pool.UnlockPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.UnlockPayload>): delegation_pool;
    onEntryAllowlistDelegator(func: (call: delegation_pool.AllowlistDelegatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.AllowlistDelegatorPayload>): delegation_pool;
    onEntryDelegateVotingPower(func: (call: delegation_pool.DelegateVotingPowerPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DelegateVotingPowerPayload>): delegation_pool;
    onEntryDisableDelegatorsAllowlisting(func: (call: delegation_pool.DisableDelegatorsAllowlistingPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DisableDelegatorsAllowlistingPayload>): delegation_pool;
    onEntryEnableDelegatorsAllowlisting(func: (call: delegation_pool.EnableDelegatorsAllowlistingPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.EnableDelegatorsAllowlistingPayload>): delegation_pool;
    onEntryEnablePartialGovernanceVoting(func: (call: delegation_pool.EnablePartialGovernanceVotingPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.EnablePartialGovernanceVotingPayload>): delegation_pool;
    onEntryEvictDelegator(func: (call: delegation_pool.EvictDelegatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.EvictDelegatorPayload>): delegation_pool;
    onEntryInitializeDelegationPool(func: (call: delegation_pool.InitializeDelegationPoolPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.InitializeDelegationPoolPayload>): delegation_pool;
    onEntryRemoveDelegatorFromAllowlist(func: (call: delegation_pool.RemoveDelegatorFromAllowlistPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.RemoveDelegatorFromAllowlistPayload>): delegation_pool;
    onEntrySetBeneficiaryForOperator(func: (call: delegation_pool.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.SetBeneficiaryForOperatorPayload>): delegation_pool;
    onEntrySynchronizeDelegationPool(func: (call: delegation_pool.SynchronizeDelegationPoolPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.SynchronizeDelegationPoolPayload>): delegation_pool;
    onEntryUpdateCommissionPercentage(func: (call: delegation_pool.UpdateCommissionPercentagePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.UpdateCommissionPercentagePayload>): delegation_pool;
    onEventCreateProposal(func: (event: delegation_pool.CreateProposalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.CreateProposalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventCreateProposalEvent(func: (event: delegation_pool.CreateProposalEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.CreateProposalEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventVote(func: (event: delegation_pool.VoteInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.VoteInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventVoteEvent(func: (event: delegation_pool.VoteEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.VoteEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventAddStake(func: (event: delegation_pool.AddStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.AddStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventAddStakeEvent(func: (event: delegation_pool.AddStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.AddStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventReactivateStake(func: (event: delegation_pool.ReactivateStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.ReactivateStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventReactivateStakeEvent(func: (event: delegation_pool.ReactivateStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.ReactivateStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventUnlockStake(func: (event: delegation_pool.UnlockStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.UnlockStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventUnlockStakeEvent(func: (event: delegation_pool.UnlockStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.UnlockStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventWithdrawStake(func: (event: delegation_pool.WithdrawStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.WithdrawStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventWithdrawStakeEvent(func: (event: delegation_pool.WithdrawStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.WithdrawStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventAllowlistDelegator(func: (event: delegation_pool.AllowlistDelegatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.AllowlistDelegatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventCommissionPercentageChange(func: (event: delegation_pool.CommissionPercentageChangeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.CommissionPercentageChangeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventDelegateVotingPower(func: (event: delegation_pool.DelegateVotingPowerInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DelegateVotingPowerInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventDelegateVotingPowerEvent(func: (event: delegation_pool.DelegateVotingPowerEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DelegateVotingPowerEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventDisableDelegatorsAllowlisting(func: (event: delegation_pool.DisableDelegatorsAllowlistingInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DisableDelegatorsAllowlistingInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventDistributeCommission(func: (event: delegation_pool.DistributeCommissionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DistributeCommissionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventDistributeCommissionEvent(func: (event: delegation_pool.DistributeCommissionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.DistributeCommissionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventEnableDelegatorsAllowlisting(func: (event: delegation_pool.EnableDelegatorsAllowlistingInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.EnableDelegatorsAllowlistingInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventEvictDelegator(func: (event: delegation_pool.EvictDelegatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.EvictDelegatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventRemoveDelegatorFromAllowlist(func: (event: delegation_pool.RemoveDelegatorFromAllowlistInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.RemoveDelegatorFromAllowlistInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
    onEventSetBeneficiaryForOperator(func: (event: delegation_pool.SetBeneficiaryForOperatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, delegation_pool.SetBeneficiaryForOperatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): delegation_pool;
}
export declare namespace delegation_pool {
    interface CreateProposal {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Vote {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::delegation_pool::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::delegation_pool::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface AddStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::delegation_pool::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface ReactivateStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    type ReactivateStakeInstance = TypedEventInstance<ReactivateStake> & {
        data_decoded: ReactivateStake;
        type_arguments: [];
    };
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    type ReactivateStakeEventInstance = TypedEventInstance<ReactivateStakeEvent> & {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    };
    interface UnlockStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface WithdrawStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    type WithdrawStakeInstance = TypedEventInstance<WithdrawStake> & {
        data_decoded: WithdrawStake;
        type_arguments: [];
    };
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    type WithdrawStakeEventInstance = TypedEventInstance<WithdrawStakeEvent> & {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    };
    interface AllowlistDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace AllowlistDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::AllowlistDelegator";
        function type(): TypeDescriptor<AllowlistDelegator>;
    }
    type AllowlistDelegatorInstance = TypedEventInstance<AllowlistDelegator> & {
        data_decoded: AllowlistDelegator;
        type_arguments: [];
    };
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CommissionPercentageChange {
        pool_address: MoveAddressType;
        owner: MoveAddressType;
        commission_percentage_next_lockup_cycle: bigint;
    }
    namespace CommissionPercentageChange {
        const TYPE_QNAME = "0x1::delegation_pool::CommissionPercentageChange";
        function type(): TypeDescriptor<CommissionPercentageChange>;
    }
    type CommissionPercentageChangeInstance = TypedEventInstance<CommissionPercentageChange> & {
        data_decoded: CommissionPercentageChange;
        type_arguments: [];
    };
    interface DelegateVotingPower {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPower {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPower";
        function type(): TypeDescriptor<DelegateVotingPower>;
    }
    type DelegateVotingPowerInstance = TypedEventInstance<DelegateVotingPower> & {
        data_decoded: DelegateVotingPower;
        type_arguments: [];
    };
    interface DelegateVotingPowerEvent {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPowerEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPowerEvent";
        function type(): TypeDescriptor<DelegateVotingPowerEvent>;
    }
    type DelegateVotingPowerEventInstance = TypedEventInstance<DelegateVotingPowerEvent> & {
        data_decoded: DelegateVotingPowerEvent;
        type_arguments: [];
    };
    interface DelegatedVotes {
        active_shares: bigint;
        pending_inactive_shares: bigint;
        active_shares_next_lockup: bigint;
        last_locked_until_secs: bigint;
    }
    namespace DelegatedVotes {
        const TYPE_QNAME = "0x1::delegation_pool::DelegatedVotes";
        function type(): TypeDescriptor<DelegatedVotes>;
    }
    interface DelegationPermission {
    }
    namespace DelegationPermission {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPermission";
        function type(): TypeDescriptor<DelegationPermission>;
    }
    interface DelegationPool {
        active_shares: pool_u64_unbound.Pool;
        observed_lockup_cycle: delegation_pool.ObservedLockupCycle;
        inactive_shares: table.Table<delegation_pool.ObservedLockupCycle, pool_u64_unbound.Pool>;
        pending_withdrawals: table.Table<MoveAddressType, delegation_pool.ObservedLockupCycle>;
        stake_pool_signer_cap: account.SignerCapability;
        total_coins_inactive: bigint;
        operator_commission_percentage: bigint;
        add_stake_events: event.EventHandle<delegation_pool.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<delegation_pool.ReactivateStakeEvent>;
        unlock_stake_events: event.EventHandle<delegation_pool.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<delegation_pool.WithdrawStakeEvent>;
        distribute_commission_events: event.EventHandle<delegation_pool.DistributeCommissionEvent>;
    }
    namespace DelegationPool {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPool";
        function type(): TypeDescriptor<DelegationPool>;
    }
    interface DelegationPoolAllowlisting {
        allowlist: smart_table.SmartTable<MoveAddressType, boolean>;
    }
    namespace DelegationPoolAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolAllowlisting";
        function type(): TypeDescriptor<DelegationPoolAllowlisting>;
    }
    interface DelegationPoolOwnership {
        pool_address: MoveAddressType;
    }
    namespace DelegationPoolOwnership {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolOwnership";
        function type(): TypeDescriptor<DelegationPoolOwnership>;
    }
    interface DisableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace DisableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DisableDelegatorsAllowlisting";
        function type(): TypeDescriptor<DisableDelegatorsAllowlisting>;
    }
    type DisableDelegatorsAllowlistingInstance = TypedEventInstance<DisableDelegatorsAllowlisting> & {
        data_decoded: DisableDelegatorsAllowlisting;
        type_arguments: [];
    };
    interface DistributeCommission {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        beneficiary: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommission {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommission";
        function type(): TypeDescriptor<DistributeCommission>;
    }
    type DistributeCommissionInstance = TypedEventInstance<DistributeCommission> & {
        data_decoded: DistributeCommission;
        type_arguments: [];
    };
    interface DistributeCommissionEvent {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommissionEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommissionEvent";
        function type(): TypeDescriptor<DistributeCommissionEvent>;
    }
    type DistributeCommissionEventInstance = TypedEventInstance<DistributeCommissionEvent> & {
        data_decoded: DistributeCommissionEvent;
        type_arguments: [];
    };
    interface EnableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace EnableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::EnableDelegatorsAllowlisting";
        function type(): TypeDescriptor<EnableDelegatorsAllowlisting>;
    }
    type EnableDelegatorsAllowlistingInstance = TypedEventInstance<EnableDelegatorsAllowlisting> & {
        data_decoded: EnableDelegatorsAllowlisting;
        type_arguments: [];
    };
    interface EvictDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace EvictDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::EvictDelegator";
        function type(): TypeDescriptor<EvictDelegator>;
    }
    type EvictDelegatorInstance = TypedEventInstance<EvictDelegator> & {
        data_decoded: EvictDelegator;
        type_arguments: [];
    };
    interface GovernanceRecords {
        votes: smart_table.SmartTable<delegation_pool.VotingRecordKey, bigint>;
        votes_per_proposal: smart_table.SmartTable<bigint, bigint>;
        vote_delegation: smart_table.SmartTable<MoveAddressType, delegation_pool.VoteDelegation>;
        delegated_votes: smart_table.SmartTable<MoveAddressType, delegation_pool.DelegatedVotes>;
        vote_events: event.EventHandle<delegation_pool.VoteEvent>;
        create_proposal_events: event.EventHandle<delegation_pool.CreateProposalEvent>;
        delegate_voting_power_events: event.EventHandle<delegation_pool.DelegateVotingPowerEvent>;
    }
    namespace GovernanceRecords {
        const TYPE_QNAME = "0x1::delegation_pool::GovernanceRecords";
        function type(): TypeDescriptor<GovernanceRecords>;
    }
    interface NextCommissionPercentage {
        commission_percentage_next_lockup_cycle: bigint;
        effective_after_secs: bigint;
    }
    namespace NextCommissionPercentage {
        const TYPE_QNAME = "0x1::delegation_pool::NextCommissionPercentage";
        function type(): TypeDescriptor<NextCommissionPercentage>;
    }
    interface ObservedLockupCycle {
        index: bigint;
    }
    namespace ObservedLockupCycle {
        const TYPE_QNAME = "0x1::delegation_pool::ObservedLockupCycle";
        function type(): TypeDescriptor<ObservedLockupCycle>;
    }
    interface RemoveDelegatorFromAllowlist {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace RemoveDelegatorFromAllowlist {
        const TYPE_QNAME = "0x1::delegation_pool::RemoveDelegatorFromAllowlist";
        function type(): TypeDescriptor<RemoveDelegatorFromAllowlist>;
    }
    type RemoveDelegatorFromAllowlistInstance = TypedEventInstance<RemoveDelegatorFromAllowlist> & {
        data_decoded: RemoveDelegatorFromAllowlist;
        type_arguments: [];
    };
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    type SetBeneficiaryForOperatorInstance = TypedEventInstance<SetBeneficiaryForOperator> & {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    };
    interface VoteDelegation {
        voter: MoveAddressType;
        pending_voter: MoveAddressType;
        last_locked_until_secs: bigint;
    }
    namespace VoteDelegation {
        const TYPE_QNAME = "0x1::delegation_pool::VoteDelegation";
        function type(): TypeDescriptor<VoteDelegation>;
    }
    interface VotingRecordKey {
        voter: MoveAddressType;
        proposal_id: bigint;
    }
    namespace VotingRecordKey {
        const TYPE_QNAME = "0x1::delegation_pool::VotingRecordKey";
        function type(): TypeDescriptor<VotingRecordKey>;
    }
    namespace entry {
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function allowlistDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateVotingPower(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function disableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enablePartialGovernanceVoting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function evictDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDelegatorFromAllowlist(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function synchronizeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function partialGovernanceVotingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getOwnedPoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function allowlistingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateDelegatorVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVoterTotalVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVotingDelegation(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType, MoveAddressType, bigint]>;
        function canWithdrawPendingInactive(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function delegationPoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function delegatorAllowlisted(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function getAddStakeFee(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegationPoolStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getDelegatorsAllowlist(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getPendingWithdrawal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean, bigint]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function isNextCommissionPercentageEffective(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function minRemainingSecsForCommissionChange(client: Aptos, version?: bigint): Promise<[bigint]>;
        function observedLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function operatorCommissionPercentageNextLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function ownerCapExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function shareholdersCountActivePool(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
    interface WithdrawPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface CreateProposalPayload extends TypedFunctionPayload<[
        MoveAddressType,
        string,
        string,
        string,
        boolean
    ]> {
        arguments_decoded: [MoveAddressType, string, string, string, boolean];
        type_arguments: [];
    }
    interface VotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, boolean];
        type_arguments: [];
    }
    interface AddStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface ReactivateStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface SetDelegatedVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface AllowlistDelegatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface DelegateVotingPowerPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface DisableDelegatorsAllowlistingPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface EnableDelegatorsAllowlistingPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface EnablePartialGovernanceVotingPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface EvictDelegatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface InitializeDelegationPoolPayload extends TypedFunctionPayload<[bigint, string]> {
        arguments_decoded: [bigint, string];
        type_arguments: [];
    }
    interface RemoveDelegatorFromAllowlistPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SynchronizeDelegationPoolPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UpdateCommissionPercentagePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
}
export declare namespace keyless_account {
    interface Configuration {
        override_aud_vals: string[];
        max_signatures_per_txn: number;
        max_exp_horizon_secs: bigint;
        training_wheels_pubkey: option.Option<string>;
        max_commited_epk_bytes: number;
        max_iss_val_bytes: number;
        max_extra_field_bytes: number;
        max_jwt_header_b64_bytes: number;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::keyless_account::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface Group {
        dummy_field: boolean;
    }
    namespace Group {
        const TYPE_QNAME = "0x1::keyless_account::Group";
        function type(): TypeDescriptor<Group>;
    }
    interface Groth16VerificationKey {
        alpha_g1: string;
        beta_g2: string;
        gamma_g2: string;
        delta_g2: string;
        gamma_abc_g1: string[];
    }
    namespace Groth16VerificationKey {
        const TYPE_QNAME = "0x1::keyless_account::Groth16VerificationKey";
        function type(): TypeDescriptor<Groth16VerificationKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare class reconfiguration extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): reconfiguration;
    onEventNewEpoch(func: (event: reconfiguration.NewEpochInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, reconfiguration.NewEpochInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): reconfiguration;
    onEventNewEpochEvent(func: (event: reconfiguration.NewEpochEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, reconfiguration.NewEpochEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): reconfiguration;
}
export declare namespace reconfiguration {
    interface Configuration {
        epoch: bigint;
        last_reconfiguration_time: bigint;
        events: event.EventHandle<reconfiguration.NewEpochEvent>;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::reconfiguration::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface DisableReconfiguration {
        dummy_field: boolean;
    }
    namespace DisableReconfiguration {
        const TYPE_QNAME = "0x1::reconfiguration::DisableReconfiguration";
        function type(): TypeDescriptor<DisableReconfiguration>;
    }
    interface NewEpoch {
        epoch: bigint;
    }
    namespace NewEpoch {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpoch";
        function type(): TypeDescriptor<NewEpoch>;
    }
    type NewEpochInstance = TypedEventInstance<NewEpoch> & {
        data_decoded: NewEpoch;
        type_arguments: [];
    };
    interface NewEpochEvent {
        epoch: bigint;
    }
    namespace NewEpochEvent {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpochEvent";
        function type(): TypeDescriptor<NewEpochEvent>;
    }
    type NewEpochEventInstance = TypedEventInstance<NewEpochEvent> & {
        data_decoded: NewEpochEvent;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare class transaction_fee extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): transaction_fee;
    onEntryConvertToAptosFaBurnRef(func: (call: transaction_fee.ConvertToAptosFaBurnRefPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, transaction_fee.ConvertToAptosFaBurnRefPayload>): transaction_fee;
    onEventFeeStatement(func: (event: transaction_fee.FeeStatementInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, transaction_fee.FeeStatementInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): transaction_fee;
}
export declare namespace transaction_fee {
    interface AptosCoinCapabilities {
        burn_cap: coin.BurnCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface AptosCoinMintCapability {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinMintCapability {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinMintCapability";
        function type(): TypeDescriptor<AptosCoinMintCapability>;
    }
    interface AptosFABurnCapabilities {
        burn_ref: fungible_asset.BurnRef;
    }
    namespace AptosFABurnCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosFABurnCapabilities";
        function type(): TypeDescriptor<AptosFABurnCapabilities>;
    }
    interface CollectedFeesPerBlock {
        amount: coin.AggregatableCoin<aptos_coin.AptosCoin>;
        proposer: option.Option<MoveAddressType>;
        burn_percentage: number;
    }
    namespace CollectedFeesPerBlock {
        const TYPE_QNAME = "0x1::transaction_fee::CollectedFeesPerBlock";
        function type(): TypeDescriptor<CollectedFeesPerBlock>;
    }
    interface FeeStatement {
        total_charge_gas_units: bigint;
        execution_gas_units: bigint;
        io_gas_units: bigint;
        storage_fee_octas: bigint;
        storage_fee_refund_octas: bigint;
    }
    namespace FeeStatement {
        const TYPE_QNAME = "0x1::transaction_fee::FeeStatement";
        function type(): TypeDescriptor<FeeStatement>;
    }
    type FeeStatementInstance = TypedEventInstance<FeeStatement> & {
        data_decoded: FeeStatement;
        type_arguments: [];
    };
    namespace entry {
        function convertToAptosFaBurnRef(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface ConvertToAptosFaBurnRefPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
}
export declare class aptos_governance extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_governance;
    onEntryCreateProposal(func: (call: aptos_governance.CreateProposalPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.CreateProposalPayload>): aptos_governance;
    onEntryCreateProposalV2(func: (call: aptos_governance.CreateProposalV2Payload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.CreateProposalV2Payload>): aptos_governance;
    onEntryVote(func: (call: aptos_governance.VotePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.VotePayload>): aptos_governance;
    onEntryReconfigure(func: (call: aptos_governance.ReconfigurePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.ReconfigurePayload>): aptos_governance;
    onEntryAddApprovedScriptHashScript(func: (call: aptos_governance.AddApprovedScriptHashScriptPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.AddApprovedScriptHashScriptPayload>): aptos_governance;
    onEntryBatchPartialVote(func: (call: aptos_governance.BatchPartialVotePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.BatchPartialVotePayload>): aptos_governance;
    onEntryBatchVote(func: (call: aptos_governance.BatchVotePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.BatchVotePayload>): aptos_governance;
    onEntryForceEndEpoch(func: (call: aptos_governance.ForceEndEpochPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.ForceEndEpochPayload>): aptos_governance;
    onEntryForceEndEpochTestOnly(func: (call: aptos_governance.ForceEndEpochTestOnlyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.ForceEndEpochTestOnlyPayload>): aptos_governance;
    onEntryPartialVote(func: (call: aptos_governance.PartialVotePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.PartialVotePayload>): aptos_governance;
    onEventCreateProposal(func: (event: aptos_governance.CreateProposalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.CreateProposalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
    onEventCreateProposalEvent(func: (event: aptos_governance.CreateProposalEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.CreateProposalEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
    onEventVote(func: (event: aptos_governance.VoteInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.VoteInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
    onEventVoteEvent(func: (event: aptos_governance.VoteEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.VoteEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
    onEventUpdateConfig(func: (event: aptos_governance.UpdateConfigInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.UpdateConfigInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
    onEventUpdateConfigEvent(func: (event: aptos_governance.UpdateConfigEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_governance.UpdateConfigEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): aptos_governance;
}
export declare namespace aptos_governance {
    interface CreateProposal {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    type CreateProposalInstance = TypedEventInstance<CreateProposal> & {
        data_decoded: CreateProposal;
        type_arguments: [];
    };
    interface CreateProposalEvent {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    type CreateProposalEventInstance = TypedEventInstance<CreateProposalEvent> & {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    };
    interface Vote {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::aptos_governance::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::aptos_governance::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface ApprovedExecutionHashes {
        hashes: simple_map.SimpleMap<bigint, string>;
    }
    namespace ApprovedExecutionHashes {
        const TYPE_QNAME = "0x1::aptos_governance::ApprovedExecutionHashes";
        function type(): TypeDescriptor<ApprovedExecutionHashes>;
    }
    interface GovernanceConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace GovernanceConfig {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceConfig";
        function type(): TypeDescriptor<GovernanceConfig>;
    }
    interface GovernanceEvents {
        create_proposal_events: event.EventHandle<aptos_governance.CreateProposalEvent>;
        update_config_events: event.EventHandle<aptos_governance.UpdateConfigEvent>;
        vote_events: event.EventHandle<aptos_governance.VoteEvent>;
    }
    namespace GovernanceEvents {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceEvents";
        function type(): TypeDescriptor<GovernanceEvents>;
    }
    interface GovernancePermission {
        dummy_field: boolean;
    }
    namespace GovernancePermission {
        const TYPE_QNAME = "0x1::aptos_governance::GovernancePermission";
        function type(): TypeDescriptor<GovernancePermission>;
    }
    interface GovernanceResponsbility {
        signer_caps: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace GovernanceResponsbility {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceResponsbility";
        function type(): TypeDescriptor<GovernanceResponsbility>;
    }
    interface RecordKey {
        stake_pool: MoveAddressType;
        proposal_id: bigint;
    }
    namespace RecordKey {
        const TYPE_QNAME = "0x1::aptos_governance::RecordKey";
        function type(): TypeDescriptor<RecordKey>;
    }
    interface UpdateConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfig {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfig";
        function type(): TypeDescriptor<UpdateConfig>;
    }
    type UpdateConfigInstance = TypedEventInstance<UpdateConfig> & {
        data_decoded: UpdateConfig;
        type_arguments: [];
    };
    interface UpdateConfigEvent {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfigEvent {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfigEvent";
        function type(): TypeDescriptor<UpdateConfigEvent>;
    }
    type UpdateConfigEventInstance = TypedEventInstance<UpdateConfigEvent> & {
        data_decoded: UpdateConfigEvent;
        type_arguments: [];
    };
    interface VotingRecords {
        votes: table.Table<aptos_governance.RecordKey, boolean>;
    }
    namespace VotingRecords {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecords";
        function type(): TypeDescriptor<VotingRecords>;
    }
    interface VotingRecordsV2 {
        votes: smart_table.SmartTable<aptos_governance.RecordKey, bigint>;
    }
    namespace VotingRecordsV2 {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecordsV2";
        function type(): TypeDescriptor<VotingRecordsV2>;
    }
    namespace entry {
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposalV2(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reconfigure(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addApprovedScriptHashScript(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchPartialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpochTestOnly(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function partialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getMinVotingThreshold(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getRequiredProposerStake(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getVotingDurationSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
        function hasEntirelyVoted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface CreateProposalPayload extends TypedFunctionPayload<[MoveAddressType, string, string, string]> {
        arguments_decoded: [MoveAddressType, string, string, string];
        type_arguments: [];
    }
    interface CreateProposalV2Payload extends TypedFunctionPayload<[
        MoveAddressType,
        string,
        string,
        string,
        boolean
    ]> {
        arguments_decoded: [MoveAddressType, string, string, string, boolean];
        type_arguments: [];
    }
    interface VotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, boolean];
        type_arguments: [];
    }
    interface ReconfigurePayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface AddApprovedScriptHashScriptPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface BatchPartialVotePayload extends TypedFunctionPayload<[MoveAddressType[], bigint, bigint, boolean]> {
        arguments_decoded: [MoveAddressType[], bigint, bigint, boolean];
        type_arguments: [];
    }
    interface BatchVotePayload extends TypedFunctionPayload<[MoveAddressType[], bigint, boolean]> {
        arguments_decoded: [MoveAddressType[], bigint, boolean];
        type_arguments: [];
    }
    interface ForceEndEpochPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface ForceEndEpochTestOnlyPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface PartialVotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, boolean];
        type_arguments: [];
    }
}
export declare namespace bls12381_algebra {
    interface FormatFq12LscLsb {
        dummy_field: boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bls12381_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface HashG1XmdSha256SswuRo {
        dummy_field: boolean;
    }
    namespace HashG1XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG1XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG1XmdSha256SswuRo>;
    }
    interface HashG2XmdSha256SswuRo {
        dummy_field: boolean;
    }
    namespace HashG2XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG2XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG2XmdSha256SswuRo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace consensus_config {
    interface ConsensusConfig {
        config: string;
    }
    namespace ConsensusConfig {
        const TYPE_QNAME = "0x1::consensus_config::ConsensusConfig";
        function type(): TypeDescriptor<ConsensusConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace execution_config {
    interface ExecutionConfig {
        config: string;
    }
    namespace ExecutionConfig {
        const TYPE_QNAME = "0x1::execution_config::ExecutionConfig";
        function type(): TypeDescriptor<ExecutionConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare class multisig_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): multisig_account;
    onEntryCreate(func: (call: multisig_account.CreatePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreatePayload>): multisig_account;
    onEntryAddOwner(func: (call: multisig_account.AddOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.AddOwnerPayload>): multisig_account;
    onEntryAddOwners(func: (call: multisig_account.AddOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.AddOwnersPayload>): multisig_account;
    onEntryAddOwnersAndUpdateSignaturesRequired(func: (call: multisig_account.AddOwnersAndUpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.AddOwnersAndUpdateSignaturesRequiredPayload>): multisig_account;
    onEntryApproveTransaction(func: (call: multisig_account.ApproveTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.ApproveTransactionPayload>): multisig_account;
    onEntryCreateTransaction(func: (call: multisig_account.CreateTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateTransactionPayload>): multisig_account;
    onEntryCreateTransactionWithHash(func: (call: multisig_account.CreateTransactionWithHashPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateTransactionWithHashPayload>): multisig_account;
    onEntryCreateWithExistingAccount(func: (call: multisig_account.CreateWithExistingAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithExistingAccountPayload>): multisig_account;
    onEntryCreateWithExistingAccountAndRevokeAuthKey(func: (call: multisig_account.CreateWithExistingAccountAndRevokeAuthKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithExistingAccountAndRevokeAuthKeyPayload>): multisig_account;
    onEntryCreateWithExistingAccountAndRevokeAuthKeyCall(func: (call: multisig_account.CreateWithExistingAccountAndRevokeAuthKeyCallPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithExistingAccountAndRevokeAuthKeyCallPayload>): multisig_account;
    onEntryCreateWithExistingAccountCall(func: (call: multisig_account.CreateWithExistingAccountCallPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithExistingAccountCallPayload>): multisig_account;
    onEntryCreateWithOwners(func: (call: multisig_account.CreateWithOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithOwnersPayload>): multisig_account;
    onEntryCreateWithOwnersThenRemoveBootstrapper(func: (call: multisig_account.CreateWithOwnersThenRemoveBootstrapperPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateWithOwnersThenRemoveBootstrapperPayload>): multisig_account;
    onEntryExecuteRejectedTransaction(func: (call: multisig_account.ExecuteRejectedTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.ExecuteRejectedTransactionPayload>): multisig_account;
    onEntryExecuteRejectedTransactions(func: (call: multisig_account.ExecuteRejectedTransactionsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.ExecuteRejectedTransactionsPayload>): multisig_account;
    onEntryRejectTransaction(func: (call: multisig_account.RejectTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.RejectTransactionPayload>): multisig_account;
    onEntryRemoveOwner(func: (call: multisig_account.RemoveOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.RemoveOwnerPayload>): multisig_account;
    onEntryRemoveOwners(func: (call: multisig_account.RemoveOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.RemoveOwnersPayload>): multisig_account;
    onEntrySwapOwner(func: (call: multisig_account.SwapOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.SwapOwnerPayload>): multisig_account;
    onEntrySwapOwners(func: (call: multisig_account.SwapOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.SwapOwnersPayload>): multisig_account;
    onEntrySwapOwnersAndUpdateSignaturesRequired(func: (call: multisig_account.SwapOwnersAndUpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.SwapOwnersAndUpdateSignaturesRequiredPayload>): multisig_account;
    onEntryUpdateMetadata(func: (call: multisig_account.UpdateMetadataPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.UpdateMetadataPayload>): multisig_account;
    onEntryUpdateSignaturesRequired(func: (call: multisig_account.UpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.UpdateSignaturesRequiredPayload>): multisig_account;
    onEntryVoteTransaction(func: (call: multisig_account.VoteTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.VoteTransactionPayload>): multisig_account;
    onEntryVoteTransactions(func: (call: multisig_account.VoteTransactionsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.VoteTransactionsPayload>): multisig_account;
    onEntryVoteTransanction(func: (call: multisig_account.VoteTransanctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.VoteTransanctionPayload>): multisig_account;
    onEventVote(func: (event: multisig_account.VoteInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.VoteInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventVoteEvent(func: (event: multisig_account.VoteEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.VoteEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventAddOwners(func: (event: multisig_account.AddOwnersInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.AddOwnersInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventAddOwnersEvent(func: (event: multisig_account.AddOwnersEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.AddOwnersEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventCreateTransaction(func: (event: multisig_account.CreateTransactionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateTransactionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventCreateTransactionEvent(func: (event: multisig_account.CreateTransactionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.CreateTransactionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventExecuteRejectedTransaction(func: (event: multisig_account.ExecuteRejectedTransactionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.ExecuteRejectedTransactionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventExecuteRejectedTransactionEvent(func: (event: multisig_account.ExecuteRejectedTransactionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.ExecuteRejectedTransactionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventMetadataUpdated(func: (event: multisig_account.MetadataUpdatedInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.MetadataUpdatedInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventMetadataUpdatedEvent(func: (event: multisig_account.MetadataUpdatedEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.MetadataUpdatedEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventRemoveOwners(func: (event: multisig_account.RemoveOwnersInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.RemoveOwnersInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventRemoveOwnersEvent(func: (event: multisig_account.RemoveOwnersEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.RemoveOwnersEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventTransactionExecutionFailed(func: (event: multisig_account.TransactionExecutionFailedInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.TransactionExecutionFailedInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventTransactionExecutionFailedEvent(func: (event: multisig_account.TransactionExecutionFailedEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.TransactionExecutionFailedEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventTransactionExecutionSucceeded(func: (event: multisig_account.TransactionExecutionSucceededInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.TransactionExecutionSucceededInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventTransactionExecutionSucceededEvent(func: (event: multisig_account.TransactionExecutionSucceededEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.TransactionExecutionSucceededEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventUpdateSignaturesRequired(func: (event: multisig_account.UpdateSignaturesRequiredInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.UpdateSignaturesRequiredInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
    onEventUpdateSignaturesRequiredEvent(func: (event: multisig_account.UpdateSignaturesRequiredEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, multisig_account.UpdateSignaturesRequiredEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): multisig_account;
}
export declare namespace multisig_account {
    interface Vote {
        multisig_account: MoveAddressType;
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::multisig_account::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    type VoteInstance = TypedEventInstance<Vote> & {
        data_decoded: Vote;
        type_arguments: [];
    };
    interface VoteEvent {
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::multisig_account::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    type VoteEventInstance = TypedEventInstance<VoteEvent> & {
        data_decoded: VoteEvent;
        type_arguments: [];
    };
    interface AddOwners {
        multisig_account: MoveAddressType;
        owners_added: MoveAddressType[];
    }
    namespace AddOwners {
        const TYPE_QNAME = "0x1::multisig_account::AddOwners";
        function type(): TypeDescriptor<AddOwners>;
    }
    type AddOwnersInstance = TypedEventInstance<AddOwners> & {
        data_decoded: AddOwners;
        type_arguments: [];
    };
    interface AddOwnersEvent {
        owners_added: MoveAddressType[];
    }
    namespace AddOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::AddOwnersEvent";
        function type(): TypeDescriptor<AddOwnersEvent>;
    }
    type AddOwnersEventInstance = TypedEventInstance<AddOwnersEvent> & {
        data_decoded: AddOwnersEvent;
        type_arguments: [];
    };
    interface CreateTransaction {
        multisig_account: MoveAddressType;
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransaction {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransaction";
        function type(): TypeDescriptor<CreateTransaction>;
    }
    type CreateTransactionInstance = TypedEventInstance<CreateTransaction> & {
        data_decoded: CreateTransaction;
        type_arguments: [];
    };
    interface CreateTransactionEvent {
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransactionEvent";
        function type(): TypeDescriptor<CreateTransactionEvent>;
    }
    type CreateTransactionEventInstance = TypedEventInstance<CreateTransactionEvent> & {
        data_decoded: CreateTransactionEvent;
        type_arguments: [];
    };
    interface ExecuteRejectedTransaction {
        multisig_account: MoveAddressType;
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransaction {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransaction";
        function type(): TypeDescriptor<ExecuteRejectedTransaction>;
    }
    type ExecuteRejectedTransactionInstance = TypedEventInstance<ExecuteRejectedTransaction> & {
        data_decoded: ExecuteRejectedTransaction;
        type_arguments: [];
    };
    interface ExecuteRejectedTransactionEvent {
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransactionEvent";
        function type(): TypeDescriptor<ExecuteRejectedTransactionEvent>;
    }
    type ExecuteRejectedTransactionEventInstance = TypedEventInstance<ExecuteRejectedTransactionEvent> & {
        data_decoded: ExecuteRejectedTransactionEvent;
        type_arguments: [];
    };
    interface ExecutionError {
        abort_location: string;
        error_type: string;
        error_code: bigint;
    }
    namespace ExecutionError {
        const TYPE_QNAME = "0x1::multisig_account::ExecutionError";
        function type(): TypeDescriptor<ExecutionError>;
    }
    interface MetadataUpdated {
        multisig_account: MoveAddressType;
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdated {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdated";
        function type(): TypeDescriptor<MetadataUpdated>;
    }
    type MetadataUpdatedInstance = TypedEventInstance<MetadataUpdated> & {
        data_decoded: MetadataUpdated;
        type_arguments: [];
    };
    interface MetadataUpdatedEvent {
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdatedEvent {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdatedEvent";
        function type(): TypeDescriptor<MetadataUpdatedEvent>;
    }
    type MetadataUpdatedEventInstance = TypedEventInstance<MetadataUpdatedEvent> & {
        data_decoded: MetadataUpdatedEvent;
        type_arguments: [];
    };
    interface MultisigAccount {
        owners: MoveAddressType[];
        num_signatures_required: bigint;
        transactions: table.Table<bigint, multisig_account.MultisigTransaction>;
        last_executed_sequence_number: bigint;
        next_sequence_number: bigint;
        signer_cap: option.Option<account.SignerCapability>;
        metadata: simple_map.SimpleMap<string, string>;
        add_owners_events: event.EventHandle<multisig_account.AddOwnersEvent>;
        remove_owners_events: event.EventHandle<multisig_account.RemoveOwnersEvent>;
        update_signature_required_events: event.EventHandle<multisig_account.UpdateSignaturesRequiredEvent>;
        create_transaction_events: event.EventHandle<multisig_account.CreateTransactionEvent>;
        vote_events: event.EventHandle<multisig_account.VoteEvent>;
        execute_rejected_transaction_events: event.EventHandle<multisig_account.ExecuteRejectedTransactionEvent>;
        execute_transaction_events: event.EventHandle<multisig_account.TransactionExecutionSucceededEvent>;
        transaction_execution_failed_events: event.EventHandle<multisig_account.TransactionExecutionFailedEvent>;
        metadata_updated_events: event.EventHandle<multisig_account.MetadataUpdatedEvent>;
    }
    namespace MultisigAccount {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccount";
        function type(): TypeDescriptor<MultisigAccount>;
    }
    interface MultisigAccountCreationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationMessage>;
    }
    interface MultisigAccountCreationWithAuthKeyRevocationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationWithAuthKeyRevocationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationWithAuthKeyRevocationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationWithAuthKeyRevocationMessage>;
    }
    interface MultisigTransaction {
        payload: option.Option<string>;
        payload_hash: option.Option<string>;
        votes: simple_map.SimpleMap<MoveAddressType, boolean>;
        creator: MoveAddressType;
        creation_time_secs: bigint;
    }
    namespace MultisigTransaction {
        const TYPE_QNAME = "0x1::multisig_account::MultisigTransaction";
        function type(): TypeDescriptor<MultisigTransaction>;
    }
    interface RemoveOwners {
        multisig_account: MoveAddressType;
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwners {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwners";
        function type(): TypeDescriptor<RemoveOwners>;
    }
    type RemoveOwnersInstance = TypedEventInstance<RemoveOwners> & {
        data_decoded: RemoveOwners;
        type_arguments: [];
    };
    interface RemoveOwnersEvent {
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwnersEvent";
        function type(): TypeDescriptor<RemoveOwnersEvent>;
    }
    type RemoveOwnersEventInstance = TypedEventInstance<RemoveOwnersEvent> & {
        data_decoded: RemoveOwnersEvent;
        type_arguments: [];
    };
    interface TransactionExecutionFailed {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailed {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailed";
        function type(): TypeDescriptor<TransactionExecutionFailed>;
    }
    type TransactionExecutionFailedInstance = TypedEventInstance<TransactionExecutionFailed> & {
        data_decoded: TransactionExecutionFailed;
        type_arguments: [];
    };
    interface TransactionExecutionFailedEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailedEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailedEvent";
        function type(): TypeDescriptor<TransactionExecutionFailedEvent>;
    }
    type TransactionExecutionFailedEventInstance = TypedEventInstance<TransactionExecutionFailedEvent> & {
        data_decoded: TransactionExecutionFailedEvent;
        type_arguments: [];
    };
    interface TransactionExecutionSucceeded {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceeded {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceeded";
        function type(): TypeDescriptor<TransactionExecutionSucceeded>;
    }
    type TransactionExecutionSucceededInstance = TypedEventInstance<TransactionExecutionSucceeded> & {
        data_decoded: TransactionExecutionSucceeded;
        type_arguments: [];
    };
    interface TransactionExecutionSucceededEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceededEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceededEvent";
        function type(): TypeDescriptor<TransactionExecutionSucceededEvent>;
    }
    type TransactionExecutionSucceededEventInstance = TypedEventInstance<TransactionExecutionSucceededEvent> & {
        data_decoded: TransactionExecutionSucceededEvent;
        type_arguments: [];
    };
    interface UpdateSignaturesRequired {
        multisig_account: MoveAddressType;
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequired {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequired";
        function type(): TypeDescriptor<UpdateSignaturesRequired>;
    }
    type UpdateSignaturesRequiredInstance = TypedEventInstance<UpdateSignaturesRequired> & {
        data_decoded: UpdateSignaturesRequired;
        type_arguments: [];
    };
    interface UpdateSignaturesRequiredEvent {
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequiredEvent {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequiredEvent";
        function type(): TypeDescriptor<UpdateSignaturesRequiredEvent>;
    }
    type UpdateSignaturesRequiredEventInstance = TypedEventInstance<UpdateSignaturesRequiredEvent> & {
        data_decoded: UpdateSignaturesRequiredEvent;
        type_arguments: [];
    };
    namespace entry {
        function create(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function approveTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransactionWithHash(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountAndRevokeAuthKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountAndRevokeAuthKeyCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwnersThenRemoveBootstrapper(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rejectTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateMetadata(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransanction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function isOwner(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
        function metadata(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function vote(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint, MoveAddressType];
        }, version?: bigint): Promise<[boolean, boolean]>;
        function availableTransactionQueueCapacity(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function canBeExecuted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canBeRejected(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canExecute(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function canReject(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function numSignaturesRequired(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function owners(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function getNextMultisigAccountAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getNextTransactionPayload(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[string]>;
        function getPendingTransactions(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction[]]>;
        function getTransaction(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction]>;
        function lastResolvedSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function nextSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
    interface CreatePayload extends TypedFunctionPayload<[bigint, string[], string[]]> {
        arguments_decoded: [bigint, string[], string[]];
        type_arguments: [];
    }
    interface AddOwnerPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface AddOwnersPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface AddOwnersAndUpdateSignaturesRequiredPayload extends TypedFunctionPayload<[MoveAddressType[], bigint]> {
        arguments_decoded: [MoveAddressType[], bigint];
        type_arguments: [];
    }
    interface ApproveTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface CreateTransactionPayload extends TypedFunctionPayload<[MoveAddressType, string]> {
        arguments_decoded: [MoveAddressType, string];
        type_arguments: [];
    }
    interface CreateTransactionWithHashPayload extends TypedFunctionPayload<[MoveAddressType, string]> {
        arguments_decoded: [MoveAddressType, string];
        type_arguments: [];
    }
    interface CreateWithExistingAccountPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType[],
        bigint,
        number,
        string,
        string,
        string[],
        string[]
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType[],
            bigint,
            number,
            string,
            string,
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface CreateWithExistingAccountAndRevokeAuthKeyPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType[],
        bigint,
        number,
        string,
        string,
        string[],
        string[]
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType[],
            bigint,
            number,
            string,
            string,
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface CreateWithExistingAccountAndRevokeAuthKeyCallPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface CreateWithExistingAccountCallPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface CreateWithOwnersPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface CreateWithOwnersThenRemoveBootstrapperPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionsPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface RejectTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface RemoveOwnerPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RemoveOwnersPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface SwapOwnerPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SwapOwnersPayload extends TypedFunctionPayload<[MoveAddressType[], MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[], MoveAddressType[]];
        type_arguments: [];
    }
    interface SwapOwnersAndUpdateSignaturesRequiredPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        MoveAddressType[],
        bigint
    ]> {
        arguments_decoded: [MoveAddressType[], MoveAddressType[], bigint];
        type_arguments: [];
    }
    interface UpdateMetadataPayload extends TypedFunctionPayload<[string[], string[]]> {
        arguments_decoded: [string[], string[]];
        type_arguments: [];
    }
    interface UpdateSignaturesRequiredPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface VoteTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, boolean];
        type_arguments: [];
    }
    interface VoteTransactionsPayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, boolean];
        type_arguments: [];
    }
    interface VoteTransanctionPayload extends TypedFunctionPayload<[MoveAddressType, bigint, boolean]> {
        arguments_decoded: [MoveAddressType, bigint, boolean];
        type_arguments: [];
    }
}
export declare class nonce_validation extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): nonce_validation;
    onEntryAddNonceBuckets(func: (call: nonce_validation.AddNonceBucketsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, nonce_validation.AddNonceBucketsPayload>): nonce_validation;
    onEntryInitializeNonceTable(func: (call: nonce_validation.InitializeNonceTablePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, nonce_validation.InitializeNonceTablePayload>): nonce_validation;
}
export declare namespace nonce_validation {
    interface Bucket {
        nonces_ordered_by_exp_time: big_ordered_map.BigOrderedMap<nonce_validation.NonceKeyWithExpTime, boolean>;
        nonce_to_exp_time_map: big_ordered_map.BigOrderedMap<nonce_validation.NonceKey, bigint>;
    }
    namespace Bucket {
        const TYPE_QNAME = "0x1::nonce_validation::Bucket";
        function type(): TypeDescriptor<Bucket>;
    }
    interface NonceHistory {
        nonce_table: table.Table<bigint, nonce_validation.Bucket>;
        next_key: bigint;
    }
    namespace NonceHistory {
        const TYPE_QNAME = "0x1::nonce_validation::NonceHistory";
        function type(): TypeDescriptor<NonceHistory>;
    }
    interface NonceKey {
        sender_address: MoveAddressType;
        nonce: bigint;
    }
    namespace NonceKey {
        const TYPE_QNAME = "0x1::nonce_validation::NonceKey";
        function type(): TypeDescriptor<NonceKey>;
    }
    interface NonceKeyWithExpTime {
        txn_expiration_time: bigint;
        sender_address: MoveAddressType;
        nonce: bigint;
    }
    namespace NonceKeyWithExpTime {
        const TYPE_QNAME = "0x1::nonce_validation::NonceKeyWithExpTime";
        function type(): TypeDescriptor<NonceKeyWithExpTime>;
    }
    namespace entry {
        function addNonceBuckets(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeNonceTable(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface AddNonceBucketsPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface InitializeNonceTablePayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
}
export declare namespace pool_u64_unbound {
    interface Pool {
        total_coins: bigint;
        total_shares: bigint;
        shares: table_with_length.TableWithLength<MoveAddressType, bigint>;
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64_unbound::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare class resource_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): resource_account;
    onEntryCreateResourceAccount(func: (call: resource_account.CreateResourceAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, resource_account.CreateResourceAccountPayload>): resource_account;
    onEntryCreateResourceAccountAndFund(func: (call: resource_account.CreateResourceAccountAndFundPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, resource_account.CreateResourceAccountAndFundPayload>): resource_account;
    onEntryCreateResourceAccountAndPublishPackage(func: (call: resource_account.CreateResourceAccountAndPublishPackagePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, resource_account.CreateResourceAccountAndPublishPackagePayload>): resource_account;
}
export declare namespace resource_account {
    interface Container {
        store: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace Container {
        const TYPE_QNAME = "0x1::resource_account::Container";
        function type(): TypeDescriptor<Container>;
    }
    namespace entry {
        function createResourceAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndFund(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndPublishPackage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface CreateResourceAccountPayload extends TypedFunctionPayload<[string, string]> {
        arguments_decoded: [string, string];
        type_arguments: [];
    }
    interface CreateResourceAccountAndFundPayload extends TypedFunctionPayload<[string, string, bigint]> {
        arguments_decoded: [string, string, bigint];
        type_arguments: [];
    }
    interface CreateResourceAccountAndPublishPackagePayload extends TypedFunctionPayload<[string, string, string[]]> {
        arguments_decoded: [string, string, string[]];
        type_arguments: [];
    }
}
export declare class staking_contract extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): staking_contract;
    onEntryAddStake(func: (call: staking_contract.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.AddStakePayload>): staking_contract;
    onEntrySetBeneficiaryForOperator(func: (call: staking_contract.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SetBeneficiaryForOperatorPayload>): staking_contract;
    onEntryCreateStakingContract(func: (call: staking_contract.CreateStakingContractPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.CreateStakingContractPayload>): staking_contract;
    onEntryDistribute(func: (call: staking_contract.DistributePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.DistributePayload>): staking_contract;
    onEntryRequestCommission(func: (call: staking_contract.RequestCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.RequestCommissionPayload>): staking_contract;
    onEntryResetLockup(func: (call: staking_contract.ResetLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.ResetLockupPayload>): staking_contract;
    onEntrySwitchOperator(func: (call: staking_contract.SwitchOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SwitchOperatorPayload>): staking_contract;
    onEntrySwitchOperatorWithSameCommission(func: (call: staking_contract.SwitchOperatorWithSameCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SwitchOperatorWithSameCommissionPayload>): staking_contract;
    onEntryUnlockRewards(func: (call: staking_contract.UnlockRewardsPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UnlockRewardsPayload>): staking_contract;
    onEntryUnlockStake(func: (call: staking_contract.UnlockStakePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UnlockStakePayload>): staking_contract;
    onEntryUpdateCommision(func: (call: staking_contract.UpdateCommisionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateCommisionPayload>): staking_contract;
    onEntryUpdateVoter(func: (call: staking_contract.UpdateVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateVoterPayload>): staking_contract;
    onEventAddStake(func: (event: staking_contract.AddStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.AddStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventAddStakeEvent(func: (event: staking_contract.AddStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.AddStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUnlockStake(func: (event: staking_contract.UnlockStakeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UnlockStakeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUnlockStakeEvent(func: (event: staking_contract.UnlockStakeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UnlockStakeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventSetBeneficiaryForOperator(func: (event: staking_contract.SetBeneficiaryForOperatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SetBeneficiaryForOperatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventAddDistribution(func: (event: staking_contract.AddDistributionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.AddDistributionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventAddDistributionEvent(func: (event: staking_contract.AddDistributionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.AddDistributionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventCreateStakingContract(func: (event: staking_contract.CreateStakingContractInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.CreateStakingContractInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventCreateStakingContractEvent(func: (event: staking_contract.CreateStakingContractEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.CreateStakingContractEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventDistribute(func: (event: staking_contract.DistributeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.DistributeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventDistributeEvent(func: (event: staking_contract.DistributeEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.DistributeEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventRequestCommission(func: (event: staking_contract.RequestCommissionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.RequestCommissionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventRequestCommissionEvent(func: (event: staking_contract.RequestCommissionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.RequestCommissionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventResetLockup(func: (event: staking_contract.ResetLockupInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.ResetLockupInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventResetLockupEvent(func: (event: staking_contract.ResetLockupEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.ResetLockupEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventStakingGroupUpdateCommissionEvent(func: (event: staking_contract.StakingGroupUpdateCommissionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.StakingGroupUpdateCommissionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventSwitchOperator(func: (event: staking_contract.SwitchOperatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SwitchOperatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventSwitchOperatorEvent(func: (event: staking_contract.SwitchOperatorEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.SwitchOperatorEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUpdateCommission(func: (event: staking_contract.UpdateCommissionInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateCommissionInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUpdateCommissionEvent(func: (event: staking_contract.UpdateCommissionEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateCommissionEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUpdateVoter(func: (event: staking_contract.UpdateVoterInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateVoterInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
    onEventUpdateVoterEvent(func: (event: staking_contract.UpdateVoterEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, staking_contract.UpdateVoterEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): staking_contract;
}
export declare namespace staking_contract {
    interface AddStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::staking_contract::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    type AddStakeInstance = TypedEventInstance<AddStake> & {
        data_decoded: AddStake;
        type_arguments: [];
    };
    interface AddStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    type AddStakeEventInstance = TypedEventInstance<AddStakeEvent> & {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    };
    interface UnlockStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    type UnlockStakeInstance = TypedEventInstance<UnlockStake> & {
        data_decoded: UnlockStake;
        type_arguments: [];
    };
    interface UnlockStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    type UnlockStakeEventInstance = TypedEventInstance<UnlockStakeEvent> & {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    };
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    type SetBeneficiaryForOperatorInstance = TypedEventInstance<SetBeneficiaryForOperator> & {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    };
    interface AddDistribution {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistribution {
        const TYPE_QNAME = "0x1::staking_contract::AddDistribution";
        function type(): TypeDescriptor<AddDistribution>;
    }
    type AddDistributionInstance = TypedEventInstance<AddDistribution> & {
        data_decoded: AddDistribution;
        type_arguments: [];
    };
    interface AddDistributionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistributionEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddDistributionEvent";
        function type(): TypeDescriptor<AddDistributionEvent>;
    }
    type AddDistributionEventInstance = TypedEventInstance<AddDistributionEvent> & {
        data_decoded: AddDistributionEvent;
        type_arguments: [];
    };
    interface CreateStakingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContract {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContract";
        function type(): TypeDescriptor<CreateStakingContract>;
    }
    type CreateStakingContractInstance = TypedEventInstance<CreateStakingContract> & {
        data_decoded: CreateStakingContract;
        type_arguments: [];
    };
    interface CreateStakingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContractEvent {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContractEvent";
        function type(): TypeDescriptor<CreateStakingContractEvent>;
    }
    type CreateStakingContractEventInstance = TypedEventInstance<CreateStakingContractEvent> & {
        data_decoded: CreateStakingContractEvent;
        type_arguments: [];
    };
    interface Distribute {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::staking_contract::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    type DistributeInstance = TypedEventInstance<Distribute> & {
        data_decoded: Distribute;
        type_arguments: [];
    };
    interface DistributeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::staking_contract::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    type DistributeEventInstance = TypedEventInstance<DistributeEvent> & {
        data_decoded: DistributeEvent;
        type_arguments: [];
    };
    interface RequestCommission {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommission {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommission";
        function type(): TypeDescriptor<RequestCommission>;
    }
    type RequestCommissionInstance = TypedEventInstance<RequestCommission> & {
        data_decoded: RequestCommission;
        type_arguments: [];
    };
    interface RequestCommissionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommissionEvent";
        function type(): TypeDescriptor<RequestCommissionEvent>;
    }
    type RequestCommissionEventInstance = TypedEventInstance<RequestCommissionEvent> & {
        data_decoded: RequestCommissionEvent;
        type_arguments: [];
    };
    interface ResetLockup {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    type ResetLockupInstance = TypedEventInstance<ResetLockup> & {
        data_decoded: ResetLockup;
        type_arguments: [];
    };
    interface ResetLockupEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    type ResetLockupEventInstance = TypedEventInstance<ResetLockupEvent> & {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    };
    interface Staker {
        staker: MoveAddressType;
    }
    namespace Staker {
        const TYPE_QNAME = "0x1::staking_contract::Staker";
        function type(): TypeDescriptor<Staker>;
    }
    interface StakingContract {
        principal: bigint;
        pool_address: MoveAddressType;
        owner_cap: stake.OwnerCapability;
        commission_percentage: bigint;
        distribution_pool: pool_u64.Pool;
        signer_cap: account.SignerCapability;
    }
    namespace StakingContract {
        const TYPE_QNAME = "0x1::staking_contract::StakingContract";
        function type(): TypeDescriptor<StakingContract>;
    }
    interface StakingGroupContainer {
        dummy_field: boolean;
    }
    namespace StakingGroupContainer {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupContainer";
        function type(): TypeDescriptor<StakingGroupContainer>;
    }
    interface StakingGroupUpdateCommissionEvent {
        update_commission_events: event.EventHandle<staking_contract.UpdateCommissionEvent>;
    }
    namespace StakingGroupUpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupUpdateCommissionEvent";
        function type(): TypeDescriptor<StakingGroupUpdateCommissionEvent>;
    }
    type StakingGroupUpdateCommissionEventInstance = TypedEventInstance<StakingGroupUpdateCommissionEvent> & {
        data_decoded: StakingGroupUpdateCommissionEvent;
        type_arguments: [];
    };
    interface Store {
        staking_contracts: simple_map.SimpleMap<MoveAddressType, staking_contract.StakingContract>;
        create_staking_contract_events: event.EventHandle<staking_contract.CreateStakingContractEvent>;
        update_voter_events: event.EventHandle<staking_contract.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<staking_contract.ResetLockupEvent>;
        add_stake_events: event.EventHandle<staking_contract.AddStakeEvent>;
        request_commission_events: event.EventHandle<staking_contract.RequestCommissionEvent>;
        unlock_stake_events: event.EventHandle<staking_contract.UnlockStakeEvent>;
        switch_operator_events: event.EventHandle<staking_contract.SwitchOperatorEvent>;
        add_distribution_events: event.EventHandle<staking_contract.AddDistributionEvent>;
        distribute_events: event.EventHandle<staking_contract.DistributeEvent>;
    }
    namespace Store {
        const TYPE_QNAME = "0x1::staking_contract::Store";
        function type(): TypeDescriptor<Store>;
    }
    interface SwitchOperator {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperator {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperator";
        function type(): TypeDescriptor<SwitchOperator>;
    }
    type SwitchOperatorInstance = TypedEventInstance<SwitchOperator> & {
        data_decoded: SwitchOperator;
        type_arguments: [];
    };
    interface SwitchOperatorEvent {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperatorEvent {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperatorEvent";
        function type(): TypeDescriptor<SwitchOperatorEvent>;
    }
    type SwitchOperatorEventInstance = TypedEventInstance<SwitchOperatorEvent> & {
        data_decoded: SwitchOperatorEvent;
        type_arguments: [];
    };
    interface UpdateCommission {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommission {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommission";
        function type(): TypeDescriptor<UpdateCommission>;
    }
    type UpdateCommissionInstance = TypedEventInstance<UpdateCommission> & {
        data_decoded: UpdateCommission;
        type_arguments: [];
    };
    interface UpdateCommissionEvent {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommissionEvent";
        function type(): TypeDescriptor<UpdateCommissionEvent>;
    }
    type UpdateCommissionEventInstance = TypedEventInstance<UpdateCommissionEvent> & {
        data_decoded: UpdateCommissionEvent;
        type_arguments: [];
    };
    interface UpdateVoter {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    type UpdateVoterInstance = TypedEventInstance<UpdateVoter> & {
        data_decoded: UpdateVoter;
        type_arguments: [];
    };
    interface UpdateVoterEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    type UpdateVoterEventInstance = TypedEventInstance<UpdateVoterEvent> & {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    };
    namespace entry {
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createStakingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType,
                bigint,
                bigint,
                string
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function requestCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommision(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function commissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function lastRecordedPrincipal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function pendingDistributionCounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function stakerAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<MoveAddressType>]>;
        function stakingContractAmounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function stakingContractExists(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface AddStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface CreateStakingContractPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType,
        bigint,
        bigint,
        string
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType,
            bigint,
            bigint,
            string
        ];
        type_arguments: [];
    }
    interface DistributePayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface RequestCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface ResetLockupPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SwitchOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, bigint];
        type_arguments: [];
    }
    interface SwitchOperatorWithSameCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateCommisionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
}
export declare namespace system_addresses {
    namespace entry { }
    namespace view { }
}
export declare namespace federated_keyless {
    interface PublicKey {
        jwk_address: MoveAddressType;
        keyless_public_key: keyless.PublicKey;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::federated_keyless::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config {
    interface ConfigOff {
        dummy_field: boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::randomness_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigV1 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV2 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
        fast_path_secrecy_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV2 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV2";
        function type(): TypeDescriptor<ConfigV2>;
    }
    interface RandomnessConfig {
        variant: copyable_any.Any;
    }
    namespace RandomnessConfig {
        const TYPE_QNAME = "0x1::randomness_config::RandomnessConfig";
        function type(): TypeDescriptor<RandomnessConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace table_with_length {
    interface TableWithLength<T0, T1> {
        inner: table.Table<T0, T1>;
        length: bigint;
    }
    namespace TableWithLength {
        const TYPE_QNAME = "0x1::table_with_length::TableWithLength";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<TableWithLength<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator_factory {
    interface AggregatorFactory {
        phantom_table: table.Table<MoveAddressType, bigint>;
    }
    namespace AggregatorFactory {
        const TYPE_QNAME = "0x1::aggregator_factory::AggregatorFactory";
        function type(): TypeDescriptor<AggregatorFactory>;
    }
    namespace entry { }
    namespace view { }
}
export declare class account_abstraction extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): account_abstraction;
    onEntryInitialize(func: (call: account_abstraction.InitializePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.InitializePayload>): account_abstraction;
    onEntryAddAuthenticationFunction(func: (call: account_abstraction.AddAuthenticationFunctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.AddAuthenticationFunctionPayload>): account_abstraction;
    onEntryAddDispatchableAuthenticationFunction(func: (call: account_abstraction.AddDispatchableAuthenticationFunctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.AddDispatchableAuthenticationFunctionPayload>): account_abstraction;
    onEntryRegisterDerivableAuthenticationFunction(func: (call: account_abstraction.RegisterDerivableAuthenticationFunctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RegisterDerivableAuthenticationFunctionPayload>): account_abstraction;
    onEntryRemoveAuthenticationFunction(func: (call: account_abstraction.RemoveAuthenticationFunctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RemoveAuthenticationFunctionPayload>): account_abstraction;
    onEntryRemoveAuthenticator(func: (call: account_abstraction.RemoveAuthenticatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RemoveAuthenticatorPayload>): account_abstraction;
    onEntryRemoveDispatchableAuthenticationFunction(func: (call: account_abstraction.RemoveDispatchableAuthenticationFunctionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RemoveDispatchableAuthenticationFunctionPayload>): account_abstraction;
    onEntryRemoveDispatchableAuthenticator(func: (call: account_abstraction.RemoveDispatchableAuthenticatorPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RemoveDispatchableAuthenticatorPayload>): account_abstraction;
    onEventRemoveDispatchableAuthenticator(func: (event: account_abstraction.RemoveDispatchableAuthenticatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.RemoveDispatchableAuthenticatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account_abstraction;
    onEventUpdateDispatchableAuthenticator(func: (event: account_abstraction.UpdateDispatchableAuthenticatorInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, account_abstraction.UpdateDispatchableAuthenticatorInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): account_abstraction;
}
export declare namespace account_abstraction {
    interface DerivableDispatchableAuthenticator {
    }
    namespace DerivableDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::DerivableDispatchableAuthenticator";
        function type(): TypeDescriptor<DerivableDispatchableAuthenticator>;
    }
    interface DerivableRegisterValue {
    }
    namespace DerivableRegisterValue {
        const TYPE_QNAME = "0x1::account_abstraction::DerivableRegisterValue";
        function type(): TypeDescriptor<DerivableRegisterValue>;
    }
    interface DispatchableAuthenticator {
    }
    namespace DispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::DispatchableAuthenticator";
        function type(): TypeDescriptor<DispatchableAuthenticator>;
    }
    interface RemoveDispatchableAuthenticator {
        account: MoveAddressType;
    }
    namespace RemoveDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::RemoveDispatchableAuthenticator";
        function type(): TypeDescriptor<RemoveDispatchableAuthenticator>;
    }
    type RemoveDispatchableAuthenticatorInstance = TypedEventInstance<RemoveDispatchableAuthenticator> & {
        data_decoded: RemoveDispatchableAuthenticator;
        type_arguments: [];
    };
    interface UpdateDispatchableAuthenticator {
        account: MoveAddressType;
        update: string;
        auth_function: function_info.FunctionInfo;
    }
    namespace UpdateDispatchableAuthenticator {
        const TYPE_QNAME = "0x1::account_abstraction::UpdateDispatchableAuthenticator";
        function type(): TypeDescriptor<UpdateDispatchableAuthenticator>;
    }
    type UpdateDispatchableAuthenticatorInstance = TypedEventInstance<UpdateDispatchableAuthenticator> & {
        data_decoded: UpdateDispatchableAuthenticator;
        type_arguments: [];
    };
    namespace entry {
        function initialize(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addDispatchableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function registerDerivableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeAuthenticator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDispatchableAuthenticationFunction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDispatchableAuthenticator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function deriveAccountAddressView(client: Aptos, request: {
            functionArguments: [MoveAddressType, string, string, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function dispatchableAuthenticator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[option.Option<function_info.FunctionInfo[]>]>;
        function usingDispatchableAuthenticator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface InitializePayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface AddAuthenticationFunctionPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface AddDispatchableAuthenticationFunctionPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface RegisterDerivableAuthenticationFunctionPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface RemoveAuthenticationFunctionPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface RemoveAuthenticatorPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RemoveDispatchableAuthenticationFunctionPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface RemoveDispatchableAuthenticatorPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
}
export declare class governance_proposal extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): governance_proposal;
    onEventGovernanceProposal(func: (event: governance_proposal.GovernanceProposalInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, governance_proposal.GovernanceProposalInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): governance_proposal;
}
export declare namespace governance_proposal {
    interface GovernanceProposal {
        dummy_field: boolean;
    }
    namespace GovernanceProposal {
        const TYPE_QNAME = "0x1::governance_proposal::GovernanceProposal";
        function type(): TypeDescriptor<GovernanceProposal>;
    }
    type GovernanceProposalInstance = TypedEventInstance<GovernanceProposal> & {
        data_decoded: GovernanceProposal;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare namespace optional_aggregator {
    interface Integer {
        value: bigint;
        limit: bigint;
    }
    namespace Integer {
        const TYPE_QNAME = "0x1::optional_aggregator::Integer";
        function type(): TypeDescriptor<Integer>;
    }
    interface OptionalAggregator {
        aggregator: option.Option<aggregator.Aggregator>;
        integer: option.Option<optional_aggregator.Integer>;
    }
    namespace OptionalAggregator {
        const TYPE_QNAME = "0x1::optional_aggregator::OptionalAggregator";
        function type(): TypeDescriptor<OptionalAggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare class permissioned_signer extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): permissioned_signer;
    onEntryRevokeAllHandles(func: (call: permissioned_signer.RevokeAllHandlesPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, permissioned_signer.RevokeAllHandlesPayload>): permissioned_signer;
    onEntryRevokePermissionStorageAddress(func: (call: permissioned_signer.RevokePermissionStorageAddressPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, permissioned_signer.RevokePermissionStorageAddressPayload>): permissioned_signer;
}
export declare namespace permissioned_signer {
    interface GrantedPermissionHandles {
        active_handles: MoveAddressType[];
    }
    namespace GrantedPermissionHandles {
        const TYPE_QNAME = "0x1::permissioned_signer::GrantedPermissionHandles";
        function type(): TypeDescriptor<GrantedPermissionHandles>;
    }
    interface PermissionStorage {
    }
    namespace PermissionStorage {
        const TYPE_QNAME = "0x1::permissioned_signer::PermissionStorage";
        function type(): TypeDescriptor<PermissionStorage>;
    }
    interface PermissionedHandle {
    }
    namespace PermissionedHandle {
        const TYPE_QNAME = "0x1::permissioned_signer::PermissionedHandle";
        function type(): TypeDescriptor<PermissionedHandle>;
    }
    interface RevokePermissionHandlePermission {
        dummy_field: boolean;
    }
    namespace RevokePermissionHandlePermission {
        const TYPE_QNAME = "0x1::permissioned_signer::RevokePermissionHandlePermission";
        function type(): TypeDescriptor<RevokePermissionHandlePermission>;
    }
    interface StorablePermissionedHandle {
    }
    namespace StorablePermissionedHandle {
        const TYPE_QNAME = "0x1::permissioned_signer::StorablePermissionedHandle";
        function type(): TypeDescriptor<StorablePermissionedHandle>;
    }
    interface StoredPermission {
    }
    namespace StoredPermission {
        const TYPE_QNAME = "0x1::permissioned_signer::StoredPermission";
        function type(): TypeDescriptor<StoredPermission>;
    }
    namespace entry {
        function revokeAllHandles(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokePermissionStorageAddress(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface RevokeAllHandlesPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RevokePermissionStorageAddressPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
}
export declare class transaction_context extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): transaction_context;
    onEventAUID(func: (event: transaction_context.AUIDInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, transaction_context.AUIDInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): transaction_context;
}
export declare namespace transaction_context {
    interface AUID {
        unique_address: MoveAddressType;
    }
    namespace AUID {
        const TYPE_QNAME = "0x1::transaction_context::AUID";
        function type(): TypeDescriptor<AUID>;
    }
    type AUIDInstance = TypedEventInstance<AUID> & {
        data_decoded: AUID;
        type_arguments: [];
    };
    interface EntryFunctionPayload {
        account_address: MoveAddressType;
        module_name: string;
        function_name: string;
        ty_args_names: string[];
        args: string[];
    }
    namespace EntryFunctionPayload {
        const TYPE_QNAME = "0x1::transaction_context::EntryFunctionPayload";
        function type(): TypeDescriptor<EntryFunctionPayload>;
    }
    interface MultisigPayload {
        multisig_address: MoveAddressType;
        entry_function_payload: option.Option<transaction_context.EntryFunctionPayload>;
    }
    namespace MultisigPayload {
        const TYPE_QNAME = "0x1::transaction_context::MultisigPayload";
        function type(): TypeDescriptor<MultisigPayload>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace jwk_consensus_config {
    interface ConfigOff {
        dummy_field: boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigV1 {
        oidc_providers: jwk_consensus_config.OIDCProvider[];
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwk_consensus_config::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface JWKConsensusConfig {
        variant: copyable_any.Any;
    }
    namespace JWKConsensusConfig {
        const TYPE_QNAME = "0x1::jwk_consensus_config::JWKConsensusConfig";
        function type(): TypeDescriptor<JWKConsensusConfig>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_elgamal {
    interface Ciphertext {
        left: ristretto255.RistrettoPoint;
        right: ristretto255.RistrettoPoint;
    }
    namespace Ciphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::Ciphertext";
        function type(): TypeDescriptor<Ciphertext>;
    }
    interface CompressedCiphertext {
        left: ristretto255.CompressedRistretto;
        right: ristretto255.CompressedRistretto;
    }
    namespace CompressedCiphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedCiphertext";
        function type(): TypeDescriptor<CompressedCiphertext>;
    }
    interface CompressedPubkey {
        point: ristretto255.CompressedRistretto;
    }
    namespace CompressedPubkey {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedPubkey";
        function type(): TypeDescriptor<CompressedPubkey>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_state {
    interface State {
        variant: copyable_any.Any;
    }
    namespace State {
        const TYPE_QNAME = "0x1::reconfiguration_state::State";
        function type(): TypeDescriptor<State>;
    }
    interface StateActive {
        start_time_secs: bigint;
    }
    namespace StateActive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateActive";
        function type(): TypeDescriptor<StateActive>;
    }
    interface StateInactive {
        dummy_field: boolean;
    }
    namespace StateInactive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateInactive";
        function type(): TypeDescriptor<StateInactive>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_pedersen {
    interface Commitment {
        point: ristretto255.RistrettoPoint;
    }
    namespace Commitment {
        const TYPE_QNAME = "0x1::ristretto255_pedersen::Commitment";
        function type(): TypeDescriptor<Commitment>;
    }
    namespace entry { }
    namespace view { }
}
export declare class object_code_deployment extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): object_code_deployment;
    onEntryFreezeCodeObject(func: (call: object_code_deployment.FreezeCodeObjectPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.FreezeCodeObjectPayload>): object_code_deployment;
    onEntryPublish(func: (call: object_code_deployment.PublishPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.PublishPayload>): object_code_deployment;
    onEntryUpgrade(func: (call: object_code_deployment.UpgradePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.UpgradePayload>): object_code_deployment;
    onEventFreeze(func: (event: object_code_deployment.FreezeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.FreezeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object_code_deployment;
    onEventPublish(func: (event: object_code_deployment.PublishInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.PublishInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object_code_deployment;
    onEventUpgrade(func: (event: object_code_deployment.UpgradeInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, object_code_deployment.UpgradeInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): object_code_deployment;
}
export declare namespace object_code_deployment {
    interface Freeze {
        object_address: MoveAddressType;
    }
    namespace Freeze {
        const TYPE_QNAME = "0x1::object_code_deployment::Freeze";
        function type(): TypeDescriptor<Freeze>;
    }
    type FreezeInstance = TypedEventInstance<Freeze> & {
        data_decoded: Freeze;
        type_arguments: [];
    };
    interface ManagingRefs {
        extend_ref: object$.ExtendRef;
    }
    namespace ManagingRefs {
        const TYPE_QNAME = "0x1::object_code_deployment::ManagingRefs";
        function type(): TypeDescriptor<ManagingRefs>;
    }
    interface Publish {
        object_address: MoveAddressType;
    }
    namespace Publish {
        const TYPE_QNAME = "0x1::object_code_deployment::Publish";
        function type(): TypeDescriptor<Publish>;
    }
    type PublishInstance = TypedEventInstance<Publish> & {
        data_decoded: Publish;
        type_arguments: [];
    };
    interface Upgrade {
        object_address: MoveAddressType;
    }
    namespace Upgrade {
        const TYPE_QNAME = "0x1::object_code_deployment::Upgrade";
        function type(): TypeDescriptor<Upgrade>;
    }
    type UpgradeInstance = TypedEventInstance<Upgrade> & {
        data_decoded: Upgrade;
        type_arguments: [];
    };
    namespace entry {
        function freezeCodeObject(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [object$.Object<code.PackageRegistry>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function publish(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgrade(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string[],
                object$.Object<code.PackageRegistry>
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
    interface FreezeCodeObjectPayload extends TypedFunctionPayload<[object$.Object<code.PackageRegistry>]> {
        arguments_decoded: [object$.Object<code.PackageRegistry>];
        type_arguments: [];
    }
    interface PublishPayload extends TypedFunctionPayload<[string, string[]]> {
        arguments_decoded: [string, string[]];
        type_arguments: [];
    }
    interface UpgradePayload extends TypedFunctionPayload<[
        string,
        string[],
        object$.Object<code.PackageRegistry>
    ]> {
        arguments_decoded: [string, string[], object$.Object<code.PackageRegistry>];
        type_arguments: [];
    }
}
export declare class primary_fungible_store extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): primary_fungible_store;
    onEntryTransfer(func: (call: primary_fungible_store.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, primary_fungible_store.TransferPayload>): primary_fungible_store;
    onEntryTransferAssertMinimumDeposit(func: (call: primary_fungible_store.TransferAssertMinimumDepositPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, primary_fungible_store.TransferAssertMinimumDepositPayload>): primary_fungible_store;
}
export declare namespace primary_fungible_store {
    interface DeriveRefPod {
        metadata_derive_ref: object$.DeriveRef;
    }
    namespace DeriveRefPod {
        const TYPE_QNAME = "0x1::primary_fungible_store::DeriveRefPod";
        function type(): TypeDescriptor<DeriveRefPod>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object$.Object<T0>,
                MoveAddressType,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function primaryStore<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[object$.Object<fungible_asset.FungibleStore>]>;
        function primaryStoreAddress<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function primaryStoreExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object$.Object<T0>,
        MoveAddressType,
        bigint
    ]> {
        arguments_decoded: [object$.Object<T0>, MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface TransferAssertMinimumDepositPayload<T0 = any> extends TypedFunctionPayload<[
        object$.Object<T0>,
        MoveAddressType,
        bigint,
        bigint
    ]> {
        arguments_decoded: [object$.Object<T0>, MoveAddressType, bigint, bigint];
        type_arguments: [string];
    }
}
export declare namespace transaction_validation {
    interface GasPermission {
        dummy_field: boolean;
    }
    namespace GasPermission {
        const TYPE_QNAME = "0x1::transaction_validation::GasPermission";
        function type(): TypeDescriptor<GasPermission>;
    }
    interface ReplayProtector {
    }
    namespace ReplayProtector {
        const TYPE_QNAME = "0x1::transaction_validation::ReplayProtector";
        function type(): TypeDescriptor<ReplayProtector>;
    }
    interface TransactionValidation {
        module_addr: MoveAddressType;
        module_name: string;
        script_prologue_name: string;
        module_prologue_name: string;
        multi_agent_prologue_name: string;
        user_epilogue_name: string;
    }
    namespace TransactionValidation {
        const TYPE_QNAME = "0x1::transaction_validation::TransactionValidation";
        function type(): TypeDescriptor<TransactionValidation>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace permissioned_delegation {
    interface AccountDelegation {
    }
    namespace AccountDelegation {
        const TYPE_QNAME = "0x1::permissioned_delegation::AccountDelegation";
        function type(): TypeDescriptor<AccountDelegation>;
    }
    interface DelegationKey {
    }
    namespace DelegationKey {
        const TYPE_QNAME = "0x1::permissioned_delegation::DelegationKey";
        function type(): TypeDescriptor<DelegationKey>;
    }
    interface RegisteredDelegations {
        delegations: big_ordered_map.BigOrderedMap<permissioned_delegation.DelegationKey, permissioned_delegation.AccountDelegation>;
    }
    namespace RegisteredDelegations {
        const TYPE_QNAME = "0x1::permissioned_delegation::RegisteredDelegations";
        function type(): TypeDescriptor<RegisteredDelegations>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace storage_slots_allocator {
    interface Link<T0> {
    }
    namespace Link {
        const TYPE_QNAME = "0x1::storage_slots_allocator::Link";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Link<T0>>;
    }
    interface ReservedSlot {
        slot_index: bigint;
    }
    namespace ReservedSlot {
        const TYPE_QNAME = "0x1::storage_slots_allocator::ReservedSlot";
        function type(): TypeDescriptor<ReservedSlot>;
    }
    interface StorageSlotsAllocator<T0> {
    }
    namespace StorageSlotsAllocator {
        const TYPE_QNAME = "0x1::storage_slots_allocator::StorageSlotsAllocator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<StorageSlotsAllocator<T0>>;
    }
    interface StoredSlot {
        slot_index: bigint;
    }
    namespace StoredSlot {
        const TYPE_QNAME = "0x1::storage_slots_allocator::StoredSlot";
        function type(): TypeDescriptor<StoredSlot>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_api_v0_config {
    interface AllowCustomMaxGasFlag {
        value: boolean;
    }
    namespace AllowCustomMaxGasFlag {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::AllowCustomMaxGasFlag";
        function type(): TypeDescriptor<AllowCustomMaxGasFlag>;
    }
    interface RequiredGasDeposit {
        gas_amount: option.Option<bigint>;
    }
    namespace RequiredGasDeposit {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::RequiredGasDeposit";
        function type(): TypeDescriptor<RequiredGasDeposit>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config_seqnum {
    interface RandomnessConfigSeqNum {
        seq_num: bigint;
    }
    namespace RandomnessConfigSeqNum {
        const TYPE_QNAME = "0x1::randomness_config_seqnum::RandomnessConfigSeqNum";
        function type(): TypeDescriptor<RandomnessConfigSeqNum>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_with_dkg {
    namespace entry { }
    namespace view { }
}
export declare namespace solana_derivable_account {
    interface SIWSAbstractSignature {
    }
    namespace SIWSAbstractSignature {
        const TYPE_QNAME = "0x1::solana_derivable_account::SIWSAbstractSignature";
        function type(): TypeDescriptor<SIWSAbstractSignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace validator_consensus_info {
    interface ValidatorConsensusInfo {
        addr: MoveAddressType;
        pk_bytes: string;
        voting_power: bigint;
    }
    namespace ValidatorConsensusInfo {
        const TYPE_QNAME = "0x1::validator_consensus_info::ValidatorConsensusInfo";
        function type(): TypeDescriptor<ValidatorConsensusInfo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_bulletproofs {
    interface RangeProof {
        bytes: string;
    }
    namespace RangeProof {
        const TYPE_QNAME = "0x1::ristretto255_bulletproofs::RangeProof";
        function type(): TypeDescriptor<RangeProof>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ethereum_derivable_account {
    interface SIWEAbstractPublicKey {
        ethereum_address: string;
        domain: string;
    }
    namespace SIWEAbstractPublicKey {
        const TYPE_QNAME = "0x1::ethereum_derivable_account::SIWEAbstractPublicKey";
        function type(): TypeDescriptor<SIWEAbstractPublicKey>;
    }
    interface SIWEAbstractSignature {
    }
    namespace SIWEAbstractSignature {
        const TYPE_QNAME = "0x1::ethereum_derivable_account::SIWEAbstractSignature";
        function type(): TypeDescriptor<SIWEAbstractSignature>;
    }
    namespace entry { }
    namespace view { }
}
export declare class dispatchable_fungible_asset extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): dispatchable_fungible_asset;
    onEntryTransfer(func: (call: dispatchable_fungible_asset.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, dispatchable_fungible_asset.TransferPayload>): dispatchable_fungible_asset;
    onEntryTransferAssertMinimumDeposit(func: (call: dispatchable_fungible_asset.TransferAssertMinimumDepositPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, dispatchable_fungible_asset.TransferAssertMinimumDepositPayload>): dispatchable_fungible_asset;
}
export declare namespace dispatchable_fungible_asset {
    interface TransferRefStore {
        transfer_ref: fungible_asset.TransferRef;
    }
    namespace TransferRefStore {
        const TYPE_QNAME = "0x1::dispatchable_fungible_asset::TransferRefStore";
        function type(): TypeDescriptor<TransferRefStore>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, object$.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object$.Object<T0>,
                object$.Object<T0>,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function derivedBalance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function derivedSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function isDerivedBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object$.Object<T0>, bigint];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object$.Object<T0>,
        object$.Object<T0>,
        bigint
    ]> {
        arguments_decoded: [object$.Object<T0>, object$.Object<T0>, bigint];
        type_arguments: [string];
    }
    interface TransferAssertMinimumDepositPayload<T0 = any> extends TypedFunctionPayload<[
        object$.Object<T0>,
        object$.Object<T0>,
        bigint,
        bigint
    ]> {
        arguments_decoded: [object$.Object<T0>, object$.Object<T0>, bigint, bigint];
        type_arguments: [string];
    }
}
export declare namespace common_account_abstractions_utils {
    namespace entry { }
    namespace view { }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map