import { CallFilter, MoveFetchConfig, EventFilter } from "@sentio/sdk/move";
import { HandlerOptions } from "@sentio/sdk";
import { AptosBindOptions, AptosBaseProcessor, TypedFunctionPayload, AptosContext } from "@sentio/sdk/aptos";
import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId } from "@aptos-labs/ts-sdk";
import * as _0x1 from "./0x1.js";
export declare class token extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): token;
    onEventBurnRef(func: (event: token.BurnRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, token.BurnRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): token;
    onEventMutatorRef(func: (event: token.MutatorRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, token.MutatorRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): token;
    onEventMutation(func: (event: token.MutationInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, token.MutationInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): token;
    onEventMutationEvent(func: (event: token.MutationEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, token.MutationEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): token;
}
export declare namespace token {
    interface BurnRef {
        inner: _0x1.option.Option<_0x1.object$.DeleteRef>;
        self: _0x1.option.Option<MoveAddressType>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x4::token::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    type BurnRefInstance = TypedEventInstance<BurnRef> & {
        data_decoded: BurnRef;
        type_arguments: [];
    };
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::token::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    type MutatorRefInstance = TypedEventInstance<MutatorRef> & {
        data_decoded: MutatorRef;
        type_arguments: [];
    };
    interface Mutation {
        token_address: MoveAddressType;
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::token::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    type MutationInstance = TypedEventInstance<Mutation> & {
        data_decoded: Mutation;
        type_arguments: [];
    };
    interface MutationEvent {
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::token::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    type MutationEventInstance = TypedEventInstance<MutationEvent> & {
        data_decoded: MutationEvent;
        type_arguments: [];
    };
    interface ConcurrentTokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.AggregatorSnapshot<string>;
    }
    namespace ConcurrentTokenIdentifiers {
        const TYPE_QNAME = "0x4::token::ConcurrentTokenIdentifiers";
        function type(): TypeDescriptor<ConcurrentTokenIdentifiers>;
    }
    interface Token {
        collection: _0x1.object$.Object<collection.Collection>;
        index: bigint;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<token.MutationEvent>;
    }
    namespace Token {
        const TYPE_QNAME = "0x4::token::Token";
        function type(): TypeDescriptor<Token>;
    }
    interface TokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.DerivedStringSnapshot;
    }
    namespace TokenIdentifiers {
        const TYPE_QNAME = "0x4::token::TokenIdentifiers";
        function type(): TypeDescriptor<TokenIdentifiers>;
    }
    namespace entry { }
    namespace view {
        function index<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function creator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function royalty<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[_0x1.option.Option<royalty.Royalty>]>;
        function description<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function uri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function collectionName<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function collectionObject<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[_0x1.object$.Object<collection.Collection>]>;
        function createTokenAddressWithSeed(client: Aptos, request: {
            functionArguments: [MoveAddressType, string, string, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
    }
}
export declare class royalty extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): royalty;
    onEventMutatorRef(func: (event: royalty.MutatorRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, royalty.MutatorRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): royalty;
}
export declare namespace royalty {
    interface MutatorRef {
        inner: _0x1.object$.ExtendRef;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::royalty::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    type MutatorRefInstance = TypedEventInstance<MutatorRef> & {
        data_decoded: MutatorRef;
        type_arguments: [];
    };
    interface Royalty {
        numerator: bigint;
        denominator: bigint;
        payee_address: MoveAddressType;
    }
    namespace Royalty {
        const TYPE_QNAME = "0x4::royalty::Royalty";
        function type(): TypeDescriptor<Royalty>;
    }
    namespace entry { }
    namespace view { }
}
export declare class collection extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): collection;
    onEventMutatorRef(func: (event: collection.MutatorRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.MutatorRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventBurn(func: (event: collection.BurnInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.BurnInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventBurnEvent(func: (event: collection.BurnEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.BurnEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventConcurrentBurnEvent(func: (event: collection.ConcurrentBurnEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.ConcurrentBurnEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventConcurrentMintEvent(func: (event: collection.ConcurrentMintEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.ConcurrentMintEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventMint(func: (event: collection.MintInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.MintInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventMintEvent(func: (event: collection.MintEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.MintEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventMutation(func: (event: collection.MutationInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.MutationInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventMutationEvent(func: (event: collection.MutationEventInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.MutationEventInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
    onEventSetMaxSupply(func: (event: collection.SetMaxSupplyInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, collection.SetMaxSupplyInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): collection;
}
export declare namespace collection {
    interface ConcurrentSupply {
        current_supply: _0x1.aggregator_v2.Aggregator<bigint>;
        total_minted: _0x1.aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x4::collection::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::collection::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    type MutatorRefInstance = TypedEventInstance<MutatorRef> & {
        data_decoded: MutatorRef;
        type_arguments: [];
    };
    interface Burn {
        collection: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
        previous_owner: MoveAddressType;
    }
    namespace Burn {
        const TYPE_QNAME = "0x4::collection::Burn";
        function type(): TypeDescriptor<Burn>;
    }
    type BurnInstance = TypedEventInstance<Burn> & {
        data_decoded: Burn;
        type_arguments: [];
    };
    interface BurnEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace BurnEvent {
        const TYPE_QNAME = "0x4::collection::BurnEvent";
        function type(): TypeDescriptor<BurnEvent>;
    }
    type BurnEventInstance = TypedEventInstance<BurnEvent> & {
        data_decoded: BurnEvent;
        type_arguments: [];
    };
    interface Collection {
        creator: MoveAddressType;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<collection.MutationEvent>;
    }
    namespace Collection {
        const TYPE_QNAME = "0x4::collection::Collection";
        function type(): TypeDescriptor<Collection>;
    }
    interface ConcurrentBurnEvent {
        collection_addr: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
    }
    namespace ConcurrentBurnEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentBurnEvent";
        function type(): TypeDescriptor<ConcurrentBurnEvent>;
    }
    type ConcurrentBurnEventInstance = TypedEventInstance<ConcurrentBurnEvent> & {
        data_decoded: ConcurrentBurnEvent;
        type_arguments: [];
    };
    interface ConcurrentMintEvent {
        collection_addr: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace ConcurrentMintEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentMintEvent";
        function type(): TypeDescriptor<ConcurrentMintEvent>;
    }
    type ConcurrentMintEventInstance = TypedEventInstance<ConcurrentMintEvent> & {
        data_decoded: ConcurrentMintEvent;
        type_arguments: [];
    };
    interface FixedSupply {
        current_supply: bigint;
        max_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace FixedSupply {
        const TYPE_QNAME = "0x4::collection::FixedSupply";
        function type(): TypeDescriptor<FixedSupply>;
    }
    interface Mint {
        collection: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace Mint {
        const TYPE_QNAME = "0x4::collection::Mint";
        function type(): TypeDescriptor<Mint>;
    }
    type MintInstance = TypedEventInstance<Mint> & {
        data_decoded: Mint;
        type_arguments: [];
    };
    interface MintEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace MintEvent {
        const TYPE_QNAME = "0x4::collection::MintEvent";
        function type(): TypeDescriptor<MintEvent>;
    }
    type MintEventInstance = TypedEventInstance<MintEvent> & {
        data_decoded: MintEvent;
        type_arguments: [];
    };
    interface Mutation {
        mutated_field_name: string;
        collection: _0x1.object$.Object<collection.Collection>;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::collection::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    type MutationInstance = TypedEventInstance<Mutation> & {
        data_decoded: Mutation;
        type_arguments: [];
    };
    interface MutationEvent {
        mutated_field_name: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::collection::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    type MutationEventInstance = TypedEventInstance<MutationEvent> & {
        data_decoded: MutationEvent;
        type_arguments: [];
    };
    interface SetMaxSupply {
        collection: _0x1.object$.Object<collection.Collection>;
        old_max_supply: bigint;
        new_max_supply: bigint;
    }
    namespace SetMaxSupply {
        const TYPE_QNAME = "0x4::collection::SetMaxSupply";
        function type(): TypeDescriptor<SetMaxSupply>;
    }
    type SetMaxSupplyInstance = TypedEventInstance<SetMaxSupply> & {
        data_decoded: SetMaxSupply;
        type_arguments: [];
    };
    interface UnlimitedSupply {
        current_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace UnlimitedSupply {
        const TYPE_QNAME = "0x4::collection::UnlimitedSupply";
        function type(): TypeDescriptor<UnlimitedSupply>;
    }
    namespace entry { }
    namespace view {
        function count<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[_0x1.option.Option<bigint>]>;
        function creator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function description<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function uri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[string]>;
    }
}
export declare class aptos_token extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_token;
    onEntryBurn(func: (call: aptos_token.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.BurnPayload>): aptos_token;
    onEntryMint(func: (call: aptos_token.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.MintPayload>): aptos_token;
    onEntrySetDescription(func: (call: aptos_token.SetDescriptionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetDescriptionPayload>): aptos_token;
    onEntrySetName(func: (call: aptos_token.SetNamePayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetNamePayload>): aptos_token;
    onEntrySetUri(func: (call: aptos_token.SetUriPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetUriPayload>): aptos_token;
    onEntryAddProperty(func: (call: aptos_token.AddPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.AddPropertyPayload>): aptos_token;
    onEntryAddTypedProperty(func: (call: aptos_token.AddTypedPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.AddTypedPropertyPayload>): aptos_token;
    onEntryCreateCollection(func: (call: aptos_token.CreateCollectionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.CreateCollectionPayload>): aptos_token;
    onEntryFreezeTransfer(func: (call: aptos_token.FreezeTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.FreezeTransferPayload>): aptos_token;
    onEntryMintSoulBound(func: (call: aptos_token.MintSoulBoundPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.MintSoulBoundPayload>): aptos_token;
    onEntryRemoveProperty(func: (call: aptos_token.RemovePropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.RemovePropertyPayload>): aptos_token;
    onEntrySetCollectionDescription(func: (call: aptos_token.SetCollectionDescriptionPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetCollectionDescriptionPayload>): aptos_token;
    onEntrySetCollectionRoyaltiesCall(func: (call: aptos_token.SetCollectionRoyaltiesCallPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetCollectionRoyaltiesCallPayload>): aptos_token;
    onEntrySetCollectionUri(func: (call: aptos_token.SetCollectionUriPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.SetCollectionUriPayload>): aptos_token;
    onEntryUnfreezeTransfer(func: (call: aptos_token.UnfreezeTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.UnfreezeTransferPayload>): aptos_token;
    onEntryUpdateProperty(func: (call: aptos_token.UpdatePropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.UpdatePropertyPayload>): aptos_token;
    onEntryUpdateTypedProperty(func: (call: aptos_token.UpdateTypedPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, handlerOptions?: HandlerOptions<MoveFetchConfig, aptos_token.UpdateTypedPropertyPayload>): aptos_token;
}
export declare namespace aptos_token {
    interface AptosCollection {
        mutator_ref: _0x1.option.Option<collection.MutatorRef>;
        royalty_mutator_ref: _0x1.option.Option<royalty.MutatorRef>;
        mutable_description: boolean;
        mutable_uri: boolean;
        mutable_token_description: boolean;
        mutable_token_name: boolean;
        mutable_token_properties: boolean;
        mutable_token_uri: boolean;
        tokens_burnable_by_creator: boolean;
        tokens_freezable_by_creator: boolean;
    }
    namespace AptosCollection {
        const TYPE_QNAME = "0x4::aptos_token::AptosCollection";
        function type(): TypeDescriptor<AptosCollection>;
    }
    interface AptosToken {
        burn_ref: _0x1.option.Option<token.BurnRef>;
        transfer_ref: _0x1.option.Option<_0x1.object$.TransferRef>;
        mutator_ref: _0x1.option.Option<token.MutatorRef>;
        property_mutator_ref: property_map.MutatorRef;
    }
    namespace AptosToken {
        const TYPE_QNAME = "0x4::aptos_token::AptosToken";
        function type(): TypeDescriptor<AptosToken>;
    }
    namespace entry {
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string,
                string,
                string,
                string[],
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDescription<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setName<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setUri<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addTypedProperty<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string, T1];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createCollection(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                bigint,
                string,
                string,
                boolean,
                boolean,
                boolean,
                boolean,
                boolean,
                boolean,
                boolean,
                boolean,
                boolean,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function freezeTransfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mintSoulBound(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string,
                string,
                string,
                string[],
                string[],
                string[],
                MoveAddressType
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionDescription<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionRoyaltiesCall<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                _0x1.object$.Object<T0>,
                bigint,
                bigint,
                MoveAddressType
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionUri<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unfreezeTransfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateTypedProperty<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>, string, T1];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function arePropertiesMutable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isBurnable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isFreezableByCreator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isMutableDescription<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isMutableName<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
        function isMutableUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object$.Object<T0>];
        }, version?: bigint): Promise<[boolean]>;
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>]> {
        arguments_decoded: [_0x1.object$.Object<T0>];
        type_arguments: [string];
    }
    interface MintPayload extends TypedFunctionPayload<[
        string,
        string,
        string,
        string,
        string[],
        string[],
        string[]
    ]> {
        arguments_decoded: [
            string,
            string,
            string,
            string,
            string[],
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface SetDescriptionPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetNamePayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetUriPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface AddPropertyPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object$.Object<T0>,
        string,
        string,
        string
    ]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string, string, string];
        type_arguments: [string];
    }
    interface AddTypedPropertyPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string, T1]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string, T1];
        type_arguments: [string, string];
    }
    interface CreateCollectionPayload extends TypedFunctionPayload<[
        string,
        bigint,
        string,
        string,
        boolean,
        boolean,
        boolean,
        boolean,
        boolean,
        boolean,
        boolean,
        boolean,
        boolean,
        bigint,
        bigint
    ]> {
        arguments_decoded: [
            string,
            bigint,
            string,
            string,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            bigint,
            bigint
        ];
        type_arguments: [];
    }
    interface FreezeTransferPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>]> {
        arguments_decoded: [_0x1.object$.Object<T0>];
        type_arguments: [string];
    }
    interface MintSoulBoundPayload extends TypedFunctionPayload<[
        string,
        string,
        string,
        string,
        string[],
        string[],
        string[],
        MoveAddressType
    ]> {
        arguments_decoded: [
            string,
            string,
            string,
            string,
            string[],
            string[],
            string[],
            MoveAddressType
        ];
        type_arguments: [];
    }
    interface RemovePropertyPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetCollectionDescriptionPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetCollectionRoyaltiesCallPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object$.Object<T0>,
        bigint,
        bigint,
        MoveAddressType
    ]> {
        arguments_decoded: [
            _0x1.object$.Object<T0>,
            bigint,
            bigint,
            MoveAddressType
        ];
        type_arguments: [string];
    }
    interface SetCollectionUriPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string];
        type_arguments: [string];
    }
    interface UnfreezeTransferPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>]> {
        arguments_decoded: [_0x1.object$.Object<T0>];
        type_arguments: [string];
    }
    interface UpdatePropertyPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object$.Object<T0>,
        string,
        string,
        string
    ]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string, string, string];
        type_arguments: [string];
    }
    interface UpdateTypedPropertyPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[_0x1.object$.Object<T0>, string, T1]> {
        arguments_decoded: [_0x1.object$.Object<T0>, string, T1];
        type_arguments: [string, string];
    }
}
export declare class property_map extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): property_map;
    onEventMutatorRef(func: (event: property_map.MutatorRefInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, property_map.MutatorRefInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): property_map;
    onEventPropertyValue(func: (event: property_map.PropertyValueInstance, ctx: AptosContext) => void, handlerOptions?: HandlerOptions<MoveFetchConfig, property_map.PropertyValueInstance>, eventFilter?: Omit<EventFilter, "type" | "account">): property_map;
}
export declare namespace property_map {
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::property_map::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    type MutatorRefInstance = TypedEventInstance<MutatorRef> & {
        data_decoded: MutatorRef;
        type_arguments: [];
    };
    interface PropertyMap {
        inner: _0x1.simple_map.SimpleMap<string, property_map.PropertyValue>;
    }
    namespace PropertyMap {
        const TYPE_QNAME = "0x4::property_map::PropertyMap";
        function type(): TypeDescriptor<PropertyMap>;
    }
    interface PropertyValue {
        type: number;
        value: string;
    }
    namespace PropertyValue {
        const TYPE_QNAME = "0x4::property_map::PropertyValue";
        function type(): TypeDescriptor<PropertyValue>;
    }
    type PropertyValueInstance = TypedEventInstance<PropertyValue> & {
        data_decoded: PropertyValue;
        type_arguments: [];
    };
    namespace entry { }
    namespace view { }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x4.d.ts.map