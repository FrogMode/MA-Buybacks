import { getPriceByType } from '../../utils/index.js';
import fetch from 'node-fetch';
import { accountTypeString, parseMoveType, SPLITTER } from '@typemove/move';
import { AptosNetwork, getClient } from '../network.js';
import { coin, fungible_asset } from '../builtin/0x1.js';
import { AptosChainId } from '@sentio/chain';
import { DEFAULT_TOKEN_LIST } from './token-list.js';
const TOKEN_MAP = new Map();
export async function initTokenList() {
    let list = DEFAULT_TOKEN_LIST;
    try {
        const resp = await fetch('https://raw.githubusercontent.com/PanoraExchange/Aptos-Tokens/refs/heads/main/token-list.json');
        list = (await resp.json());
    }
    catch (e) {
        console.warn("Can't not fetch newest token list, use default list");
    }
    setTokenList(list);
}
function tokenInfoToSimple(info) {
    const type = info.tokenAddress || info.faAddress;
    if (!type) {
        throw Error('Token info must have tokenAddress or faAddress');
    }
    return {
        type,
        tokenAddress: info.tokenAddress || undefined,
        faAddress: info.faAddress || undefined,
        name: info.name,
        symbol: info.panoraSymbol,
        decimals: info.decimals,
        bridge: info.bridge === null ? 'Native' : info.bridge,
        logoUrl: info.logoUrl || undefined,
        websiteUrl: info.websiteUrl || undefined,
        category: info.category,
        coinGeckoId: info.coinGeckoId || undefined,
        coinMarketCapId: info.coinMarketCapId == null ? undefined : info.coinMarketCapId
    };
}
function setTokenList(list) {
    for (const info of list) {
        const simpleInfo = tokenInfoToSimple(info);
        if (simpleInfo.tokenAddress ===
            '0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::stapt_token::StakedApt' &&
            simpleInfo.symbol === 'stAPT') {
            simpleInfo.symbol = 'amStApt';
        }
        if (info.tokenAddress) {
            TOKEN_MAP.set(info.tokenAddress, simpleInfo);
        }
        if (info.faAddress) {
            TOKEN_MAP.set(info.faAddress, simpleInfo);
        }
    }
}
export function whitelistTokens() {
    return TOKEN_MAP;
}
export function isWhiteListToken(token) {
    if (token.includes(SPLITTER)) {
        const [addr, module, type] = token.split(SPLITTER);
        const normalized = [accountTypeString(addr), module, type].join(SPLITTER);
        return TOKEN_MAP.has(normalized);
    }
    return TOKEN_MAP.has(accountTypeString(token));
}
const TOKEN_METADATA_CACHE = new Map();
// Go to more common method
function toTypeString(ty) {
    const module = Buffer.from(ty.module_name.replace('0x', ''), 'hex');
    const name = Buffer.from(ty.struct_name.replace('0x', ''), 'hex');
    return `${ty.account_address}::${module.toString('utf-8')}::${name.toString('utf-8')}`;
}
async function getFungibleTokenInfo(client, faAddress) {
    const meta = await client.getTypedAccountResource({
        accountAddress: faAddress,
        resourceType: fungible_asset.Metadata.type()
    });
    if (!meta) {
        throw Error('fa token not existed: ' + faAddress);
    }
    const paired = await coin.view.pairedCoin(client, { functionArguments: [faAddress] });
    let type = faAddress;
    let tokeType;
    if (paired[0].vec[0]) {
        tokeType = type = toTypeString(paired[0].vec[0]);
    }
    return {
        type: type,
        category: 'Native',
        tokenAddress: tokeType,
        faAddress: faAddress,
        name: meta.name,
        symbol: meta.symbol,
        decimals: meta.decimals,
        bridge: 'Native',
        logoUrl: meta.icon_uri,
        websiteUrl: meta.project_uri
    };
}
async function getCoinTokenInfo(client, type) {
    const account = type.split(SPLITTER)[0];
    const info = await client.getTypedAccountResource({
        accountAddress: account,
        resourceType: coin.CoinInfo.type(parseMoveType(type))
    });
    if (!info) {
        throw Error('coin not existed: ' + type);
    }
    let faAddress;
    try {
        const paired = await coin.view.pairedMetadata(client, { typeArguments: [type] });
        if (paired[0].vec[0]) {
            faAddress = paired[0].vec[0];
        }
    }
    catch (e) {
        console.debug("can't locate paired fa token for", type);
    }
    return {
        type: type,
        category: 'Native',
        tokenAddress: type,
        faAddress,
        name: info.name,
        symbol: info.symbol,
        decimals: info.decimals,
        bridge: 'Native'
    };
}
// token: address of the fungible asset, e.g. "0xa", or the coin type, e.g. "0x1::aptos::AptosCoin"
export async function getTokenInfoWithFallback(token, network) {
    network = network || AptosNetwork.MAIN_NET;
    if (network === AptosNetwork.MAIN_NET) {
        const r = TOKEN_MAP.get(token);
        if (r) {
            return r;
        }
    }
    const key = network + '_' + token;
    let promise = TOKEN_METADATA_CACHE.get(key);
    const isFungibleAsset = !token.includes(SPLITTER);
    const client = getClient(network);
    if (!promise) {
        if (isFungibleAsset) {
            promise = getFungibleTokenInfo(client, token);
        }
        else {
            promise = getCoinTokenInfo(client, token);
        }
        TOKEN_METADATA_CACHE.set(key, promise);
    }
    return promise;
}
export async function getPriceForToken(token, timestamp, network = AptosChainId.APTOS_MAINNET) {
    const date = new Date(timestamp / 1000);
    try {
        return (await getPriceByType(network, token, date)) || 0;
    }
    catch (error) {
        console.log(JSON.stringify(error));
        throw error;
    }
}
export async function tokenTokenValueInUsd(n, coinInfo, timestamp, network = AptosChainId.APTOS_MAINNET) {
    const token = coinInfo.tokenAddress || coinInfo.faAddress;
    if (token) {
        const price = await getPriceForToken(token, timestamp, network);
        const amount = n.scaleDown(coinInfo.decimals);
        return amount.multipliedBy(price);
    }
    throw Error('Token not found' + JSON.stringify(coinInfo));
}
setTokenList(DEFAULT_TOKEN_LIST);
//# sourceMappingURL=token.js.map