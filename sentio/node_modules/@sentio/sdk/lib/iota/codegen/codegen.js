import * as fs from 'fs';
import chalk from 'chalk';
import { structQname } from '@typemove/move';
import { IotaCodegen as BaseIotaCodegen } from '@typemove/iota/codegen';
import path, { join } from 'path';
import { SharedNetworkCodegen } from '../../move/shared-network-codegen.js';
import { getRpcEndpoint, IotaNetwork } from '../network.js';
import { recursiveCodegen } from '../../core/codegen.js';
export async function codegen(abisDir, outDir = join('src', 'types', 'iota'), genExample = false, builtin = false) {
    if (!fs.existsSync(abisDir)) {
        return;
    }
    const gen = new IotaCodegen();
    const numFiles = await gen.generate(abisDir, outDir, builtin);
    console.log(chalk.green(`Generated ${numFiles} for Iota`));
}
class IotaNetworkCodegen extends BaseIotaCodegen {
    moduleGenerator;
    SYSTEM_PACKAGE = '@sentio/sdk/iota';
    constructor(network) {
        const endpoint = getRpcEndpoint(network);
        super(endpoint);
        const generator = this;
        this.moduleGenerator = new (class extends SharedNetworkCodegen {
            ADDRESS_TYPE = 'string';
            PREFIX = 'Iota';
            SYSTEM_PACKAGE = '@sentio/sdk/iota';
            NETWORK = IotaNetwork;
            generateStructs(module, struct, events) {
                let content = '';
                switch (structQname(module, struct)) {
                    // TODO they should still have module code generated
                    case '0x1::ascii::Char':
                    case '0x1::ascii::String':
                    case '0x2::object::ID':
                        content += `export type ${struct.name} = string`;
                        break;
                    case '0x2::coin::Coin':
                        content += `export type ${struct.name}<T> = string`;
                        break;
                    case '0x2::balance::Balance':
                        content += `export type ${struct.name}<T> = bigint`;
                        break;
                    case '0x1::option::Option':
                        content += `export type Option<T> = T | undefined`;
                        break;
                }
                return content + super.generateStructs(module, struct, events, content !== '');
            }
            generateForOnEvents(module, struct) {
                switch (structQname(module, struct)) {
                    case '0x1::ascii::Char':
                    case '0x1::ascii::String':
                    case '0x2::object::ID':
                    case '0x2::coin::Coin':
                    case '0x1::option::Option':
                    case '0x2::balance::Balance':
                        return '';
                }
                return super.generateForOnEvents(module, struct);
            }
            generateExtra(address, module) {
                return generator.generateExtra(address, module);
            }
        })(network, this.chainAdapter);
    }
    generateModule(module, allEventStructs) {
        return this.moduleGenerator.generateModule(module, allEventStructs);
    }
    generateImports() {
        return super.generateImports() + this.moduleGenerator.generateImports();
    }
    generateLoadAll(isSystem) {
        return this.moduleGenerator.generateLoadAll(isSystem);
    }
}
class IotaCodegen {
    async generate(srcDir, outputDir, builtin = false) {
        let numFiles = 0;
        const generators = [
            ['', new IotaNetworkCodegen(IotaNetwork.MAIN_NET)],
            ['testnet', new IotaNetworkCodegen(IotaNetwork.TEST_NET)]
        ];
        for (const [network, gen] of generators) {
            const exclude = network ? [] : ['testnet'];
            numFiles += await recursiveCodegen(path.join(srcDir, network), path.join(outputDir, network), (src, dst) => gen.generate(src, dst, builtin), exclude);
        }
        return numFiles;
    }
}
//# sourceMappingURL=codegen.js.map