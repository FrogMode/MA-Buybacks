import { Data_SuiCall, Data_SuiObject, Data_SuiObjectChange, HandleInterval, MoveAccountFetchConfig, MoveFetchConfig, MoveOwnerType, ProcessResult } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { IotaNetwork } from './network.js';
import { IotaAddressContext, IotaContext, IotaObjectChangeContext, IotaObjectContext } from './context.js';
import { IotaMoveObject, IotaObjectChange, IotaTransactionBlockResponse } from '@iota/iota-sdk/client';
import { PromiseOrVoid } from '../core/index.js';
import { IndexConfigure, IotaBindOptions } from './iota-processor.js';
import { CallHandler, TransactionFilter, ObjectChangeHandler } from '../move/index.js';
import { TypeDescriptor } from '@typemove/move';
import { TypedIotaMoveObject } from './models.js';
export interface IotaObjectBindOptions {
    objectId: string;
    network?: IotaNetwork;
    startCheckpoint?: bigint;
    endCheckpoint?: bigint;
    baseLabels?: {
        [key: string]: string;
    };
}
export interface IotaObjectTypeBindOptions<T> {
    objectType: TypeDescriptor<T>;
    network?: IotaNetwork;
    startCheckpoint?: bigint;
    endCheckpoint?: bigint;
    baseLabels?: {
        [key: string]: string;
    };
}
interface ObjectHandler {
    type?: string;
    checkPointInterval?: HandleInterval;
    timeIntervalInMinutes?: HandleInterval;
    fetchConfig: MoveAccountFetchConfig;
    handler: (resource: Data_SuiObject) => Promise<ProcessResult>;
    handlerName: string;
}
export declare const DEFAULT_ACCOUNT_FETCH_CONFIG: MoveAccountFetchConfig;
export declare class IotaAccountProcessorState extends ListStateStorage<IotaBaseObjectOrAddressProcessor<any>> {
    static INSTANCE: IotaAccountProcessorState;
}
export interface IotaInternalObjectsBindOptions extends IotaBindOptions {
    ownerType: MoveOwnerType;
}
export declare abstract class IotaBaseObjectOrAddressProcessor<HandlerType> {
    config: IndexConfigure;
    ownerType: MoveOwnerType;
    templateId: number | undefined;
    objectHandlers: ObjectHandler[];
    objectChangeHandlers: ObjectChangeHandler<Data_SuiObjectChange>[];
    protected constructor(options: IotaInternalObjectsBindOptions);
    getChainId(): string;
    protected abstract doHandle(handler: HandlerType, data: Data_SuiObject, ctx: IotaObjectContext): Promise<any>;
    onInterval(handler: HandlerType, //(resources: IotaMoveObject[], ctx: IotaObjectsContext) => PromiseOrVoid,
    timeInterval: HandleInterval | undefined, checkpointInterval: HandleInterval | undefined, type: string | undefined, fetchConfig: Partial<MoveAccountFetchConfig> | undefined, handlerName?: string): this;
}
declare abstract class IotaBaseObjectOrAddressProcessorInternal<HandlerType> extends IotaBaseObjectOrAddressProcessor<HandlerType> {
    onTimeInterval(handler: HandlerType, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: HandlerType, checkpointInterval?: number, backfillCheckpointInterval?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class IotaAddressProcessor extends IotaBaseObjectOrAddressProcessorInternal<(objects: IotaMoveObject[], ctx: IotaAddressContext) => PromiseOrVoid> {
    callHandlers: CallHandler<Data_SuiCall>[];
    static bind(options: IotaBindOptions): IotaAddressProcessor;
    protected doHandle(handler: (objects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: IotaObjectContext): Promise<any>;
    onTransactionBlock(handler: (transaction: IotaTransactionBlockResponse, ctx: IotaContext) => PromiseOrVoid, filter?: TransactionFilter, fetchConfig?: Partial<MoveFetchConfig>): this;
}
export declare class IotaObjectProcessor extends IotaBaseObjectOrAddressProcessorInternal<(self: IotaMoveObject, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid> {
    static bind(options: IotaObjectBindOptions): IotaObjectProcessor;
    protected doHandle(handler: (self: IotaMoveObject, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: IotaObjectContext): Promise<any>;
}
export declare class IotaObjectTypeProcessor<T> extends IotaBaseObjectOrAddressProcessor<(self: TypedIotaMoveObject<T>, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid> {
    objectType: TypeDescriptor<T>;
    static bind<T>(options: IotaObjectTypeBindOptions<T>): IotaObjectTypeProcessor<T>;
    protected doHandle(handler: (self: TypedIotaMoveObject<T>, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: IotaObjectContext): Promise<any>;
    onObjectChange(handler: (changes: IotaObjectChange[], ctx: IotaObjectChangeContext) => PromiseOrVoid): this;
    onTimeInterval(handler: (self: TypedIotaMoveObject<T>, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: (self: TypedIotaMoveObject<T>, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, checkpointInterval?: number, backfillCheckpointInterval?: number, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class IotaWrappedObjectProcessor extends IotaBaseObjectOrAddressProcessorInternal<(dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid> {
    static bind(options: IotaObjectBindOptions): IotaWrappedObjectProcessor;
    protected doHandle(handler: (dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: IotaObjectContext): Promise<any>;
}
export {};
//# sourceMappingURL=iota-object-processor.d.ts.map