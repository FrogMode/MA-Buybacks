import { ListStateStorage, processMetrics } from '@sentio/runtime';
import { DEFAULT_ACCOUNT_FETCH_CONFIG, IotaAccountProcessorState, IotaAddressProcessor, IotaObjectProcessor, IotaWrappedObjectProcessor } from './iota-object-processor.js';
import { accountAddressString } from '../move/index.js';
import { ServerError, Status } from 'nice-grpc';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
class ObjectHandler {
    type;
    checkpointInterval;
    timeIntervalInMinutes;
    handlerName;
    handler;
    fetchConfig;
}
export class IotaAccountProcessorTemplateState extends ListStateStorage {
    static INSTANCE = new IotaAccountProcessorTemplateState();
}
export class IotaObjectOrAddressProcessorTemplate {
    id;
    objectHandlers = [];
    instances = new Set();
    constructor() {
        this.id = IotaAccountProcessorTemplateState.INSTANCE.getValues().length;
        IotaAccountProcessorTemplateState.INSTANCE.addValue(this);
        return proxyProcessor(this);
    }
    bind(options, ctx) {
        options.network = options.network || ctx.network;
        options.startCheckpoint = options.startCheckpoint || ctx.checkpoint;
        let id = options.objectId || options.address;
        if (id === '*') {
            throw new ServerError(Status.INVALID_ARGUMENT, "can't bind template instance with *");
        }
        id = accountAddressString(id);
        const instance = {
            templateId: this.id,
            contract: {
                name: '',
                chainId: options.network,
                address: id,
                abi: ''
            },
            startBlock: options.startCheckpoint || 0n,
            endBlock: options.endCheckpoint || 0n,
            baseLabels: options.baseLabels
        };
        ctx.sendTemplateInstance(instance);
        ctx.update({
            states: {
                configUpdated: true
            }
        });
        processMetrics.processor_template_instance_count.add(1, {
            chain_id: options.network,
            template: this.constructor.name
        });
    }
    startInstance(options, ctx) {
        options.network = options.network || ctx.network;
        options.startCheckpoint = options.startCheckpoint || ctx.checkpoint;
        let id = options.objectId || options.address;
        if (id === '*') {
            throw new ServerError(Status.INVALID_ARGUMENT, "can't bind template instance with *");
        }
        id = accountAddressString(id);
        const sig = [options.network, id].join('_');
        if (this.instances.has(sig)) {
            console.debug(`Same object id can be bind to one template only once, ignore duplicate bind: ${sig}`);
            return;
        }
        this.instances.add(sig);
        const processor = this.createProcessor(options);
        for (const h of this.objectHandlers) {
            processor.onInterval(h.handler, h.timeIntervalInMinutes, h.checkpointInterval, h.type, h.fetchConfig, h.handlerName);
        }
        console.log(`successfully bind template ${sig}`);
    }
    unbind(options, ctx) {
        options.network = options.network || ctx.network;
        options.startCheckpoint = options.startCheckpoint || ctx.checkpoint;
        let id = options.objectId || options.address;
        if (id === '*') {
            throw new ServerError(Status.INVALID_ARGUMENT, "can't delete template instance bind with *");
        }
        id = accountAddressString(id);
        const sig = [options.network, id].join('_');
        if (!this.instances.has(sig)) {
            console.log(`the template instance ${sig} not existed or already unbind`);
            return;
        }
        this.instances.delete(sig);
        const oldProcessors = IotaAccountProcessorState.INSTANCE.unregister();
        let deleted = 0;
        for (const processor of oldProcessors) {
            if (processor.templateId === this.id) {
                if (processor.config.network == options.network && processor.config.address === id) {
                    deleted++;
                    continue;
                }
            }
            IotaAccountProcessorState.INSTANCE.addValue(processor);
        }
        if (deleted !== 1) {
            throw new ServerError(Status.INVALID_ARGUMENT, `Failed to delete processor for template ${this.id}, ${sig}. deleted ${deleted} times`);
        }
        console.log(`successfully unbind template ${sig}`);
        ctx.update({
            states: {
                configUpdated: true
            }
        });
        ctx.sendTemplateInstance({
            templateId: this.id,
            contract: {
                name: '',
                chainId: options.network,
                address: id,
                abi: ''
            },
            startBlock: options.startCheckpoint || 0n,
            endBlock: options.endCheckpoint || 0n,
            baseLabels: options.baseLabels
        }, true);
    }
    onInterval(handler, timeInterval, checkpointInterval, type, fetchConfig) {
        this.objectHandlers.push({
            handlerName: getHandlerName(),
            handler: handler,
            timeIntervalInMinutes: timeInterval,
            checkpointInterval: checkpointInterval,
            type,
            fetchConfig: { ...DEFAULT_ACCOUNT_FETCH_CONFIG, ...fetchConfig }
        });
        return this;
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, type, fetchConfig) {
        return this.onInterval(handler, {
            recentInterval: timeIntervalInMinutes,
            backfillInterval: backfillTimeIntervalInMinutes
        }, undefined, type, fetchConfig);
    }
    onCheckpointInterval(handler, checkpointInterval = 100000, backfillCheckpointInterval = 400000, type, fetchConfig) {
        return this.onInterval(handler, undefined, { recentInterval: checkpointInterval, backfillInterval: backfillCheckpointInterval }, type, fetchConfig);
    }
}
class AddressTransactionHandler {
    handler;
    filter;
    fetchConfig;
}
export class IotaAddressProcessorTemplate extends IotaObjectOrAddressProcessorTemplate {
    handlers = [];
    createProcessor(options) {
        const p = IotaAddressProcessor.bind(options);
        for (const handler of this.handlers) {
            p.onTransactionBlock(handler.handler, handler.filter, handler.fetchConfig);
        }
        p.templateId = this.id;
        return p;
    }
    onTransactionBlock(handler, filter, fetchConfig) {
        this.handlers.push({
            handler,
            filter,
            fetchConfig
        });
        return this;
    }
}
export class IotaObjectProcessorTemplate extends IotaObjectOrAddressProcessorTemplate {
    createProcessor(options) {
        const p = IotaObjectProcessor.bind(options);
        p.templateId = this.id;
        return p;
    }
}
export class IotaWrappedObjectProcessorTemplate extends IotaObjectOrAddressProcessorTemplate {
    createProcessor(options) {
        const p = IotaWrappedObjectProcessor.bind(options);
        p.templateId = this.id;
        return p;
    }
}
//# sourceMappingURL=iota-object-processor-template.js.map