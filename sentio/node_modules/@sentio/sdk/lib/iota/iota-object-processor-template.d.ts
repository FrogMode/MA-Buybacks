import { HandleInterval, MoveAccountFetchConfig, MoveFetchConfig } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { IotaAddressContext, IotaContext, IotaObjectContext } from './context.js';
import { IotaMoveObject, IotaTransactionBlockResponse } from '@iota/iota-sdk/client';
import { PromiseOrVoid } from '../core/index.js';
import { IotaAddressProcessor, IotaBaseObjectOrAddressProcessor, IotaObjectBindOptions, IotaObjectProcessor, IotaWrappedObjectProcessor } from './iota-object-processor.js';
import { IotaBindOptions } from './iota-processor.js';
import { TransactionFilter } from '../move/index.js';
declare class ObjectHandler<HandlerType> {
    type?: string;
    checkpointInterval?: HandleInterval;
    timeIntervalInMinutes?: HandleInterval;
    handlerName: string;
    handler: HandlerType;
    fetchConfig: MoveAccountFetchConfig;
}
export declare class IotaAccountProcessorTemplateState extends ListStateStorage<IotaObjectOrAddressProcessorTemplate<any, any, any>> {
    static INSTANCE: IotaAccountProcessorTemplateState;
}
export declare abstract class IotaObjectOrAddressProcessorTemplate<HandlerType, OptionType extends IotaObjectBindOptions | IotaBindOptions, ProcessorType extends IotaBaseObjectOrAddressProcessor<HandlerType>> {
    id: number;
    objectHandlers: ObjectHandler<HandlerType>[];
    instances: Set<string>;
    constructor();
    protected abstract createProcessor(options: IotaObjectBindOptions | IotaBindOptions): ProcessorType;
    bind(options: OptionType, ctx: IotaContext): void;
    startInstance(options: OptionType, ctx: IotaContext): void;
    unbind(options: OptionType, ctx: IotaContext): void;
    protected onInterval(handler: HandlerType, timeInterval: HandleInterval | undefined, checkpointInterval: HandleInterval | undefined, type: string | undefined, fetchConfig: Partial<MoveAccountFetchConfig> | undefined): this;
    onTimeInterval(handler: HandlerType, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: HandlerType, checkpointInterval?: number, backfillCheckpointInterval?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class IotaAddressProcessorTemplate extends IotaObjectOrAddressProcessorTemplate<(objects: IotaMoveObject[], ctx: IotaAddressContext) => PromiseOrVoid, IotaBindOptions, IotaAddressProcessor> {
    private handlers;
    createProcessor(options: IotaBindOptions): IotaAddressProcessor;
    onTransactionBlock(handler: (transaction: IotaTransactionBlockResponse, ctx: IotaContext) => void, filter?: TransactionFilter, fetchConfig?: Partial<MoveFetchConfig>): this;
}
export declare class IotaObjectProcessorTemplate extends IotaObjectOrAddressProcessorTemplate<(self: IotaMoveObject, dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, IotaObjectBindOptions, IotaObjectProcessor> {
    createProcessor(options: IotaObjectBindOptions): IotaObjectProcessor;
}
export declare class IotaWrappedObjectProcessorTemplate extends IotaObjectOrAddressProcessorTemplate<(dynamicFieldObjects: IotaMoveObject[], ctx: IotaObjectContext) => PromiseOrVoid, IotaObjectBindOptions, IotaWrappedObjectProcessor> {
    createProcessor(options: IotaObjectBindOptions): IotaWrappedObjectProcessor;
}
export {};
//# sourceMappingURL=iota-object-processor-template.d.ts.map