import { Endpoints, PluginManager, ProcessorServiceImpl, State, StoreContext } from '@sentio/runtime';
import { AptosFacet } from './aptos-facet.js';
import { SolanaFacet } from './solana-facet.js';
import { EthFacet } from './eth-facet.js';
import { SuiFacet } from './sui-facet.js';
import { FuelFacet } from './fuel-facet.js';
import { CosmosFacet } from './cosmos-facet.js';
import { StarknetFacet } from './starknet-facet.js';
import { Subject } from 'rxjs';
import { MemoryDatabase } from './memory-database.js';
import { DatabaseSchemaState } from '../core/database-schema.js';
import { IotaFacet } from './iota-facet.js';
import { ChainInfo } from '@sentio/chain';
export const TEST_CONTEXT = {};
export function cleanTest() {
    // retain the DatabaseSchemaState
    const state = State.INSTANCE.stateMap.get(DatabaseSchemaState.INSTANCE.key());
    State.reset();
    State.INSTANCE.stateMap.set(DatabaseSchemaState.INSTANCE.key(), state);
}
export class TestProcessorServer {
    service;
    contractConfigs;
    accountConfigs;
    storeContext;
    aptos;
    eth;
    solana;
    sui;
    iota;
    fuel;
    cosmos;
    starknet;
    _db;
    constructor(loader, httpEndpoints = {}) {
        cleanTest();
        this.service = new ProcessorServiceImpl(loader);
        this.aptos = new AptosFacet(this);
        this.solana = new SolanaFacet(this);
        this.eth = new EthFacet(this);
        this.sui = new SuiFacet(this);
        this.iota = new IotaFacet(this);
        this.fuel = new FuelFacet(this);
        this.cosmos = new CosmosFacet(this);
        this.starknet = new StarknetFacet(this);
        for (const k of Object.keys(ChainInfo)) {
            const http = httpEndpoints[k] || '';
            Endpoints.INSTANCE.chainServer.set(k, http);
        }
        // start a memory database for testing
        const subject = new Subject();
        this.storeContext = new TestStoreContext(subject, 1);
        this._db = new MemoryDatabase(this.storeContext);
    }
    async start(request = { templateInstances: [] }, context = TEST_CONTEXT) {
        const res = await this.service.start(request, context);
        const config = await this.getConfig({});
        this.contractConfigs = config.contractConfigs;
        this.accountConfigs = config.accountConfigs;
        this._db.start();
        this.storeContext.templateInstances = request.templateInstances;
        return res;
    }
    stop(request, context = TEST_CONTEXT) {
        return this.service.stop(request, context);
    }
    async getConfig(request, context = TEST_CONTEXT) {
        const config = await this.service.getConfig(request, context);
        return {
            ...config,
            templateInstances: this.storeContext.templateInstances
        };
    }
    processBindings(request, context = TEST_CONTEXT) {
        return PluginManager.INSTANCE.dbContextLocalStorage.run(this.storeContext, async () => {
            const ret = await this.service.processBindings(request, context);
            if (ret.result?.states?.configUpdated) {
                // template may changed
                await PluginManager.INSTANCE.updateTemplates({
                    chainId: request.bindings[0].chainId,
                    templateInstances: this.storeContext.templateInstances
                });
            }
            return ret;
        });
    }
    async processBinding(request, context = TEST_CONTEXT) {
        const ret = await PluginManager.INSTANCE.dbContextLocalStorage.run(this.storeContext, () => {
            return this.service.processBindings({ bindings: [request] }, context);
        });
        if (ret.result?.states?.configUpdated) {
            // template may changed
            await PluginManager.INSTANCE.updateTemplates({
                chainId: request.chainId,
                templateInstances: this.storeContext.templateInstances
            });
        }
        return ret;
    }
    processBindingsStream(requests, context) {
        throw new Error('Method not implemented.');
    }
    preprocessBindingsStream(requests, context) {
        throw new Error('Method not implemented.');
    }
    // processBindingsStream(request: AsyncIterable<ProcessStreamRequest>, context: CallContext) {
    //   return this.service.processBindingsStream(request, context)
    // }
    get db() {
        return this._db;
    }
    get store() {
        return this._db.store;
    }
}
class TestStoreContext extends StoreContext {
    subject;
    constructor(subject, processId) {
        super(subject, processId);
        this.subject = subject;
    }
    templateInstances = [];
    sendTemplateRequest(templates, remove) {
        if (remove) {
            this.templateInstances = this.templateInstances.filter((i) => !templates.find((t) => t.templateId === i.templateId && t.contract?.address === i.contract?.address));
        }
        else {
            this.templateInstances.push(...templates);
        }
    }
    sendTimeseriesRequest(timeseries) {
        throw new Error('Method not implemented.');
    }
}
//# sourceMappingURL=test-processor-server.js.map