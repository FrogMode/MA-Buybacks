import { HandlerType } from '@sentio/protos';
import { FuelNetwork } from '../fuel/index.js';
import { getRpcEndpoint } from '../fuel/network.js';
export class FuelFacet {
    server;
    constructor(server) {
        this.server = server;
    }
    testOnTransaction(transaction, network = FuelNetwork.TEST_NET) {
        const bindings = this.buildBinding(transaction, network);
        if (!bindings) {
            throw Error('Invalid test transaction: ' + JSON.stringify(transaction));
        }
        return this.server.processBindings({
            bindings
        });
    }
    /*
     * Test on transactions by downloading them from the network
     */
    async testOnTransactionByID(network = FuelNetwork.TEST_NET, ...txIds) {
        const url = getRpcEndpoint(network);
        const allBindings = [];
        for (const txId of txIds) {
            const tx = await this.gqlQuery(url, txId);
            const bindings = this.buildBinding(tx, network);
            allBindings.push(...bindings);
        }
        return this.server.processBindings({
            bindings: allBindings
        });
    }
    buildBinding(transaction, network) {
        const res = [];
        for (const config of this.server.contractConfigs) {
            if (config.contract?.chainId !== network) {
                continue;
            }
            for (const callConfig of config.fuelTransactionConfigs) {
                const binding = {
                    data: {
                        fuelTransaction: {
                            transaction,
                            timestamp: new Date()
                        }
                    },
                    handlerIds: [callConfig.handlerId],
                    handlerType: HandlerType.FUEL_TRANSACTION,
                    chainId: network
                };
                res.push(binding);
            }
            for (const assetConfig of config.assetConfigs) {
                const binding = {
                    data: {
                        fuelTransaction: {
                            transaction,
                            timestamp: new Date()
                        }
                    },
                    handlerIds: [assetConfig.handlerId],
                    handlerType: HandlerType.FUEL_TRANSACTION,
                    chainId: network
                };
                res.push(binding);
            }
        }
        // keep receipts order
        const receipts = transaction.status.receipts || [];
        for (let i = 0; i < receipts.length; i++) {
            const receipt = receipts[i];
            if (receipt.receiptType != 'LOG' && receipt.receiptType != 'LOG_DATA') {
                continue;
            }
            for (const config of this.server.contractConfigs) {
                for (const logConfig of config.fuelReceiptConfigs) {
                    const logIds = logConfig.log?.logIds ?? [];
                    if (logIds.includes(receipt.rb)) {
                        const binding = {
                            data: {
                                fuelLog: {
                                    transaction,
                                    timestamp: new Date(),
                                    receiptIndex: BigInt(i)
                                }
                            },
                            handlerIds: [logConfig.handlerId],
                            handlerType: HandlerType.FUEL_RECEIPT,
                            chainId: network
                        };
                        res.push(binding);
                    }
                }
            }
        }
        return res;
    }
    async gqlQuery(url, txId) {
        const res = await fetch(url, {
            body: JSON.stringify({
                query: GetTransactionQuery,
                variables: {
                    id: txId
                }
            }),
            headers: {
                'Content-Type': 'application/json'
            },
            method: 'POST'
        });
        if (!res.ok) {
            throw Error('Failed to fetch transaction: ' + res.statusText);
        }
        const json = (await res.json());
        return json.data.transaction;
    }
}
const GetTransactionQuery = `
      query GetTransaction($id: TransactionId!) {
    transaction(id: $id) {
        id
        rawPayload
        status {
            type: __typename
            ... on SuccessStatus {
                block {
                    id
                    header {
                        height
                    }
                }
                time
                programState {
                    returnType
                    data
                }
                blockHeight
                transactionId
                totalGas
                totalFee
                receipts {
                    id
                    pc
                    is
                    to
                    toAddress
                    amount
                    assetId
                    gas
                    param1
                    param2
                    val
                    ptr
                    digest
                    reason
                    ra
                    rb
                    rc
                    rd
                    len
                    receiptType
                    result
                    gasUsed
                    data
                    sender
                    recipient
                    nonce
                    contractId
                    subId
                }
            }
            ... on SubmittedStatus {
                time
            }
            ... on SqueezedOutStatus {
                reason
            }
            ... on FailureStatus {
                transactionId
                blockHeight
                time
                reason
                totalGas
                totalFee
            }
        }
        inputs {
            ... on InputCoin {
                utxoId
                owner
                amount
                assetId
                txPointer
                witnessIndex
                predicateGasUsed
                predicate
                predicateData
            }
            ... on InputContract {
                utxoId
                balanceRoot
                stateRoot
                txPointer
                contractId
            }
            ... on InputMessage {
                sender
                recipient
                amount
                nonce
                predicateGasUsed
                data
                predicate
                predicateData
            }
        }
        outputs {
            ... on ContractCreated {
                contract
                stateRoot
            }
            ... on VariableOutput {
                to
                amount
                assetId
            }
            ... on ChangeOutput {
                to
                amount
                assetId
            }
            ... on ContractOutput {
                inputIndex
                balanceRoot
                stateRoot
            }
            ... on CoinOutput {
                to
                amount
                assetId
            }
        }
        receiptsRoot
    }
}`;
//# sourceMappingURL=fuel-facet.js.map