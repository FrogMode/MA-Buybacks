import { addContractByABI, getContractByABI, addProcessor, getProcessor, getProvider, transformEtherError, BaseProcessor, BaseProcessorTemplate, BoundContractView, ContractView, DummyProvider, encodeCallData, } from "@sentio/sdk/eth";
import { ERC20Bytes__factory } from "./index.js";
const templateContract = ERC20Bytes__factory.connect("0x0", DummyProvider);
export class ERC20BytesContractView extends ContractView {
    constructor(contract) {
        super(contract);
        this.callStatic.contract = contract;
    }
    async name(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("name()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async totalSupply(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("totalSupply()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async decimals(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("decimals()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async balanceOf(who, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("balanceOf(address)")(who, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async symbol(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("symbol()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async allowance(owner, spender, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("allowance(address,address)")(owner, spender, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    callStatic = {
        contract: this.contract,
        async approve(spender, value, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("approve(address,uint256)")
                    .staticCall(spender, value, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transferFrom(from, to, value, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transferFrom(address,address,uint256)")
                    .staticCall(from, to, value, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transfer(to, value, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transfer(address,uint256)")
                    .staticCall(to, value, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
    encodeCall = {
        name(callContext) {
            return encodeCallData(callContext, "name", "function name()", []);
        },
        approve(spender, value, callContext) {
            return encodeCallData(callContext, "approve", "function approve(address,uint256)", [spender, value]);
        },
        totalSupply(callContext) {
            return encodeCallData(callContext, "totalSupply", "function totalSupply()", []);
        },
        transferFrom(from, to, value, callContext) {
            return encodeCallData(callContext, "transferFrom", "function transferFrom(address,address,uint256)", [from, to, value]);
        },
        decimals(callContext) {
            return encodeCallData(callContext, "decimals", "function decimals()", []);
        },
        balanceOf(who, callContext) {
            return encodeCallData(callContext, "balanceOf", "function balanceOf(address)", [who]);
        },
        symbol(callContext) {
            return encodeCallData(callContext, "symbol", "function symbol()", []);
        },
        transfer(to, value, callContext) {
            return encodeCallData(callContext, "transfer", "function transfer(address,uint256)", [to, value]);
        },
        allowance(owner, spender, callContext) {
            return encodeCallData(callContext, "allowance", "function allowance(address,address)", [owner, spender]);
        },
    };
}
export class ERC20BytesBoundContractView extends BoundContractView {
    async name(overrides) {
        return await this.view.name({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async totalSupply(overrides) {
        return await this.view.totalSupply({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async decimals(overrides) {
        return await this.view.decimals({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async balanceOf(who, overrides) {
        return await this.view.balanceOf(who, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async symbol(overrides) {
        return await this.view.symbol({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async allowance(owner, spender, overrides) {
        return await this.view.allowance(owner, spender, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    callStatic = {
        view: this.view,
        context: this.context,
        async approve(spender, value, overrides) {
            return await this.view.callStatic.approve(spender, value, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
        async transferFrom(from, to, value, overrides) {
            return await this.view.callStatic.transferFrom(from, to, value, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
        async transfer(to, value, overrides) {
            return await this.view.callStatic.transfer(to, value, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
    };
    encodeCall = {
        view: this.view,
        context: this.context,
        name(overrides) {
            return this.view.encodeCall.name({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        approve(spender, value, overrides) {
            return this.view.encodeCall.approve(spender, value, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        totalSupply(overrides) {
            return this.view.encodeCall.totalSupply({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        transferFrom(from, to, value, overrides) {
            return this.view.encodeCall.transferFrom(from, to, value, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        decimals(overrides) {
            return this.view.encodeCall.decimals({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        balanceOf(who, overrides) {
            return this.view.encodeCall.balanceOf(who, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        symbol(overrides) {
            return this.view.encodeCall.symbol({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        transfer(to, value, overrides) {
            return this.view.encodeCall.transfer(to, value, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        allowance(owner, spender, overrides) {
            return this.view.encodeCall.allowance(owner, spender, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
    };
}
export class ERC20BytesProcessor extends BaseProcessor {
    onEventApproval(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransfer(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onCallName(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x06fdde03", handler, handlerOptions, preprocessHandler);
    }
    onCallApprove(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x095ea7b3", handler, handlerOptions, preprocessHandler);
    }
    onCallTotalSupply(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x18160ddd", handler, handlerOptions, preprocessHandler);
    }
    onCallTransferFrom(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x23b872dd", handler, handlerOptions, preprocessHandler);
    }
    onCallDecimals(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x313ce567", handler, handlerOptions, preprocessHandler);
    }
    onCallBalanceOf(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x70a08231", handler, handlerOptions, preprocessHandler);
    }
    onCallSymbol(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x95d89b41", handler, handlerOptions, preprocessHandler);
    }
    onCallTransfer(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0xa9059cbb", handler, handlerOptions, preprocessHandler);
    }
    onCallAllowance(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0xdd62ed3e", handler, handlerOptions, preprocessHandler);
    }
    static filters = {
        Approval(owner, spender, value) {
            return templateContract.filters["Approval(address,address,uint256)"](owner, spender, value);
        },
        Transfer(from, to, value) {
            return templateContract.filters["Transfer(address,address,uint256)"](from, to, value);
        },
    };
    CreateBoundContractView() {
        const view = getERC20BytesContract(this.config.network, this.config.address);
        return new ERC20BytesBoundContractView(this.config.address, view);
    }
    static bind(options) {
        if (!options.name) {
            options.name = "ERC20Bytes";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC20BytesProcessor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
}
export class ERC20BytesProcessorTemplate extends BaseProcessorTemplate {
    bindInternal(options) {
        if (!options.name) {
            options.name = "ERC20Bytes";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC20BytesProcessor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
    onEventApproval(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransfer(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
}
export function getERC20BytesContract(chainId, address) {
    let contract = getContractByABI("ERC20Bytes", address, chainId);
    if (!contract) {
        const rawContract = ERC20Bytes__factory.connect(address, getProvider(chainId));
        contract = new ERC20BytesContractView(rawContract);
        addContractByABI("ERC20Bytes", address, chainId, contract);
    }
    return contract;
}
export function getERC20BytesContractOnContext(context, address) {
    const view = getERC20BytesContract(context.getChainId(), address);
    const boundView = new ERC20BytesBoundContractView(address, view);
    boundView.context = context;
    if (boundView.callStatic) {
        boundView.callStatic.context = context;
    }
    return boundView;
}
//# sourceMappingURL=erc20bytes-processor.js.map