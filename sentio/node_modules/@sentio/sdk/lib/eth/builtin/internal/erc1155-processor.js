import { addContractByABI, getContractByABI, addProcessor, getProcessor, getProvider, transformEtherError, BaseProcessor, BaseProcessorTemplate, BoundContractView, ContractView, DummyProvider, encodeCallData, } from "@sentio/sdk/eth";
import { ERC1155__factory } from "./index.js";
const templateContract = ERC1155__factory.connect("0x0", DummyProvider);
export class ERC1155ContractView extends ContractView {
    constructor(contract) {
        super(contract);
        this.callStatic.contract = contract;
    }
    async balanceOf(account, id, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("balanceOf(address,uint256)")(account, id, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async balanceOfBatch(accounts, ids, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("balanceOfBatch(address[],uint256[])")(accounts, ids, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async isApprovedForAll(account, operator, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("isApprovedForAll(address,address)")(account, operator, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async supportsInterface(interfaceId, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("supportsInterface(bytes4)")(interfaceId, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async uri(id, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("uri(uint256)")(id, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    callStatic = {
        contract: this.contract,
        async safeBatchTransferFrom(from, to, ids, amounts, data, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)")
                    .staticCall(from, to, ids, amounts, data, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async safeTransferFrom(from, to, id, amount, data, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("safeTransferFrom(address,address,uint256,uint256,bytes)")
                    .staticCall(from, to, id, amount, data, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async setApprovalForAll(operator, approved, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("setApprovalForAll(address,bool)")
                    .staticCall(operator, approved, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
    encodeCall = {
        balanceOf(account, id, callContext) {
            return encodeCallData(callContext, "balanceOf", "function balanceOf(address,uint256)", [account, id]);
        },
        balanceOfBatch(accounts, ids, callContext) {
            return encodeCallData(callContext, "balanceOfBatch", "function balanceOfBatch(address[],uint256[])", [accounts, ids]);
        },
        isApprovedForAll(account, operator, callContext) {
            return encodeCallData(callContext, "isApprovedForAll", "function isApprovedForAll(address,address)", [account, operator]);
        },
        safeBatchTransferFrom(from, to, ids, amounts, data, callContext) {
            return encodeCallData(callContext, "safeBatchTransferFrom", "function safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)", [from, to, ids, amounts, data]);
        },
        safeTransferFrom(from, to, id, amount, data, callContext) {
            return encodeCallData(callContext, "safeTransferFrom", "function safeTransferFrom(address,address,uint256,uint256,bytes)", [from, to, id, amount, data]);
        },
        setApprovalForAll(operator, approved, callContext) {
            return encodeCallData(callContext, "setApprovalForAll", "function setApprovalForAll(address,bool)", [operator, approved]);
        },
        supportsInterface(interfaceId, callContext) {
            return encodeCallData(callContext, "supportsInterface", "function supportsInterface(bytes4)", [interfaceId]);
        },
        uri(id, callContext) {
            return encodeCallData(callContext, "uri", "function uri(uint256)", [id]);
        },
    };
}
export class ERC1155BoundContractView extends BoundContractView {
    async balanceOf(account, id, overrides) {
        return await this.view.balanceOf(account, id, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async balanceOfBatch(accounts, ids, overrides) {
        return await this.view.balanceOfBatch(accounts, ids, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async isApprovedForAll(account, operator, overrides) {
        return await this.view.isApprovedForAll(account, operator, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async supportsInterface(interfaceId, overrides) {
        return await this.view.supportsInterface(interfaceId, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    async uri(id, overrides) {
        return await this.view.uri(id, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, this.context.getEthCallContext());
    }
    callStatic = {
        view: this.view,
        context: this.context,
        async safeBatchTransferFrom(from, to, ids, amounts, data, overrides) {
            return await this.view.callStatic.safeBatchTransferFrom(from, to, ids, amounts, data, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
        async safeTransferFrom(from, to, id, amount, data, overrides) {
            return await this.view.callStatic.safeTransferFrom(from, to, id, amount, data, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
        async setApprovalForAll(operator, approved, overrides) {
            return await this.view.callStatic.setApprovalForAll(operator, approved, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, this.context.getEthCallContext());
        },
    };
    encodeCall = {
        view: this.view,
        context: this.context,
        balanceOf(account, id, overrides) {
            return this.view.encodeCall.balanceOf(account, id, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        balanceOfBatch(accounts, ids, overrides) {
            return this.view.encodeCall.balanceOfBatch(accounts, ids, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        isApprovedForAll(account, operator, overrides) {
            return this.view.encodeCall.isApprovedForAll(account, operator, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        safeBatchTransferFrom(from, to, ids, amounts, data, overrides) {
            return this.view.encodeCall.safeBatchTransferFrom(from, to, ids, amounts, data, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        safeTransferFrom(from, to, id, amount, data, overrides) {
            return this.view.encodeCall.safeTransferFrom(from, to, id, amount, data, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        setApprovalForAll(operator, approved, overrides) {
            return this.view.encodeCall.setApprovalForAll(operator, approved, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        supportsInterface(interfaceId, overrides) {
            return this.view.encodeCall.supportsInterface(interfaceId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
        uri(id, overrides) {
            return this.view.encodeCall.uri(id, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: this.context.getBlockTag(overrides),
            });
        },
    };
}
export class ERC1155Processor extends BaseProcessor {
    onEventApprovalForAll(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["ApprovalForAll(address,address,bool)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransferBatch(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["TransferBatch(address,address,address,uint256[],uint256[])"](null, null, null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransferSingle(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["TransferSingle(address,address,address,uint256,uint256)"](null, null, null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventURI(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["URI(string,uint256)"](null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onCallBalanceOf(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x00fdd58e", handler, handlerOptions, preprocessHandler);
    }
    onCallBalanceOfBatch(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x4e1273f4", handler, handlerOptions, preprocessHandler);
    }
    onCallIsApprovedForAll(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0xe985e9c5", handler, handlerOptions, preprocessHandler);
    }
    onCallSafeBatchTransferFrom(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x2eb2c2d6", handler, handlerOptions, preprocessHandler);
    }
    onCallSafeTransferFrom(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0xf242432a", handler, handlerOptions, preprocessHandler);
    }
    onCallSetApprovalForAll(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0xa22cb465", handler, handlerOptions, preprocessHandler);
    }
    onCallSupportsInterface(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x01ffc9a7", handler, handlerOptions, preprocessHandler);
    }
    onCallUri(handler, handlerOptions, preprocessHandler) {
        return super.onEthTrace("0x0e89341c", handler, handlerOptions, preprocessHandler);
    }
    static filters = {
        ApprovalForAll(account, operator, approved) {
            return templateContract.filters["ApprovalForAll(address,address,bool)"](account, operator, approved);
        },
        TransferBatch(operator, from, to, ids, values) {
            return templateContract.filters["TransferBatch(address,address,address,uint256[],uint256[])"](operator, from, to, ids, values);
        },
        TransferSingle(operator, from, to, id, value) {
            return templateContract.filters["TransferSingle(address,address,address,uint256,uint256)"](operator, from, to, id, value);
        },
        URI(value, id) {
            return templateContract.filters["URI(string,uint256)"](value, id);
        },
    };
    CreateBoundContractView() {
        const view = getERC1155Contract(this.config.network, this.config.address);
        return new ERC1155BoundContractView(this.config.address, view);
    }
    static bind(options) {
        if (!options.name) {
            options.name = "ERC1155";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC1155Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
}
export class ERC1155ProcessorTemplate extends BaseProcessorTemplate {
    bindInternal(options) {
        if (!options.name) {
            options.name = "ERC1155";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC1155Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
    onEventApprovalForAll(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["ApprovalForAll(address,address,bool)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransferBatch(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["TransferBatch(address,address,address,uint256[],uint256[])"](null, null, null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventTransferSingle(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["TransferSingle(address,address,address,uint256,uint256)"](null, null, null, null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
    onEventURI(handler, filter, handlerOptions, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["URI(string,uint256)"](null, null);
        }
        return super.onEthEvent(handler, filter, handlerOptions, preprocessHandler);
    }
}
export function getERC1155Contract(chainId, address) {
    let contract = getContractByABI("ERC1155", address, chainId);
    if (!contract) {
        const rawContract = ERC1155__factory.connect(address, getProvider(chainId));
        contract = new ERC1155ContractView(rawContract);
        addContractByABI("ERC1155", address, chainId, contract);
    }
    return contract;
}
export function getERC1155ContractOnContext(context, address) {
    const view = getERC1155Contract(context.getChainId(), address);
    const boundView = new ERC1155BoundContractView(address, view);
    boundView.context = context;
    if (boundView.callStatic) {
        boundView.callStatic.context = context;
    }
    return boundView;
}
//# sourceMappingURL=erc1155-processor.js.map