import { defaultPreprocessHandler } from './base-processor.js';
import { getOptionsSignature } from './bind-options.js';
import { EthFetchConfig } from '@sentio/protos';
import { ListStateStorage, processMetrics } from '@sentio/runtime';
import { validateAndNormalizeAddress } from './eth.js';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
export class ProcessorTemplateProcessorState extends ListStateStorage {
    static INSTANCE = new ProcessorTemplateProcessorState();
}
export class BaseProcessorTemplate {
    id;
    blockHandlers = [];
    traceHandlers = [];
    eventHandlers = [];
    instances = new Set();
    constructor() {
        this.id = ProcessorTemplateProcessorState.INSTANCE.getValues().length;
        ProcessorTemplateProcessorState.INSTANCE.addValue(this);
        return proxyProcessor(this);
    }
    /**
     * Bind template using {@param options}, using {@param ctx}'s network value if not provided in the option
     * @param options
     * @param ctx
     */
    bind(options, ctx) {
        options = { ...options, address: validateAndNormalizeAddress(options.address) };
        const instance = {
            templateId: this.id,
            contract: {
                address: options.address,
                name: options.name || '',
                chainId: ctx.chainId,
                abi: ''
            },
            startBlock: BigInt(options.startBlock || 0),
            endBlock: BigInt(options.endBlock || 0),
            baseLabels: options.baseLabels
        };
        ctx.sendTemplateInstance(instance);
        ctx.update({
            states: {
                configUpdated: true
            }
        });
        processMetrics.processor_template_instance_count.add(1, { chain_id: ctx.chainId, template: this.constructor.name });
    }
    startInstance(options, ctx) {
        options = { ...options, address: validateAndNormalizeAddress(options.address) };
        const sig = getOptionsSignature({
            address: options.address,
            network: ctx.chainId
        });
        if (this.instances.has(sig)) {
            console.debug(`Same address can be bind to one template only once, ignore duplicate bind: ${sig}`);
            return;
        }
        const processor = this.bindInternal({ ...options, network: ctx.chainId });
        for (const eh of this.eventHandlers) {
            // @ts-ignore friendly
            processor.onEthEvent(eh.handler, eh.filter, eh.fetchConfig, eh.preprocessHandler, eh.handlerName);
        }
        for (const th of this.traceHandlers) {
            // @ts-ignore friendly
            processor.onEthTrace(th.signature, th.handler, th.fetchConfig, th.preprocessHandler, th.handlerName);
        }
        for (const bh of this.blockHandlers) {
            processor.onInterval(bh.handler, bh.timeIntervalInMinutes, bh.blockInterval, bh.fetchConfig, bh.preprocessHandler, bh.handlerName);
        }
        this.instances.add(sig);
    }
    onEthEvent(handler, filter, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        this.eventHandlers.push({
            handlerName: getHandlerName(),
            handler: handler,
            preprocessHandler,
            filter: filter,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {})
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 1000, backfillBlockInterval = 4000, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, fetchConfig, preprocessHandler);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, fetchConfig, preprocessHandler);
    }
    onInterval(handler, timeInterval, blockInterval, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        this.blockHandlers.push({
            handlerName: getHandlerName(),
            handler,
            preprocessHandler,
            timeIntervalInMinutes: timeInterval,
            blockInterval,
            fetchConfig
        });
        return this;
    }
    onTrace(signature, handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        this.traceHandlers.push({
            signature,
            handlerName: getHandlerName(),
            handler,
            preprocessHandler,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {})
        });
        return this;
    }
}
//# sourceMappingURL=base-processor-template.js.map