import { ContractContext, GlobalContext } from './context.js';
import { EthFetchConfig, PreprocessResult, ProcessResult } from '@sentio/protos';
import { ServerError, Status } from 'nice-grpc';
import { fixEmptyKey, formatEthData, TypedEvent, validateAndNormalizeAddress } from './eth.js';
import sha3 from 'js-sha3';
import { ListStateStorage } from '@sentio/runtime';
import { EthChainId } from '@sentio/chain';
import { getHandlerName, proxyHandlers, proxyProcessor } from '../utils/metrics.js';
import { ALL_ADDRESS } from '../core/index.js';
import { parseLog, decodeTrace } from './abi-decoder/index.js';
export const defaultPreprocessHandler = () => ({ ethCallParams: [] });
export class EventsHandler {
    filters;
    handlerName;
    handler;
    preprocessHandler;
    fetchConfig;
    partitionHandler;
}
export class TraceHandler {
    signatures;
    handlerName;
    handler;
    preprocessHandler;
    fetchConfig;
    partitionHandler;
}
export class BlockHandler {
    blockInterval;
    timeIntervalInMinutes;
    handlerName;
    handler;
    preprocessHandler;
    fetchConfig;
    partitionHandler;
}
export class TransactionHandler {
    handler;
    handlerName;
    preprocessHandler;
    fetchConfig;
    partitionHandler;
}
class BindInternalOptions {
    address;
    network;
    name;
    start;
    end;
    baseLabels;
}
export class GlobalProcessorState extends ListStateStorage {
    static INSTANCE = new GlobalProcessorState();
}
export class GlobalProcessor {
    config;
    blockHandlers = proxyHandlers([]);
    transactionHandler = proxyHandlers([]);
    traceHandlers = proxyHandlers([]);
    eventHandlers = [];
    static bind(config) {
        const processor = new GlobalProcessor(config);
        GlobalProcessorState.INSTANCE.addValue(processor);
        return processor;
    }
    constructor(config) {
        this.config = {
            address: ALL_ADDRESS,
            name: config.name || 'Global',
            network: config.network || EthChainId.ETHEREUM,
            start: config.start || {
                block: 0
            },
            end: config.end
        };
        if (config.startBlock) {
            this.config.start = {
                block: config.startBlock
            };
        }
        if (config.endBlock) {
            this.config.end = {
                block: config.endBlock
            };
        }
        return proxyProcessor(this);
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, handlerOptions, preprocessHandler);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, handlerOptions, preprocessHandler);
    }
    getChainId() {
        return this.config.network;
    }
    onInterval(handler, timeInterval, blockInterval, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        if (timeInterval) {
            if (timeInterval.backfillInterval < timeInterval.recentInterval) {
                timeInterval.backfillInterval = timeInterval.recentInterval;
            }
        }
        const processor = this;
        this.blockHandlers.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const ctx = new GlobalContext(chainId, ALL_ADDRESS, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const ctx = new GlobalContext(chainId, ALL_ADDRESS, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                return preprocessHandler(block, ctx, preprocessStore);
            },
            timeIntervalInMinutes: timeInterval,
            blockInterval: blockInterval,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const { block } = formatEthData(data);
                    if (!block)
                        return undefined;
                    return p(block);
                }
                return p;
            }
        });
        return this;
    }
    onTransaction(handler, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        const processor = this;
        this.transactionHandler.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is empty');
                }
                let to = transaction.to;
                if (to === trace?.action.from) {
                    to = '*';
                }
                const ctx = new GlobalContext(chainId, to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                await handler(transaction, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is empty');
                }
                let to = transaction.to;
                if (to === trace?.action.from) {
                    to = '*';
                }
                const ctx = new GlobalContext(chainId, to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(transaction, ctx, preprocessStore);
            },
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const { transaction } = formatEthData(data);
                    return p(transaction);
                }
                return p;
            }
        });
        return this;
    }
    onEvent(handler, filter, handlerOptions) {
        let _filters = [];
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else if (filter) {
            _filters.push(filter);
        }
        const chainId = this.getChainId();
        this.eventHandlers.push({
            filters: _filters,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            handlerName: getHandlerName(),
            handler: async function (data) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                const ctx = new GlobalContext(chainId, transaction?.to || '*', data.timestamp, block, log, undefined, transaction, transactionReceipt);
                await handler(log, ctx);
                return ctx.stopAndGetResult();
            }
        });
        return this;
    }
    onTrace(signatures, handler, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        if (typeof signatures === 'string') {
            signatures = [signatures];
        }
        for (const signature of signatures) {
            if (signature.length <= 2) {
                throw new Error('Invalid signature length, must start with 0x');
            }
        }
        const processor = this;
        this.traceHandlers.push({
            signatures,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            handlerName: getHandlerName(),
            handler: async function (data) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!trace) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const ctx = new GlobalContext(chainId, trace.action.to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                await handler(trace, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!trace) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const ctx = new GlobalContext(chainId, trace.action.to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(trace, ctx, preprocessStore);
            },
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const { trace } = formatEthData(data);
                    if (!trace)
                        return undefined;
                    return p(trace);
                }
                return p;
            }
        });
        return this;
    }
}
export class BaseProcessor {
    blockHandlers = proxyHandlers([]);
    eventHandlers = proxyHandlers([]);
    traceHandlers = proxyHandlers([]);
    config;
    constructor(config) {
        this.config = {
            address: validateAndNormalizeAddress(config.address),
            name: config.name || '',
            network: config.network || EthChainId.ETHEREUM,
            start: config.start || {
                block: 0
            },
            end: config.end,
            baseLabels: config.baseLabels
        };
        if (config.startBlock) {
            this.config.start = {
                block: config.startBlock
            };
        }
        if (config.endBlock) {
            this.config.end = {
                block: config.endBlock
            };
        }
        return proxyProcessor(this);
    }
    getChainId() {
        return this.config.network;
    }
    onEvent(handler, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        const _filters = [];
        const tmpContract = this.CreateBoundContractView();
        for (const fragment of tmpContract.rawContract.interface.fragments) {
            if (fragment.type === 'event') {
                const filter = tmpContract.rawContract.filters[fragment.format()];
                _filters.push(filter());
            }
        }
        return this.onEthEvent(handler, _filters, handlerOptions, preprocessHandler);
    }
    onEthEvent(handler, filter, handlerOptions, preprocessHandler = defaultPreprocessHandler, handlerName = getHandlerName()) {
        const chainId = this.getChainId();
        let _filters = [];
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        const contractName = this.config.name;
        const processor = this;
        this.eventHandlers.push({
            filters: _filters,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            handlerName,
            handler: async function (data, preparedData) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                let contractView;
                try {
                    contractView = processor.CreateBoundContractView();
                }
                catch (e) {
                    throw e;
                    // console.log(e)
                }
                if (processor.config.address === '*') {
                    contractView.address = log.address;
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, log, undefined, transaction, transactionReceipt, processor.config.baseLabels, preparedData);
                if (handlerOptions?.skipDecoding) {
                    await handler(log, ctx);
                    return ctx.stopAndGetResult();
                }
                let parsed = null;
                try {
                    parsed = await getCachedParsedLog(data, processor, log);
                }
                catch (e) {
                    // RangeError data out-of-bounds
                    if (e instanceof Error) {
                        if (e.message.includes('data out-of-bounds')) {
                            console.error("Can't decode", log, 'may because of incompatible ABIs, e.g. string vs indexed string', e);
                            return ProcessResult.fromPartial({});
                        }
                    }
                    throw e;
                }
                if (parsed) {
                    const event = new TypedEvent(log, parsed.name, fixEmptyKey(parsed));
                    await handler(event, ctx);
                    return ctx.stopAndGetResult();
                }
                return ProcessResult.fromPartial({});
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                let contractView;
                try {
                    contractView = processor.CreateBoundContractView();
                }
                catch (e) {
                    throw e;
                    // console.log(e)
                }
                if (processor.config.address === '*') {
                    contractView.address = log.address;
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, log, undefined, transaction, transactionReceipt, processor.config.baseLabels);
                let parsed = null;
                try {
                    parsed = await getCachedParsedLog(data, processor, log);
                }
                catch (e) {
                    // RangeError data out-of-bounds
                    if (e instanceof Error) {
                        if (e.message.includes('data out-of-bounds')) {
                            console.error("Can't decode", log, 'may because of incompatible ABIs, e.g. string vs indexed string', e);
                            return PreprocessResult.fromPartial({});
                        }
                    }
                    throw e;
                }
                if (parsed) {
                    const event = new TypedEvent(log, parsed.name, fixEmptyKey(parsed));
                    return preprocessHandler(event, ctx, preprocessStore);
                }
                return PreprocessResult.fromPartial({});
            },
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const { log } = formatEthData(data);
                    if (!log)
                        return undefined;
                    let parsed = null;
                    try {
                        parsed = await getCachedParsedLog(data, processor, log);
                    }
                    catch (e) {
                        return undefined;
                    }
                    if (parsed) {
                        const event = new TypedEvent(log, parsed.name, fixEmptyKey(parsed));
                        return p(event);
                    }
                    return undefined;
                }
                return p;
            }
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, handlerOptions, preprocessHandler);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, handlerOptions, preprocessHandler);
    }
    onInterval(handler, timeInterval, blockInterval, handlerOptions, preprocessHandler = defaultPreprocessHandler, handlerName = getHandlerName()) {
        const chainId = this.getChainId();
        const processor = this;
        const contractName = this.config.name;
        this.blockHandlers.push({
            handlerName,
            handler: async function (data, preparedData) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const contractView = processor.CreateBoundContractView();
                const ctx = new ContractContext(contractName, contractView, chainId, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels, preparedData);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const contractView = processor.CreateBoundContractView();
                const ctx = new ContractContext(contractName, contractView, chainId, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                return preprocessHandler(block, ctx, preprocessStore);
            },
            timeIntervalInMinutes: timeInterval,
            blockInterval: blockInterval,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const { block } = formatEthData(data);
                    if (!block)
                        return undefined;
                    return p(block);
                }
                return p;
            }
        });
        return this;
    }
    onEthTrace(signatures, handler, handlerOptions, preprocessHandler = defaultPreprocessHandler, handlerName = getHandlerName()) {
        const chainId = this.getChainId();
        const contractName = this.config.name;
        const processor = this;
        if (typeof signatures === 'string') {
            signatures = [signatures];
        }
        this.traceHandlers.push({
            signatures,
            fetchConfig: EthFetchConfig.fromPartial(handlerOptions || {}),
            handlerName,
            handler: async function (data, preparedData) {
                const contractView = processor.CreateBoundContractView();
                const contractInterface = contractView.rawContract.interface;
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                const sighash = trace?.action.input?.slice(0, 10);
                if (!sighash) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace has no sighash');
                }
                const fragment = contractInterface.getFunction(sighash);
                if (!trace || !fragment) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const typedTrace = trace;
                typedTrace.name = fragment.name;
                typedTrace.functionSignature = fragment.format();
                // const trace = data.trace as Trace
                if (!trace?.action.input) {
                    return ProcessResult.fromPartial({});
                }
                const traceData = '0x' + trace.action.input.slice(10);
                try {
                    typedTrace.args = await decodeTrace(processor, fragment.inputs, traceData);
                    // typedTrace.args = contractInterface.getAbiCoder().decode(fragment.inputs, traceData, true)
                }
                catch (e) {
                    if (!trace.error) {
                        throw e;
                    }
                    console.error('Failed to decode successful trace', e);
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels, preparedData);
                await handler(typedTrace, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const contractView = processor.CreateBoundContractView();
                const contractInterface = contractView.rawContract.interface;
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                const sighash = trace?.action.input?.slice(0, 10);
                if (!sighash) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace has no sighash');
                }
                const fragment = contractInterface.getFunction(sighash);
                if (!trace || !fragment) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const typedTrace = trace;
                typedTrace.name = fragment.name;
                typedTrace.functionSignature = fragment.format();
                // const trace = data.trace as Trace
                if (!trace?.action.input) {
                    return PreprocessResult.fromPartial({});
                }
                const traceData = '0x' + trace.action.input.slice(10);
                try {
                    typedTrace.args = await decodeTrace(processor, fragment.inputs, traceData);
                }
                catch (e) {
                    if (!trace.error) {
                        throw e;
                    }
                    console.error('Failed to decode successful trace', e);
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(typedTrace, ctx, preprocessStore);
            },
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const contractView = processor.CreateBoundContractView();
                    const contractInterface = contractView.rawContract.interface;
                    const { trace } = formatEthData(data);
                    if (!trace)
                        return undefined;
                    const sighash = trace.action.input?.slice(0, 10);
                    if (!sighash)
                        return undefined;
                    const fragment = contractInterface.getFunction(sighash);
                    if (!fragment)
                        return undefined;
                    const typedTrace = trace;
                    typedTrace.name = fragment.name;
                    typedTrace.functionSignature = fragment.format();
                    if (trace.action.input) {
                        const traceData = '0x' + trace.action.input.slice(10);
                        try {
                            typedTrace.args = await decodeTrace(processor, fragment.inputs, traceData);
                        }
                        catch (e) {
                            if (!trace.error) {
                                throw e;
                            }
                        }
                    }
                    return p(typedTrace);
                }
                return p;
            }
        });
        return this;
    }
    onTrace(handler, handlerOptions, preprocessHandler = defaultPreprocessHandler) {
        const tmpContract = this.CreateBoundContractView();
        const sighashes = [];
        for (const fragment of tmpContract.rawContract.interface.fragments) {
            if (fragment.type === 'function') {
                const signature = fragment.format();
                const test = new TextEncoder().encode(signature);
                const sighash = '0x' + sha3.keccak_256(test).substring(0, 8);
                sighashes.push(sighash);
            }
        }
        return this.onEthTrace(sighashes, handler, handlerOptions, preprocessHandler);
    }
}
// Helper function to get cached or parse log data
async function getCachedParsedLog(data, processor, log) {
    // Check if parsed log is already cached on data object
    if (data.__parsedLog !== undefined) {
        return data.__parsedLog;
    }
    try {
        const parsed = await parseLog(processor, log);
        data.__parsedLog = parsed;
        return parsed;
    }
    catch (e) {
        // Cache the null result to avoid retrying
        ;
        data.__parsedLog = null;
        throw e;
    }
}
//# sourceMappingURL=base-processor.js.map