import { DatabaseSchema } from '../core/index.js';
import { AddOp, MultiplyOp } from './types.js';
import { EntityUpdateData_Operator, DBRequest_DBOperator } from '@sentio/protos';
import { PluginManager } from '@sentio/runtime';
import { serializeRichValue } from './util.js';
export function getEntityName(entity) {
    if (entity == null) {
        throw new Error("can't figure out entityName from undefined");
    }
    if (typeof entity == 'string') {
        return entity;
    }
    if (typeof entity == 'function') {
        return entity.entityName;
    }
    if (typeof entity == 'object') {
        return entity.constructor.entityName;
    }
    throw new Error(`can't figure out entityName from ${typeof entity}`);
}
export function getEntityField(entity, field) {
    const entityName = getEntityName(entity);
    const entityClass = DatabaseSchema.findEntity(entityName);
    if (!entityClass) {
        throw new Error(`Entity ${entityName} not found`);
    }
    // @ts-ignore access prototype
    const proto = Object.getPrototypeOf(entityClass.prototype);
    const [fieldWithoutID, hasIDSuffix] = field.endsWith('IDs')
        ? [field.slice(0, -3), true]
        : field.endsWith('ID')
            ? [field.slice(0, -2), true]
            : [field, false];
    if (hasIDSuffix &&
        Object.getOwnPropertyDescriptor(proto, fieldWithoutID) &&
        Object.getOwnPropertyDescriptor(proto, field)) {
        return fieldWithoutID;
    }
    return field;
}
export class Store {
    context;
    constructor(context) {
        this.context = context;
    }
    async get(entity, id) {
        const entityName = getEntityName(entity);
        const promise = this.context.sendRequest({
            get: {
                entity: entityName,
                id: id.toString()
            }
        });
        const data = (await promise);
        if (data.entityList?.entities[0]) {
            const entityData = data.entityList?.entities[0];
            return this.newEntity(entity, entityData);
        }
        return undefined;
    }
    async delete(entity, id) {
        const request = {
            entity: [],
            id: []
        };
        const entityName = getEntityName(entity);
        if (id) {
            if (Array.isArray(id)) {
                for (const i of id) {
                    request.entity.push(entityName);
                    request.id.push(i.toString());
                }
            }
            else {
                request.entity.push(entityName);
                request.id.push(id);
            }
        }
        else {
            const entities = Array.isArray(entity) ? entity : [entity];
            for (const e of entities) {
                request.entity.push(entityName);
                request.id.push(e.id.toString());
            }
        }
        await this.context.sendRequest({
            delete: request
        });
    }
    async update(entity, values) {
        if (values.id) {
            const update = {
                entity: [getEntityName(entity)],
                id: [values.id.toString()],
                entityData: [{ fields: {} }]
            };
            for (const [key, value] of Object.entries(values)) {
                if (key !== 'id') {
                    const field = getEntityField(entity, key);
                    if (value instanceof AddOp) {
                        update.entityData[0].fields[field] = {
                            op: EntityUpdateData_Operator.ADD,
                            value: serializeRichValue(value.value)
                        };
                    }
                    else if (value instanceof MultiplyOp) {
                        update.entityData[0].fields[field] = {
                            op: EntityUpdateData_Operator.MULTIPLY,
                            value: serializeRichValue(value.value)
                        };
                    }
                    else if (value !== undefined) {
                        update.entityData[0].fields[field] = {
                            op: EntityUpdateData_Operator.SET,
                            value: serializeRichValue(value)
                        };
                    }
                }
            }
            await this.context.sendRequest({
                update
            });
        }
        else {
            throw new Error('Update must have id field');
        }
    }
    async upsert(entity) {
        const entities = Array.isArray(entity) ? entity : [entity];
        const request = {
            upsert: {
                entity: entities.map((e) => getEntityName(e)),
                // data: entities.map((e) => serialize(e.data)),
                id: entities.map((e) => e.id.toString()),
                entityData: entities.map((e) => e._data)
            }
        };
        await this.context.sendRequest(request);
    }
    async *listIterator(entity, filters) {
        let cursor = undefined;
        while (true) {
            const response = await this.listRequest(entity, filters || [], cursor);
            for (const data of response.entityList?.entities || []) {
                yield this.newEntity(entity, data);
            }
            if (!response.nextCursor) {
                break;
            }
            cursor = response.nextCursor;
        }
    }
    async *listBatched(entity, filters, batchSize = 100) {
        let cursor = undefined;
        while (true) {
            const response = await this.listRequest(entity, filters || [], cursor, batchSize);
            const entities = (response.entityList?.entities || []).map((data) => this.newEntity(entity, data));
            yield entities;
            if (!response.nextCursor) {
                break;
            }
            cursor = response.nextCursor;
        }
    }
    async listRequest(entity, filters, cursor, pageSize) {
        const response = (await this.context.sendRequest({
            list: {
                entity: getEntityName(entity),
                cursor,
                pageSize,
                filters: filters?.map((f) => {
                    let values;
                    switch (f.op) {
                        case 'in':
                        case 'not in':
                        case 'has all':
                        case 'has any':
                            values = Array.isArray(f.value)
                                ? f.value.map((v) => serializeRichValue(v))
                                : [serializeRichValue(f.value)];
                            break;
                        default:
                            //   = , != should set it to  [[]]
                            values = [serializeRichValue(f.value)];
                    }
                    const field = getEntityField(entity, f.field);
                    return {
                        field,
                        op: ops[f.op],
                        value: {
                            values
                        }
                    };
                }) || []
            }
        }, 3600));
        return response;
    }
    async list(entity, filters, cursor) {
        if (cursor) {
            const response = await this.listRequest(entity, filters || [], cursor.cursor, cursor.pageSize);
            cursor.cursor = response.nextCursor;
            return response.entityList?.entities.map((data) => this.newEntity(entity, data)) || [];
        }
        // TODO Array.fromAsync when upgrade to node 22
        return this.fromAsync(this.listIterator(entity, filters ?? []));
    }
    async fromAsync(gen) {
        const out = [];
        for await (const x of gen) {
            out.push(x);
        }
        return out;
    }
    newEntity(entity, data) {
        if (typeof entity == 'string') {
            let en = DatabaseSchema.findEntity(entity);
            if (!en) {
                // it is an interface
                en = DatabaseSchema.findEntity(data.entity);
                if (!en) {
                    throw new Error(`Entity ${entity} not found`);
                }
            }
            entity = en;
        }
        const res = new entity({});
        res._data = data.data;
        return res;
    }
}
const ops = {
    '=': DBRequest_DBOperator.EQ,
    '!=': DBRequest_DBOperator.NE,
    '<': DBRequest_DBOperator.LT,
    '<=': DBRequest_DBOperator.LE,
    '>': DBRequest_DBOperator.GT,
    '>=': DBRequest_DBOperator.GE,
    in: DBRequest_DBOperator.IN,
    'not in': DBRequest_DBOperator.NOT_IN,
    like: DBRequest_DBOperator.LIKE,
    'not like': DBRequest_DBOperator.NOT_LIKE,
    'has all': DBRequest_DBOperator.HAS_ALL,
    'has any': DBRequest_DBOperator.HAS_ANY
};
export function getStore() {
    const dbContext = PluginManager.INSTANCE.dbContextLocalStorage.getStore();
    if (dbContext) {
        return new Store(dbContext);
    }
    throw new Error('Store not found in context, please ensure you are calling this in a handler function');
}
//# sourceMappingURL=store.js.map