import { MoveFetchConfig } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { SuiNetwork } from './network.js';
import { ServerError, Status } from 'nice-grpc';
import { SuiContext, SuiObjectChangeContext } from './context.js';
import { accountAddressString, SPLITTER } from '../move/index.js';
import { getMoveCalls } from './utils.js';
import { defaultMoveCoder } from './index.js';
import { ALL_ADDRESS } from '../core/index.js';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
export const DEFAULT_FETCH_CONFIG = {
    resourceChanges: false,
    allEvents: true,
    inputs: true
};
export function configure(options) {
    return {
        startCheckpoint: options.startCheckpoint || 0n,
        endCheckpoint: options.endCheckpoint,
        address: options.address === ALL_ADDRESS ? ALL_ADDRESS : accountAddressString(options.address),
        network: options.network || SuiNetwork.MAIN_NET,
        baseLabels: options.baseLabels
    };
}
export class SuiProcessorState extends ListStateStorage {
    static INSTANCE = new SuiProcessorState();
}
export class SuiBaseProcessor {
    moduleName;
    config;
    eventHandlers = [];
    callHandlers = [];
    objectChangeHandlers = [];
    coder;
    constructor(name, options) {
        this.moduleName = name;
        this.config = configure(options);
        SuiProcessorState.INSTANCE.addValue(this);
        this.coder = defaultMoveCoder(this.config.network);
        return proxyProcessor(this);
    }
    getChainId() {
        return this.config.network;
    }
    onMoveEvent(handler, filter, handlerOptions) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...handlerOptions });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        // const address = this.config.address
        // const moduleName = this.moduleName
        const processor = this;
        this.eventHandlers.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                if (!data.rawTransaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'event is null');
                }
                const txn = JSON.parse(data.rawTransaction);
                if (txn.events == null) {
                    txn.events = [];
                }
                const evt = JSON.parse(data.rawEvent);
                const idx = Number(evt.id.eventSeq) || 0;
                const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, txn, idx, processor.config.baseLabels);
                const decoded = await processor.coder.decodeEvent(evt);
                await handler(decoded || evt, ctx);
                return ctx.stopAndGetResult();
            },
            filters: _filters,
            fetchConfig: _fetchConfig,
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const evt = JSON.parse(data.rawEvent);
                    const decoded = await processor.coder.decodeEvent(evt);
                    return p(decoded || evt);
                }
                return p;
            }
        });
        return this;
    }
    onEntryFunctionCall(handler, filter, handlerOptions) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...handlerOptions });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        const processor = this;
        const allFunctionType = new Set(_filters.map((f) => f.function));
        this.callHandlers.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                if (!data.rawTransaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'call is null');
                }
                const tx = JSON.parse(data.rawTransaction);
                const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, tx, 0, processor.config.baseLabels);
                if (tx) {
                    const calls = getMoveCalls(tx);
                    const txKind = tx.transaction?.data?.transaction;
                    if (!txKind) {
                        throw new ServerError(Status.INVALID_ARGUMENT, 'Unexpected getTransactionKind get empty');
                    }
                    // getProgrammableTransaction(txKind)
                    const programmableTx = txKind.kind === 'ProgrammableTransaction' ? txKind : undefined;
                    // TODO potential pass index
                    for (const call of calls) {
                        const functionType = [call.module, call.function].join(SPLITTER);
                        if (!allFunctionType.has(functionType)) {
                            continue;
                        }
                        // TODO maybe do in parallel
                        const decoded = await processor.coder.decodeFunctionPayload(call, programmableTx?.inputs || []);
                        await handler(decoded, ctx);
                    }
                }
                return ctx.stopAndGetResult();
            },
            filters: _filters,
            fetchConfig: _fetchConfig,
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const tx = JSON.parse(data.rawTransaction);
                    const calls = getMoveCalls(tx);
                    // For simplicity, use the first call for partitioning
                    if (calls.length > 0) {
                        return p(calls[0]);
                    }
                    return undefined;
                }
                return p;
            }
        });
        return this;
    }
    onEvent(handler, handlerOptions) {
        this.onMoveEvent(handler, { type: '' }, handlerOptions);
        return this;
    }
    onTransactionBlock(handler, filter, handlerOptions) {
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...handlerOptions });
        const processor = this;
        this.callHandlers.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                if (!data.rawTransaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is null');
                }
                const tx = JSON.parse(data.rawTransaction);
                const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, tx, 0, processor.config.baseLabels);
                if (tx) {
                    await handler(tx, ctx);
                }
                return ctx.stopAndGetResult();
            },
            filters: [{ ...filter, function: '' }],
            fetchConfig: _fetchConfig,
            partitionHandler: async (data) => {
                const p = handlerOptions?.partitionKey;
                if (!p)
                    return undefined;
                if (typeof p === 'function') {
                    const tx = JSON.parse(data.rawTransaction);
                    return p(tx);
                }
                return p;
            }
        });
        return this;
    }
    onObjectChange(handler, type) {
        if (this.config.network === SuiNetwork.TEST_NET) {
            throw new ServerError(Status.INVALID_ARGUMENT, 'object change not supported in testnet');
        }
        const processor = this;
        this.objectChangeHandlers.push({
            handlerName: getHandlerName(),
            handler: async function (data) {
                const ctx = new SuiObjectChangeContext(processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, data.txDigest, processor.config.baseLabels);
                await handler(data.rawChanges.map((r) => JSON.parse(r)), ctx);
                return ctx.stopAndGetResult();
            },
            type
        });
        return this;
    }
}
export class SuiModulesProcessor extends SuiBaseProcessor {
    static bind(options) {
        return new SuiModulesProcessor(ALL_ADDRESS, options);
    }
}
export class SuiGlobalProcessor extends SuiBaseProcessor {
    static bind(options) {
        return new SuiGlobalProcessor(ALL_ADDRESS, { ...options, address: ALL_ADDRESS });
    }
    onTransactionBlock(handler, filter, fetchConfig) {
        // TODO enable more strict check
        // if (!filter.publicKeyPrefix || filter.publicKeyPrefix.length < 2) {
        //   throw new ServerError(Status.INVALID_ARGUMENT, 'restriction too low for global processor')
        // }
        return super.onTransactionBlock(handler, filter, fetchConfig);
    }
    // deprecated,, use object type processor
    onObjectChange(handler, type) {
        return super.onObjectChange(handler, type);
    }
}
//# sourceMappingURL=sui-processor.js.map