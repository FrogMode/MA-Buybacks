import { Data_SuiCall, Data_SuiObject, Data_SuiObjectChange, HandleInterval, MoveAccountFetchConfig, MoveFetchConfig, MoveOwnerType, ProcessResult } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { SuiNetwork } from './network.js';
import { SuiAddressContext, SuiContext, SuiObjectChangeContext, SuiObjectContext } from './context.js';
import { SuiMoveObject, SuiObjectChange, SuiTransactionBlockResponse } from '@mysten/sui/client';
import { PromiseOrVoid } from '../core/index.js';
import { IndexConfigure, SuiBindOptions } from './sui-processor.js';
import { CallHandler, TransactionFilter, ObjectChangeHandler } from '../move/index.js';
import { TypeDescriptor } from '@typemove/move';
import { TypedSuiMoveObject } from './models.js';
export interface SuiObjectBindOptions {
    objectId: string;
    network?: SuiNetwork;
    startCheckpoint?: bigint;
    endCheckpoint?: bigint;
    baseLabels?: {
        [key: string]: string;
    };
}
export interface SuiObjectTypeBindOptions<T> {
    objectType: TypeDescriptor<T>;
    network?: SuiNetwork;
    startCheckpoint?: bigint;
    endCheckpoint?: bigint;
    baseLabels?: {
        [key: string]: string;
    };
}
interface ObjectHandler {
    type?: string;
    checkPointInterval?: HandleInterval;
    timeIntervalInMinutes?: HandleInterval;
    fetchConfig: MoveAccountFetchConfig;
    handler: (resource: Data_SuiObject) => Promise<ProcessResult>;
    handlerName: string;
}
export declare const DEFAULT_ACCOUNT_FETCH_CONFIG: MoveAccountFetchConfig;
export declare class SuiAccountProcessorState extends ListStateStorage<SuiBaseObjectOrAddressProcessor<any>> {
    static INSTANCE: SuiAccountProcessorState;
}
export interface SuiInternalObjectsBindOptions extends SuiBindOptions {
    ownerType: MoveOwnerType;
}
export declare abstract class SuiBaseObjectOrAddressProcessor<HandlerType> {
    config: IndexConfigure;
    ownerType: MoveOwnerType;
    templateId: number | undefined;
    objectHandlers: ObjectHandler[];
    objectChangeHandlers: ObjectChangeHandler<Data_SuiObjectChange>[];
    protected constructor(options: SuiInternalObjectsBindOptions);
    getChainId(): string;
    protected abstract doHandle(handler: HandlerType, data: Data_SuiObject, ctx: SuiObjectContext): Promise<any>;
    onInterval(handler: HandlerType, //(resources: SuiMoveObject[], ctx: SuiObjectsContext) => PromiseOrVoid,
    timeInterval: HandleInterval | undefined, checkpointInterval: HandleInterval | undefined, type: string | undefined, fetchConfig: Partial<MoveAccountFetchConfig> | undefined, handlerName?: string): this;
}
declare abstract class SuiBaseObjectOrAddressProcessorInternal<HandlerType> extends SuiBaseObjectOrAddressProcessor<HandlerType> {
    onTimeInterval(handler: HandlerType, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: HandlerType, checkpointInterval?: number, backfillCheckpointInterval?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class SuiAddressProcessor extends SuiBaseObjectOrAddressProcessorInternal<(objects: SuiMoveObject[], ctx: SuiAddressContext) => PromiseOrVoid> {
    callHandlers: CallHandler<Data_SuiCall>[];
    static bind(options: SuiBindOptions): SuiAddressProcessor;
    protected doHandle(handler: (objects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): Promise<any>;
    onTransactionBlock(handler: (transaction: SuiTransactionBlockResponse, ctx: SuiContext) => PromiseOrVoid, filter?: TransactionFilter, fetchConfig?: Partial<MoveFetchConfig>): this;
}
export declare class SuiObjectProcessor extends SuiBaseObjectOrAddressProcessorInternal<(self: SuiMoveObject, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid> {
    static bind(options: SuiObjectBindOptions): SuiObjectProcessor;
    protected doHandle(handler: (self: SuiMoveObject, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): Promise<any>;
}
export declare class SuiObjectTypeProcessor<T> extends SuiBaseObjectOrAddressProcessor<(self: TypedSuiMoveObject<T>, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid> {
    objectType: TypeDescriptor<T>;
    static bind<T>(options: SuiObjectTypeBindOptions<T>): SuiObjectTypeProcessor<T>;
    protected doHandle(handler: (self: TypedSuiMoveObject<T>, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): Promise<any>;
    onObjectChange(handler: (changes: SuiObjectChange[], ctx: SuiObjectChangeContext) => PromiseOrVoid): this;
    onTimeInterval(handler: (self: TypedSuiMoveObject<T>, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: (self: TypedSuiMoveObject<T>, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, checkpointInterval?: number, backfillCheckpointInterval?: number, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class SuiWrappedObjectProcessor extends SuiBaseObjectOrAddressProcessorInternal<(dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid> {
    static bind(options: SuiObjectBindOptions): SuiWrappedObjectProcessor;
    protected doHandle(handler: (dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): Promise<any>;
}
export {};
//# sourceMappingURL=sui-object-processor.d.ts.map