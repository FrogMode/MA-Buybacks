import { ProcessResult, RecordMetaData, TemplateInstance } from '@sentio/protos';
import { EventLoggerBinding } from './event-logger.js';
import { Meter, Labels } from './meter.js';
import { ChainId } from '@sentio/chain';
import { Store } from '../store/store.js';
import { MemoryCache } from '../store/cache.js';
export declare abstract class BaseContext {
    meter: Meter;
    eventLogger: EventLoggerBinding;
    private _store;
    private _cache;
    baseLabels: Labels;
    private active;
    private _res;
    update(res: Partial<ProcessResult>): void;
    protected constructor(baseLabels: Labels | undefined);
    stopAndGetResult(): ProcessResult;
    private metadataCache;
    getMetaData(name: string, labels: Labels): RecordMetaData;
    protected abstract getMetaDataInternal(name: string, labels: Labels): RecordMetaData;
    abstract getChainId(): ChainId;
    get store(): Store;
    /**
     * Access the in-memory key-value cache.
     *
     * The cache allows storing and retrieving JSON-serializable values that persist
     * across handler invocations. Useful for caching computed results, tracking
     * cumulative state, or storing intermediate processing data.
     *
     * @returns The MemoryCache instance, or undefined if cache is not available
     *
     * @example
     * ```typescript
     * // Store and retrieve values
     * await ctx.cache.set('totalVolume', volume)
     * const cached = await ctx.cache.get<number>('totalVolume')
     *
     * // Block-scoped values (isolated per block)
     * await ctx.cache.setInBlock('blockCount', count)
     * ```
     *
     * @see {@link MemoryCache} for full API documentation
     */
    get cache(): MemoryCache;
    initStore(): void;
    sendTemplateInstance(instance: TemplateInstance, unbind?: boolean): void;
}
//# sourceMappingURL=base-context.d.ts.map