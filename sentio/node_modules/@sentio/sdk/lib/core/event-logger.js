import { EventLogConfig, EventLogConfig_BasicFieldType, EventLogConfig_StructFieldType, LogLevel, TimeseriesResult_TimeseriesType } from '@sentio/protos';
import { normalizeAttribute, normalizeLabels, normalizeToRichStruct } from './normalization.js';
import { MapStateStorage, processMetrics } from '@sentio/runtime';
import { DatabaseSchema } from './database-schema.js';
export class EventLoggerState extends MapStateStorage {
    static INSTANCE = new EventLoggerState();
}
export class EventLoggerBinding {
    ctx;
    constructor(ctx) {
        this.ctx = ctx;
    }
    emit(eventName, event) {
        checkEventName(eventName);
        emit(this.ctx, eventName, event);
    }
}
export const BasicFieldType = EventLogConfig_BasicFieldType;
export function fieldsToProtos(fields) {
    const fieldsProto = [];
    for (const [key, value] of Object.entries(fields)) {
        let basicType;
        let coinType;
        let structType;
        if (typeof value === 'number') {
            basicType = value;
        }
        else {
            if (value.address || value.symbol) {
                coinType = value;
            }
            else {
                structType = EventLogConfig_StructFieldType.create({
                    fields: fieldsToProtos(value)
                });
            }
        }
        fieldsProto.push({
            name: key,
            basicType,
            coinType,
            structType
        });
    }
    return fieldsProto;
}
export class EventLogger {
    eventName;
    config;
    constructor(eventName, config) {
        this.eventName = eventName;
        this.config = config;
    }
    static register(eventName, options) {
        checkEventName(eventName);
        let config = EventLogConfig.create();
        if (options?.fields) {
            config = EventLogConfig.create({
                name: eventName,
                fields: fieldsToProtos(options.fields)
            });
        }
        const logger = new EventLogger(eventName, config);
        return EventLoggerState.INSTANCE.getOrSetValue(eventName, logger);
    }
    emit(ctx, event) {
        emit(ctx, this.eventName, event);
    }
}
function checkEventName(eventName) {
    const entity = DatabaseSchema.findEntity(eventName);
    if (entity) {
        throw new Error(`Event name ${eventName} is already used in the database schema`);
    }
}
function emit(ctx, eventName, event) {
    const { distinctId, severity, message, ...payload } = event;
    const data = {
        fields: {
            severity: {
                stringValue: (severity || LogLevel.INFO).toString()
            },
            message: {
                stringValue: message || ''
            },
            // don't rename to distinctEntityId in new events.
            distinctId: {
                stringValue: distinctId || ''
            },
            ...normalizeToRichStruct(ctx.baseLabels, payload).fields
        }
    };
    // legacy v2 events, deprecating
    const eventRes = {
        metadata: ctx.getMetaData(eventName, {}),
        severity: severity || LogLevel.INFO,
        message: message || '',
        distinctEntityId: distinctId || '',
        attributes: {
            ...normalizeLabels(ctx.baseLabels), // TODO avoid dup label in metadata
            ...normalizeAttribute(payload)
        },
        runtimeInfo: undefined,
        noMetric: true,
        attributes2: normalizeToRichStruct(ctx.baseLabels, payload)
    };
    const res = {
        metadata: ctx.getMetaData(eventName, {}),
        type: TimeseriesResult_TimeseriesType.EVENT,
        data,
        runtimeInfo: undefined
    };
    processMetrics.process_eventemit_count.add(1);
    ctx.update({ timeseriesResult: [res], events: [eventRes] });
}
//# sourceMappingURL=event-logger.js.map