import { FuelProcessorState } from './types.js';
import { getProvider } from './network.js';
import { FuelContext } from './context.js';
import { decodeFuelTransaction } from './transaction.js';
import { InputType, OutputType } from 'fuels';
import { getOptionsSignature } from './fuel-processor.js';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
export class FuelAssetProcessor {
    config;
    txHandlers = [];
    blockHandlers = [];
    provider;
    static bind(config) {
        const processor = new FuelAssetProcessor(config);
        const sig = 'assets_' +
            getOptionsSignature({
                ...config,
                address: '*'
            });
        FuelProcessorState.INSTANCE.getOrSetValue(sig, processor);
        return processor;
    }
    constructor(config) {
        this.config = config;
        return proxyProcessor(this);
    }
    async configure() {
        this.provider = await getProvider(this.config.chainId);
    }
    onTransfer(filter, handler) {
        const filters = [];
        const assetIds = arrayify(filter.assetId);
        const froms = arrayify(filter.from);
        const tos = arrayify(filter.to);
        for (const assetId of assetIds) {
            for (const from of froms) {
                for (const to of tos) {
                    filters.push({
                        assetId: assetId,
                        fromAddress: from,
                        toAddress: to
                    });
                }
            }
        }
        const callHandler = {
            handlerName: getHandlerName(),
            handler: async (call) => {
                const gqlTransaction = call.transaction;
                const tx = await decodeFuelTransaction(gqlTransaction, this.provider);
                const transfer = {
                    from: [],
                    to: []
                };
                let assetId = '';
                for (const input of tx.transaction.inputs || []) {
                    if (input.type == InputType.Coin) {
                        transfer.from.push({
                            address: input.owner,
                            assetId: input.assetId,
                            amount: BigInt(input.amount.toString(10))
                        });
                        assetId = input.assetId;
                    }
                }
                for (const output of tx.transaction.outputs || []) {
                    switch (output.type) {
                        case OutputType.Change:
                        case OutputType.Coin:
                        case OutputType.Variable:
                            const value = output.amount.toString(10);
                            transfer.to.push({
                                address: output.to,
                                amount: BigInt(value),
                                assetId: output.assetId
                            });
                            if (assetId == '') {
                                assetId = output.assetId;
                            }
                    }
                }
                const ctx = new FuelContext(this.config.chainId, assetId, this.config.name ?? '', call.timestamp || new Date(0), tx, null);
                await handler(transfer, ctx);
                return ctx.stopAndGetResult();
            },
            assetConfig: {
                filters
            }
        };
        this.txHandlers.push(callHandler);
        return this;
    }
}
function arrayify(value) {
    if (value) {
        if (Array.isArray(value)) {
            return value.length > 0 ? value : [undefined];
        }
        return [value];
    }
    return [undefined];
}
//# sourceMappingURL=asset-processor.js.map