import { FuelProcessorState } from './types.js';
import { bn } from 'fuels';
import { getProvider } from './network.js';
import { decodeFuelTransaction, DEFAULT_FUEL_FETCH_CONFIG } from './transaction.js';
import { FuelContext } from './context.js';
import { getOptionsSignature } from './fuel-processor.js';
import { mergeProcessResults } from '@sentio/runtime';
import { ALL_ADDRESS } from '../core/index.js';
import { getHandlerName, proxyProcessor } from '../utils/metrics.js';
export class FuelGlobalProcessor {
    config;
    txHandlers = [];
    blockHandlers = [];
    provider;
    static bind(config) {
        const processor = new FuelGlobalProcessor(config);
        const sig = 'global_' +
            getOptionsSignature({
                ...config,
                address: ALL_ADDRESS
            });
        FuelProcessorState.INSTANCE.getOrSetValue(sig, processor);
        return processor;
    }
    constructor(config) {
        this.config = config;
        return proxyProcessor(this);
    }
    async configure() {
        this.provider = await getProvider(this.config.chainId);
    }
    onTransaction(handler, config = DEFAULT_FUEL_FETCH_CONFIG) {
        const callHandler = {
            handlerName: getHandlerName(),
            handler: async (call) => {
                let tx;
                try {
                    tx = await decodeFuelTransaction(call.transaction, this.provider);
                }
                catch (e) {
                    console.error('error decoding transaction', e);
                    return mergeProcessResults([]);
                }
                const header = call.transaction?.status.block.header;
                const ctx = new FuelContext(this.config.chainId, ALL_ADDRESS, this.config.name ?? '*', call.timestamp || new Date(0), tx, header
                    ? {
                        header: {
                            daHeight: bn(header.daHeight)
                        }
                    }
                    : null);
                await handler(tx, ctx);
                return ctx.stopAndGetResult();
            },
            fetchConfig: {
                filters: [],
                ...config
            }
        };
        this.txHandlers.push(callHandler);
        return this;
    }
}
//# sourceMappingURL=global-processor.js.map