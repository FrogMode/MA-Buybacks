/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x2, original address 0x2 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/iota";

import { defaultMoveCoder } from "@sentio/sdk/iota";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/iota";
import {
  Transaction,
  TransactionArgument,
  TransactionObjectArgument,
} from "@iota/iota-sdk/transactions";
import { IotaClient } from "@iota/iota-sdk/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrVec,
  transactionArgumentOrPure,
  transactionArgumentOrPureU8,
  transactionArgumentOrPureU16,
  transactionArgumentOrPureU32,
  transactionArgumentOrPureU64,
  transactionArgumentOrPureU128,
  transactionArgumentOrPureU256,
  transactionArgumentOrPureBool,
  transactionArgumentOrPureString,
  transactionArgumentOrPureAddress,
} from "@typemove/iota";

import { CallFilter, MoveFetchConfig, EventFilter } from "@sentio/sdk/move";
import { HandlerOptions } from "@sentio/sdk";
import {
  IotaBindOptions,
  IotaBaseProcessor,
  IotaNetwork,
  TypedFunctionPayload,
  IotaContext,
} from "@sentio/sdk/iota";

import * as _0x1 from "./0x1.js";

export namespace address {
  export namespace builder {
    export function fromAsciiBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_ascii_bytes",
        arguments: _args,
      });
    }
    export function fromBytes(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_bytes",
        arguments: _args,
      });
    }
    export function fromU256(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_u256",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::length",
        arguments: _args,
      });
    }
    export function max(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::max",
        arguments: _args,
      });
    }
    export function toAsciiString(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_ascii_string",
        arguments: _args,
      });
    }
    export function toBytes(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_bytes",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_string",
        arguments: _args,
      });
    }
    export function toU256(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_u256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function fromAsciiBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fromAsciiBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromBytes(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromU256(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fromU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toAsciiString(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new Transaction();
      builder.toAsciiString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function toBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.toBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function toU256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.toU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export class authenticator_state extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("authenticator_state", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): authenticator_state {
    return new authenticator_state({
      ...authenticator_state.DEFAULT_OPTIONS,
      ...options,
    });
  }

  onEventActiveJwk(
    func: (
      event: authenticator_state.ActiveJwkInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      authenticator_state.ActiveJwkInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): authenticator_state {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "authenticator_state::ActiveJwk" },
      handlerOptions,
    );
    return this;
  }

  onEventJWK(
    func: (event: authenticator_state.JWKInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      authenticator_state.JWKInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): authenticator_state {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "authenticator_state::JWK" },
      handlerOptions,
    );
    return this;
  }

  onEventJwkId(
    func: (event: authenticator_state.JwkIdInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      authenticator_state.JwkIdInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): authenticator_state {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "authenticator_state::JwkId" },
      handlerOptions,
    );
    return this;
  }
}

export namespace authenticator_state {
  export interface ActiveJwk {
    jwk_id: authenticator_state.JwkId;
    jwk: authenticator_state.JWK;
    epoch: bigint;
  }

  export namespace ActiveJwk {
    export const TYPE_QNAME = "0x2::authenticator_state::ActiveJwk";

    const TYPE = new TypeDescriptor<ActiveJwk>(ActiveJwk.TYPE_QNAME);

    export function type(): TypeDescriptor<ActiveJwk> {
      return TYPE.apply();
    }
  }

  export type ActiveJwkInstance = TypedEventInstance<ActiveJwk> & {
    data_decoded: ActiveJwk;
    type_arguments: [];
  };

  export interface AuthenticatorState {
    id: object$.UID;
    version: bigint;
  }

  export namespace AuthenticatorState {
    export const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorState";

    const TYPE = new TypeDescriptor<AuthenticatorState>(
      AuthenticatorState.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<AuthenticatorState> {
      return TYPE.apply();
    }
  }

  export interface AuthenticatorStateInner {
    version: bigint;
    active_jwks: authenticator_state.ActiveJwk[];
  }

  export namespace AuthenticatorStateInner {
    export const TYPE_QNAME =
      "0x2::authenticator_state::AuthenticatorStateInner";

    const TYPE = new TypeDescriptor<AuthenticatorStateInner>(
      AuthenticatorStateInner.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<AuthenticatorStateInner> {
      return TYPE.apply();
    }
  }

  export interface JWK {
    kty: string;
    e: string;
    n: string;
    alg: string;
  }

  export namespace JWK {
    export const TYPE_QNAME = "0x2::authenticator_state::JWK";

    const TYPE = new TypeDescriptor<JWK>(JWK.TYPE_QNAME);

    export function type(): TypeDescriptor<JWK> {
      return TYPE.apply();
    }
  }

  export type JWKInstance = TypedEventInstance<JWK> & {
    data_decoded: JWK;
    type_arguments: [];
  };

  export interface JwkId {
    iss: string;
    kid: string;
  }

  export namespace JwkId {
    export const TYPE_QNAME = "0x2::authenticator_state::JwkId";

    const TYPE = new TypeDescriptor<JwkId>(JwkId.TYPE_QNAME);

    export function type(): TypeDescriptor<JwkId> {
      return TYPE.apply();
    }
  }

  export type JwkIdInstance = TypedEventInstance<JwkId> & {
    data_decoded: JwkId;
    type_arguments: [];
  };

  export namespace builder {}
  export namespace view {}
}

export namespace bag {
  export interface Bag {
    id: object$.UID;
    size: bigint;
  }

  export namespace Bag {
    export const TYPE_QNAME = "0x2::bag::Bag";

    const TYPE = new TypeDescriptor<Bag>(Bag.TYPE_QNAME);

    export function type(): TypeDescriptor<Bag> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function containsWithType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::contains_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty(
      tx: Transaction,
      args: [bag.Bag | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::destroy_empty",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::length",
        arguments: _args,
      });
    }
    export function new$(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::new",
        arguments: _args,
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function containsWithType<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.containsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty(
      client: IotaClient,
      args: [bag.Bag],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bag.Bag]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bag.Bag]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace balance {
  export type Balance<T> = bigint;
  export namespace Balance {
    export const TYPE_QNAME = "0x2::balance::Balance";

    const TYPE = new TypeDescriptor<Balance<any>>(Balance.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Balance<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface Supply<T0> {
    value: bigint;
  }

  export namespace Supply {
    export const TYPE_QNAME = "0x2::balance::Supply";

    const TYPE = new TypeDescriptor<Supply<any>>(Supply.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Supply<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function createSupply<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::create_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decreaseSupply<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::decrease_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroySupply<T0 = any>(
      tx: Transaction,
      args: [balance.Supply<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::destroy_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: Transaction,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function increaseSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::increase_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyValue<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::supply_value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function value<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdrawAll<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::withdraw_all",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function createSupply<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Supply<T0>]>> {
      const tx = new Transaction();
      builder.createSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Supply<T0>]
      >(inspectRes);
    }
    export async function decreaseSupply<T0 = any>(
      client: IotaClient,
      args: [string, balance.Balance<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.decreaseSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function destroySupply<T0 = any>(
      client: IotaClient,
      args: [balance.Supply<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.destroySupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function destroyZero<T0 = any>(
      client: IotaClient,
      args: [balance.Balance<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function increaseSupply<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.increaseSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function join<T0 = any>(
      client: IotaClient,
      args: [string, balance.Balance<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function supplyValue<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.supplyValue(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function withdrawAll<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.withdrawAll(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function zero<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
  }
}

export class bcs extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("bcs", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): bcs {
    return new bcs({ ...bcs.DEFAULT_OPTIONS, ...options });
  }

  onEventBCS(
    func: (event: bcs.BCSInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, bcs.BCSInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): bcs {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "bcs::BCS" },
      handlerOptions,
    );
    return this;
  }
}

export namespace bcs {
  export interface BCS {
    bytes: number[];
  }

  export namespace BCS {
    export const TYPE_QNAME = "0x2::bcs::BCS";

    const TYPE = new TypeDescriptor<BCS>(BCS.TYPE_QNAME);

    export function type(): TypeDescriptor<BCS> {
      return TYPE.apply();
    }
  }

  export type BCSInstance = TypedEventInstance<BCS> & {
    data_decoded: BCS;
    type_arguments: [];
  };

  export namespace builder {
    export function intoRemainderBytes(
      tx: Transaction,
      args: [bcs.BCS | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::into_remainder_bytes",
        arguments: _args,
      });
    }
    export function new$(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::new",
        arguments: _args,
      });
    }
    export function peelAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_address",
        arguments: _args,
      });
    }
    export function peelBool(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_bool",
        arguments: _args,
      });
    }
    export function peelEnumTag(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_enum_tag",
        arguments: _args,
      });
    }
    export function peelOptionAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_address",
        arguments: _args,
      });
    }
    export function peelOptionBool(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_bool",
        arguments: _args,
      });
    }
    export function peelOptionU128(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u128",
        arguments: _args,
      });
    }
    export function peelOptionU16(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u16",
        arguments: _args,
      });
    }
    export function peelOptionU256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u256",
        arguments: _args,
      });
    }
    export function peelOptionU32(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u32",
        arguments: _args,
      });
    }
    export function peelOptionU64(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u64",
        arguments: _args,
      });
    }
    export function peelOptionU8(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u8",
        arguments: _args,
      });
    }
    export function peelU128(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u128",
        arguments: _args,
      });
    }
    export function peelU16(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u16",
        arguments: _args,
      });
    }
    export function peelU256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u256",
        arguments: _args,
      });
    }
    export function peelU32(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u32",
        arguments: _args,
      });
    }
    export function peelU64(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u64",
        arguments: _args,
      });
    }
    export function peelU8(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u8",
        arguments: _args,
      });
    }
    export function peelVecAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_address",
        arguments: _args,
      });
    }
    export function peelVecBool(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_bool",
        arguments: _args,
      });
    }
    export function peelVecLength(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_length",
        arguments: _args,
      });
    }
    export function peelVecU128(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u128",
        arguments: _args,
      });
    }
    export function peelVecU16(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u16",
        arguments: _args,
      });
    }
    export function peelVecU256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u256",
        arguments: _args,
      });
    }
    export function peelVecU32(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u32",
        arguments: _args,
      });
    }
    export function peelVecU64(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u64",
        arguments: _args,
      });
    }
    export function peelVecU8(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u8",
        arguments: _args,
      });
    }
    export function peelVecVecU8(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_vec_u8",
        arguments: _args,
      });
    }
    export function toBytes<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::to_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function intoRemainderBytes(
      client: IotaClient,
      args: [bcs.BCS],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.intoRemainderBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[bcs.BCS]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bcs.BCS]>(
        inspectRes,
      );
    }
    export async function peelAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.peelAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function peelBool(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.peelBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function peelEnumTag(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.peelEnumTag(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function peelOptionAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new Transaction();
      builder.peelOptionAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function peelOptionBool(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<boolean>]>> {
      const tx = new Transaction();
      builder.peelOptionBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<boolean>]
      >(inspectRes);
    }
    export async function peelOptionU128(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.peelOptionU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function peelOptionU16(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>> {
      const tx = new Transaction();
      builder.peelOptionU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<number>]
      >(inspectRes);
    }
    export async function peelOptionU256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.peelOptionU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function peelOptionU32(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>> {
      const tx = new Transaction();
      builder.peelOptionU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<number>]
      >(inspectRes);
    }
    export async function peelOptionU64(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.peelOptionU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function peelOptionU8(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>> {
      const tx = new Transaction();
      builder.peelOptionU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<number>]
      >(inspectRes);
    }
    export async function peelU128(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.peelU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU16(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.peelU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function peelU256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.peelU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU32(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.peelU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function peelU64(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.peelU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU8(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.peelU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function peelVecAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new Transaction();
      builder.peelVecAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function peelVecBool(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean[]]>> {
      const tx = new Transaction();
      builder.peelVecBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean[]]>(
        inspectRes,
      );
    }
    export async function peelVecLength(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.peelVecLength(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelVecU128(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new Transaction();
      builder.peelVecU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function peelVecU16(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.peelVecU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function peelVecU256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new Transaction();
      builder.peelVecU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function peelVecU32(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.peelVecU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function peelVecU64(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new Transaction();
      builder.peelVecU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function peelVecU8(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.peelVecU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function peelVecVecU8(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[][]]>> {
      const tx = new Transaction();
      builder.peelVecVecU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[][]]>(
        inspectRes,
      );
    }
    export async function toBytes<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.toBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace bls12381 {
  export interface G1 {
    dummy_field: boolean;
  }

  export namespace G1 {
    export const TYPE_QNAME = "0x2::bls12381::G1";

    const TYPE = new TypeDescriptor<G1>(G1.TYPE_QNAME);

    export function type(): TypeDescriptor<G1> {
      return TYPE.apply();
    }
  }

  export interface G2 {
    dummy_field: boolean;
  }

  export namespace G2 {
    export const TYPE_QNAME = "0x2::bls12381::G2";

    const TYPE = new TypeDescriptor<G2>(G2.TYPE_QNAME);

    export function type(): TypeDescriptor<G2> {
      return TYPE.apply();
    }
  }

  export interface GT {
    dummy_field: boolean;
  }

  export namespace GT {
    export const TYPE_QNAME = "0x2::bls12381::GT";

    const TYPE = new TypeDescriptor<GT>(GT.TYPE_QNAME);

    export function type(): TypeDescriptor<GT> {
      return TYPE.apply();
    }
  }

  export interface Scalar {
    dummy_field: boolean;
  }

  export namespace Scalar {
    export const TYPE_QNAME = "0x2::bls12381::Scalar";

    const TYPE = new TypeDescriptor<Scalar>(Scalar.TYPE_QNAME);

    export function type(): TypeDescriptor<Scalar> {
      return TYPE.apply();
    }
  }

  export interface UncompressedG1 {
    dummy_field: boolean;
  }

  export namespace UncompressedG1 {
    export const TYPE_QNAME = "0x2::bls12381::UncompressedG1";

    const TYPE = new TypeDescriptor<UncompressedG1>(UncompressedG1.TYPE_QNAME);

    export function type(): TypeDescriptor<UncompressedG1> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function bls12381MinPkVerify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::bls12381_min_pk_verify",
        arguments: _args,
      });
    }
    export function bls12381MinSigVerify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::bls12381_min_sig_verify",
        arguments: _args,
      });
    }
    export function g1Add(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_add",
        arguments: _args,
      });
    }
    export function g1Div(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_div",
        arguments: _args,
      });
    }
    export function g1FromBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_from_bytes",
        arguments: _args,
      });
    }
    export function g1Generator(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_generator",
        arguments: _args,
      });
    }
    export function g1Identity(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_identity",
        arguments: _args,
      });
    }
    export function g1Mul(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_mul",
        arguments: _args,
      });
    }
    export function g1MultiScalarMultiplication(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_multi_scalar_multiplication",
        arguments: _args,
      });
    }
    export function g1Neg(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_neg",
        arguments: _args,
      });
    }
    export function g1Sub(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_sub",
        arguments: _args,
      });
    }
    export function g1ToUncompressedG1(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_to_uncompressed_g1",
        arguments: _args,
      });
    }
    export function g2Add(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_add",
        arguments: _args,
      });
    }
    export function g2Div(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_div",
        arguments: _args,
      });
    }
    export function g2FromBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_from_bytes",
        arguments: _args,
      });
    }
    export function g2Generator(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_generator",
        arguments: _args,
      });
    }
    export function g2Identity(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_identity",
        arguments: _args,
      });
    }
    export function g2Mul(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_mul",
        arguments: _args,
      });
    }
    export function g2MultiScalarMultiplication(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_multi_scalar_multiplication",
        arguments: _args,
      });
    }
    export function g2Neg(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_neg",
        arguments: _args,
      });
    }
    export function g2Sub(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_sub",
        arguments: _args,
      });
    }
    export function gtAdd(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_add",
        arguments: _args,
      });
    }
    export function gtDiv(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_div",
        arguments: _args,
      });
    }
    export function gtGenerator(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_generator",
        arguments: _args,
      });
    }
    export function gtIdentity(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_identity",
        arguments: _args,
      });
    }
    export function gtMul(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_mul",
        arguments: _args,
      });
    }
    export function gtNeg(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_neg",
        arguments: _args,
      });
    }
    export function gtSub(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_sub",
        arguments: _args,
      });
    }
    export function hashToG1(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::hash_to_g1",
        arguments: _args,
      });
    }
    export function hashToG2(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::hash_to_g2",
        arguments: _args,
      });
    }
    export function pairing(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::pairing",
        arguments: _args,
      });
    }
    export function scalarAdd(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_add",
        arguments: _args,
      });
    }
    export function scalarDiv(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_div",
        arguments: _args,
      });
    }
    export function scalarFromBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_from_bytes",
        arguments: _args,
      });
    }
    export function scalarFromU64(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_from_u64",
        arguments: _args,
      });
    }
    export function scalarInv(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_inv",
        arguments: _args,
      });
    }
    export function scalarMul(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_mul",
        arguments: _args,
      });
    }
    export function scalarNeg(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_neg",
        arguments: _args,
      });
    }
    export function scalarOne(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_one",
        arguments: _args,
      });
    }
    export function scalarSub(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_sub",
        arguments: _args,
      });
    }
    export function scalarZero(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_zero",
        arguments: _args,
      });
    }
    export function uncompressedG1Sum(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::uncompressed_g1_sum",
        arguments: _args,
      });
    }
    export function uncompressedG1ToG1(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::uncompressed_g1_to_g1",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bls12381MinPkVerify(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.bls12381MinPkVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function bls12381MinSigVerify(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.bls12381MinSigVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function g1Add(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Div(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1FromBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1FromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Generator(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Generator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Identity(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Identity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Mul(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1MultiScalarMultiplication(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1MultiScalarMultiplication(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Neg(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Neg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Sub(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.g1Sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1ToUncompressedG1(
      client: IotaClient,
      args: [string],
    ): Promise<
      TypedDevInspectResults<[group_ops.Element<bls12381.UncompressedG1>]>
    > {
      const tx = new Transaction();
      builder.g1ToUncompressedG1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.UncompressedG1>]
      >(inspectRes);
    }
    export async function g2Add(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Div(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2FromBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2FromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Generator(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Generator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Identity(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Identity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Mul(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2MultiScalarMultiplication(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2MultiScalarMultiplication(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Neg(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Neg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Sub(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.g2Sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function gtAdd(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtAdd(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtDiv(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtGenerator(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtGenerator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtIdentity(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtIdentity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtMul(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtNeg(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtNeg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtSub(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.gtSub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function hashToG1(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.hashToG1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function hashToG2(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new Transaction();
      builder.hashToG2(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function pairing(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new Transaction();
      builder.pairing(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function scalarAdd(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarAdd(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarDiv(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarFromBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarFromU64(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarFromU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarInv(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarInv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarMul(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarNeg(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarNeg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarOne(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarOne(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarSub(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarSub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarZero(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new Transaction();
      builder.scalarZero(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function uncompressedG1Sum(
      client: IotaClient,
      args: [string],
    ): Promise<
      TypedDevInspectResults<[group_ops.Element<bls12381.UncompressedG1>]>
    > {
      const tx = new Transaction();
      builder.uncompressedG1Sum(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.UncompressedG1>]
      >(inspectRes);
    }
    export async function uncompressedG1ToG1(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new Transaction();
      builder.uncompressedG1ToG1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
  }
}

export namespace borrow {
  export interface Borrow {
    ref: string;
    obj: object$.ID;
  }

  export namespace Borrow {
    export const TYPE_QNAME = "0x2::borrow::Borrow";

    const TYPE = new TypeDescriptor<Borrow>(Borrow.TYPE_QNAME);

    export function type(): TypeDescriptor<Borrow> {
      return TYPE.apply();
    }
  }

  export interface Referent<T0> {
    id: string;
    value: _0x1.option.Option<T0>;
  }

  export namespace Referent {
    export const TYPE_QNAME = "0x2::borrow::Referent";

    const TYPE = new TypeDescriptor<Referent<any>>(Referent.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Referent<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroy<T0 = any>(
      tx: Transaction,
      args: [borrow.Referent<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::destroy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function putBack<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        borrow.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::put_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, borrow.Borrow]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, borrow.Borrow]
      >(inspectRes);
    }
    export async function destroy<T0 = any>(
      client: IotaClient,
      args: [borrow.Referent<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.destroy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[borrow.Referent<T0>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [borrow.Referent<T0>]
      >(inspectRes);
    }
    export async function putBack<T0 = any>(
      client: IotaClient,
      args: [string, T0, borrow.Borrow],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.putBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace clock {
  export interface Clock {
    id: object$.UID;
    timestamp_ms: bigint;
  }

  export namespace Clock {
    export const TYPE_QNAME = "0x2::clock::Clock";

    const TYPE = new TypeDescriptor<Clock>(Clock.TYPE_QNAME);

    export function type(): TypeDescriptor<Clock> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function timestampMs(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::clock::timestamp_ms",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function timestampMs(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.timestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export class coin extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("coin", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): coin {
    return new coin({ ...coin.DEFAULT_OPTIONS, ...options });
  }

  onEntryBurn(
    func: (call: coin.BurnPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin.BurnPayload>,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::burn",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryJoin(
    func: (call: coin.JoinPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin.JoinPayload>,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::join",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryMintAndTransfer(
    func: (call: coin.MintAndTransferPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      coin.MintAndTransferPayload
    >,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::mint_and_transfer",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryUpdateDescription(
    func: (call: coin.UpdateDescriptionPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      coin.UpdateDescriptionPayload
    >,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::update_description",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryUpdateIconUrl(
    func: (call: coin.UpdateIconUrlPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin.UpdateIconUrlPayload>,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::update_icon_url",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryUpdateName(
    func: (call: coin.UpdateNamePayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin.UpdateNamePayload>,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::update_name",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryUpdateSymbol(
    func: (call: coin.UpdateSymbolPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin.UpdateSymbolPayload>,
  ): coin {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin::update_symbol",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace coin {
  export type Coin<T> = string;
  export namespace Coin {
    export const TYPE_QNAME = "0x2::coin::Coin";

    const TYPE = new TypeDescriptor<Coin<any>>(Coin.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Coin<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CoinMetadata<T0> {
    id: object$.UID;
    decimals: number;
    name: string;
    symbol: _0x1.ascii.String;
    description: string;
    icon_url: _0x1.option.Option<url.Url>;
  }

  export namespace CoinMetadata {
    export const TYPE_QNAME = "0x2::coin::CoinMetadata";

    const TYPE = new TypeDescriptor<CoinMetadata<any>>(CoinMetadata.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CoinMetadata<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface DenyCapV1<T0> {
    id: object$.UID;
    allow_global_pause: boolean;
  }

  export namespace DenyCapV1 {
    export const TYPE_QNAME = "0x2::coin::DenyCapV1";

    const TYPE = new TypeDescriptor<DenyCapV1<any>>(DenyCapV1.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<DenyCapV1<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RegulatedCoinMetadata<T0> {
    id: object$.UID;
    coin_metadata_object: object$.ID;
    deny_cap_object: object$.ID;
  }

  export namespace RegulatedCoinMetadata {
    export const TYPE_QNAME = "0x2::coin::RegulatedCoinMetadata";

    const TYPE = new TypeDescriptor<RegulatedCoinMetadata<any>>(
      RegulatedCoinMetadata.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RegulatedCoinMetadata<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TreasuryCap<T0> {
    id: object$.UID;
    total_supply: balance.Supply<T0>;
  }

  export namespace TreasuryCap {
    export const TYPE_QNAME = "0x2::coin::TreasuryCap";

    const TYPE = new TypeDescriptor<TreasuryCap<any>>(TreasuryCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TreasuryCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function balance<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function balanceMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::balance_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function burn<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::burn",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createCurrency<T0 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::create_currency",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createRegulatedCurrencyV1<T0 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPureBool(args[6], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::create_regulated_currency_v1",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1Add<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1ContainsCurrentEpoch<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_contains_current_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1ContainsNextEpoch<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_contains_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1DisableGlobalPause<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_disable_global_pause",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1EnableGlobalPause<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_enable_global_pause",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1IsGlobalPauseEnabledCurrentEpoch<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_is_global_pause_enabled_current_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1IsGlobalPauseEnabledNextEpoch<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_is_global_pause_enabled_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListV1Remove<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_v1_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: Transaction,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function divideIntoN<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::divide_into_n",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromBalance<T0 = any>(
      tx: Transaction,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::from_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getDecimals<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_decimals",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getDescription<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getIconUrl<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getName<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getSymbol<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoBalance<T0 = any>(
      tx: Transaction,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::into_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mint<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintAndTransfer<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintBalance<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function put<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::put",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyImmut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::supply_immut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::supply_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function take<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::take",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function totalSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::total_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function treasuryIntoSupply<T0 = any>(
      tx: Transaction,
      args: [coin.TreasuryCap<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::treasury_into_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateDescription<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateIconUrl<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateName<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateSymbol<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function value<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function balance<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.balance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function balanceMut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.balanceMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function burn<T0 = any>(
      client: IotaClient,
      args: [string, coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.burn(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function createCurrency<T0 = any>(
      client: IotaClient,
      args: [
        T0,
        number,
        string[],
        string[],
        string[],
        _0x1.option.Option<url.Url>,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[coin.TreasuryCap<T0>, coin.CoinMetadata<T0>]>
    > {
      const tx = new Transaction();
      builder.createCurrency(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.TreasuryCap<T0>, coin.CoinMetadata<T0>]
      >(inspectRes);
    }
    export async function createRegulatedCurrencyV1<T0 = any>(
      client: IotaClient,
      args: [
        T0,
        number,
        string[],
        string[],
        string[],
        _0x1.option.Option<url.Url>,
        boolean,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [coin.TreasuryCap<T0>, coin.DenyCapV1<T0>, coin.CoinMetadata<T0>]
      >
    > {
      const tx = new Transaction();
      builder.createRegulatedCurrencyV1(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.TreasuryCap<T0>, coin.DenyCapV1<T0>, coin.CoinMetadata<T0>]
      >(inspectRes);
    }
    export async function denyListV1Add<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.denyListV1Add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function denyListV1ContainsCurrentEpoch<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.denyListV1ContainsCurrentEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function denyListV1ContainsNextEpoch<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.denyListV1ContainsNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function denyListV1DisableGlobalPause<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.denyListV1DisableGlobalPause(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function denyListV1EnableGlobalPause<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.denyListV1EnableGlobalPause(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function denyListV1IsGlobalPauseEnabledCurrentEpoch<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.denyListV1IsGlobalPauseEnabledCurrentEpoch(
        tx,
        args,
        typeArguments,
      );
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function denyListV1IsGlobalPauseEnabledNextEpoch<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.denyListV1IsGlobalPauseEnabledNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function denyListV1Remove<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.denyListV1Remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function destroyZero<T0 = any>(
      client: IotaClient,
      args: [coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function divideIntoN<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>[]]>> {
      const tx = new Transaction();
      builder.divideIntoN(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>[]]
      >(inspectRes);
    }
    export async function fromBalance<T0 = any>(
      client: IotaClient,
      args: [balance.Balance<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.fromBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function getDecimals<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.getDecimals(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function getDescription<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getDescription(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getIconUrl<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<url.Url>]>> {
      const tx = new Transaction();
      builder.getIconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<url.Url>]
      >(inspectRes);
    }
    export async function getName<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getSymbol<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new Transaction();
      builder.getSymbol(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function intoBalance<T0 = any>(
      client: IotaClient,
      args: [coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.intoBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function join<T0 = any>(
      client: IotaClient,
      args: [string, coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mint<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.mint(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function mintAndTransfer<T0 = any>(
      client: IotaClient,
      args: [string, bigint, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.mintAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mintBalance<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.mintBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function put<T0 = any>(
      client: IotaClient,
      args: [string, coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.put(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function supplyImmut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.supplyImmut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function supplyMut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.supplyMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function take<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.take(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function totalSupply<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function treasuryIntoSupply<T0 = any>(
      client: IotaClient,
      args: [coin.TreasuryCap<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Supply<T0>]>> {
      const tx = new Transaction();
      builder.treasuryIntoSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Supply<T0>]
      >(inspectRes);
    }
    export async function updateDescription<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateDescription(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateIconUrl<T0 = any>(
      client: IotaClient,
      args: [string, string, _0x1.ascii.String],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateIconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateName<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateSymbol<T0 = any>(
      client: IotaClient,
      args: [string, string, _0x1.ascii.String],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateSymbol(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function zero<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
  }

  export interface BurnPayload<T0 = any>
    extends TypedFunctionPayload<[string, coin.Coin<T0>]> {
    arguments_decoded: [string, coin.Coin<T0>];
    type_arguments: [string];
  }

  export interface JoinPayload<T0 = any>
    extends TypedFunctionPayload<[string, coin.Coin<T0>]> {
    arguments_decoded: [string, coin.Coin<T0>];
    type_arguments: [string];
  }

  export interface MintAndTransferPayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint, string, string]> {
    arguments_decoded: [string, bigint, string, string];
    type_arguments: [string];
  }

  export interface UpdateDescriptionPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, string]> {
    arguments_decoded: [string, string, string];
    type_arguments: [string];
  }

  export interface UpdateIconUrlPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, _0x1.ascii.String]> {
    arguments_decoded: [string, string, _0x1.ascii.String];
    type_arguments: [string];
  }

  export interface UpdateNamePayload<T0 = any>
    extends TypedFunctionPayload<[string, string, string]> {
    arguments_decoded: [string, string, string];
    type_arguments: [string];
  }

  export interface UpdateSymbolPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, _0x1.ascii.String]> {
    arguments_decoded: [string, string, _0x1.ascii.String];
    type_arguments: [string];
  }
}

export class coin_manager extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("coin_manager", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): coin_manager {
    return new coin_manager({ ...coin_manager.DEFAULT_OPTIONS, ...options });
  }

  onEntryBurn(
    func: (call: coin_manager.BurnPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, coin_manager.BurnPayload>,
  ): coin_manager {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "coin_manager::burn",
      },
      handlerOptions,
    );
    return this;
  }

  onEventCoinManaged(
    func: (event: coin_manager.CoinManagedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      coin_manager.CoinManagedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): coin_manager {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "coin_manager::CoinManaged" },
      handlerOptions,
    );
    return this;
  }

  onEventMetadataOwnershipRenounced(
    func: (
      event: coin_manager.MetadataOwnershipRenouncedInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      coin_manager.MetadataOwnershipRenouncedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): coin_manager {
    this.onMoveEvent(
      func,
      {
        ...(eventFilter ?? {}),
        type: "coin_manager::MetadataOwnershipRenounced",
      },
      handlerOptions,
    );
    return this;
  }

  onEventTreasuryOwnershipRenounced(
    func: (
      event: coin_manager.TreasuryOwnershipRenouncedInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      coin_manager.TreasuryOwnershipRenouncedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): coin_manager {
    this.onMoveEvent(
      func,
      {
        ...(eventFilter ?? {}),
        type: "coin_manager::TreasuryOwnershipRenounced",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace coin_manager {
  export interface CoinManaged {
    coin_name: _0x1.ascii.String;
  }

  export namespace CoinManaged {
    export const TYPE_QNAME = "0x2::coin_manager::CoinManaged";

    const TYPE = new TypeDescriptor<CoinManaged>(CoinManaged.TYPE_QNAME);

    export function type(): TypeDescriptor<CoinManaged> {
      return TYPE.apply();
    }
  }

  export type CoinManagedInstance = TypedEventInstance<CoinManaged> & {
    data_decoded: CoinManaged;
    type_arguments: [];
  };

  export interface CoinManager<T0> {
    id: object$.UID;
    treasury_cap: coin.TreasuryCap<T0>;
    metadata: _0x1.option.Option<coin.CoinMetadata<T0>>;
    immutable_metadata: _0x1.option.Option<
      coin_manager.ImmutableCoinMetadata<T0>
    >;
    maximum_supply: _0x1.option.Option<bigint>;
    supply_immutable: boolean;
    metadata_immutable: boolean;
  }

  export namespace CoinManager {
    export const TYPE_QNAME = "0x2::coin_manager::CoinManager";

    const TYPE = new TypeDescriptor<CoinManager<any>>(CoinManager.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CoinManager<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CoinManagerMetadataCap<T0> {
    id: object$.UID;
  }

  export namespace CoinManagerMetadataCap {
    export const TYPE_QNAME = "0x2::coin_manager::CoinManagerMetadataCap";

    const TYPE = new TypeDescriptor<CoinManagerMetadataCap<any>>(
      CoinManagerMetadataCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CoinManagerMetadataCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CoinManagerTreasuryCap<T0> {
    id: object$.UID;
  }

  export namespace CoinManagerTreasuryCap {
    export const TYPE_QNAME = "0x2::coin_manager::CoinManagerTreasuryCap";

    const TYPE = new TypeDescriptor<CoinManagerTreasuryCap<any>>(
      CoinManagerTreasuryCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CoinManagerTreasuryCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ImmutableCoinMetadata<T0> {
    decimals: number;
    name: string;
    symbol: _0x1.ascii.String;
    description: string;
    icon_url: _0x1.option.Option<url.Url>;
  }

  export namespace ImmutableCoinMetadata {
    export const TYPE_QNAME = "0x2::coin_manager::ImmutableCoinMetadata";

    const TYPE = new TypeDescriptor<ImmutableCoinMetadata<any>>(
      ImmutableCoinMetadata.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ImmutableCoinMetadata<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface MetadataOwnershipRenounced {
    coin_name: _0x1.ascii.String;
  }

  export namespace MetadataOwnershipRenounced {
    export const TYPE_QNAME = "0x2::coin_manager::MetadataOwnershipRenounced";

    const TYPE = new TypeDescriptor<MetadataOwnershipRenounced>(
      MetadataOwnershipRenounced.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<MetadataOwnershipRenounced> {
      return TYPE.apply();
    }
  }

  export type MetadataOwnershipRenouncedInstance =
    TypedEventInstance<MetadataOwnershipRenounced> & {
      data_decoded: MetadataOwnershipRenounced;
      type_arguments: [];
    };

  export interface TreasuryOwnershipRenounced {
    coin_name: _0x1.ascii.String;
  }

  export namespace TreasuryOwnershipRenounced {
    export const TYPE_QNAME = "0x2::coin_manager::TreasuryOwnershipRenounced";

    const TYPE = new TypeDescriptor<TreasuryOwnershipRenounced>(
      TreasuryOwnershipRenounced.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<TreasuryOwnershipRenounced> {
      return TYPE.apply();
    }
  }

  export type TreasuryOwnershipRenouncedInstance =
    TypedEventInstance<TreasuryOwnershipRenounced> & {
      data_decoded: TreasuryOwnershipRenounced;
      type_arguments: [];
    };

  export namespace builder {
    export function addAdditionalMetadata<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::add_additional_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function additionalMetadata<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::additional_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function availableSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::available_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function burn<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::burn",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function create<T0 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::create",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decimals<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::decimals",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function description<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function enforceMaximumSupply<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::enforce_maximum_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getAdditionalMetadata<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::get_additional_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function hasMaximumSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::has_maximum_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function iconUrl<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function immutableMetadata<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::immutable_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function maximumSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::maximum_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function metadata<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function metadataIsImmutable<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::metadata_is_immutable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mint<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::mint",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintAndTransfer<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::mint_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintBalance<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::mint_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function name<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [
        coin.TreasuryCap<T0> | TransactionArgument,
        coin.CoinMetadata<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newWithImmutableMetadata<T0 = any>(
      tx: Transaction,
      args: [
        coin.TreasuryCap<T0> | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::new_with_immutable_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function renounceMetadataOwnership<T0 = any>(
      tx: Transaction,
      args: [
        coin_manager.CoinManagerMetadataCap<T0> | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::renounce_metadata_ownership",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function renounceTreasuryOwnership<T0 = any>(
      tx: Transaction,
      args: [
        coin_manager.CoinManagerTreasuryCap<T0> | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::renounce_treasury_ownership",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function replaceAdditionalMetadata<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::replace_additional_metadata",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function supplyImmut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::supply_immut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyIsImmutable<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::supply_is_immutable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function symbol$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function totalSupply<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::total_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateDescription<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::update_description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateIconUrl<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::update_icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateName<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::update_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateSymbol<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin_manager::update_symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addAdditionalMetadata<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addAdditionalMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function additionalMetadata<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.additionalMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function availableSupply<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.availableSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function burn<T0 = any>(
      client: IotaClient,
      args: [string, string, coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.burn(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function create<T0 = any>(
      client: IotaClient,
      args: [
        T0,
        number,
        string[],
        string[],
        string[],
        _0x1.option.Option<url.Url>,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [
          coin_manager.CoinManagerTreasuryCap<T0>,
          coin_manager.CoinManagerMetadataCap<T0>,
          coin_manager.CoinManager<T0>,
        ]
      >
    > {
      const tx = new Transaction();
      builder.create(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          coin_manager.CoinManagerTreasuryCap<T0>,
          coin_manager.CoinManagerMetadataCap<T0>,
          coin_manager.CoinManager<T0>,
        ]
      >(inspectRes);
    }
    export async function decimals<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.decimals(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function description<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.description(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function enforceMaximumSupply<T0 = any>(
      client: IotaClient,
      args: [string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.enforceMaximumSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getAdditionalMetadata<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getAdditionalMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function hasMaximumSupply<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasMaximumSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function iconUrl<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<url.Url>]>> {
      const tx = new Transaction();
      builder.iconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<url.Url>]
      >(inspectRes);
    }
    export async function immutableMetadata<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.immutableMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function maximumSupply<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.maximumSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function metadata<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.metadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function metadataIsImmutable<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.metadataIsImmutable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function mint<T0 = any>(
      client: IotaClient,
      args: [string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new Transaction();
      builder.mint(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function mintAndTransfer<T0 = any>(
      client: IotaClient,
      args: [string, string, bigint, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.mintAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mintBalance<T0 = any>(
      client: IotaClient,
      args: [string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new Transaction();
      builder.mintBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function name<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.name(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [coin.TreasuryCap<T0>, coin.CoinMetadata<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [
          coin_manager.CoinManagerTreasuryCap<T0>,
          coin_manager.CoinManagerMetadataCap<T0>,
          coin_manager.CoinManager<T0>,
        ]
      >
    > {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          coin_manager.CoinManagerTreasuryCap<T0>,
          coin_manager.CoinManagerMetadataCap<T0>,
          coin_manager.CoinManager<T0>,
        ]
      >(inspectRes);
    }
    export async function newWithImmutableMetadata<T0 = any>(
      client: IotaClient,
      args: [coin.TreasuryCap<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [coin_manager.CoinManagerTreasuryCap<T0>, coin_manager.CoinManager<T0>]
      >
    > {
      const tx = new Transaction();
      builder.newWithImmutableMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin_manager.CoinManagerTreasuryCap<T0>, coin_manager.CoinManager<T0>]
      >(inspectRes);
    }
    export async function renounceMetadataOwnership<T0 = any>(
      client: IotaClient,
      args: [coin_manager.CoinManagerMetadataCap<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.renounceMetadataOwnership(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function renounceTreasuryOwnership<T0 = any>(
      client: IotaClient,
      args: [coin_manager.CoinManagerTreasuryCap<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.renounceTreasuryOwnership(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function replaceAdditionalMetadata<
      T0 = any,
      T1 = any,
      T2 = any,
    >(
      client: IotaClient,
      args: [string, string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[T2]>> {
      const tx = new Transaction();
      builder.replaceAdditionalMetadata(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T2]>(
        inspectRes,
      );
    }
    export async function supplyImmut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.supplyImmut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function supplyIsImmutable<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.supplyIsImmutable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function symbol$<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new Transaction();
      builder.symbol$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function totalSupply<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function updateDescription<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateDescription(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateIconUrl<T0 = any>(
      client: IotaClient,
      args: [string, string, _0x1.ascii.String],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateIconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateName<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateSymbol<T0 = any>(
      client: IotaClient,
      args: [string, string, _0x1.ascii.String],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateSymbol(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }

  export interface BurnPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, coin.Coin<T0>]> {
    arguments_decoded: [string, string, coin.Coin<T0>];
    type_arguments: [string];
  }
}

export namespace config {
  export interface Config<T0> {
    id: object$.UID;
  }

  export namespace Config {
    export const TYPE_QNAME = "0x2::config::Config";

    const TYPE = new TypeDescriptor<Config<any>>(Config.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Config<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface Setting<T0> {
    data: _0x1.option.Option<config.SettingData<T0>>;
  }

  export namespace Setting {
    export const TYPE_QNAME = "0x2::config::Setting";

    const TYPE = new TypeDescriptor<Setting<any>>(Setting.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Setting<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface SettingData<T0> {
    newer_value_epoch: bigint;
    newer_value: _0x1.option.Option<T0>;
    older_value_opt: _0x1.option.Option<T0>;
  }

  export namespace SettingData {
    export const TYPE_QNAME = "0x2::config::SettingData";

    const TYPE = new TypeDescriptor<SettingData<any>>(SettingData.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<SettingData<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function addForNextEpoch<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::add_for_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function borrowForNextEpochMut<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::borrow_for_next_epoch_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function existsWithType<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T1 | TransactionArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function existsWithTypeForNextEpoch<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T1 | TransactionArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::exists_with_type_for_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function readSetting<T0 = any, T1 = any>(
      tx: Transaction,
      args: [object$.ID | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::read_setting",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function readSettingForNextEpoch<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T1 | TransactionArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::read_setting_for_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function removeForNextEpoch<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::remove_for_next_epoch",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function share<T0 = any>(
      tx: Transaction,
      args: [config.Config<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::share",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transfer<T0 = any>(
      tx: Transaction,
      args: [
        config.Config<T0> | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::config::transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addForNextEpoch<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, string, T1, T2],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>> {
      const tx = new Transaction();
      builder.addForNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T2>]
      >(inspectRes);
    }
    export async function borrowForNextEpochMut<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowForNextEpochMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function existsWithType<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.existsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function existsWithTypeForNextEpoch<
      T0 = any,
      T1 = any,
      T2 = any,
    >(
      client: IotaClient,
      args: [string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.existsWithTypeForNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[config.Config<T0>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [config.Config<T0>]
      >(inspectRes);
    }
    export async function readSetting<T0 = any, T1 = any>(
      client: IotaClient,
      args: [object$.ID, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>> {
      const tx = new Transaction();
      builder.readSetting(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T1>]
      >(inspectRes);
    }
    export async function readSettingForNextEpoch<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>> {
      const tx = new Transaction();
      builder.readSettingForNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T2>]
      >(inspectRes);
    }
    export async function removeForNextEpoch<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, string, T1],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T2>]>> {
      const tx = new Transaction();
      builder.removeForNextEpoch(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T2>]
      >(inspectRes);
    }
    export async function share<T0 = any>(
      client: IotaClient,
      args: [config.Config<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.share(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transfer<T0 = any>(
      client: IotaClient,
      args: [config.Config<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export class deny_list extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("deny_list", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): deny_list {
    return new deny_list({ ...deny_list.DEFAULT_OPTIONS, ...options });
  }

  onEventAddressKey(
    func: (event: deny_list.AddressKeyInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      deny_list.AddressKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): deny_list {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "deny_list::AddressKey" },
      handlerOptions,
    );
    return this;
  }

  onEventConfigKey(
    func: (event: deny_list.ConfigKeyInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      deny_list.ConfigKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): deny_list {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "deny_list::ConfigKey" },
      handlerOptions,
    );
    return this;
  }

  onEventGlobalPauseKey(
    func: (event: deny_list.GlobalPauseKeyInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      deny_list.GlobalPauseKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): deny_list {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "deny_list::GlobalPauseKey" },
      handlerOptions,
    );
    return this;
  }

  onEventPerTypeConfigCreated(
    func: (
      event: deny_list.PerTypeConfigCreatedInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      deny_list.PerTypeConfigCreatedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): deny_list {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "deny_list::PerTypeConfigCreated" },
      handlerOptions,
    );
    return this;
  }
}

export namespace deny_list {
  export interface AddressKey {
    pos0: string;
  }

  export namespace AddressKey {
    export const TYPE_QNAME = "0x2::deny_list::AddressKey";

    const TYPE = new TypeDescriptor<AddressKey>(AddressKey.TYPE_QNAME);

    export function type(): TypeDescriptor<AddressKey> {
      return TYPE.apply();
    }
  }

  export type AddressKeyInstance = TypedEventInstance<AddressKey> & {
    data_decoded: AddressKey;
    type_arguments: [];
  };

  export interface ConfigKey {
    per_type_index: bigint;
    per_type_key: number[];
  }

  export namespace ConfigKey {
    export const TYPE_QNAME = "0x2::deny_list::ConfigKey";

    const TYPE = new TypeDescriptor<ConfigKey>(ConfigKey.TYPE_QNAME);

    export function type(): TypeDescriptor<ConfigKey> {
      return TYPE.apply();
    }
  }

  export type ConfigKeyInstance = TypedEventInstance<ConfigKey> & {
    data_decoded: ConfigKey;
    type_arguments: [];
  };

  export interface ConfigWriteCap {
    dummy_field: boolean;
  }

  export namespace ConfigWriteCap {
    export const TYPE_QNAME = "0x2::deny_list::ConfigWriteCap";

    const TYPE = new TypeDescriptor<ConfigWriteCap>(ConfigWriteCap.TYPE_QNAME);

    export function type(): TypeDescriptor<ConfigWriteCap> {
      return TYPE.apply();
    }
  }

  export interface DenyList {
    id: object$.UID;
    lists: bag.Bag;
  }

  export namespace DenyList {
    export const TYPE_QNAME = "0x2::deny_list::DenyList";

    const TYPE = new TypeDescriptor<DenyList>(DenyList.TYPE_QNAME);

    export function type(): TypeDescriptor<DenyList> {
      return TYPE.apply();
    }
  }

  export interface GlobalPauseKey {
    dummy_field: boolean;
  }

  export namespace GlobalPauseKey {
    export const TYPE_QNAME = "0x2::deny_list::GlobalPauseKey";

    const TYPE = new TypeDescriptor<GlobalPauseKey>(GlobalPauseKey.TYPE_QNAME);

    export function type(): TypeDescriptor<GlobalPauseKey> {
      return TYPE.apply();
    }
  }

  export type GlobalPauseKeyInstance = TypedEventInstance<GlobalPauseKey> & {
    data_decoded: GlobalPauseKey;
    type_arguments: [];
  };

  export interface PerTypeConfigCreated {
    key: deny_list.ConfigKey;
    config_id: object$.ID;
  }

  export namespace PerTypeConfigCreated {
    export const TYPE_QNAME = "0x2::deny_list::PerTypeConfigCreated";

    const TYPE = new TypeDescriptor<PerTypeConfigCreated>(
      PerTypeConfigCreated.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PerTypeConfigCreated> {
      return TYPE.apply();
    }
  }

  export type PerTypeConfigCreatedInstance =
    TypedEventInstance<PerTypeConfigCreated> & {
      data_decoded: PerTypeConfigCreated;
      type_arguments: [];
    };

  export namespace builder {
    export function add(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::add",
        arguments: _args,
      });
    }
    export function containsCurrentEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::contains_current_epoch",
        arguments: _args,
      });
    }
    export function containsNextEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::contains_next_epoch",
        arguments: _args,
      });
    }
    export function disableGlobalPause(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::disable_global_pause",
        arguments: _args,
      });
    }
    export function enableGlobalPause(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::enable_global_pause",
        arguments: _args,
      });
    }
    export function isGlobalPauseEnabledCurrentEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::is_global_pause_enabled_current_epoch",
        arguments: _args,
      });
    }
    export function isGlobalPauseEnabledNextEpoch(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::is_global_pause_enabled_next_epoch",
        arguments: _args,
      });
    }
    export function remove(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPureAddress(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::remove",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function add(
      client: IotaClient,
      args: [string, bigint, string[], string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function containsCurrentEpoch(
      client: IotaClient,
      args: [string, bigint, string[], string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.containsCurrentEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function containsNextEpoch(
      client: IotaClient,
      args: [string, bigint, string[], string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.containsNextEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function disableGlobalPause(
      client: IotaClient,
      args: [string, bigint, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.disableGlobalPause(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function enableGlobalPause(
      client: IotaClient,
      args: [string, bigint, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.enableGlobalPause(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isGlobalPauseEnabledCurrentEpoch(
      client: IotaClient,
      args: [string, bigint, string[]],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isGlobalPauseEnabledCurrentEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isGlobalPauseEnabledNextEpoch(
      client: IotaClient,
      args: [string, bigint, string[]],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isGlobalPauseEnabledNextEpoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function remove(
      client: IotaClient,
      args: [string, bigint, string[], string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.remove(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export class display extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("display", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): display {
    return new display({ ...display.DEFAULT_OPTIONS, ...options });
  }

  onEntryAdd(
    func: (call: display.AddPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, display.AddPayload>,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::add",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryAddMultiple(
    func: (call: display.AddMultiplePayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      display.AddMultiplePayload
    >,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::add_multiple",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryCreateAndKeep(
    func: (call: display.CreateAndKeepPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      display.CreateAndKeepPayload
    >,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::create_and_keep",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryEdit(
    func: (call: display.EditPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, display.EditPayload>,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::edit",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryRemove(
    func: (call: display.RemovePayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, display.RemovePayload>,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::remove",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryUpdateVersion(
    func: (call: display.UpdateVersionPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      display.UpdateVersionPayload
    >,
  ): display {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "display::update_version",
      },
      handlerOptions,
    );
    return this;
  }

  onEventDisplayCreated(
    func: (event: display.DisplayCreatedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      display.DisplayCreatedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): display {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "display::DisplayCreated" },
      handlerOptions,
    );
    return this;
  }

  onEventVersionUpdated(
    func: (event: display.VersionUpdatedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      display.VersionUpdatedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): display {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "display::VersionUpdated" },
      handlerOptions,
    );
    return this;
  }
}

export namespace display {
  export interface Display<T0> {
    id: object$.UID;
    fields: vec_map.VecMap<string, string>;
    version: number;
  }

  export namespace Display {
    export const TYPE_QNAME = "0x2::display::Display";

    const TYPE = new TypeDescriptor<Display<any>>(Display.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Display<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface DisplayCreated<T0> {
    id: object$.ID;
  }

  export namespace DisplayCreated {
    export const TYPE_QNAME = "0x2::display::DisplayCreated";

    const TYPE = new TypeDescriptor<DisplayCreated<any>>(
      DisplayCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<DisplayCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type DisplayCreatedInstance = TypedEventInstance<
    DisplayCreated<any>
  > & {
    data_decoded: DisplayCreated<any>;
    type_arguments: [string];
  };

  export interface VersionUpdated<T0> {
    id: object$.ID;
    version: number;
    fields: vec_map.VecMap<string, string>;
  }

  export namespace VersionUpdated {
    export const TYPE_QNAME = "0x2::display::VersionUpdated";

    const TYPE = new TypeDescriptor<VersionUpdated<any>>(
      VersionUpdated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<VersionUpdated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type VersionUpdatedInstance = TypedEventInstance<
    VersionUpdated<any>
  > & {
    data_decoded: VersionUpdated<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function add<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function addMultiple<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::add_multiple",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createAndKeep<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::create_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function edit<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::edit",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fields<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::fields",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isAuthorized<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::is_authorized",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newWithFields<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::new_with_fields",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateVersion<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::update_version",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function version<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::version",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addMultiple<T0 = any>(
      client: IotaClient,
      args: [string, string[], string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addMultiple(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function createAndKeep<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.createAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function edit<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.edit(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function fields<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fields(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isAuthorized<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isAuthorized(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[display.Display<T0>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [display.Display<T0>]
      >(inspectRes);
    }
    export async function newWithFields<T0 = any>(
      client: IotaClient,
      args: [string, string[], string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[display.Display<T0>]>> {
      const tx = new Transaction();
      builder.newWithFields(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [display.Display<T0>]
      >(inspectRes);
    }
    export async function remove<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateVersion<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.updateVersion(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function version<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.version(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
  }

  export interface AddPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, string]> {
    arguments_decoded: [string, string, string];
    type_arguments: [string];
  }

  export interface AddMultiplePayload<T0 = any>
    extends TypedFunctionPayload<[string, string[], string[]]> {
    arguments_decoded: [string, string[], string[]];
    type_arguments: [string];
  }

  export interface CreateAndKeepPayload<T0 = any>
    extends TypedFunctionPayload<[string, string]> {
    arguments_decoded: [string, string];
    type_arguments: [string];
  }

  export interface EditPayload<T0 = any>
    extends TypedFunctionPayload<[string, string, string]> {
    arguments_decoded: [string, string, string];
    type_arguments: [string];
  }

  export interface RemovePayload<T0 = any>
    extends TypedFunctionPayload<[string, string]> {
    arguments_decoded: [string, string];
    type_arguments: [string];
  }

  export interface UpdateVersionPayload<T0 = any>
    extends TypedFunctionPayload<[string]> {
    arguments_decoded: [string];
    type_arguments: [string];
  }
}

export namespace dynamic_field {
  export interface Field<T0, T1> {
    id: object$.UID;
    name: T0;
    value: T1;
  }

  export namespace Field {
    export const TYPE_QNAME = "0x2::dynamic_field::Field";

    const TYPE = new TypeDescriptor<Field<any, any>>(Field.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Field<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addChildObject<T0 = any>(
      tx: Transaction,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::add_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowChildObject<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowChildObjectMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_child_object_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function exists_<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::exists_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function existsWithType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function fieldInfo<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::field_info",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fieldInfoMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::field_info_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hasChildObject(
      tx: Transaction,
      args: [string | TransactionArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::has_child_object",
        arguments: _args,
      });
    }
    export function hasChildObjectWithTy<T0 = any>(
      tx: Transaction,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::has_child_object_with_ty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hashTypeAndKey<T0 = any>(
      tx: Transaction,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::hash_type_and_key",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeChildObject<T0 = any>(
      tx: Transaction,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeIfExists<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove_if_exists",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addChildObject<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowChildObject<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowChildObjectMut<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowChildObjectMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function exists_<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.exists_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function existsWithType<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.existsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function fieldInfo<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new Transaction();
      builder.fieldInfo(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function fieldInfoMut<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new Transaction();
      builder.fieldInfoMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function hasChildObject(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasChildObject(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function hasChildObjectWithTy<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasChildObjectWithTy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function hashTypeAndKey<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.hashTypeAndKey(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function removeChildObject<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.removeChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function removeIfExists<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>> {
      const tx = new Transaction();
      builder.removeIfExists(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T1>]
      >(inspectRes);
    }
  }
}

export class dynamic_object_field extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("dynamic_object_field", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): dynamic_object_field {
    return new dynamic_object_field({
      ...dynamic_object_field.DEFAULT_OPTIONS,
      ...options,
    });
  }

  onEventWrapper(
    func: (
      event: dynamic_object_field.WrapperInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      dynamic_object_field.WrapperInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): dynamic_object_field {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "dynamic_object_field::Wrapper" },
      handlerOptions,
    );
    return this;
  }
}

export namespace dynamic_object_field {
  export interface Wrapper<T0> {
    name: T0;
  }

  export namespace Wrapper {
    export const TYPE_QNAME = "0x2::dynamic_object_field::Wrapper";

    const TYPE = new TypeDescriptor<Wrapper<any>>(Wrapper.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Wrapper<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type WrapperInstance = TypedEventInstance<Wrapper<any>> & {
    data_decoded: Wrapper<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function exists_<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::exists_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function existsWithType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function id<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function internalAdd<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::internal_add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function internalBorrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::internal_borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function internalBorrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::internal_borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function internalExistsWithType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::internal_exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function internalRemove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::internal_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function exists_<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.exists_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function existsWithType<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.existsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function id<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>> {
      const tx = new Transaction();
      builder.id(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object$.ID>]
      >(inspectRes);
    }
    export async function internalAdd<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.internalAdd(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function internalBorrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.internalBorrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function internalBorrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.internalBorrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function internalExistsWithType<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.internalExistsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function internalRemove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.internalRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace ecdsa_k1 {
  export namespace builder {
    export function decompressPubkey(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::decompress_pubkey",
        arguments: _args,
      });
    }
    export function secp256k1Ecrecover(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU8(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::secp256k1_ecrecover",
        arguments: _args,
      });
    }
    export function secp256k1Verify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU8(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::secp256k1_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function decompressPubkey(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.decompressPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256k1Ecrecover(
      client: IotaClient,
      args: [string, string, number],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.secp256k1Ecrecover(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256k1Verify(
      client: IotaClient,
      args: [string, string, string, number],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.secp256k1Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ecdsa_r1 {
  export namespace builder {
    export function secp256r1Ecrecover(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureU8(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_r1::secp256r1_ecrecover",
        arguments: _args,
      });
    }
    export function secp256r1Verify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU8(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_r1::secp256r1_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function secp256r1Ecrecover(
      client: IotaClient,
      args: [string, string, number],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.secp256r1Ecrecover(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256r1Verify(
      client: IotaClient,
      args: [string, string, string, number],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.secp256r1Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ecvrf {
  export namespace builder {
    export function ecvrfVerify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecvrf::ecvrf_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function ecvrfVerify(
      client: IotaClient,
      args: [string, string, string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.ecvrfVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ed25519 {
  export namespace builder {
    export function ed25519Verify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ed25519::ed25519_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function ed25519Verify(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.ed25519Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace event {
  export namespace builder {
    export function emit<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::event::emit",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function emit<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.emit(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export class groth16 extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("groth16", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): groth16 {
    return new groth16({ ...groth16.DEFAULT_OPTIONS, ...options });
  }

  onEventCurve(
    func: (event: groth16.CurveInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, groth16.CurveInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): groth16 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "groth16::Curve" },
      handlerOptions,
    );
    return this;
  }

  onEventPreparedVerifyingKey(
    func: (
      event: groth16.PreparedVerifyingKeyInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      groth16.PreparedVerifyingKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): groth16 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "groth16::PreparedVerifyingKey" },
      handlerOptions,
    );
    return this;
  }

  onEventProofPoints(
    func: (event: groth16.ProofPointsInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      groth16.ProofPointsInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): groth16 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "groth16::ProofPoints" },
      handlerOptions,
    );
    return this;
  }

  onEventPublicProofInputs(
    func: (event: groth16.PublicProofInputsInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      groth16.PublicProofInputsInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): groth16 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "groth16::PublicProofInputs" },
      handlerOptions,
    );
    return this;
  }
}

export namespace groth16 {
  export interface Curve {
    id: number;
  }

  export namespace Curve {
    export const TYPE_QNAME = "0x2::groth16::Curve";

    const TYPE = new TypeDescriptor<Curve>(Curve.TYPE_QNAME);

    export function type(): TypeDescriptor<Curve> {
      return TYPE.apply();
    }
  }

  export type CurveInstance = TypedEventInstance<Curve> & {
    data_decoded: Curve;
    type_arguments: [];
  };

  export interface PreparedVerifyingKey {
    vk_gamma_abc_g1_bytes: number[];
    alpha_g1_beta_g2_bytes: number[];
    gamma_g2_neg_pc_bytes: number[];
    delta_g2_neg_pc_bytes: number[];
  }

  export namespace PreparedVerifyingKey {
    export const TYPE_QNAME = "0x2::groth16::PreparedVerifyingKey";

    const TYPE = new TypeDescriptor<PreparedVerifyingKey>(
      PreparedVerifyingKey.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PreparedVerifyingKey> {
      return TYPE.apply();
    }
  }

  export type PreparedVerifyingKeyInstance =
    TypedEventInstance<PreparedVerifyingKey> & {
      data_decoded: PreparedVerifyingKey;
      type_arguments: [];
    };

  export interface ProofPoints {
    bytes: number[];
  }

  export namespace ProofPoints {
    export const TYPE_QNAME = "0x2::groth16::ProofPoints";

    const TYPE = new TypeDescriptor<ProofPoints>(ProofPoints.TYPE_QNAME);

    export function type(): TypeDescriptor<ProofPoints> {
      return TYPE.apply();
    }
  }

  export type ProofPointsInstance = TypedEventInstance<ProofPoints> & {
    data_decoded: ProofPoints;
    type_arguments: [];
  };

  export interface PublicProofInputs {
    bytes: number[];
  }

  export namespace PublicProofInputs {
    export const TYPE_QNAME = "0x2::groth16::PublicProofInputs";

    const TYPE = new TypeDescriptor<PublicProofInputs>(
      PublicProofInputs.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PublicProofInputs> {
      return TYPE.apply();
    }
  }

  export type PublicProofInputsInstance =
    TypedEventInstance<PublicProofInputs> & {
      data_decoded: PublicProofInputs;
      type_arguments: [];
    };

  export namespace builder {
    export function bls12381(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::bls12381",
        arguments: _args,
      });
    }
    export function bn254(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::bn254",
        arguments: _args,
      });
    }
    export function prepareVerifyingKey(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::prepare_verifying_key",
        arguments: _args,
      });
    }
    export function proofPointsFromBytes(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::proof_points_from_bytes",
        arguments: _args,
      });
    }
    export function publicProofInputsFromBytes(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::public_proof_inputs_from_bytes",
        arguments: _args,
      });
    }
    export function pvkFromBytes(
      tx: Transaction,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::pvk_from_bytes",
        arguments: _args,
      });
    }
    export function pvkToBytes(
      tx: Transaction,
      args: [groth16.PreparedVerifyingKey | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::pvk_to_bytes",
        arguments: _args,
      });
    }
    export function verifyGroth16Proof(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::verify_groth16_proof",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bls12381(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[groth16.Curve]>> {
      const tx = new Transaction();
      builder.bls12381(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.Curve]
      >(inspectRes);
    }
    export async function bn254(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[groth16.Curve]>> {
      const tx = new Transaction();
      builder.bn254(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.Curve]
      >(inspectRes);
    }
    export async function prepareVerifyingKey(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>> {
      const tx = new Transaction();
      builder.prepareVerifyingKey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PreparedVerifyingKey]
      >(inspectRes);
    }
    export async function proofPointsFromBytes(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[groth16.ProofPoints]>> {
      const tx = new Transaction();
      builder.proofPointsFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.ProofPoints]
      >(inspectRes);
    }
    export async function publicProofInputsFromBytes(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[groth16.PublicProofInputs]>> {
      const tx = new Transaction();
      builder.publicProofInputsFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PublicProofInputs]
      >(inspectRes);
    }
    export async function pvkFromBytes(
      client: IotaClient,
      args: [string[], string[], string[], string[]],
    ): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>> {
      const tx = new Transaction();
      builder.pvkFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PreparedVerifyingKey]
      >(inspectRes);
    }
    export async function pvkToBytes(
      client: IotaClient,
      args: [groth16.PreparedVerifyingKey],
    ): Promise<TypedDevInspectResults<[number[][]]>> {
      const tx = new Transaction();
      builder.pvkToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[][]]>(
        inspectRes,
      );
    }
    export async function verifyGroth16Proof(
      client: IotaClient,
      args: [string, string, string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.verifyGroth16Proof(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export class group_ops extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("group_ops", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): group_ops {
    return new group_ops({ ...group_ops.DEFAULT_OPTIONS, ...options });
  }

  onEventElement(
    func: (event: group_ops.ElementInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, group_ops.ElementInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): group_ops {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "group_ops::Element" },
      handlerOptions,
    );
    return this;
  }
}

export namespace group_ops {
  export interface Element<T0> {
    bytes: number[];
  }

  export namespace Element {
    export const TYPE_QNAME = "0x2::group_ops::Element";

    const TYPE = new TypeDescriptor<Element<any>>(Element.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Element<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type ElementInstance = TypedEventInstance<Element<any>> & {
    data_decoded: Element<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function add<T0 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function bytes<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function convert<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        number | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::convert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function div<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::div",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function equal<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::equal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromBytes<T0 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureBool(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::from_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hashTo<T0 = any>(
      tx: Transaction,
      args: [number | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::hash_to",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mul<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::mul",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function multiScalarMultiplication<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::multi_scalar_multiplication",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pairing<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::pairing",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function setAsPrefix(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        boolean | TransactionArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureBool(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::set_as_prefix",
        arguments: _args,
      });
    }
    export function sub<T0 = any>(
      tx: Transaction,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::sub",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function sum<T0 = any>(
      tx: Transaction,
      args: [number | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::sum",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function bytes<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.bytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function convert<T0 = any, T1 = any>(
      client: IotaClient,
      args: [number, number, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new Transaction();
      builder.convert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function div<T0 = any, T1 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new Transaction();
      builder.div(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function equal<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.equal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function fromBytes<T0 = any>(
      client: IotaClient,
      args: [number, string, boolean],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new Transaction();
      builder.fromBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function hashTo<T0 = any>(
      client: IotaClient,
      args: [number, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new Transaction();
      builder.hashTo(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function mul<T0 = any, T1 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new Transaction();
      builder.mul(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function multiScalarMultiplication<T0 = any, T1 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new Transaction();
      builder.multiScalarMultiplication(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function pairing<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T2>]>> {
      const tx = new Transaction();
      builder.pairing(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T2>]
      >(inspectRes);
    }
    export async function setAsPrefix(
      client: IotaClient,
      args: [bigint, boolean, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setAsPrefix(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function sub<T0 = any>(
      client: IotaClient,
      args: [number, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new Transaction();
      builder.sub(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function sum<T0 = any>(
      client: IotaClient,
      args: [number, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new Transaction();
      builder.sum(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
  }
}

export namespace hash {
  export namespace builder {
    export function blake2b256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hash::blake2b256",
        arguments: _args,
      });
    }
    export function keccak256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hash::keccak256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function blake2b256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.blake2b256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function keccak256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.keccak256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace hex {
  export namespace builder {
    export function decode(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hex::decode",
        arguments: _args,
      });
    }
    export function encode(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hex::encode",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function decode(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.decode(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function encode(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.encode(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace hmac {
  export namespace builder {
    export function hmacSha3256(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hmac::hmac_sha3_256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function hmacSha3256(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.hmacSha3256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export class iota extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("iota", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): iota {
    return new iota({ ...iota.DEFAULT_OPTIONS, ...options });
  }

  onEntryTransfer(
    func: (call: iota.TransferPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, iota.TransferPayload>,
  ): iota {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "iota::transfer",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace iota {
  export interface IOTA {
    dummy_field: boolean;
  }

  export namespace IOTA {
    export const TYPE_QNAME = "0x2::iota::IOTA";

    const TYPE = new TypeDescriptor<IOTA>(IOTA.TYPE_QNAME);

    export function type(): TypeDescriptor<IOTA> {
      return TYPE.apply();
    }
  }

  export interface IotaTreasuryCap {
    inner: coin.TreasuryCap<iota.IOTA>;
  }

  export namespace IotaTreasuryCap {
    export const TYPE_QNAME = "0x2::iota::IotaTreasuryCap";

    const TYPE = new TypeDescriptor<IotaTreasuryCap>(
      IotaTreasuryCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<IotaTreasuryCap> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function burn(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        coin.Coin<iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::burn",
        arguments: _args,
      });
    }
    export function burnBalance(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        balance.Balance<iota.IOTA> | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::burn_balance",
        arguments: _args,
      });
    }
    export function mint(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::mint",
        arguments: _args,
      });
    }
    export function mintBalance(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::mint_balance",
        arguments: _args,
      });
    }
    export function totalSupply(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::total_supply",
        arguments: _args,
      });
    }
    export function transfer(
      tx: Transaction,
      args: [
        coin.Coin<iota.IOTA> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::iota::transfer",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function burn(
      client: IotaClient,
      args: [string, coin.Coin<iota.IOTA>],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.burn(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function burnBalance(
      client: IotaClient,
      args: [string, balance.Balance<iota.IOTA>],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.burnBalance(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function mint(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.mint(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<iota.IOTA>]
      >(inspectRes);
    }
    export async function mintBalance(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[balance.Balance<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.mintBalance(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<iota.IOTA>]
      >(inspectRes);
    }
    export async function totalSupply(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.totalSupply(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function transfer(
      client: IotaClient,
      args: [coin.Coin<iota.IOTA>, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transfer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }

  export interface TransferPayload
    extends TypedFunctionPayload<[coin.Coin<iota.IOTA>, string]> {
    arguments_decoded: [coin.Coin<iota.IOTA>, string];
    type_arguments: [];
  }
}

export class kiosk extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("kiosk", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): kiosk {
    return new kiosk({ ...kiosk.DEFAULT_OPTIONS, ...options });
  }

  onEntryDefault(
    func: (call: kiosk.DefaultPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, kiosk.DefaultPayload>,
  ): kiosk {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "kiosk::default",
      },
      handlerOptions,
    );
    return this;
  }

  onEventItem(
    func: (event: kiosk.ItemInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, kiosk.ItemInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::Item" },
      handlerOptions,
    );
    return this;
  }

  onEventItemDelisted(
    func: (event: kiosk.ItemDelistedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      kiosk.ItemDelistedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::ItemDelisted" },
      handlerOptions,
    );
    return this;
  }

  onEventItemListed(
    func: (event: kiosk.ItemListedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, kiosk.ItemListedInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::ItemListed" },
      handlerOptions,
    );
    return this;
  }

  onEventItemPurchased(
    func: (event: kiosk.ItemPurchasedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      kiosk.ItemPurchasedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::ItemPurchased" },
      handlerOptions,
    );
    return this;
  }

  onEventListing(
    func: (event: kiosk.ListingInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, kiosk.ListingInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::Listing" },
      handlerOptions,
    );
    return this;
  }

  onEventLock(
    func: (event: kiosk.LockInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, kiosk.LockInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk::Lock" },
      handlerOptions,
    );
    return this;
  }
}

export namespace kiosk {
  export interface Borrow {
    kiosk_id: object$.ID;
    item_id: object$.ID;
  }

  export namespace Borrow {
    export const TYPE_QNAME = "0x2::kiosk::Borrow";

    const TYPE = new TypeDescriptor<Borrow>(Borrow.TYPE_QNAME);

    export function type(): TypeDescriptor<Borrow> {
      return TYPE.apply();
    }
  }

  export interface Item {
    id: object$.ID;
  }

  export namespace Item {
    export const TYPE_QNAME = "0x2::kiosk::Item";

    const TYPE = new TypeDescriptor<Item>(Item.TYPE_QNAME);

    export function type(): TypeDescriptor<Item> {
      return TYPE.apply();
    }
  }

  export type ItemInstance = TypedEventInstance<Item> & {
    data_decoded: Item;
    type_arguments: [];
  };

  export interface ItemDelisted<T0> {
    kiosk: object$.ID;
    id: object$.ID;
  }

  export namespace ItemDelisted {
    export const TYPE_QNAME = "0x2::kiosk::ItemDelisted";

    const TYPE = new TypeDescriptor<ItemDelisted<any>>(ItemDelisted.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemDelisted<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type ItemDelistedInstance = TypedEventInstance<ItemDelisted<any>> & {
    data_decoded: ItemDelisted<any>;
    type_arguments: [string];
  };

  export interface ItemListed<T0> {
    kiosk: object$.ID;
    id: object$.ID;
    price: bigint;
  }

  export namespace ItemListed {
    export const TYPE_QNAME = "0x2::kiosk::ItemListed";

    const TYPE = new TypeDescriptor<ItemListed<any>>(ItemListed.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemListed<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type ItemListedInstance = TypedEventInstance<ItemListed<any>> & {
    data_decoded: ItemListed<any>;
    type_arguments: [string];
  };

  export interface ItemPurchased<T0> {
    kiosk: object$.ID;
    id: object$.ID;
    price: bigint;
  }

  export namespace ItemPurchased {
    export const TYPE_QNAME = "0x2::kiosk::ItemPurchased";

    const TYPE = new TypeDescriptor<ItemPurchased<any>>(
      ItemPurchased.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemPurchased<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type ItemPurchasedInstance = TypedEventInstance<ItemPurchased<any>> & {
    data_decoded: ItemPurchased<any>;
    type_arguments: [string];
  };

  export interface Kiosk {
    id: object$.UID;
    profits: balance.Balance<iota.IOTA>;
    owner: string;
    item_count: number;
  }

  export namespace Kiosk {
    export const TYPE_QNAME = "0x2::kiosk::Kiosk";

    const TYPE = new TypeDescriptor<Kiosk>(Kiosk.TYPE_QNAME);

    export function type(): TypeDescriptor<Kiosk> {
      return TYPE.apply();
    }
  }

  export interface KioskOwnerCap {
    id: object$.UID;
    for: object$.ID;
  }

  export namespace KioskOwnerCap {
    export const TYPE_QNAME = "0x2::kiosk::KioskOwnerCap";

    const TYPE = new TypeDescriptor<KioskOwnerCap>(KioskOwnerCap.TYPE_QNAME);

    export function type(): TypeDescriptor<KioskOwnerCap> {
      return TYPE.apply();
    }
  }

  export interface Listing {
    id: object$.ID;
    is_exclusive: boolean;
  }

  export namespace Listing {
    export const TYPE_QNAME = "0x2::kiosk::Listing";

    const TYPE = new TypeDescriptor<Listing>(Listing.TYPE_QNAME);

    export function type(): TypeDescriptor<Listing> {
      return TYPE.apply();
    }
  }

  export type ListingInstance = TypedEventInstance<Listing> & {
    data_decoded: Listing;
    type_arguments: [];
  };

  export interface Lock {
    id: object$.ID;
  }

  export namespace Lock {
    export const TYPE_QNAME = "0x2::kiosk::Lock";

    const TYPE = new TypeDescriptor<Lock>(Lock.TYPE_QNAME);

    export function type(): TypeDescriptor<Lock> {
      return TYPE.apply();
    }
  }

  export type LockInstance = TypedEventInstance<Lock> & {
    data_decoded: Lock;
    type_arguments: [];
  };

  export interface PurchaseCap<T0> {
    id: object$.UID;
    kiosk_id: object$.ID;
    item_id: object$.ID;
    min_price: bigint;
  }

  export namespace PurchaseCap {
    export const TYPE_QNAME = "0x2::kiosk::PurchaseCap";

    const TYPE = new TypeDescriptor<PurchaseCap<any>>(PurchaseCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<PurchaseCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowVal<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow_val",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function closeAndWithdraw(
      tx: Transaction,
      args: [
        kiosk.Kiosk | TransactionArgument,
        kiosk.KioskOwnerCap | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::close_and_withdraw",
        arguments: _args,
      });
    }
    export function default$(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::default",
        arguments: _args,
      });
    }
    export function delist<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::delist",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hasAccess(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_access",
        arguments: _args,
      });
    }
    export function hasItem(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_item",
        arguments: _args,
      });
    }
    export function hasItemWithType<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_item_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isListed(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_listed",
        arguments: _args,
      });
    }
    export function isListedExclusively(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_listed_exclusively",
        arguments: _args,
      });
    }
    export function isLocked(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_locked",
        arguments: _args,
      });
    }
    export function itemCount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::item_count",
        arguments: _args,
      });
    }
    export function kioskOwnerCapFor(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::kiosk_owner_cap_for",
        arguments: _args,
      });
    }
    export function list<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::list",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function listWithPurchaseCap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::list_with_purchase_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lock<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockInternal<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::lock_internal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::new",
        arguments: _args,
      });
    }
    export function owner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::owner",
        arguments: _args,
      });
    }
    export function place<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function placeAndList<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place_and_list",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function placeInternal<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place_internal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function profitsAmount(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::profits_amount",
        arguments: _args,
      });
    }
    export function profitsMut(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::profits_mut",
        arguments: _args,
      });
    }
    export function purchase<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
        coin.Coin<iota.IOTA> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapItem<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_item",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapKiosk<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_kiosk",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapMinPrice<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_min_price",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseWithCap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
        coin.Coin<iota.IOTA> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_with_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function returnPurchaseCap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::return_purchase_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function returnVal<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        kiosk.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::return_val",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function setOwner(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::set_owner",
        arguments: _args,
      });
    }
    export function setOwnerCustom(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::set_owner_custom",
        arguments: _args,
      });
    }
    export function take<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::take",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uid(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid",
        arguments: _args,
      });
    }
    export function uidMutAsOwner(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid_mut_as_owner",
        arguments: _args,
      });
    }
    export function uidMutInternal(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid_mut_internal",
        arguments: _args,
      });
    }
    export function withdraw(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::withdraw",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowVal<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, kiosk.Borrow]>> {
      const tx = new Transaction();
      builder.borrowVal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, kiosk.Borrow]
      >(inspectRes);
    }
    export async function closeAndWithdraw(
      client: IotaClient,
      args: [kiosk.Kiosk, kiosk.KioskOwnerCap],
    ): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.closeAndWithdraw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<iota.IOTA>]
      >(inspectRes);
    }

    export async function delist<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.delist(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function hasAccess(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasAccess(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function hasItem(
      client: IotaClient,
      args: [string, object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasItem(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function hasItemWithType<T0 = any>(
      client: IotaClient,
      args: [string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasItemWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isListed(
      client: IotaClient,
      args: [string, object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isListed(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isListedExclusively(
      client: IotaClient,
      args: [string, object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isListedExclusively(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isLocked(
      client: IotaClient,
      args: [string, object$.ID],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isLocked(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function itemCount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.itemCount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function kioskOwnerCapFor(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.kioskOwnerCapFor(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function list<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.list(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function listWithPurchaseCap<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[kiosk.PurchaseCap<T0>]>> {
      const tx = new Transaction();
      builder.listWithPurchaseCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [kiosk.PurchaseCap<T0>]
      >(inspectRes);
    }
    export async function lock<T0 = any>(
      client: IotaClient,
      args: [string, string, string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.lock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function lockInternal<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.lockInternal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[kiosk.Kiosk, kiosk.KioskOwnerCap]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [kiosk.Kiosk, kiosk.KioskOwnerCap]
      >(inspectRes);
    }
    export async function owner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function place<T0 = any>(
      client: IotaClient,
      args: [string, string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.place(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function placeAndList<T0 = any>(
      client: IotaClient,
      args: [string, string, T0, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.placeAndList(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function placeInternal<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.placeInternal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function profitsAmount(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.profitsAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function profitsMut(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.profitsMut(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function purchase<T0 = any>(
      client: IotaClient,
      args: [string, object$.ID, coin.Coin<iota.IOTA>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>
    > {
      const tx = new Transaction();
      builder.purchase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function purchaseCapItem<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.purchaseCapItem(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function purchaseCapKiosk<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.purchaseCapKiosk(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function purchaseCapMinPrice<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.purchaseCapMinPrice(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function purchaseWithCap<T0 = any>(
      client: IotaClient,
      args: [string, kiosk.PurchaseCap<T0>, coin.Coin<iota.IOTA>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>
    > {
      const tx = new Transaction();
      builder.purchaseWithCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function returnPurchaseCap<T0 = any>(
      client: IotaClient,
      args: [string, kiosk.PurchaseCap<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.returnPurchaseCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function returnVal<T0 = any>(
      client: IotaClient,
      args: [string, T0, kiosk.Borrow],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.returnVal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setOwner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setOwner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setOwnerCustom(
      client: IotaClient,
      args: [string, string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.setOwnerCustom(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function take<T0 = any>(
      client: IotaClient,
      args: [string, string, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.take(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function uid(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uid(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutAsOwner(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uidMutAsOwner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutInternal(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uidMutInternal(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function withdraw(
      client: IotaClient,
      args: [string, string, _0x1.option.Option<bigint>],
    ): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.withdraw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<iota.IOTA>]
      >(inspectRes);
    }
  }

  export interface DefaultPayload extends TypedFunctionPayload<[string]> {
    arguments_decoded: [string];
    type_arguments: [];
  }
}

export class kiosk_extension extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("kiosk_extension", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): kiosk_extension {
    return new kiosk_extension({
      ...kiosk_extension.DEFAULT_OPTIONS,
      ...options,
    });
  }

  onEventExtensionKey(
    func: (
      event: kiosk_extension.ExtensionKeyInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      kiosk_extension.ExtensionKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): kiosk_extension {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "kiosk_extension::ExtensionKey" },
      handlerOptions,
    );
    return this;
  }
}

export namespace kiosk_extension {
  export interface Extension {
    storage: bag.Bag;
    permissions: bigint;
    is_enabled: boolean;
  }

  export namespace Extension {
    export const TYPE_QNAME = "0x2::kiosk_extension::Extension";

    const TYPE = new TypeDescriptor<Extension>(Extension.TYPE_QNAME);

    export function type(): TypeDescriptor<Extension> {
      return TYPE.apply();
    }
  }

  export interface ExtensionKey<T0> {
    dummy_field: boolean;
  }

  export namespace ExtensionKey {
    export const TYPE_QNAME = "0x2::kiosk_extension::ExtensionKey";

    const TYPE = new TypeDescriptor<ExtensionKey<any>>(ExtensionKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ExtensionKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type ExtensionKeyInstance = TypedEventInstance<ExtensionKey<any>> & {
    data_decoded: ExtensionKey<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function add<T0 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU128(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function canLock<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::can_lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function canPlace<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::can_place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function disable<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::disable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function enable<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::enable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEnabled<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::is_enabled",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isInstalled<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::is_installed",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lock<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function place<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function storage<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::storage",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function storageMut<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::storage_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: IotaClient,
      args: [T0, string, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function canLock<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.canLock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function canPlace<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.canPlace(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function disable<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.disable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function enable<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.enable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEnabled<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEnabled(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isInstalled<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isInstalled(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function lock<T0 = any, T1 = any>(
      client: IotaClient,
      args: [T0, string, T1, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.lock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function place<T0 = any, T1 = any>(
      client: IotaClient,
      args: [T0, string, T1, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.place(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function storage<T0 = any>(
      client: IotaClient,
      args: [T0, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.storage(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function storageMut<T0 = any>(
      client: IotaClient,
      args: [T0, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.storageMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace labeler {
  export interface LabelerCap<T0> {
    id: object$.UID;
  }

  export namespace LabelerCap {
    export const TYPE_QNAME = "0x2::labeler::LabelerCap";

    const TYPE = new TypeDescriptor<LabelerCap<any>>(LabelerCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<LabelerCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function createLabelerCap<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::labeler::create_labeler_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyLabelerCap<T0 = any>(
      tx: Transaction,
      args: [labeler.LabelerCap<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::labeler::destroy_labeler_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function createLabelerCap<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[labeler.LabelerCap<T0>]>> {
      const tx = new Transaction();
      builder.createLabelerCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [labeler.LabelerCap<T0>]
      >(inspectRes);
    }
    export async function destroyLabelerCap<T0 = any>(
      client: IotaClient,
      args: [labeler.LabelerCap<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyLabelerCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace linked_table {
  export interface LinkedTable<T0, T1> {
    id: object$.UID;
    size: bigint;
    head: _0x1.option.Option<T0>;
    tail: _0x1.option.Option<T0>;
  }

  export namespace LinkedTable {
    export const TYPE_QNAME = "0x2::linked_table::LinkedTable";

    const TYPE = new TypeDescriptor<LinkedTable<any, any>>(
      LinkedTable.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<LinkedTable<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface Node<T0, T1> {
    prev: _0x1.option.Option<T0>;
    next: _0x1.option.Option<T0>;
    value: T1;
  }

  export namespace Node {
    export const TYPE_QNAME = "0x2::linked_table::Node";

    const TYPE = new TypeDescriptor<Node<any, any>>(Node.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Node<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function back<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function drop<T0 = any, T1 = any>(
      tx: Transaction,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function front<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new$<T0 = any, T1 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function next<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::next",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function popFront<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::pop_front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function prev<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::prev",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pushFront<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::push_front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function back<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.back(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [linked_table.LinkedTable<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any, T1 = any>(
      client: IotaClient,
      args: [linked_table.LinkedTable<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function front<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.front(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any, T1 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[linked_table.LinkedTable<T0, T1>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [linked_table.LinkedTable<T0, T1>]
      >(inspectRes);
    }
    export async function next<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.next(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new Transaction();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function popFront<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new Transaction();
      builder.popFront(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function prev<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.prev(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function pushFront<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.pushFront(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace object$ {
  export type ID = string;
  export namespace ID {
    export const TYPE_QNAME = "0x2::object::ID";

    const TYPE = new TypeDescriptor<ID>(ID.TYPE_QNAME);

    export function type(): TypeDescriptor<ID> {
      return TYPE.apply();
    }
  }

  export interface UID {
    id: object$.ID;
  }

  export namespace UID {
    export const TYPE_QNAME = "0x2::object::UID";

    const TYPE = new TypeDescriptor<UID>(UID.TYPE_QNAME);

    export function type(): TypeDescriptor<UID> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function authenticatorState(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::authenticator_state",
        arguments: _args,
      });
    }
    export function borrowId<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::borrow_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function clock(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::clock",
        arguments: _args,
      });
    }
    export function delete$(
      tx: Transaction,
      args: [object$.UID | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::delete",
        arguments: _args,
      });
    }
    export function id<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idAddress<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_address",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idBytes<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idFromAddress(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_from_address",
        arguments: _args,
      });
    }
    export function idFromBytes(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_from_bytes",
        arguments: _args,
      });
    }
    export function idToAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_to_address",
        arguments: _args,
      });
    }
    export function idToBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_to_bytes",
        arguments: _args,
      });
    }
    export function iotaDenyListObjectId(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::iota_deny_list_object_id",
        arguments: _args,
      });
    }
    export function new$(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::new",
        arguments: _args,
      });
    }
    export function newUidFromHash(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::new_uid_from_hash",
        arguments: _args,
      });
    }
    export function randomnessState(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::randomness_state",
        arguments: _args,
      });
    }
    export function uidAsInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_as_inner",
        arguments: _args,
      });
    }
    export function uidToAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_address",
        arguments: _args,
      });
    }
    export function uidToBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_bytes",
        arguments: _args,
      });
    }
    export function uidToInner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_inner",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function authenticatorState(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.authenticatorState(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function borrowId<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function clock(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.clock(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function delete$(
      client: IotaClient,
      args: [object$.UID],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.delete$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function id<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.id(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function idAddress<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.idAddress(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function idBytes<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.idBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function idFromAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.idFromAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function idFromBytes(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.idFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function idToAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.idToAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function idToBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.idToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function iotaDenyListObjectId(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.iotaDenyListObjectId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function newUidFromHash(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.newUidFromHash(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function randomnessState(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object$.UID]>> {
      const tx = new Transaction();
      builder.randomnessState(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.UID]>(
        inspectRes,
      );
    }
    export async function uidAsInner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uidAsInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidToAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uidToAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidToBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.uidToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function uidToInner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.uidToInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
  }
}

export namespace object_bag {
  export interface ObjectBag {
    id: object$.UID;
    size: bigint;
  }

  export namespace ObjectBag {
    export const TYPE_QNAME = "0x2::object_bag::ObjectBag";

    const TYPE = new TypeDescriptor<ObjectBag>(ObjectBag.TYPE_QNAME);

    export function type(): TypeDescriptor<ObjectBag> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function containsWithType<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::contains_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty(
      tx: Transaction,
      args: [object_bag.ObjectBag | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::destroy_empty",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::length",
        arguments: _args,
      });
    }
    export function new$(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::new",
        arguments: _args,
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function valueId<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::value_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function containsWithType<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.containsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty(
      client: IotaClient,
      args: [object_bag.ObjectBag],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_bag.ObjectBag]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object_bag.ObjectBag]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function valueId<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>> {
      const tx = new Transaction();
      builder.valueId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object$.ID>]
      >(inspectRes);
    }
  }
}

export namespace object_table {
  export interface ObjectTable<T0, T1> {
    id: object$.UID;
    size: bigint;
  }

  export namespace ObjectTable {
    export const TYPE_QNAME = "0x2::object_table::ObjectTable";

    const TYPE = new TypeDescriptor<ObjectTable<any, any>>(
      ObjectTable.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<ObjectTable<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [object_table.ObjectTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new$<T0 = any, T1 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function valueId<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::value_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [object_table.ObjectTable<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any, T1 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[object_table.ObjectTable<T0, T1>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object_table.ObjectTable<T0, T1>]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function valueId<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object$.ID>]>> {
      const tx = new Transaction();
      builder.valueId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object$.ID>]
      >(inspectRes);
    }
  }
}

export class package$ extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("package", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): package$ {
    return new package$({ ...package$.DEFAULT_OPTIONS, ...options });
  }

  onEntryMakeImmutable(
    func: (call: package$.MakeImmutablePayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      package$.MakeImmutablePayload
    >,
  ): package$ {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "package::make_immutable",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryOnlyAdditiveUpgrades(
    func: (
      call: package$.OnlyAdditiveUpgradesPayload,
      ctx: IotaContext,
    ) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      package$.OnlyAdditiveUpgradesPayload
    >,
  ): package$ {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "package::only_additive_upgrades",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryOnlyDepUpgrades(
    func: (call: package$.OnlyDepUpgradesPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      package$.OnlyDepUpgradesPayload
    >,
  ): package$ {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "package::only_dep_upgrades",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace package$ {
  export interface Publisher {
    id: object$.UID;
    package: _0x1.ascii.String;
    module_name: _0x1.ascii.String;
  }

  export namespace Publisher {
    export const TYPE_QNAME = "0x2::package::Publisher";

    const TYPE = new TypeDescriptor<Publisher>(Publisher.TYPE_QNAME);

    export function type(): TypeDescriptor<Publisher> {
      return TYPE.apply();
    }
  }

  export interface UpgradeCap {
    id: object$.UID;
    package: object$.ID;
    version: bigint;
    policy: number;
  }

  export namespace UpgradeCap {
    export const TYPE_QNAME = "0x2::package::UpgradeCap";

    const TYPE = new TypeDescriptor<UpgradeCap>(UpgradeCap.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeCap> {
      return TYPE.apply();
    }
  }

  export interface UpgradeReceipt {
    cap: object$.ID;
    package: object$.ID;
  }

  export namespace UpgradeReceipt {
    export const TYPE_QNAME = "0x2::package::UpgradeReceipt";

    const TYPE = new TypeDescriptor<UpgradeReceipt>(UpgradeReceipt.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeReceipt> {
      return TYPE.apply();
    }
  }

  export interface UpgradeTicket {
    cap: object$.ID;
    package: object$.ID;
    policy: number;
    digest: number[];
  }

  export namespace UpgradeTicket {
    export const TYPE_QNAME = "0x2::package::UpgradeTicket";

    const TYPE = new TypeDescriptor<UpgradeTicket>(UpgradeTicket.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeTicket> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function additivePolicy(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::additive_policy",
        arguments: _args,
      });
    }
    export function authorizeUpgrade(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::authorize_upgrade",
        arguments: _args,
      });
    }
    export function burnPublisher(
      tx: Transaction,
      args: [package$.Publisher | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::burn_publisher",
        arguments: _args,
      });
    }
    export function claim<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::claim",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function claimAndKeep<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::claim_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function commitUpgrade(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        package$.UpgradeReceipt | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::commit_upgrade",
        arguments: _args,
      });
    }
    export function compatiblePolicy(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::compatible_policy",
        arguments: _args,
      });
    }
    export function depOnlyPolicy(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::dep_only_policy",
        arguments: _args,
      });
    }
    export function fromModule<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::from_module",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromPackage<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::from_package",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function makeImmutable(
      tx: Transaction,
      args: [package$.UpgradeCap | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::make_immutable",
        arguments: _args,
      });
    }
    export function onlyAdditiveUpgrades(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::only_additive_upgrades",
        arguments: _args,
      });
    }
    export function onlyDepUpgrades(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::only_dep_upgrades",
        arguments: _args,
      });
    }
    export function publishedModule(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::published_module",
        arguments: _args,
      });
    }
    export function publishedPackage(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::published_package",
        arguments: _args,
      });
    }
    export function receiptCap(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::receipt_cap",
        arguments: _args,
      });
    }
    export function receiptPackage(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::receipt_package",
        arguments: _args,
      });
    }
    export function ticketDigest(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_digest",
        arguments: _args,
      });
    }
    export function ticketPackage(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_package",
        arguments: _args,
      });
    }
    export function ticketPolicy(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_policy",
        arguments: _args,
      });
    }
    export function upgradePackage(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::upgrade_package",
        arguments: _args,
      });
    }
    export function upgradePolicy(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::upgrade_policy",
        arguments: _args,
      });
    }
    export function version(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::version",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function additivePolicy(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.additivePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function authorizeUpgrade(
      client: IotaClient,
      args: [string, number, string[]],
    ): Promise<TypedDevInspectResults<[package$.UpgradeTicket]>> {
      const tx = new Transaction();
      builder.authorizeUpgrade(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [package$.UpgradeTicket]
      >(inspectRes);
    }
    export async function burnPublisher(
      client: IotaClient,
      args: [package$.Publisher],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.burnPublisher(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function claim<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[package$.Publisher]>> {
      const tx = new Transaction();
      builder.claim(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [package$.Publisher]
      >(inspectRes);
    }
    export async function claimAndKeep<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.claimAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function commitUpgrade(
      client: IotaClient,
      args: [string, package$.UpgradeReceipt],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.commitUpgrade(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function compatiblePolicy(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.compatiblePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function depOnlyPolicy(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.depOnlyPolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function fromModule<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.fromModule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function fromPackage<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.fromPackage(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function makeImmutable(
      client: IotaClient,
      args: [package$.UpgradeCap],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.makeImmutable(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function onlyAdditiveUpgrades(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.onlyAdditiveUpgrades(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function onlyDepUpgrades(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.onlyDepUpgrades(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publishedModule(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.publishedModule(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function publishedPackage(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.publishedPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function receiptCap(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.receiptCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function receiptPackage(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.receiptPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function ticketDigest(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.ticketDigest(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function ticketPackage(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.ticketPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function ticketPolicy(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.ticketPolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function upgradePackage(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.upgradePackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function upgradePolicy(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.upgradePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function version(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.version(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }

  export interface MakeImmutablePayload
    extends TypedFunctionPayload<[package$.UpgradeCap]> {
    arguments_decoded: [package$.UpgradeCap];
    type_arguments: [];
  }

  export interface OnlyAdditiveUpgradesPayload
    extends TypedFunctionPayload<[string]> {
    arguments_decoded: [string];
    type_arguments: [];
  }

  export interface OnlyDepUpgradesPayload
    extends TypedFunctionPayload<[string]> {
    arguments_decoded: [string];
    type_arguments: [];
  }
}

export class pay extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("pay", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): pay {
    return new pay({ ...pay.DEFAULT_OPTIONS, ...options });
  }

  onEntryDivideAndKeep(
    func: (call: pay.DivideAndKeepPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, pay.DivideAndKeepPayload>,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::divide_and_keep",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryJoinVec(
    func: (call: pay.JoinVecPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, pay.JoinVecPayload>,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::join_vec",
      },
      handlerOptions,
    );
    return this;
  }

  onEntryJoinVecAndTransfer(
    func: (call: pay.JoinVecAndTransferPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      pay.JoinVecAndTransferPayload
    >,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::join_vec_and_transfer",
      },
      handlerOptions,
    );
    return this;
  }

  onEntrySplit(
    func: (call: pay.SplitPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, pay.SplitPayload>,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::split",
      },
      handlerOptions,
    );
    return this;
  }

  onEntrySplitAndTransfer(
    func: (call: pay.SplitAndTransferPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      pay.SplitAndTransferPayload
    >,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::split_and_transfer",
      },
      handlerOptions,
    );
    return this;
  }

  onEntrySplitVec(
    func: (call: pay.SplitVecPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<MoveFetchConfig, pay.SplitVecPayload>,
  ): pay {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "pay::split_vec",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace pay {
  export namespace builder {
    export function divideAndKeep<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::divide_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinVec<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::join_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinVecAndTransfer<T0 = any>(
      tx: Transaction,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::join_vec_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keep<T0 = any>(
      tx: Transaction,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function splitAndTransfer<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function splitVec<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function divideAndKeep<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.divideAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function joinVec<T0 = any>(
      client: IotaClient,
      args: [string, string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.joinVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function joinVecAndTransfer<T0 = any>(
      client: IotaClient,
      args: [string[], string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.joinVecAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function keep<T0 = any>(
      client: IotaClient,
      args: [coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.keep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function splitAndTransfer<T0 = any>(
      client: IotaClient,
      args: [string, bigint, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.splitAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function splitVec<T0 = any>(
      client: IotaClient,
      args: [string, string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.splitVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }

  export interface DivideAndKeepPayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint, string]> {
    arguments_decoded: [string, bigint, string];
    type_arguments: [string];
  }

  export interface JoinVecPayload<T0 = any>
    extends TypedFunctionPayload<[string, coin.Coin<T0>[]]> {
    arguments_decoded: [string, coin.Coin<T0>[]];
    type_arguments: [string];
  }

  export interface JoinVecAndTransferPayload<T0 = any>
    extends TypedFunctionPayload<[coin.Coin<T0>[], string]> {
    arguments_decoded: [coin.Coin<T0>[], string];
    type_arguments: [string];
  }

  export interface SplitPayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint, string]> {
    arguments_decoded: [string, bigint, string];
    type_arguments: [string];
  }

  export interface SplitAndTransferPayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint, string, string]> {
    arguments_decoded: [string, bigint, string, string];
    type_arguments: [string];
  }

  export interface SplitVecPayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint[], string]> {
    arguments_decoded: [string, bigint[], string];
    type_arguments: [string];
  }
}

export namespace poseidon {
  export namespace builder {
    export function poseidonBn254(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::poseidon::poseidon_bn254",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function poseidonBn254(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.poseidonBn254(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace priority_queue {
  export interface Entry<T0> {
    priority: bigint;
    value: T0;
  }

  export namespace Entry {
    export const TYPE_QNAME = "0x2::priority_queue::Entry";

    const TYPE = new TypeDescriptor<Entry<any>>(Entry.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Entry<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface PriorityQueue<T0> {
    entries: priority_queue.Entry<T0>[];
  }

  export namespace PriorityQueue {
    export const TYPE_QNAME = "0x2::priority_queue::PriorityQueue";

    const TYPE = new TypeDescriptor<PriorityQueue<any>>(
      PriorityQueue.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<PriorityQueue<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function createEntries<T0 = any>(
      tx: Transaction,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::create_entries",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newEntry<T0 = any>(
      tx: Transaction,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::new_entry",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popMax<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::pop_max",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function priorities<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::priorities",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function createEntries<T0 = any>(
      client: IotaClient,
      args: [string[], string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>[]]>> {
      const tx = new Transaction();
      builder.createEntries(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.Entry<T0>[]]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: IotaClient,
      args: [string, bigint, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.PriorityQueue<T0>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.PriorityQueue<T0>]
      >(inspectRes);
    }
    export async function newEntry<T0 = any>(
      client: IotaClient,
      args: [bigint, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>]>> {
      const tx = new Transaction();
      builder.newEntry(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.Entry<T0>]
      >(inspectRes);
    }
    export async function popMax<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, T0]>> {
      const tx = new Transaction();
      builder.popMax(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint, T0]>(
        inspectRes,
      );
    }
    export async function priorities<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new Transaction();
      builder.priorities(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
  }
}

export namespace prover {
  export namespace builder {}
  export namespace view {}
}

export namespace random {
  export interface Random {
    id: object$.UID;
    inner: versioned.Versioned;
  }

  export namespace Random {
    export const TYPE_QNAME = "0x2::random::Random";

    const TYPE = new TypeDescriptor<Random>(Random.TYPE_QNAME);

    export function type(): TypeDescriptor<Random> {
      return TYPE.apply();
    }
  }

  export interface RandomGenerator {
    seed: number[];
    counter: number;
    buffer: number[];
  }

  export namespace RandomGenerator {
    export const TYPE_QNAME = "0x2::random::RandomGenerator";

    const TYPE = new TypeDescriptor<RandomGenerator>(
      RandomGenerator.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<RandomGenerator> {
      return TYPE.apply();
    }
  }

  export interface RandomInner {
    version: bigint;
    epoch: bigint;
    randomness_round: bigint;
    random_bytes: number[];
  }

  export namespace RandomInner {
    export const TYPE_QNAME = "0x2::random::RandomInner";

    const TYPE = new TypeDescriptor<RandomInner>(RandomInner.TYPE_QNAME);

    export function type(): TypeDescriptor<RandomInner> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function generateBool(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_bool",
        arguments: _args,
      });
    }
    export function generateBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_bytes",
        arguments: _args,
      });
    }
    export function generateU128(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u128",
        arguments: _args,
      });
    }
    export function generateU128InRange(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));
      _args.push(transactionArgumentOrPureU128(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u128_in_range",
        arguments: _args,
      });
    }
    export function generateU16(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u16",
        arguments: _args,
      });
    }
    export function generateU16InRange(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));
      _args.push(transactionArgumentOrPureU16(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u16_in_range",
        arguments: _args,
      });
    }
    export function generateU256(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u256",
        arguments: _args,
      });
    }
    export function generateU32(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u32",
        arguments: _args,
      });
    }
    export function generateU32InRange(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU32(args[1], tx));
      _args.push(transactionArgumentOrPureU32(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u32_in_range",
        arguments: _args,
      });
    }
    export function generateU64(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u64",
        arguments: _args,
      });
    }
    export function generateU64InRange(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u64_in_range",
        arguments: _args,
      });
    }
    export function generateU8(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u8",
        arguments: _args,
      });
    }
    export function generateU8InRange(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));
      _args.push(transactionArgumentOrPureU8(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u8_in_range",
        arguments: _args,
      });
    }
    export function newGenerator(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::new_generator",
        arguments: _args,
      });
    }
    export function shuffle<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::shuffle",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function generateBool(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.generateBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function generateBytes(
      client: IotaClient,
      args: [string, number],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.generateBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function generateU128(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.generateU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU128InRange(
      client: IotaClient,
      args: [string, bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.generateU128InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU16(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU16InRange(
      client: IotaClient,
      args: [string, number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU16InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU256(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.generateU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU32(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU32InRange(
      client: IotaClient,
      args: [string, number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU32InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU64(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.generateU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU64InRange(
      client: IotaClient,
      args: [string, bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.generateU64InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU8(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU8InRange(
      client: IotaClient,
      args: [string, number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.generateU8InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function newGenerator(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[random.RandomGenerator]>> {
      const tx = new Transaction();
      builder.newGenerator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [random.RandomGenerator]
      >(inspectRes);
    }
    export async function shuffle<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.shuffle(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace system_admin_cap {
  export interface IotaSystemAdminCap {
    dummy_field: boolean;
  }

  export namespace IotaSystemAdminCap {
    export const TYPE_QNAME = "0x2::system_admin_cap::IotaSystemAdminCap";

    const TYPE = new TypeDescriptor<IotaSystemAdminCap>(
      IotaSystemAdminCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<IotaSystemAdminCap> {
      return TYPE.apply();
    }
  }

  export namespace builder {}
  export namespace view {}
}

export namespace table {
  export interface Table<T0, T1> {
    id: object$.UID;
    size: bigint;
  }

  export namespace Table {
    export const TYPE_QNAME = "0x2::table::Table";

    const TYPE = new TypeDescriptor<Table<any, any>>(Table.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Table<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function drop<T0 = any, T1 = any>(
      tx: Transaction,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new$<T0 = any, T1 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [table.Table<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any, T1 = any>(
      client: IotaClient,
      args: [table.Table<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any, T1 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[table.Table<T0, T1>]>> {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table.Table<T0, T1>]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace table_vec {
  export interface TableVec<T0> {
    contents: table.Table<bigint, T0>;
  }

  export namespace TableVec {
    export const TYPE_QNAME = "0x2::table_vec::TableVec";

    const TYPE = new TypeDescriptor<TableVec<any>>(TableVec.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TableVec<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any>(
      tx: Transaction,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function drop<T0 = any>(
      tx: Transaction,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function length<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapRemove<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::swap_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any>(
      client: IotaClient,
      args: [table_vec.TableVec<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any>(
      client: IotaClient,
      args: [table_vec.TableVec<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>> {
      const tx = new Transaction();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table_vec.TableVec<T0>]
      >(inspectRes);
    }
    export async function isEmpty<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>> {
      const tx = new Transaction();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table_vec.TableVec<T0>]
      >(inspectRes);
    }
    export async function swap<T0 = any>(
      client: IotaClient,
      args: [string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapRemove<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.swapRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
  }
}

export class timelock extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("timelock", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): timelock {
    return new timelock({ ...timelock.DEFAULT_OPTIONS, ...options });
  }

  onEntrySplitBalance(
    func: (call: timelock.SplitBalancePayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      timelock.SplitBalancePayload
    >,
  ): timelock {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "timelock::split_balance",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace timelock {
  export interface TimeLock<T0> {
    id: object$.UID;
    locked: T0;
    expiration_timestamp_ms: bigint;
    label: _0x1.option.Option<string>;
  }

  export namespace TimeLock {
    export const TYPE_QNAME = "0x2::timelock::TimeLock";

    const TYPE = new TypeDescriptor<TimeLock<any>>(TimeLock.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TimeLock<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function expirationTimestampMs<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::expiration_timestamp_ms",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isLabeledWith<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::is_labeled_with",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isLocked<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::is_locked",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isLockedWithClock<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::is_locked_with_clock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        timelock.TimeLock<balance.Balance<T0>> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinVec<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::join_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function label<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::label",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lock<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockAndTransfer<T0 = any>(
      tx: Transaction,
      args: [
        T0 | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::lock_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockWithLabel<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::lock_with_label",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function lockWithLabelAndTransfer<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureAddress(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::lock_with_label_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function locked<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::locked",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remainingTime<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::remaining_time",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remainingTimeWithClock<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::remaining_time_with_clock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function splitBalance<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::split_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function systemPack<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
        _0x1.option.Option<string> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::system_pack",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function systemUnpack<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        timelock.TimeLock<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::system_unpack",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transferToSender<T0 = any>(
      tx: Transaction,
      args: [timelock.TimeLock<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::transfer_to_sender",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function typeName<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::type_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function unlock<T0 = any>(
      tx: Transaction,
      args: [timelock.TimeLock<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::unlock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function unlockWithClock<T0 = any>(
      tx: Transaction,
      args: [
        timelock.TimeLock<T0> | TransactionArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::timelock::unlock_with_clock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function expirationTimestampMs<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.expirationTimestampMs(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isLabeledWith<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isLabeledWith(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isLocked<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isLocked(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isLockedWithClock<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isLockedWithClock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function join<T0 = any>(
      client: IotaClient,
      args: [string, timelock.TimeLock<balance.Balance<T0>>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function joinVec<T0 = any>(
      client: IotaClient,
      args: [string, string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.joinVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function label<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new Transaction();
      builder.label(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function lock<T0 = any>(
      client: IotaClient,
      args: [T0, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>> {
      const tx = new Transaction();
      builder.lock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelock.TimeLock<T0>]
      >(inspectRes);
    }
    export async function lockAndTransfer<T0 = any>(
      client: IotaClient,
      args: [T0, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.lockAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function lockWithLabel<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>> {
      const tx = new Transaction();
      builder.lockWithLabel(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelock.TimeLock<T0>]
      >(inspectRes);
    }
    export async function lockWithLabelAndTransfer<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.lockWithLabelAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function locked<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.locked(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function remainingTime<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.remainingTime(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function remainingTimeWithClock<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.remainingTimeWithClock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[timelock.TimeLock<balance.Balance<T0>>]>
    > {
      const tx = new Transaction();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelock.TimeLock<balance.Balance<T0>>]
      >(inspectRes);
    }
    export async function splitBalance<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.splitBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function systemPack<T0 = any>(
      client: IotaClient,
      args: [string, T0, bigint, _0x1.option.Option<string>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[timelock.TimeLock<T0>]>> {
      const tx = new Transaction();
      builder.systemPack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [timelock.TimeLock<T0>]
      >(inspectRes);
    }
    export async function systemUnpack<T0 = any>(
      client: IotaClient,
      args: [string, timelock.TimeLock<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[T0, bigint, _0x1.option.Option<string>]>
    > {
      const tx = new Transaction();
      builder.systemUnpack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, bigint, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function transferToSender<T0 = any>(
      client: IotaClient,
      args: [timelock.TimeLock<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transferToSender(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function typeName<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.typeName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function unlock<T0 = any>(
      client: IotaClient,
      args: [timelock.TimeLock<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.unlock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function unlockWithClock<T0 = any>(
      client: IotaClient,
      args: [timelock.TimeLock<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.unlockWithClock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
  }

  export interface SplitBalancePayload<T0 = any>
    extends TypedFunctionPayload<[string, bigint, string]> {
    arguments_decoded: [string, bigint, string];
    type_arguments: [string];
  }
}

export class token extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("token", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): token {
    return new token({ ...token.DEFAULT_OPTIONS, ...options });
  }

  onEventRuleKey(
    func: (event: token.RuleKeyInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, token.RuleKeyInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): token {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "token::RuleKey" },
      handlerOptions,
    );
    return this;
  }

  onEventTokenPolicyCreated(
    func: (event: token.TokenPolicyCreatedInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      token.TokenPolicyCreatedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): token {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "token::TokenPolicyCreated" },
      handlerOptions,
    );
    return this;
  }
}

export namespace token {
  export interface ActionRequest<T0> {
    name: string;
    amount: bigint;
    sender: string;
    recipient: _0x1.option.Option<string>;
    spent_balance: _0x1.option.Option<balance.Balance<T0>>;
    approvals: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace ActionRequest {
    export const TYPE_QNAME = "0x2::token::ActionRequest";

    const TYPE = new TypeDescriptor<ActionRequest<any>>(
      ActionRequest.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ActionRequest<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RuleKey<T0> {
    is_protected: boolean;
  }

  export namespace RuleKey {
    export const TYPE_QNAME = "0x2::token::RuleKey";

    const TYPE = new TypeDescriptor<RuleKey<any>>(RuleKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RuleKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type RuleKeyInstance = TypedEventInstance<RuleKey<any>> & {
    data_decoded: RuleKey<any>;
    type_arguments: [string];
  };

  export interface Token<T0> {
    id: object$.UID;
    balance: balance.Balance<T0>;
  }

  export namespace Token {
    export const TYPE_QNAME = "0x2::token::Token";

    const TYPE = new TypeDescriptor<Token<any>>(Token.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Token<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicy<T0> {
    id: object$.UID;
    spent_balance: balance.Balance<T0>;
    rules: vec_map.VecMap<string, vec_set.VecSet<_0x1.type_name.TypeName>>;
  }

  export namespace TokenPolicy {
    export const TYPE_QNAME = "0x2::token::TokenPolicy";

    const TYPE = new TypeDescriptor<TokenPolicy<any>>(TokenPolicy.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicy<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicyCap<T0> {
    id: object$.UID;
    for: object$.ID;
  }

  export namespace TokenPolicyCap {
    export const TYPE_QNAME = "0x2::token::TokenPolicyCap";

    const TYPE = new TypeDescriptor<TokenPolicyCap<any>>(
      TokenPolicyCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicyCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicyCreated<T0> {
    id: object$.ID;
    is_mutable: boolean;
  }

  export namespace TokenPolicyCreated {
    export const TYPE_QNAME = "0x2::token::TokenPolicyCreated";

    const TYPE = new TypeDescriptor<TokenPolicyCreated<any>>(
      TokenPolicyCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicyCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type TokenPolicyCreatedInstance = TypedEventInstance<
    TokenPolicyCreated<any>
  > & {
    data_decoded: TokenPolicyCreated<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function action<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function addApproval<T0 = any, T1 = any>(
      tx: Transaction,
      args: [T1 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_approval",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addRuleConfig<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function addRuleForAction<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_rule_for_action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function allow<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::allow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function amount<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::amount",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function approvals<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::approvals",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function burn<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::burn",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmRequest<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmRequestMut<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_request_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmWithPolicyCap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_with_policy_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmWithTreasuryCap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_with_treasury_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: Transaction,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function disallow<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::disallow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function flush<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::flush",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromCoin<T0 = any>(
      tx: Transaction,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::from_coin",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromCoinAction(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::from_coin_action",
        arguments: _args,
      });
    }
    export function hasRuleConfig<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::has_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::has_rule_config_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function isAllowed<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::is_allowed",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keep<T0 = any>(
      tx: Transaction,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mint<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::mint",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newPolicy<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::new_policy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newRequest<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        _0x1.option.Option<string> | TransactionArgument,
        _0x1.option.Option<balance.Balance<T0>> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::new_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function recipient<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::recipient",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeRuleConfig<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::remove_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function removeRuleForAction<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::remove_rule_for_action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function ruleConfig<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [T1 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function ruleConfigMut<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rule_config_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function rules<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rules",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function sender<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::sender",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function sharePolicy<T0 = any>(
      tx: Transaction,
      args: [token.TokenPolicy<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::share_policy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spend<T0 = any>(
      tx: Transaction,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spend",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spendAction(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spend_action",
        arguments: _args,
      });
    }
    export function spent<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spent",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spentBalance<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spent_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toCoin<T0 = any>(
      tx: Transaction,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::to_coin",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toCoinAction(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::to_coin_action",
        arguments: _args,
      });
    }
    export function transfer<T0 = any>(
      tx: Transaction,
      args: [
        token.Token<T0> | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transferAction(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::transfer_action",
        arguments: _args,
      });
    }
    export function value<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function action<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.action(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function addApproval<T0 = any, T1 = any>(
      client: IotaClient,
      args: [T1, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addApproval(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRuleConfig<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [T1, string, string, T2],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRuleForAction<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addRuleForAction(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function allow<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.allow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function amount<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.amount(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function approvals<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>
    > {
      const tx = new Transaction();
      builder.approvals(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<_0x1.type_name.TypeName>]
      >(inspectRes);
    }
    export async function burn<T0 = any>(
      client: IotaClient,
      args: [string, token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.burn(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function confirmRequest<T0 = any>(
      client: IotaClient,
      args: [string, token.ActionRequest<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new Transaction();
      builder.confirmRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmRequestMut<T0 = any>(
      client: IotaClient,
      args: [string, token.ActionRequest<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new Transaction();
      builder.confirmRequestMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmWithPolicyCap<T0 = any>(
      client: IotaClient,
      args: [string, token.ActionRequest<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new Transaction();
      builder.confirmWithPolicyCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmWithTreasuryCap<T0 = any>(
      client: IotaClient,
      args: [string, token.ActionRequest<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new Transaction();
      builder.confirmWithTreasuryCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function destroyZero<T0 = any>(
      client: IotaClient,
      args: [token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function disallow<T0 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.disallow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function flush<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.flush(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function fromCoin<T0 = any>(
      client: IotaClient,
      args: [coin.Coin<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[token.Token<T0>, token.ActionRequest<T0>]>
    > {
      const tx = new Transaction();
      builder.fromCoin(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>, token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function fromCoinAction(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fromCoinAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function hasRuleConfig<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasRuleConfigWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isAllowed<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isAllowed(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function join<T0 = any>(
      client: IotaClient,
      args: [string, token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function keep<T0 = any>(
      client: IotaClient,
      args: [token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.keep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mint<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new Transaction();
      builder.mint(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
    export async function newPolicy<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[token.TokenPolicy<T0>, token.TokenPolicyCap<T0>]>
    > {
      const tx = new Transaction();
      builder.newPolicy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.TokenPolicy<T0>, token.TokenPolicyCap<T0>]
      >(inspectRes);
    }
    export async function newRequest<T0 = any>(
      client: IotaClient,
      args: [
        string,
        bigint,
        _0x1.option.Option<string>,
        _0x1.option.Option<balance.Balance<T0>>,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new Transaction();
      builder.newRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function recipient<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new Transaction();
      builder.recipient(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function removeRuleConfig<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[T2]>> {
      const tx = new Transaction();
      builder.removeRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T2]>(
        inspectRes,
      );
    }
    export async function removeRuleForAction<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.removeRuleForAction(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function ruleConfig<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [T1, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.ruleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function ruleConfigMut<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [T1, string, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.ruleConfigMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function rules<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>
    > {
      const tx = new Transaction();
      builder.rules(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<_0x1.type_name.TypeName>]
      >(inspectRes);
    }
    export async function sender<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.sender(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function sharePolicy<T0 = any>(
      client: IotaClient,
      args: [token.TokenPolicy<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.sharePolicy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function spend<T0 = any>(
      client: IotaClient,
      args: [token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new Transaction();
      builder.spend(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function spendAction(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.spendAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function spent<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.spent(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function spentBalance<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.spentBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new Transaction();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
    export async function toCoin<T0 = any>(
      client: IotaClient,
      args: [token.Token<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[coin.Coin<T0>, token.ActionRequest<T0>]>
    > {
      const tx = new Transaction();
      builder.toCoin(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>, token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function toCoinAction(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toCoinAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function transfer<T0 = any>(
      client: IotaClient,
      args: [token.Token<T0>, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new Transaction();
      builder.transfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function transferAction(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.transferAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function zero<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new Transaction();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
  }
}

export namespace transfer {
  export interface Receiving<T0> {
    id: object$.ID;
    version: bigint;
  }

  export namespace Receiving {
    export const TYPE_QNAME = "0x2::transfer::Receiving";

    const TYPE = new TypeDescriptor<Receiving<any>>(Receiving.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Receiving<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function freezeObject<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::freeze_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function freezeObjectImpl<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::freeze_object_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicFreezeObject<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_freeze_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicReceive<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_receive",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicShareObject<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_share_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicTransfer<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function receive<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::receive",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function receivingObjectId<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::receiving_object_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function shareObject<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::share_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function shareObjectImpl<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::share_object_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transfer<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transferImpl<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureAddress(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::transfer_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function freezeObject<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.freezeObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function freezeObjectImpl<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.freezeObjectImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicFreezeObject<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.publicFreezeObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicReceive<T0 = any>(
      client: IotaClient,
      args: [string, transfer.Receiving<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.publicReceive(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function publicShareObject<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.publicShareObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicTransfer<T0 = any>(
      client: IotaClient,
      args: [T0, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.publicTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function receive<T0 = any>(
      client: IotaClient,
      args: [string, transfer.Receiving<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.receive(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function receivingObjectId<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.receivingObjectId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function shareObject<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.shareObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function shareObjectImpl<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.shareObjectImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transfer<T0 = any>(
      client: IotaClient,
      args: [T0, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transferImpl<T0 = any>(
      client: IotaClient,
      args: [T0, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.transferImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export class transfer_policy extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("transfer_policy", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): transfer_policy {
    return new transfer_policy({
      ...transfer_policy.DEFAULT_OPTIONS,
      ...options,
    });
  }

  onEntryDefault(
    func: (call: transfer_policy.DefaultPayload, ctx: IotaContext) => void,
    filter?: CallFilter,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      transfer_policy.DefaultPayload
    >,
  ): transfer_policy {
    this.onEntryFunctionCall(
      func,
      {
        ...filter,
        function: "transfer_policy::default",
      },
      handlerOptions,
    );
    return this;
  }

  onEventRuleKey(
    func: (event: transfer_policy.RuleKeyInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      transfer_policy.RuleKeyInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): transfer_policy {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "transfer_policy::RuleKey" },
      handlerOptions,
    );
    return this;
  }

  onEventTransferPolicyCreated(
    func: (
      event: transfer_policy.TransferPolicyCreatedInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      transfer_policy.TransferPolicyCreatedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): transfer_policy {
    this.onMoveEvent(
      func,
      {
        ...(eventFilter ?? {}),
        type: "transfer_policy::TransferPolicyCreated",
      },
      handlerOptions,
    );
    return this;
  }

  onEventTransferPolicyDestroyed(
    func: (
      event: transfer_policy.TransferPolicyDestroyedInstance,
      ctx: IotaContext,
    ) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      transfer_policy.TransferPolicyDestroyedInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): transfer_policy {
    this.onMoveEvent(
      func,
      {
        ...(eventFilter ?? {}),
        type: "transfer_policy::TransferPolicyDestroyed",
      },
      handlerOptions,
    );
    return this;
  }
}

export namespace transfer_policy {
  export interface RuleKey<T0> {
    dummy_field: boolean;
  }

  export namespace RuleKey {
    export const TYPE_QNAME = "0x2::transfer_policy::RuleKey";

    const TYPE = new TypeDescriptor<RuleKey<any>>(RuleKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RuleKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type RuleKeyInstance = TypedEventInstance<RuleKey<any>> & {
    data_decoded: RuleKey<any>;
    type_arguments: [string];
  };

  export interface TransferPolicy<T0> {
    id: object$.UID;
    balance: balance.Balance<iota.IOTA>;
    rules: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace TransferPolicy {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicy";

    const TYPE = new TypeDescriptor<TransferPolicy<any>>(
      TransferPolicy.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicy<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyCap<T0> {
    id: object$.UID;
    policy_id: object$.ID;
  }

  export namespace TransferPolicyCap {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCap";

    const TYPE = new TypeDescriptor<TransferPolicyCap<any>>(
      TransferPolicyCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyCreated<T0> {
    id: object$.ID;
  }

  export namespace TransferPolicyCreated {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCreated";

    const TYPE = new TypeDescriptor<TransferPolicyCreated<any>>(
      TransferPolicyCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type TransferPolicyCreatedInstance = TypedEventInstance<
    TransferPolicyCreated<any>
  > & {
    data_decoded: TransferPolicyCreated<any>;
    type_arguments: [string];
  };

  export interface TransferPolicyDestroyed<T0> {
    id: object$.ID;
  }

  export namespace TransferPolicyDestroyed {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyDestroyed";

    const TYPE = new TypeDescriptor<TransferPolicyDestroyed<any>>(
      TransferPolicyDestroyed.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyDestroyed<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type TransferPolicyDestroyedInstance = TypedEventInstance<
    TransferPolicyDestroyed<any>
  > & {
    data_decoded: TransferPolicyDestroyed<any>;
    type_arguments: [string];
  };

  export interface TransferRequest<T0> {
    item: object$.ID;
    paid: bigint;
    from: object$.ID;
    receipts: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace TransferRequest {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferRequest";

    const TYPE = new TypeDescriptor<TransferRequest<any>>(
      TransferRequest.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferRequest<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function addReceipt<T0 = any, T1 = any>(
      tx: Transaction,
      args: [T1 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_receipt",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addRule<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function addToBalance<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument,
        coin.Coin<iota.IOTA> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_to_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function confirmRequest<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        transfer_policy.TransferRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::confirm_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function default$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyAndWithdraw<T0 = any>(
      tx: Transaction,
      args: [
        transfer_policy.TransferPolicy<T0> | TransactionArgument,
        transfer_policy.TransferPolicyCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::destroy_and_withdraw",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function from$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::from",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getRule<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [T1 | TransactionArgument, string | TransactionObjectArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::get_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function hasRule<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::has_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function item<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::item",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new$<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newRequest<T0 = any>(
      tx: Transaction,
      args: [
        object$.ID | TransactionArgument,
        bigint | TransactionArgument,
        object$.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::new_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function paid<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::paid",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeRule<T0 = any, T1 = any, T2 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::remove_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function rules<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::rules",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uid<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::uid",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uidMutAsOwner<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::uid_mut_as_owner",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdraw<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::withdraw",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addReceipt<T0 = any, T1 = any>(
      client: IotaClient,
      args: [T1, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addReceipt(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRule<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [T1, string, string, T2],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addToBalance<T0 = any, T1 = any>(
      client: IotaClient,
      args: [T1, string, coin.Coin<iota.IOTA>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.addToBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function confirmRequest<T0 = any>(
      client: IotaClient,
      args: [string, transfer_policy.TransferRequest<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID, bigint, object$.ID]>> {
      const tx = new Transaction();
      builder.confirmRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object$.ID, bigint, object$.ID]
      >(inspectRes);
    }

    export async function destroyAndWithdraw<T0 = any>(
      client: IotaClient,
      args: [
        transfer_policy.TransferPolicy<T0>,
        transfer_policy.TransferPolicyCap<T0>,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.destroyAndWithdraw(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<iota.IOTA>]
      >(inspectRes);
    }
    export async function from$<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.from$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function getRule<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [T1, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function hasRule<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.hasRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function item<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object$.ID]>> {
      const tx = new Transaction();
      builder.item(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object$.ID]>(
        inspectRes,
      );
    }
    export async function new$<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [
          transfer_policy.TransferPolicy<T0>,
          transfer_policy.TransferPolicyCap<T0>,
        ]
      >
    > {
      const tx = new Transaction();
      builder.new$(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          transfer_policy.TransferPolicy<T0>,
          transfer_policy.TransferPolicyCap<T0>,
        ]
      >(inspectRes);
    }
    export async function newRequest<T0 = any>(
      client: IotaClient,
      args: [object$.ID, bigint, object$.ID],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[transfer_policy.TransferRequest<T0>]>> {
      const tx = new Transaction();
      builder.newRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function paid<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.paid(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function removeRule<T0 = any, T1 = any, T2 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.removeRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function rules<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.rules(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uid<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uid(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutAsOwner<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.uidMutAsOwner(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function withdraw<T0 = any>(
      client: IotaClient,
      args: [string, string, _0x1.option.Option<bigint>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<iota.IOTA>]>> {
      const tx = new Transaction();
      builder.withdraw(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<iota.IOTA>]
      >(inspectRes);
    }
  }

  export interface DefaultPayload<T0 = any>
    extends TypedFunctionPayload<[string, string]> {
    arguments_decoded: [string, string];
    type_arguments: [string];
  }
}

export namespace tx_context {
  export interface TxContext {
    sender: string;
    tx_hash: number[];
    epoch: bigint;
    epoch_timestamp_ms: bigint;
    ids_created: bigint;
  }

  export namespace TxContext {
    export const TYPE_QNAME = "0x2::tx_context::TxContext";

    const TYPE = new TypeDescriptor<TxContext>(TxContext.TYPE_QNAME);

    export function type(): TypeDescriptor<TxContext> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function digest(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::digest",
        arguments: _args,
      });
    }
    export function epoch(tx: Transaction, args: []): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::epoch",
        arguments: _args,
      });
    }
    export function epochTimestampMs(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::epoch_timestamp_ms",
        arguments: _args,
      });
    }
    export function freshObjectAddress(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::fresh_object_address",
        arguments: _args,
      });
    }
    export function sender(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::sender",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function digest(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.digest(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function epoch(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.epoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function epochTimestampMs(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.epochTimestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function freshObjectAddress(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.freshObjectAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function sender(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.sender(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace types {
  export namespace builder {
    export function isOneTimeWitness<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::types::is_one_time_witness",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function isOneTimeWitness<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isOneTimeWitness(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export class url extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("url", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): url {
    return new url({ ...url.DEFAULT_OPTIONS, ...options });
  }

  onEventUrl(
    func: (event: url.UrlInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, url.UrlInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): url {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "url::Url" },
      handlerOptions,
    );
    return this;
  }
}

export namespace url {
  export interface Url {
    url: _0x1.ascii.String;
  }

  export namespace Url {
    export const TYPE_QNAME = "0x2::url::Url";

    const TYPE = new TypeDescriptor<Url>(Url.TYPE_QNAME);

    export function type(): TypeDescriptor<Url> {
      return TYPE.apply();
    }
  }

  export type UrlInstance = TypedEventInstance<Url> & {
    data_decoded: Url;
    type_arguments: [];
  };

  export namespace builder {
    export function innerUrl(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::inner_url",
        arguments: _args,
      });
    }
    export function newUnsafe(
      tx: Transaction,
      args: [_0x1.ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::new_unsafe",
        arguments: _args,
      });
    }
    export function newUnsafeFromBytes(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::new_unsafe_from_bytes",
        arguments: _args,
      });
    }
    export function update(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::update",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function innerUrl(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new Transaction();
      builder.innerUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function newUnsafe(
      client: IotaClient,
      args: [_0x1.ascii.String],
    ): Promise<TypedDevInspectResults<[url.Url]>> {
      const tx = new Transaction();
      builder.newUnsafe(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[url.Url]>(
        inspectRes,
      );
    }
    export async function newUnsafeFromBytes(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[url.Url]>> {
      const tx = new Transaction();
      builder.newUnsafeFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[url.Url]>(
        inspectRes,
      );
    }
    export async function update(
      client: IotaClient,
      args: [string, _0x1.ascii.String],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.update(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace vdf {
  export namespace builder {
    export function hashToInput(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vdf::hash_to_input",
        arguments: _args,
      });
    }
    export function vdfVerify(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPureU64(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vdf::vdf_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function hashToInput(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.hashToInput(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function vdfVerify(
      client: IotaClient,
      args: [string, string, string, bigint],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.vdfVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export class vec_map extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("vec_map", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): vec_map {
    return new vec_map({ ...vec_map.DEFAULT_OPTIONS, ...options });
  }

  onEventEntry(
    func: (event: vec_map.EntryInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, vec_map.EntryInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): vec_map {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "vec_map::Entry" },
      handlerOptions,
    );
    return this;
  }

  onEventVecMap(
    func: (event: vec_map.VecMapInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, vec_map.VecMapInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): vec_map {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "vec_map::VecMap" },
      handlerOptions,
    );
    return this;
  }
}

export namespace vec_map {
  export interface Entry<T0, T1> {
    key: T0;
    value: T1;
  }

  export namespace Entry {
    export const TYPE_QNAME = "0x2::vec_map::Entry";

    const TYPE = new TypeDescriptor<Entry<any, any>>(Entry.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Entry<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type EntryInstance = TypedEventInstance<Entry<any, any>> & {
    data_decoded: Entry<any, any>;
    type_arguments: [string, string];
  };

  export interface VecMap<T0, T1> {
    contents: vec_map.Entry<T0, T1>[];
  }

  export namespace VecMap {
    export const TYPE_QNAME = "0x2::vec_map::VecMap";

    const TYPE = new TypeDescriptor<VecMap<any, any>>(VecMap.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<VecMap<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export type VecMapInstance = TypedEventInstance<VecMap<any, any>> & {
    data_decoded: VecMap<any, any>;
    type_arguments: [string, string];
  };

  export namespace builder {
    export function contains<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function empty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function fromKeysValues<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::from_keys_values",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function get<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getEntryByIdx<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_entry_by_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getEntryByIdxMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_entry_by_idx_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getIdx<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getIdxOpt<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_idx_opt",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getMut<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function insert<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function intoKeysValues<T0 = any, T1 = any>(
      tx: Transaction,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::into_keys_values",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function keys<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pop<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::pop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeEntryByIdx<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::remove_entry_by_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function size<T0 = any, T1 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::size",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function tryGet<T0 = any, T1 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::try_get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function contains<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [vec_map.VecMap<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>> {
      const tx = new Transaction();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_map.VecMap<T0, T1>]
      >(inspectRes);
    }
    export async function fromKeysValues<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string[], string[]],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>> {
      const tx = new Transaction();
      builder.fromKeysValues(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_map.VecMap<T0, T1>]
      >(inspectRes);
    }
    export async function get<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.get(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getEntryByIdx<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new Transaction();
      builder.getEntryByIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function getEntryByIdxMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new Transaction();
      builder.getEntryByIdxMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function getIdx<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getIdxOpt<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.getIdxOpt(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function getMut<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.getMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function insert<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, T0, T1],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoKeysValues<T0 = any, T1 = any>(
      client: IotaClient,
      args: [vec_map.VecMap<T0, T1>],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0[], T1[]]>> {
      const tx = new Transaction();
      builder.intoKeysValues(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[], T1[]]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function keys<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.keys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
    export async function pop<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new Transaction();
      builder.pop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function removeEntryByIdx<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new Transaction();
      builder.removeEntryByIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function size<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.size(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function tryGet<T0 = any, T1 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>> {
      const tx = new Transaction();
      builder.tryGet(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T1>]
      >(inspectRes);
    }
  }
}

export class vec_set extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("vec_set", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x2",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): vec_set {
    return new vec_set({ ...vec_set.DEFAULT_OPTIONS, ...options });
  }

  onEventVecSet(
    func: (event: vec_set.VecSetInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, vec_set.VecSetInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): vec_set {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "vec_set::VecSet" },
      handlerOptions,
    );
    return this;
  }
}

export namespace vec_set {
  export interface VecSet<T0> {
    contents: T0[];
  }

  export namespace VecSet {
    export const TYPE_QNAME = "0x2::vec_set::VecSet";

    const TYPE = new TypeDescriptor<VecSet<any>>(VecSet.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<VecSet<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export type VecSetInstance = TypedEventInstance<VecSet<any>> & {
    data_decoded: VecSet<any>;
    type_arguments: [string];
  };

  export namespace builder {
    export function contains<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromKeys<T0 = any>(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::from_keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoKeys<T0 = any>(
      tx: Transaction,
      args: [vec_set.VecSet<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::into_keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keys<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function size<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::size",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function contains<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new Transaction();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function fromKeys<T0 = any>(
      client: IotaClient,
      args: [string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new Transaction();
      builder.fromKeys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoKeys<T0 = any>(
      client: IotaClient,
      args: [vec_set.VecSet<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.intoKeys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function keys<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.keys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new Transaction();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function size<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.size(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace versioned {
  export interface VersionChangeCap {
    versioned_id: object$.ID;
    old_version: bigint;
  }

  export namespace VersionChangeCap {
    export const TYPE_QNAME = "0x2::versioned::VersionChangeCap";

    const TYPE = new TypeDescriptor<VersionChangeCap>(
      VersionChangeCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<VersionChangeCap> {
      return TYPE.apply();
    }
  }

  export interface Versioned {
    id: object$.UID;
    version: bigint;
  }

  export namespace Versioned {
    export const TYPE_QNAME = "0x2::versioned::Versioned";

    const TYPE = new TypeDescriptor<Versioned>(Versioned.TYPE_QNAME);

    export function type(): TypeDescriptor<Versioned> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function create<T0 = any>(
      tx: Transaction,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::create",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroy<T0 = any>(
      tx: Transaction,
      args: [versioned.Versioned | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::destroy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function loadValue<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::load_value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function loadValueMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::load_value_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeValueForUpgrade<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::remove_value_for_upgrade",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function upgrade<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
        versioned.VersionChangeCap | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::upgrade",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function version(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::version",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function create<T0 = any>(
      client: IotaClient,
      args: [bigint, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[versioned.Versioned]>> {
      const tx = new Transaction();
      builder.create(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [versioned.Versioned]
      >(inspectRes);
    }
    export async function destroy<T0 = any>(
      client: IotaClient,
      args: [versioned.Versioned],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.destroy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function loadValue<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.loadValue(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function loadValueMut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.loadValueMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function removeValueForUpgrade<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, versioned.VersionChangeCap]>> {
      const tx = new Transaction();
      builder.removeValueForUpgrade(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, versioned.VersionChangeCap]
      >(inspectRes);
    }
    export async function upgrade<T0 = any>(
      client: IotaClient,
      args: [string, bigint, T0, versioned.VersionChangeCap],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.upgrade(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function version(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.version(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace zklogin_verified_id {
  export interface VerifiedID {
    id: object$.UID;
    owner: string;
    key_claim_name: string;
    key_claim_value: string;
    issuer: string;
    audience: string;
  }

  export namespace VerifiedID {
    export const TYPE_QNAME = "0x2::zklogin_verified_id::VerifiedID";

    const TYPE = new TypeDescriptor<VerifiedID>(VerifiedID.TYPE_QNAME);

    export function type(): TypeDescriptor<VerifiedID> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function audience(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::audience",
        arguments: _args,
      });
    }
    export function checkZkloginId(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));
      _args.push(transactionArgumentOrObject(args[4], tx));
      _args.push(transactionArgumentOrPureU256(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::check_zklogin_id",
        arguments: _args,
      });
    }
    export function delete$(
      tx: Transaction,
      args: [zklogin_verified_id.VerifiedID | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::delete",
        arguments: _args,
      });
    }
    export function issuer(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::issuer",
        arguments: _args,
      });
    }
    export function keyClaimName(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::key_claim_name",
        arguments: _args,
      });
    }
    export function keyClaimValue(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::key_claim_value",
        arguments: _args,
      });
    }
    export function owner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::owner",
        arguments: _args,
      });
    }
    export function verifyZkloginId(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPureU256(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::verify_zklogin_id",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function audience(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.audience(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function checkZkloginId(
      client: IotaClient,
      args: [string, string, string, string, string, bigint],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.checkZkloginId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function delete$(
      client: IotaClient,
      args: [zklogin_verified_id.VerifiedID],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.delete$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function issuer(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.issuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function keyClaimName(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.keyClaimName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function keyClaimValue(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.keyClaimValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function owner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function verifyZkloginId(
      client: IotaClient,
      args: [string, string, string, string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.verifyZkloginId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace zklogin_verified_issuer {
  export interface VerifiedIssuer {
    id: object$.UID;
    owner: string;
    issuer: string;
  }

  export namespace VerifiedIssuer {
    export const TYPE_QNAME = "0x2::zklogin_verified_issuer::VerifiedIssuer";

    const TYPE = new TypeDescriptor<VerifiedIssuer>(VerifiedIssuer.TYPE_QNAME);

    export function type(): TypeDescriptor<VerifiedIssuer> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function checkZkloginIssuer(
      tx: Transaction,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureAddress(args[0], tx));
      _args.push(transactionArgumentOrPureU256(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::check_zklogin_issuer",
        arguments: _args,
      });
    }
    export function delete$(
      tx: Transaction,
      args: [zklogin_verified_issuer.VerifiedIssuer | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::delete",
        arguments: _args,
      });
    }
    export function issuer(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::issuer",
        arguments: _args,
      });
    }
    export function owner(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::owner",
        arguments: _args,
      });
    }
    export function verifyZkloginIssuer(
      tx: Transaction,
      args: [bigint | TransactionArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::verify_zklogin_issuer",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function checkZkloginIssuer(
      client: IotaClient,
      args: [string, bigint, string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.checkZkloginIssuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function delete$(
      client: IotaClient,
      args: [zklogin_verified_issuer.VerifiedIssuer],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.delete$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function issuer(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.issuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function owner(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function verifyZkloginIssuer(
      client: IotaClient,
      args: [bigint, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.verifyZkloginIssuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"address":{"fileFormatVersion":6,"address":"0x2","name":"address","friends":[],"structs":{},"exposedFunctions":{"from_ascii_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":["Address"]},"from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":["Address"]},"from_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":["Address"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U256"]},"to_ascii_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Vector":"U8"}]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"to_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":["U256"]}}},"authenticator_state":{"fileFormatVersion":6,"address":"0x2","name":"authenticator_state","friends":[],"structs":{"ActiveJwk":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"jwk_id","type":{"Struct":{"address":"0x2","module":"authenticator_state","name":"JwkId","typeArguments":[]}}},{"name":"jwk","type":{"Struct":{"address":"0x2","module":"authenticator_state","name":"JWK","typeArguments":[]}}},{"name":"epoch","type":"U64"}]},"AuthenticatorState":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"version","type":"U64"}]},"AuthenticatorStateInner":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"version","type":"U64"},{"name":"active_jwks","type":{"Vector":{"Struct":{"address":"0x2","module":"authenticator_state","name":"ActiveJwk","typeArguments":[]}}}}]},"JWK":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"kty","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"e","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"n","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"alg","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"JwkId":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"iss","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"kid","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{}},"bag":{"fileFormatVersion":6,"address":"0x2","name":"bag","friends":[],"structs":{"Bag":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"contains_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"balance":{"fileFormatVersion":6,"address":"0x2","name":"balance","friends":[],"structs":{"Balance":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"value","type":"U64"}]},"Supply":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"value","type":"U64"}]}},"exposedFunctions":{"create_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}]},"decrease_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"destroy_supply":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"increase_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"join":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"supply_value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"withdraw_all":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},"bcs":{"fileFormatVersion":6,"address":"0x2","name":"bcs","friends":[],"structs":{"BCS":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"into_remainder_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}]},"peel_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["Address"]},"peel_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["Bool"]},"peel_enum_tag":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U32"]},"peel_option_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"peel_option_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Bool"]}}]},"peel_option_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U128"]}}]},"peel_option_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U16"]}}]},"peel_option_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U256"]}}]},"peel_option_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U32"]}}]},"peel_option_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"peel_option_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]},"peel_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U128"]},"peel_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U16"]},"peel_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U256"]},"peel_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U32"]},"peel_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U64"]},"peel_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U8"]},"peel_vec_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"peel_vec_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"Bool"}]},"peel_vec_length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U64"]},"peel_vec_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U128"}]},"peel_vec_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U16"}]},"peel_vec_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U256"}]},"peel_vec_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U32"}]},"peel_vec_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U64"}]},"peel_vec_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"peel_vec_vec_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":{"Vector":"U8"}}]},"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]}}},"bls12381":{"fileFormatVersion":6,"address":"0x2","name":"bls12381","friends":[],"structs":{"G1":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"G2":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"GT":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"Scalar":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"UncompressedG1":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"bls12381_min_pk_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]},"bls12381_min_sig_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]},"g1_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_multi_scalar_multiplication":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_to_uncompressed_g1":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"UncompressedG1","typeArguments":[]}}]}}]},"g2_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_multi_scalar_multiplication":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"gt_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"hash_to_g1":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"hash_to_g2":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"pairing":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"scalar_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_from_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_inv":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_one":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_zero":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"uncompressed_g1_sum":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"UncompressedG1","typeArguments":[]}}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"UncompressedG1","typeArguments":[]}}]}}]},"uncompressed_g1_to_g1":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"UncompressedG1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]}}},"borrow":{"fileFormatVersion":6,"address":"0x2","name":"borrow","friends":[],"structs":{"Borrow":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"ref","type":"Address"},{"name":"obj","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Referent":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":false}],"fields":[{"name":"id","type":"Address"},{"name":"value","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"borrow","name":"Borrow","typeArguments":[]}}]},"destroy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}]},"put_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0},{"Struct":{"address":"0x2","module":"borrow","name":"Borrow","typeArguments":[]}}],"return":[]}}},"clock":{"fileFormatVersion":6,"address":"0x2","name":"clock","friends":[],"structs":{"Clock":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"timestamp_ms","type":"U64"}]}},"exposedFunctions":{"timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":["U64"]}}},"coin":{"fileFormatVersion":6,"address":"0x2","name":"coin","friends":[],"structs":{"Coin":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"CoinMetadata":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"decimals","type":"U8"},{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"symbol","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"name":"description","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"icon_url","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}}]},"DenyCapV1":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"allow_global_pause","type":"Bool"}]},"RegulatedCoinMetadata":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"coin_metadata_object","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"deny_cap_object","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TreasuryCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"total_supply","type":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]}},"exposedFunctions":{"balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"balance_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"burn":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"create_currency":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},"U8",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}]},"create_regulated_currency_v1":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},"U8",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}},"Bool",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"DenyCapV1","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}]},"deny_list_v1_add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCapV1","typeArguments":[{"TypeParameter":0}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deny_list_v1_contains_current_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"Address",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"deny_list_v1_contains_next_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"Address"],"return":["Bool"]},"deny_list_v1_disable_global_pause":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCapV1","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deny_list_v1_enable_global_pause":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCapV1","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deny_list_v1_is_global_pause_enabled_current_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"deny_list_v1_is_global_pause_enabled_next_epoch":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}}],"return":["Bool"]},"deny_list_v1_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCapV1","typeArguments":[{"TypeParameter":0}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"divide_into_n":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}]},"from_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"get_decimals":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":["U8"]},"get_description":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"get_icon_url":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}]},"get_name":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"get_symbol":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"into_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"join":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"mint_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64","Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"mint_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"put":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"supply_immut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"supply_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"take":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"total_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"treasury_into_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}]},"update_description":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_icon_url":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"update_name":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_symbol":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]}}},"coin_manager":{"fileFormatVersion":6,"address":"0x2","name":"coin_manager","friends":[],"structs":{"CoinManaged":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"coin_name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"CoinManager":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"treasury_cap","type":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"name":"metadata","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}]}}},{"name":"immutable_metadata","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"coin_manager","name":"ImmutableCoinMetadata","typeArguments":[{"TypeParameter":0}]}}]}}},{"name":"maximum_supply","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}},{"name":"supply_immutable","type":"Bool"},{"name":"metadata_immutable","type":"Bool"}]},"CoinManagerMetadataCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"CoinManagerTreasuryCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"ImmutableCoinMetadata":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"decimals","type":"U8"},{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"symbol","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"name":"description","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"icon_url","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}}]},"MetadataOwnershipRenounced":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"coin_name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"TreasuryOwnershipRenounced":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[],"fields":[{"name":"coin_name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"add_additional_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":1}],"return":[]},"additional_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":1}}]},"available_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"burn":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"create":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},"U8",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}]},"decimals":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["U8"]},"description":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"enforce_maximum_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[]},"get_additional_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":1}}]},"has_maximum_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"icon_url":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}]},"immutable_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"ImmutableCoinMetadata","typeArguments":[{"TypeParameter":0}]}}}]},"maximum_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}]},"metadata_is_immutable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"mint_and_transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},"U64","Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"mint_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"name":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}]},"new_with_immutable_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}]},"renounce_metadata_ownership":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"renounce_treasury_ownership":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerTreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"replace_additional_metadata":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":1}],"return":[{"TypeParameter":2}]},"supply_immut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"supply_is_immutable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"symbol":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"total_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"update_description":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_icon_url":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"update_name":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_symbol":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManagerMetadataCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin_manager","name":"CoinManager","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]}}},"config":{"fileFormatVersion":6,"address":"0x2","name":"config","friends":[{"address":"0x2","name":"deny_list"}],"structs":{"Config":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"Setting":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false}],"fields":[{"name":"data","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"config","name":"SettingData","typeArguments":[{"TypeParameter":0}]}}]}}}]},"SettingData":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false}],"fields":[{"name":"newer_value_epoch","type":"U64"},{"name":"newer_value","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"older_value_opt","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]}},"exposedFunctions":{"add_for_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"TypeParameter":0}},{"TypeParameter":1},{"TypeParameter":2},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":2}]}}]},"borrow_for_next_epoch_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"TypeParameter":0}},{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"MutableReference":{"TypeParameter":2}}]},"exists_with_type":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":1}],"return":["Bool"]},"exists_with_type_for_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"TypeParameter":0}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}]},"read_setting":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"TypeParameter":0},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":1}]}}]},"read_setting_for_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":1}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":2}]}}]},"remove_for_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Copy","Drop","Store"]},{"abilities":["Copy","Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"TypeParameter":0}},{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":2}]}}]},"share":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"transfer":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"config","name":"Config","typeArguments":[{"TypeParameter":0}]}},"Address"],"return":[]}}},"deny_list":{"fileFormatVersion":6,"address":"0x2","name":"deny_list","friends":[{"address":"0x2","name":"coin"}],"structs":{"AddressKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"pos0","type":"Address"}]},"ConfigKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"per_type_index","type":"U64"},{"name":"per_type_key","type":{"Vector":"U8"}}]},"ConfigWriteCap":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"DenyList":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"lists","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"GlobalPauseKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"PerTypeConfigCreated":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"key","type":{"Struct":{"address":"0x2","module":"deny_list","name":"ConfigKey","typeArguments":[]}}},{"name":"config_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]}},"exposedFunctions":{"add":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"contains_current_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"contains_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address"],"return":["Bool"]},"disable_global_pause":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"enable_global_pause":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"is_global_pause_enabled_current_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"is_global_pause_enabled_next_epoch":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"}],"return":["Bool"]},"remove":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}},"display":{"fileFormatVersion":6,"address":"0x2","name":"display","friends":[],"structs":{"Display":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"fields","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},{"name":"version","type":"U16"}]},"DisplayCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"VersionUpdated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U16"},{"name":"fields","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"add_multiple":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[]},"create_and_keep":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"edit":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"fields":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]},"is_authorized":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}]},"new_with_fields":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}]},"remove":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_version":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":["U16"]}}},"dynamic_field":{"fileFormatVersion":6,"address":"0x2","name":"dynamic_field","friends":[{"address":"0x2","name":"config"},{"address":"0x2","name":"dynamic_object_field"}],"structs":{"Field":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"name","type":{"TypeParameter":0}},{"name":"value","type":{"TypeParameter":1}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"add_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address",{"TypeParameter":0}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_child_object_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"exists_":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"exists_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"field_info":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"]},"field_info_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"]},"has_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address","Address"],"return":["Bool"]},"has_child_object_with_ty":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address","Address"],"return":["Bool"]},"hash_type_and_key":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":["Address",{"TypeParameter":0}],"return":["Address"]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"remove_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address","Address"],"return":[{"TypeParameter":0}]},"remove_if_exists":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":1}]}}]}}},"dynamic_object_field":{"fileFormatVersion":6,"address":"0x2","name":"dynamic_object_field","friends":[{"address":"0x2","name":"deny_list"}],"structs":{"Wrapper":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"name","type":{"TypeParameter":0}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"exists_":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"exists_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]},"internal_add":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"internal_borrow":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"internal_borrow_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"internal_exists_with_type":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"internal_remove":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"ecdsa_k1":{"fileFormatVersion":6,"address":"0x2","name":"ecdsa_k1","friends":[],"structs":{},"exposedFunctions":{"decompress_pubkey":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"secp256k1_ecrecover":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":[{"Vector":"U8"}]},"secp256k1_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":["Bool"]}}},"ecdsa_r1":{"fileFormatVersion":6,"address":"0x2","name":"ecdsa_r1","friends":[],"structs":{},"exposedFunctions":{"secp256r1_ecrecover":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":[{"Vector":"U8"}]},"secp256r1_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":["Bool"]}}},"ecvrf":{"fileFormatVersion":6,"address":"0x2","name":"ecvrf","friends":[],"structs":{},"exposedFunctions":{"ecvrf_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]}}},"ed25519":{"fileFormatVersion":6,"address":"0x2","name":"ed25519","friends":[],"structs":{},"exposedFunctions":{"ed25519_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]}}},"event":{"fileFormatVersion":6,"address":"0x2","name":"event","friends":[],"structs":{},"exposedFunctions":{"emit":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"TypeParameter":0}],"return":[]}}},"groth16":{"fileFormatVersion":6,"address":"0x2","name":"groth16","friends":[],"structs":{"Curve":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":"U8"}]},"PreparedVerifyingKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"vk_gamma_abc_g1_bytes","type":{"Vector":"U8"}},{"name":"alpha_g1_beta_g2_bytes","type":{"Vector":"U8"}},{"name":"gamma_g2_neg_pc_bytes","type":{"Vector":"U8"}},{"name":"delta_g2_neg_pc_bytes","type":{"Vector":"U8"}}]},"ProofPoints":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]},"PublicProofInputs":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"bls12381":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}]},"bn254":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}]},"prepare_verifying_key":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}},{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}]},"proof_points_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"ProofPoints","typeArguments":[]}}]},"public_proof_inputs_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PublicProofInputs","typeArguments":[]}}]},"pvk_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}]},"pvk_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}],"return":[{"Vector":{"Vector":"U8"}}]},"verify_groth16_proof":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"PublicProofInputs","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"ProofPoints","typeArguments":[]}}}],"return":["Bool"]}}},"group_ops":{"fileFormatVersion":6,"address":"0x2","name":"group_ops","friends":[{"address":"0x2","name":"bls12381"}],"structs":{"Element":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"add":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"convert":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8","U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"div":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"equal":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"from_bytes":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":"U8"}},"Bool"],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"hash_to":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"mul":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"multi_scalar_multiplication":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"pairing":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":2}]}}]},"set_as_prefix":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","Bool",{"MutableReference":{"Vector":"U8"}}],"return":[]},"sub":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"sum":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]}}},"hash":{"fileFormatVersion":6,"address":"0x2","name":"hash","friends":[],"structs":{},"exposedFunctions":{"blake2b256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"keccak256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]}}},"hex":{"fileFormatVersion":6,"address":"0x2","name":"hex","friends":[],"structs":{},"exposedFunctions":{"decode":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]},"encode":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]}}},"hmac":{"fileFormatVersion":6,"address":"0x2","name":"hmac","friends":[],"structs":{},"exposedFunctions":{"hmac_sha3_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]}}},"iota":{"fileFormatVersion":6,"address":"0x2","name":"iota","friends":[],"structs":{"IOTA":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"IotaTreasuryCap":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"inner","type":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}}]}},"exposedFunctions":{"burn":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"burn_balance":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"mint_balance":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"total_supply":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"iota","name":"IotaTreasuryCap","typeArguments":[]}}}],"return":["U64"]},"transfer":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}},"Address"],"return":[]}}},"kiosk":{"fileFormatVersion":6,"address":"0x2","name":"kiosk","friends":[{"address":"0x2","name":"kiosk_extension"}],"structs":{"Borrow":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"kiosk_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"item_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Item":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ItemDelisted":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ItemListed":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"price","type":"U64"}]},"ItemPurchased":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"price","type":"U64"}]},"Kiosk":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"profits","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"owner","type":"Address"},{"name":"item_count","type":"U32"}]},"KioskOwnerCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"for","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Listing":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"is_exclusive","type":"Bool"}]},"Lock":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"PurchaseCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"kiosk_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"item_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"min_price","type":"U64"}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_val":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"kiosk","name":"Borrow","typeArguments":[]}}]},"close_and_withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}},{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"default":{"visibility":"Private","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"delist":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[]},"has_access":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":["Bool"]},"has_item":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"has_item_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_listed":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_listed_exclusively":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_locked":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"item_count":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["U32"]},"kiosk_owner_cap_for":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"list":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64"],"return":[]},"list_with_purchase_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}]},"lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"lock_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}},{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Address"]},"place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"place_and_list":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"TypeParameter":0},"U64"],"return":[]},"place_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"profits_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["U64"]},"profits_mut":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}}]},"purchase":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"purchase_cap_item":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"purchase_cap_kiosk":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"purchase_cap_min_price":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"purchase_with_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"return_purchase_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"return_val":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0},{"Struct":{"address":"0x2","module":"kiosk","name":"Borrow","typeArguments":[]}}],"return":[]},"set_owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"set_owner_custom":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},"Address"],"return":[]},"take":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"TypeParameter":0}]},"uid":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_as_owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}}},"kiosk_extension":{"fileFormatVersion":6,"address":"0x2","name":"kiosk_extension","friends":[],"structs":{"Extension":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"storage","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"name":"permissions","type":"U128"},{"name":"is_enabled","type":"Bool"}]},"ExtensionKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},"U128",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"can_lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"can_place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"disable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"enable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"is_enabled":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"is_installed":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]},{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":1}]}}}],"return":[]},"place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]},{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":1}]}}}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"storage":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"storage_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}}},"labeler":{"fileFormatVersion":6,"address":"0x2","name":"labeler","friends":[],"structs":{"LabelerCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]}},"exposedFunctions":{"create_labeler_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"labeler","name":"LabelerCap","typeArguments":[{"TypeParameter":0}]}}]},"destroy_labeler_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"labeler","name":"LabelerCap","typeArguments":[{"TypeParameter":0}]}}],"return":[]}}},"linked_table":{"fileFormatVersion":6,"address":"0x2","name":"linked_table","friends":[],"structs":{"LinkedTable":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"},{"name":"head","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"tail","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"Node":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"prev","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"next","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"value","type":{"TypeParameter":1}}]}},"exposedFunctions":{"back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"next":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"pop_front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"prev":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"push_front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"object":{"fileFormatVersion":6,"address":"0x2","name":"object","friends":[{"address":"0x2","name":"authenticator_state"},{"address":"0x2","name":"clock"},{"address":"0x2","name":"deny_list"},{"address":"0x2","name":"dynamic_field"},{"address":"0x2","name":"random"}],"structs":{"ID":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":"Address"}]},"UID":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]}},"exposedFunctions":{"authenticator_state":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"borrow_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"clock":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}],"return":[]},"id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_address":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":["Address"]},"id_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]},"id_from_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_to_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":["Address"]},"id_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"iota_deny_list_object_id":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"new_uid_from_hash":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"randomness_state":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"uid_as_inner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"uid_to_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":["Address"]},"uid_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"uid_to_inner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}},"object_bag":{"fileFormatVersion":6,"address":"0x2","name":"object_bag","friends":[],"structs":{"ObjectBag":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"contains_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"value_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]}}},"object_table":{"fileFormatVersion":6,"address":"0x2","name":"object_table","friends":[],"structs":{"ObjectTable":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":true},{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"value_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]}}},"package":{"fileFormatVersion":6,"address":"0x2","name":"package","friends":[],"structs":{"Publisher":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"name":"module_name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"UpgradeCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U64"},{"name":"policy","type":"U8"}]},"UpgradeReceipt":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"cap","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"UpgradeTicket":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"cap","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"policy","type":"U8"},{"name":"digest","type":{"Vector":"U8"}}]}},"exposedFunctions":{"additive_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"authorize_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}},"U8",{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}]},"burn_publisher":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}],"return":[]},"claim":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}]},"claim_and_keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"commit_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}],"return":[]},"compatible_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"dep_only_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"from_module":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"from_package":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"make_immutable":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}],"return":[]},"only_additive_upgrades":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[]},"only_dep_upgrades":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[]},"published_module":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"published_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"receipt_cap":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"receipt_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"ticket_digest":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"ticket_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"ticket_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":["U8"]},"upgrade_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"upgrade_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":["U8"]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":["U64"]}}},"pay":{"fileFormatVersion":6,"address":"0x2","name":"pay","friends":[],"structs":{},"exposedFunctions":{"divide_and_keep":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"join_vec":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"join_vec_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"Address"],"return":[]},"keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split_vec":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":"U64"},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}},"poseidon":{"fileFormatVersion":6,"address":"0x2","name":"poseidon","friends":[],"structs":{},"exposedFunctions":{"poseidon_bn254":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U256"}}],"return":["U256"]}}},"priority_queue":{"fileFormatVersion":6,"address":"0x2","name":"priority_queue","friends":[],"structs":{"Entry":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":false}],"fields":[{"name":"priority","type":"U64"},{"name":"value","type":{"TypeParameter":0}}]},"PriorityQueue":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":false}],"fields":[{"name":"entries","type":{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}}]}},"exposedFunctions":{"create_entries":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Vector":"U64"},{"Vector":{"TypeParameter":0}}],"return":[{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}},"U64",{"TypeParameter":0}],"return":[]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}]},"new_entry":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":["U64",{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}]},"pop_max":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64",{"TypeParameter":0}]},"priorities":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Vector":"U64"}]}}},"prover":{"fileFormatVersion":6,"address":"0x2","name":"prover","friends":[],"structs":{},"exposedFunctions":{}},"random":{"fileFormatVersion":6,"address":"0x2","name":"random","friends":[],"structs":{"Random":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"inner","type":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}]},"RandomGenerator":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"seed","type":{"Vector":"U8"}},{"name":"counter","type":"U16"},{"name":"buffer","type":{"Vector":"U8"}}]},"RandomInner":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"version","type":"U64"},{"name":"epoch","type":"U64"},{"name":"randomness_round","type":"U64"},{"name":"random_bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"generate_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["Bool"]},"generate_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U16"],"return":[{"Vector":"U8"}]},"generate_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U128"]},"generate_u128_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U128","U128"],"return":["U128"]},"generate_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U16"]},"generate_u16_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U16","U16"],"return":["U16"]},"generate_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U256"]},"generate_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U32"]},"generate_u32_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U32","U32"],"return":["U32"]},"generate_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U64"]},"generate_u64_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U64","U64"],"return":["U64"]},"generate_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U8"]},"generate_u8_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U8","U8"],"return":["U8"]},"new_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"random","name":"Random","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}]},"shuffle":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[]}}},"system_admin_cap":{"fileFormatVersion":6,"address":"0x2","name":"system_admin_cap","friends":[],"structs":{"IotaSystemAdminCap":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{}},"table":{"fileFormatVersion":6,"address":"0x2","name":"table","friends":[],"structs":{"Table":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":true},{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"table_vec":{"fileFormatVersion":6,"address":"0x2","name":"table_vec","friends":[],"structs":{"TableVec":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"contents","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"TypeParameter":0}]}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64","U64"],"return":[]},"swap_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"TypeParameter":0}]}}},"timelock":{"fileFormatVersion":6,"address":"0x2","name":"timelock","friends":[],"structs":{"TimeLock":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"locked","type":{"TypeParameter":0}},{"name":"expiration_timestamp_ms","type":"U64"},{"name":"label","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]}},"exposedFunctions":{"expiration_timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"is_labeled_with":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_locked":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Bool"]},"is_locked_with_clock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":["Bool"]},"join":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}],"return":[]},"join_vec":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},{"Vector":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}}],"return":[]},"label":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"TypeParameter":0},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}]},"lock_and_transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"TypeParameter":0},"Address","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"lock_with_label":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"labeler","name":"LabelerCap","typeArguments":[{"TypeParameter":1}]}}},{"TypeParameter":0},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}]},"lock_with_label_and_transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"labeler","name":"LabelerCap","typeArguments":[{"TypeParameter":1}]}}},{"TypeParameter":0},"Address","U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"locked":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"remaining_time":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"remaining_time_with_clock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":["U64"]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}]},"split_balance":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"system_pack":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}},{"TypeParameter":0},"U64",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}]},"system_unpack":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"system_admin_cap","name":"IotaSystemAdminCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0},"U64",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"transfer_to_sender":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"type_name":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"unlock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"TypeParameter":0}]},"unlock_with_clock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"timelock","name":"TimeLock","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"TypeParameter":0}]}}},"token":{"fileFormatVersion":6,"address":"0x2","name":"token","friends":[],"structs":{"ActionRequest":{"abilities":{"abilities":[]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"amount","type":"U64"},{"name":"sender","type":"Address"},{"name":"recipient","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}},{"name":"spent_balance","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},{"name":"approvals","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"RuleKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"is_protected","type":"Bool"}]},"Token":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"TokenPolicy":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"spent_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"rules","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]}}}]},"TokenPolicyCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"for","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TokenPolicyCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"is_mutable","type":"Bool"}]}},"exposedFunctions":{"action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"add_approval":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"add_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":2},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"add_rule_for_action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"allow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"amount":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"approvals":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]},"burn":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"confirm_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_request_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_with_policy_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_with_treasury_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"disallow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"flush":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"from_coin":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"from_coin_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"has_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"has_rule_config_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_allowed":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"join":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]},"new_policy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}]},"new_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"recipient":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"remove_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"TypeParameter":2}]},"remove_rule_for_action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":2}}]},"rule_config_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"TypeParameter":2}}]},"rules":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]},"sender":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["Address"]},"share_policy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"spend":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"spend_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"spent":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"spent_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]},"to_coin":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"to_coin_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"transfer_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]}}},"transfer":{"fileFormatVersion":6,"address":"0x2","name":"transfer","friends":[],"structs":{"Receiving":{"abilities":{"abilities":["Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U64"}]}},"exposedFunctions":{"freeze_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"freeze_object_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_freeze_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_receive":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"public_share_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]},"receive":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"receiving_object_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"share_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"share_object_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]},"transfer_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]}}},"transfer_policy":{"fileFormatVersion":6,"address":"0x2","name":"transfer_policy","friends":[],"structs":{"RuleKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":true}],"fields":[{"name":"dummy_field","type":"Bool"}]},"TransferPolicy":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}},{"name":"rules","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"TransferPolicyCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"policy_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferPolicyCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferPolicyDestroyed":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferRequest":{"abilities":{"abilities":[]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"item","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"paid","type":"U64"},{"name":"from","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"receipts","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]}},"exposedFunctions":{"add_receipt":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"add_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":2}],"return":[]},"add_to_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}],"return":[]},"confirm_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"default":{"visibility":"Private","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"destroy_and_withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]},"from":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"get_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":2}}]},"has_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"item":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}]},"new_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"paid":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"remove_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"rules":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"uid":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_as_owner":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"iota","name":"IOTA","typeArguments":[]}}]}}]}}},"tx_context":{"fileFormatVersion":6,"address":"0x2","name":"tx_context","friends":[],"structs":{"TxContext":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"sender","type":"Address"},{"name":"tx_hash","type":{"Vector":"U8"}},{"name":"epoch","type":"U64"},{"name":"epoch_timestamp_ms","type":"U64"},{"name":"ids_created","type":"U64"}]}},"exposedFunctions":{"digest":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"epoch_timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"fresh_object_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Address"]},"sender":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Address"]}}},"types":{"fileFormatVersion":6,"address":"0x2","name":"types","friends":[],"structs":{},"exposedFunctions":{"is_one_time_witness":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":["Bool"]}}},"url":{"fileFormatVersion":6,"address":"0x2","name":"url","friends":[],"structs":{"Url":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"url","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"inner_url":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"new_unsafe":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]},"new_unsafe_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]},"update":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]}}},"vdf":{"fileFormatVersion":6,"address":"0x2","name":"vdf","friends":[],"structs":{},"exposedFunctions":{"hash_to_input":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"vdf_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U64"],"return":["Bool"]}}},"vec_map":{"fileFormatVersion":6,"address":"0x2","name":"vec_map","friends":[],"structs":{"Entry":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy"]},"isPhantom":false},{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"key","type":{"TypeParameter":0}},{"name":"value","type":{"TypeParameter":1}}]},"VecMap":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy"]},"isPhantom":false},{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"contents","type":{"Vector":{"Struct":{"address":"0x2","module":"vec_map","name":"Entry","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}}]}},"exposedFunctions":{"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"from_keys_values":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Vector":{"TypeParameter":0}},{"Vector":{"TypeParameter":1}}],"return":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"TypeParameter":1}}]},"get_entry_by_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}},{"Reference":{"TypeParameter":1}}]},"get_entry_by_idx_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}},{"MutableReference":{"TypeParameter":1}}]},"get_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":["U64"]},"get_idx_opt":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"get_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"MutableReference":{"TypeParameter":1}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"into_keys_values":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[{"Vector":{"TypeParameter":0}},{"Vector":{"TypeParameter":1}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Vector":{"TypeParameter":0}}]},"pop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"remove_entry_by_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"size":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"try_get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":["Copy"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":1}]}}]}}},"vec_set":{"fileFormatVersion":6,"address":"0x2","name":"vec_set","friends":[],"structs":{"VecSet":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop"]},"isPhantom":false}],"fields":[{"name":"contents","type":{"Vector":{"TypeParameter":0}}}]}},"exposedFunctions":{"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"from_keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Vector":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"into_keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Vector":{"TypeParameter":0}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Vector":{"TypeParameter":0}}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"size":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]}}},"versioned":{"fileFormatVersion":6,"address":"0x2","name":"versioned","friends":[],"structs":{"VersionChangeCap":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"versioned_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"old_version","type":"U64"}]},"Versioned":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"version","type":"U64"}]}},"exposedFunctions":{"create":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":["U64",{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}]},"destroy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}],"return":[{"TypeParameter":0}]},"load_value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"load_value_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"remove_value_for_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"versioned","name":"VersionChangeCap","typeArguments":[]}}]},"upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}},"U64",{"TypeParameter":0},{"Struct":{"address":"0x2","module":"versioned","name":"VersionChangeCap","typeArguments":[]}}],"return":[]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":["U64"]}}},"zklogin_verified_id":{"fileFormatVersion":6,"address":"0x2","name":"zklogin_verified_id","friends":[],"structs":{"VerifiedID":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"owner","type":"Address"},{"name":"key_claim_name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"key_claim_value","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"issuer","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"audience","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"audience":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"check_zklogin_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address",{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U256"],"return":["Bool"]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}],"return":[]},"issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"key_claim_name":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"key_claim_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":["Address"]},"verify_zklogin_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U256",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}},"zklogin_verified_issuer":{"fileFormatVersion":6,"address":"0x2","name":"zklogin_verified_issuer","friends":[],"structs":{"VerifiedIssuer":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"owner","type":"Address"},{"name":"issuer","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"check_zklogin_issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address","U256",{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}],"return":[]},"issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}}],"return":["Address"]},"verify_zklogin_issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256",{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  _0x1.loadAllTypes(coder);
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0x2");
  }
}

loadAllTypes(defaultMoveCoder(IotaNetwork.MAIN_NET));
loadAllTypes(defaultMoveCoder(IotaNetwork.TEST_NET));
