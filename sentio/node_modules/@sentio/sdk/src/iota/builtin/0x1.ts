/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x1, original address 0x1 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/iota";

import { defaultMoveCoder } from "@sentio/sdk/iota";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/iota";
import {
  Transaction,
  TransactionArgument,
  TransactionObjectArgument,
} from "@iota/iota-sdk/transactions";
import { IotaClient } from "@iota/iota-sdk/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrVec,
  transactionArgumentOrPure,
  transactionArgumentOrPureU8,
  transactionArgumentOrPureU16,
  transactionArgumentOrPureU32,
  transactionArgumentOrPureU64,
  transactionArgumentOrPureU128,
  transactionArgumentOrPureU256,
  transactionArgumentOrPureBool,
  transactionArgumentOrPureString,
  transactionArgumentOrPureAddress,
} from "@typemove/iota";

import { CallFilter, MoveFetchConfig, EventFilter } from "@sentio/sdk/move";
import { HandlerOptions } from "@sentio/sdk";
import {
  IotaBindOptions,
  IotaBaseProcessor,
  IotaNetwork,
  TypedFunctionPayload,
  IotaContext,
} from "@sentio/sdk/iota";

export namespace address {
  export namespace builder {
    export function length(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::address::length",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function length(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace ascii {
  export type Char = string;
  export namespace Char {
    export const TYPE_QNAME = "0x1::ascii::Char";

    const TYPE = new TypeDescriptor<Char>(Char.TYPE_QNAME);

    export function type(): TypeDescriptor<Char> {
      return TYPE.apply();
    }
  }

  export type String = string;
  export namespace String {
    export const TYPE_QNAME = "0x1::ascii::String";

    const TYPE = new TypeDescriptor<String>(String.TYPE_QNAME);

    export function type(): TypeDescriptor<String> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function allCharactersPrintable(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::all_characters_printable",
        arguments: _args,
      });
    }
    export function append(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        ascii.String | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::append",
        arguments: _args,
      });
    }
    export function asBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::as_bytes",
        arguments: _args,
      });
    }
    export function byte(
      tx: Transaction,
      args: [ascii.Char | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::byte",
        arguments: _args,
      });
    }
    export function char(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::char",
        arguments: _args,
      });
    }
    export function indexOf(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::index_of",
        arguments: _args,
      });
    }
    export function insert(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        ascii.String | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::insert",
        arguments: _args,
      });
    }
    export function intoBytes(
      tx: Transaction,
      args: [ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::into_bytes",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::is_empty",
        arguments: _args,
      });
    }
    export function isPrintableChar(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::is_printable_char",
        arguments: _args,
      });
    }
    export function isValidChar(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::is_valid_char",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::length",
        arguments: _args,
      });
    }
    export function popChar(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::pop_char",
        arguments: _args,
      });
    }
    export function pushChar(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        ascii.Char | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::push_char",
        arguments: _args,
      });
    }
    export function string$(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::string",
        arguments: _args,
      });
    }
    export function substring(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::substring",
        arguments: _args,
      });
    }
    export function toLowercase(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::to_lowercase",
        arguments: _args,
      });
    }
    export function toUppercase(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::to_uppercase",
        arguments: _args,
      });
    }
    export function tryString(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::try_string",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function allCharactersPrintable(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.allCharactersPrintable(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function append(
      client: IotaClient,
      args: [string, ascii.String],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.append(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function asBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.asBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function byte(
      client: IotaClient,
      args: [ascii.Char],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.byte(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function char(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[ascii.Char]>> {
      const tx = new Transaction();
      builder.char(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[ascii.Char]>(
        inspectRes,
      );
    }
    export async function indexOf(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.indexOf(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function insert(
      client: IotaClient,
      args: [string, bigint, ascii.String],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoBytes(
      client: IotaClient,
      args: [ascii.String],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.intoBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isPrintableChar(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPrintableChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isValidChar(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isValidChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popChar(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.Char]>> {
      const tx = new Transaction();
      builder.popChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[ascii.Char]>(
        inspectRes,
      );
    }
    export async function pushChar(
      client: IotaClient,
      args: [string, ascii.Char],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.pushChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function string$(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.string$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function substring(
      client: IotaClient,
      args: [string, bigint, bigint],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.substring(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function toLowercase(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.toLowercase(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function toUppercase(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.toUppercase(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function tryString(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[option.Option<ascii.String>]>> {
      const tx = new Transaction();
      builder.tryString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<ascii.String>]
      >(inspectRes);
    }
  }
}

export namespace bcs {
  export namespace builder {
    export function toBytes<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bcs::to_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function toBytes<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.toBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export class bit_vector extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("bit_vector", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): bit_vector {
    return new bit_vector({ ...bit_vector.DEFAULT_OPTIONS, ...options });
  }

  onEventBitVector(
    func: (event: bit_vector.BitVectorInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      bit_vector.BitVectorInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): bit_vector {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "bit_vector::BitVector" },
      handlerOptions,
    );
    return this;
  }
}

export namespace bit_vector {
  export interface BitVector {
    length: bigint;
    bit_field: boolean[];
  }

  export namespace BitVector {
    export const TYPE_QNAME = "0x1::bit_vector::BitVector";

    const TYPE = new TypeDescriptor<BitVector>(BitVector.TYPE_QNAME);

    export function type(): TypeDescriptor<BitVector> {
      return TYPE.apply();
    }
  }

  export type BitVectorInstance = TypedEventInstance<BitVector> & {
    data_decoded: BitVector;
    type_arguments: [];
  };

  export namespace builder {
    export function isIndexSet(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::is_index_set",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::length",
        arguments: _args,
      });
    }
    export function longestSetSequenceStartingAt(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::longest_set_sequence_starting_at",
        arguments: _args,
      });
    }
    export function new$(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::new",
        arguments: _args,
      });
    }
    export function set(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::set",
        arguments: _args,
      });
    }
    export function shiftLeft(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::shift_left",
        arguments: _args,
      });
    }
    export function unset(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::unset",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function isIndexSet(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isIndexSet(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function longestSetSequenceStartingAt(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.longestSetSequenceStartingAt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new$(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bit_vector.BitVector]>> {
      const tx = new Transaction();
      builder.new$(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bit_vector.BitVector]
      >(inspectRes);
    }
    export async function set(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.set(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function shiftLeft(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.shiftLeft(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function unset(
      client: IotaClient,
      args: [string, bigint],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.unset(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace debug {
  export namespace builder {
    export function print<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::debug::print",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function printStackTrace(
      tx: Transaction,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::debug::print_stack_trace",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function print<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.print(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function printStackTrace(
      client: IotaClient,
      args: [],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.printStackTrace(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export class fixed_point32 extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("fixed_point32", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): fixed_point32 {
    return new fixed_point32({ ...fixed_point32.DEFAULT_OPTIONS, ...options });
  }

  onEventFixedPoint32(
    func: (event: fixed_point32.FixedPoint32Instance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      fixed_point32.FixedPoint32Instance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): fixed_point32 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "fixed_point32::FixedPoint32" },
      handlerOptions,
    );
    return this;
  }
}

export namespace fixed_point32 {
  export interface FixedPoint32 {
    value: bigint;
  }

  export namespace FixedPoint32 {
    export const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";

    const TYPE = new TypeDescriptor<FixedPoint32>(FixedPoint32.TYPE_QNAME);

    export function type(): TypeDescriptor<FixedPoint32> {
      return TYPE.apply();
    }
  }

  export type FixedPoint32Instance = TypedEventInstance<FixedPoint32> & {
    data_decoded: FixedPoint32;
    type_arguments: [];
  };

  export namespace builder {
    export function createFromRational(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::create_from_rational",
        arguments: _args,
      });
    }
    export function createFromRawValue(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::create_from_raw_value",
        arguments: _args,
      });
    }
    export function divideU64(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::divide_u64",
        arguments: _args,
      });
    }
    export function getRawValue(
      tx: Transaction,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::get_raw_value",
        arguments: _args,
      });
    }
    export function isZero(
      tx: Transaction,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::is_zero",
        arguments: _args,
      });
    }
    export function multiplyU64(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::multiply_u64",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function createFromRational(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>> {
      const tx = new Transaction();
      builder.createFromRational(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [fixed_point32.FixedPoint32]
      >(inspectRes);
    }
    export async function createFromRawValue(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>> {
      const tx = new Transaction();
      builder.createFromRawValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [fixed_point32.FixedPoint32]
      >(inspectRes);
    }
    export async function divideU64(
      client: IotaClient,
      args: [bigint, fixed_point32.FixedPoint32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.divideU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getRawValue(
      client: IotaClient,
      args: [fixed_point32.FixedPoint32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.getRawValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isZero(
      client: IotaClient,
      args: [fixed_point32.FixedPoint32],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isZero(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function multiplyU64(
      client: IotaClient,
      args: [bigint, fixed_point32.FixedPoint32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.multiplyU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace hash {
  export namespace builder {
    export function sha2256(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::hash::sha2_256",
        arguments: _args,
      });
    }
    export function sha3256(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::hash::sha3_256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function sha2256(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.sha2256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function sha3256(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.sha3256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace macros {
  export namespace builder {}
  export namespace view {}
}

export namespace option {
  export type Option<T> = T | undefined;
  export namespace Option {
    export const TYPE_QNAME = "0x1::option::Option";

    const TYPE = new TypeDescriptor<Option<any>>(Option.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Option<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowWithDefault<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyNone<T0 = any>(
      tx: Transaction,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroySome<T0 = any>(
      tx: Transaction,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyWithDefault<T0 = any>(
      tx: Transaction,
      args: [option.Option<T0> | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function extract<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::extract",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fill<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::fill",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getWithDefault<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::get_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isNone<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::is_none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isSome<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::is_some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function none<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function some<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapOrFill<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::swap_or_fill",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toVec<T0 = any>(
      tx: Transaction,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::to_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowWithDefault<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyNone<T0 = any>(
      client: IotaClient,
      args: [option.Option<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyNone(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function destroySome<T0 = any>(
      client: IotaClient,
      args: [option.Option<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.destroySome(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function destroyWithDefault<T0 = any>(
      client: IotaClient,
      args: [option.Option<T0>, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.destroyWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function extract<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.extract(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function fill<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.fill(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getWithDefault<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.getWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function isNone<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isNone(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function isSome<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isSome(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function none<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new Transaction();
      builder.none(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function some<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new Transaction();
      builder.some(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function swap<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function swapOrFill<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new Transaction();
      builder.swapOrFill(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function toVec<T0 = any>(
      client: IotaClient,
      args: [option.Option<T0>],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.toVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
  }
}

export class string$ extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("string", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): string$ {
    return new string$({ ...string$.DEFAULT_OPTIONS, ...options });
  }

  onEventString(
    func: (event: string$.StringInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, string$.StringInstance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): string$ {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "string::String" },
      handlerOptions,
    );
    return this;
  }
}

export namespace string$ {
  export interface String {
    bytes: number[];
  }

  export namespace String {
    export const TYPE_QNAME = "0x1::string::String";

    const TYPE = new TypeDescriptor<String>(String.TYPE_QNAME);

    export function type(): TypeDescriptor<String> {
      return TYPE.apply();
    }
  }

  export type StringInstance = TypedEventInstance<String> & {
    data_decoded: String;
    type_arguments: [];
  };

  export namespace builder {
    export function append(
      tx: Transaction,
      args: [string | TransactionObjectArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::append",
        arguments: _args,
      });
    }
    export function appendUtf8(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::append_utf8",
        arguments: _args,
      });
    }
    export function asBytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::as_bytes",
        arguments: _args,
      });
    }
    export function bytes(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::bytes",
        arguments: _args,
      });
    }
    export function fromAscii(
      tx: Transaction,
      args: [ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::from_ascii",
        arguments: _args,
      });
    }
    export function indexOf(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::index_of",
        arguments: _args,
      });
    }
    export function insert(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::insert",
        arguments: _args,
      });
    }
    export function intoBytes(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::into_bytes",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::length",
        arguments: _args,
      });
    }
    export function subString(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::sub_string",
        arguments: _args,
      });
    }
    export function substring(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::substring",
        arguments: _args,
      });
    }
    export function toAscii(
      tx: Transaction,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::to_ascii",
        arguments: _args,
      });
    }
    export function tryUtf8(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::try_utf8",
        arguments: _args,
      });
    }
    export function utf8(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::utf8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function append(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.append(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function appendUtf8(
      client: IotaClient,
      args: [string, string[]],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.appendUtf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function asBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.asBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function bytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.bytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromAscii(
      client: IotaClient,
      args: [ascii.String],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.fromAscii(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function indexOf(
      client: IotaClient,
      args: [string, string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.indexOf(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function insert(
      client: IotaClient,
      args: [string, bigint, string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoBytes(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new Transaction();
      builder.intoBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function subString(
      client: IotaClient,
      args: [string, bigint, bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.subString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function substring(
      client: IotaClient,
      args: [string, bigint, bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.substring(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function toAscii(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.toAscii(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function tryUtf8(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[option.Option<string>]>> {
      const tx = new Transaction();
      builder.tryUtf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<string>]
      >(inspectRes);
    }
    export async function utf8(
      client: IotaClient,
      args: [string[]],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.utf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export class type_name extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("type_name", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): type_name {
    return new type_name({ ...type_name.DEFAULT_OPTIONS, ...options });
  }

  onEventTypeName(
    func: (event: type_name.TypeNameInstance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<
      MoveFetchConfig,
      type_name.TypeNameInstance
    >,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): type_name {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "type_name::TypeName" },
      handlerOptions,
    );
    return this;
  }
}

export namespace type_name {
  export interface TypeName {
    name: ascii.String;
  }

  export namespace TypeName {
    export const TYPE_QNAME = "0x1::type_name::TypeName";

    const TYPE = new TypeDescriptor<TypeName>(TypeName.TYPE_QNAME);

    export function type(): TypeDescriptor<TypeName> {
      return TYPE.apply();
    }
  }

  export type TypeNameInstance = TypedEventInstance<TypeName> & {
    data_decoded: TypeName;
    type_arguments: [];
  };

  export namespace builder {
    export function borrowString(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::borrow_string",
        arguments: _args,
      });
    }
    export function get<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getAddress(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_address",
        arguments: _args,
      });
    }
    export function getModule(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_module",
        arguments: _args,
      });
    }
    export function getWithOriginalIds<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_with_original_ids",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoString(
      tx: Transaction,
      args: [type_name.TypeName | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::into_string",
        arguments: _args,
      });
    }
    export function isPrimitive(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::is_primitive",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function borrowString(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function get<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[type_name.TypeName]>> {
      const tx = new Transaction();
      builder.get(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [type_name.TypeName]
      >(inspectRes);
    }
    export async function getAddress(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.getAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function getModule(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.getModule(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function getWithOriginalIds<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[type_name.TypeName]>> {
      const tx = new Transaction();
      builder.getWithOriginalIds(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [type_name.TypeName]
      >(inspectRes);
    }
    export async function intoString(
      client: IotaClient,
      args: [type_name.TypeName],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new Transaction();
      builder.intoString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function isPrimitive(
      client: IotaClient,
      args: [string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isPrimitive(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace u128 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::sqrt",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::to_string",
        arguments: _args,
      });
    }
    export function tryAsU16(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::try_as_u16",
        arguments: _args,
      });
    }
    export function tryAsU32(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::try_as_u32",
        arguments: _args,
      });
    }
    export function tryAsU64(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::try_as_u64",
        arguments: _args,
      });
    }
    export function tryAsU8(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u128::try_as_u8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [bigint, number],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function tryAsU16(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU32(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU64(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.tryAsU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<bigint>]
      >(inspectRes);
    }
    export async function tryAsU8(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
  }
}

export namespace u16 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));
      _args.push(transactionArgumentOrPureU16(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::sqrt",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::to_string",
        arguments: _args,
      });
    }
    export function tryAsU8(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU16(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u16::try_as_u8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function tryAsU8(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
  }
}

export namespace u256 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPureU256(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPureU256(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPureU256(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPureU256(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::pow",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::to_string",
        arguments: _args,
      });
    }
    export function tryAsU128(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::try_as_u128",
        arguments: _args,
      });
    }
    export function tryAsU16(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::try_as_u16",
        arguments: _args,
      });
    }
    export function tryAsU32(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::try_as_u32",
        arguments: _args,
      });
    }
    export function tryAsU64(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::try_as_u64",
        arguments: _args,
      });
    }
    export function tryAsU8(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU256(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u256::try_as_u8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [bigint, number],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function tryAsU128(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.tryAsU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<bigint>]
      >(inspectRes);
    }
    export async function tryAsU16(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU32(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU64(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<bigint>]>> {
      const tx = new Transaction();
      builder.tryAsU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<bigint>]
      >(inspectRes);
    }
    export async function tryAsU8(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
  }
}

export namespace u32 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));
      _args.push(transactionArgumentOrPureU32(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));
      _args.push(transactionArgumentOrPureU32(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));
      _args.push(transactionArgumentOrPureU32(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));
      _args.push(transactionArgumentOrPureU32(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::sqrt",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::to_string",
        arguments: _args,
      });
    }
    export function tryAsU16(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::try_as_u16",
        arguments: _args,
      });
    }
    export function tryAsU8(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u32::try_as_u8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function tryAsU16(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU8(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
  }
}

export namespace u64 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::sqrt",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::to_string",
        arguments: _args,
      });
    }
    export function tryAsU16(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::try_as_u16",
        arguments: _args,
      });
    }
    export function tryAsU32(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::try_as_u32",
        arguments: _args,
      });
    }
    export function tryAsU8(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u64::try_as_u8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [bigint, number],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function tryAsU16(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU32(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
    export async function tryAsU8(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[option.Option<number>]>> {
      const tx = new Transaction();
      builder.tryAsU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<number>]
      >(inspectRes);
    }
  }
}

export namespace u8 {
  export namespace builder {
    export function bitwiseNot(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::bitwise_not",
        arguments: _args,
      });
    }
    export function diff(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::max",
        arguments: _args,
      });
    }
    export function min(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: Transaction,
      args: [number | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));
      _args.push(transactionArgumentOrPureU8(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::sqrt",
        arguments: _args,
      });
    }
    export function toString(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU8(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::u8::to_string",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bitwiseNot(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.bitwiseNot(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function diff(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function max(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function min(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function pow(
      client: IotaClient,
      args: [number, number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function toString(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export class uq32_32 extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("uq32_32", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): uq32_32 {
    return new uq32_32({ ...uq32_32.DEFAULT_OPTIONS, ...options });
  }

  onEventUQ32_32(
    func: (event: uq32_32.UQ32_32Instance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, uq32_32.UQ32_32Instance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): uq32_32 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "uq32_32::UQ32_32" },
      handlerOptions,
    );
    return this;
  }
}

export namespace uq32_32 {
  export interface UQ32_32 {
    pos0: bigint;
  }

  export namespace UQ32_32 {
    export const TYPE_QNAME = "0x1::uq32_32::UQ32_32";

    const TYPE = new TypeDescriptor<UQ32_32>(UQ32_32.TYPE_QNAME);

    export function type(): TypeDescriptor<UQ32_32> {
      return TYPE.apply();
    }
  }

  export type UQ32_32Instance = TypedEventInstance<UQ32_32> & {
    data_decoded: UQ32_32;
    type_arguments: [];
  };

  export namespace builder {
    export function add(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::add",
        arguments: _args,
      });
    }
    export function div(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::div",
        arguments: _args,
      });
    }
    export function fromInt(
      tx: Transaction,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU32(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::from_int",
        arguments: _args,
      });
    }
    export function fromQuotient(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::from_quotient",
        arguments: _args,
      });
    }
    export function fromRaw(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::from_raw",
        arguments: _args,
      });
    }
    export function ge(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::ge",
        arguments: _args,
      });
    }
    export function gt(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::gt",
        arguments: _args,
      });
    }
    export function intDiv(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::int_div",
        arguments: _args,
      });
    }
    export function intMul(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::int_mul",
        arguments: _args,
      });
    }
    export function le(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::le",
        arguments: _args,
      });
    }
    export function lt(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::lt",
        arguments: _args,
      });
    }
    export function mul(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::mul",
        arguments: _args,
      });
    }
    export function sub(
      tx: Transaction,
      args: [
        uq32_32.UQ32_32 | TransactionArgument,
        uq32_32.UQ32_32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::sub",
        arguments: _args,
      });
    }
    export function toInt(
      tx: Transaction,
      args: [uq32_32.UQ32_32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::to_int",
        arguments: _args,
      });
    }
    export function toRaw(
      tx: Transaction,
      args: [uq32_32.UQ32_32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq32_32::to_raw",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function add(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function div(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function fromInt(
      client: IotaClient,
      args: [number],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.fromInt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function fromQuotient(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.fromQuotient(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function fromRaw(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.fromRaw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function ge(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.ge(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function gt(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.gt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function intDiv(
      client: IotaClient,
      args: [bigint, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.intDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function intMul(
      client: IotaClient,
      args: [bigint, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.intMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function le(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.le(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function lt(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.lt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function mul(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function sub(
      client: IotaClient,
      args: [uq32_32.UQ32_32, uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[uq32_32.UQ32_32]>> {
      const tx = new Transaction();
      builder.sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq32_32.UQ32_32]
      >(inspectRes);
    }
    export async function toInt(
      client: IotaClient,
      args: [uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new Transaction();
      builder.toInt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function toRaw(
      client: IotaClient,
      args: [uq32_32.UQ32_32],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.toRaw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export class uq64_64 extends IotaBaseProcessor {
  constructor(options: IotaBindOptions) {
    super("uq64_64", options);
  }
  static DEFAULT_OPTIONS: IotaBindOptions = {
    address: "0x1",
    network: IotaNetwork.MAIN_NET,
  };

  static bind(options: Partial<IotaBindOptions> = {}): uq64_64 {
    return new uq64_64({ ...uq64_64.DEFAULT_OPTIONS, ...options });
  }

  onEventUQ64_64(
    func: (event: uq64_64.UQ64_64Instance, ctx: IotaContext) => void,
    handlerOptions?: HandlerOptions<MoveFetchConfig, uq64_64.UQ64_64Instance>,
    eventFilter?: Omit<EventFilter, "type" | "account">,
  ): uq64_64 {
    this.onMoveEvent(
      func,
      { ...(eventFilter ?? {}), type: "uq64_64::UQ64_64" },
      handlerOptions,
    );
    return this;
  }
}

export namespace uq64_64 {
  export interface UQ64_64 {
    pos0: bigint;
  }

  export namespace UQ64_64 {
    export const TYPE_QNAME = "0x1::uq64_64::UQ64_64";

    const TYPE = new TypeDescriptor<UQ64_64>(UQ64_64.TYPE_QNAME);

    export function type(): TypeDescriptor<UQ64_64> {
      return TYPE.apply();
    }
  }

  export type UQ64_64Instance = TypedEventInstance<UQ64_64> & {
    data_decoded: UQ64_64;
    type_arguments: [];
  };

  export namespace builder {
    export function add(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::add",
        arguments: _args,
      });
    }
    export function div(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::div",
        arguments: _args,
      });
    }
    export function fromInt(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU64(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::from_int",
        arguments: _args,
      });
    }
    export function fromQuotient(
      tx: Transaction,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPureU128(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::from_quotient",
        arguments: _args,
      });
    }
    export function fromRaw(
      tx: Transaction,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::from_raw",
        arguments: _args,
      });
    }
    export function ge(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::ge",
        arguments: _args,
      });
    }
    export function gt(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::gt",
        arguments: _args,
      });
    }
    export function intDiv(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::int_div",
        arguments: _args,
      });
    }
    export function intMul(
      tx: Transaction,
      args: [
        bigint | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPureU128(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::int_mul",
        arguments: _args,
      });
    }
    export function le(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::le",
        arguments: _args,
      });
    }
    export function lt(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::lt",
        arguments: _args,
      });
    }
    export function mul(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::mul",
        arguments: _args,
      });
    }
    export function sub(
      tx: Transaction,
      args: [
        uq64_64.UQ64_64 | TransactionArgument,
        uq64_64.UQ64_64 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::sub",
        arguments: _args,
      });
    }
    export function toInt(
      tx: Transaction,
      args: [uq64_64.UQ64_64 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::to_int",
        arguments: _args,
      });
    }
    export function toRaw(
      tx: Transaction,
      args: [uq64_64.UQ64_64 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::uq64_64::to_raw",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function add(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function div(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function fromInt(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.fromInt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function fromQuotient(
      client: IotaClient,
      args: [bigint, bigint],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.fromQuotient(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function fromRaw(
      client: IotaClient,
      args: [bigint],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.fromRaw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function ge(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.ge(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function gt(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.gt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function intDiv(
      client: IotaClient,
      args: [bigint, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.intDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function intMul(
      client: IotaClient,
      args: [bigint, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.intMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function le(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.le(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function lt(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.lt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function mul(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function sub(
      client: IotaClient,
      args: [uq64_64.UQ64_64, uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[uq64_64.UQ64_64]>> {
      const tx = new Transaction();
      builder.sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [uq64_64.UQ64_64]
      >(inspectRes);
    }
    export async function toInt(
      client: IotaClient,
      args: [uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.toInt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toRaw(
      client: IotaClient,
      args: [uq64_64.UQ64_64],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.toRaw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace vector {
  export namespace builder {
    export function append<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::append",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any>(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: Transaction,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function flatten<T0 = any>(
      tx: Transaction,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::flatten",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function indexOf<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        string | TransactionObjectArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::index_of",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function length<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function reverse<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::reverse",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: Transaction,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: Transaction,
      args: [
        string | TransactionObjectArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));
      _args.push(transactionArgumentOrPureU64(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapRemove<T0 = any>(
      tx: Transaction,
      args: [string | TransactionObjectArgument, bigint | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPureU64(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::swap_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function append<T0 = any>(
      client: IotaClient,
      args: [string, string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.append(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new Transaction();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any>(
      client: IotaClient,
      args: [string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: IotaClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
    export async function flatten<T0 = any>(
      client: IotaClient,
      args: [string[]],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.flatten(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
    export async function indexOf<T0 = any>(
      client: IotaClient,
      args: [string, string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean, bigint]>> {
      const tx = new Transaction();
      builder.indexOf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [boolean, bigint]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: IotaClient,
      args: [string, T0, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[boolean]>> {
      const tx = new Transaction();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new Transaction();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any>(
      client: IotaClient,
      args: [string, T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function reverse<T0 = any>(
      client: IotaClient,
      args: [string],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.reverse(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: IotaClient,
      args: [T0],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[]]>> {
      const tx = new Transaction();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0[]]>(
        inspectRes,
      );
    }
    export async function swap<T0 = any>(
      client: IotaClient,
      args: [string, bigint, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new Transaction();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapRemove<T0 = any>(
      client: IotaClient,
      args: [string, bigint],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new Transaction();
      builder.swapRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"address":{"fileFormatVersion":6,"address":"0x1","name":"address","friends":[],"structs":{},"exposedFunctions":{"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]}}},"ascii":{"fileFormatVersion":6,"address":"0x1","name":"ascii","friends":[],"structs":{"Char":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"byte","type":"U8"}]},"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"all_characters_printable":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["Bool"]},"append":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"as_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"byte":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":["U8"]},"char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},"U64",{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"into_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["Bool"]},"is_printable_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"is_valid_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["U64"]},"pop_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"push_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":[]},"string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"substring":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_lowercase":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_uppercase":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]}}]}}},"bcs":{"fileFormatVersion":6,"address":"0x1","name":"bcs","friends":[],"structs":{},"exposedFunctions":{"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]}}},"bit_vector":{"fileFormatVersion":6,"address":"0x1","name":"bit_vector","friends":[],"structs":{"BitVector":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"length","type":"U64"},{"name":"bit_field","type":{"Vector":"Bool"}}]}},"exposedFunctions":{"is_index_set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}}],"return":["U64"]},"longest_set_sequence_starting_at":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}]},"set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"shift_left":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"unset":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]}}},"debug":{"fileFormatVersion":6,"address":"0x1","name":"debug","friends":[],"structs":{},"exposedFunctions":{"print":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[]},"print_stack_trace":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[]}}},"fixed_point32":{"fileFormatVersion":6,"address":"0x1","name":"fixed_point32","friends":[],"structs":{"FixedPoint32":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"value","type":"U64"}]}},"exposedFunctions":{"create_from_rational":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"create_from_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"divide_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"get_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"is_zero":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["Bool"]},"multiply_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]}}},"hash":{"fileFormatVersion":6,"address":"0x1","name":"hash","friends":[],"structs":{},"exposedFunctions":{"sha2_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]},"sha3_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]}}},"macros":{"fileFormatVersion":6,"address":"0x1","name":"macros","friends":[],"structs":{},"exposedFunctions":{}},"option":{"fileFormatVersion":6,"address":"0x1","name":"option","friends":[],"structs":{"Option":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"vec","type":{"Vector":{"TypeParameter":0}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"destroy_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"destroy_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"extract":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0}]},"fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"get_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"is_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"swap_or_fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"to_vec":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Vector":{"TypeParameter":0}}]}}},"string":{"fileFormatVersion":6,"address":"0x1","name":"string","friends":[],"structs":{"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"append_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"as_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"from_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64",{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"into_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"sub_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"substring":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"to_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},"type_name":{"fileFormatVersion":6,"address":"0x1","name":"type_name","friends":[],"structs":{"TypeName":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"borrow_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"get_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_module":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_with_original_ids":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"into_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"is_primitive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":["Bool"]}}},"u128":{"fileFormatVersion":6,"address":"0x1","name":"u128","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U128"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U8"],"return":["U128"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U128"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"try_as_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U16"]}}]},"try_as_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U32"]}}]},"try_as_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"try_as_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]}}},"u16":{"fileFormatVersion":6,"address":"0x1","name":"u16","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16"],"return":["U16"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U8"],"return":["U16"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16"],"return":["U16"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"try_as_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]}}},"u256":{"fileFormatVersion":6,"address":"0x1","name":"u256","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":["U256"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U8"],"return":["U256"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"try_as_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U128"]}}]},"try_as_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U16"]}}]},"try_as_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U32"]}}]},"try_as_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"try_as_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]}}},"u32":{"fileFormatVersion":6,"address":"0x1","name":"u32","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":["U32"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U8"],"return":["U32"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":["U32"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"try_as_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U16"]}}]},"try_as_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]}}},"u64":{"fileFormatVersion":6,"address":"0x1","name":"u64","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":["U64"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U8"],"return":["U64"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":["U64"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"try_as_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U16"]}}]},"try_as_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U32"]}}]},"try_as_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]}}},"u8":{"fileFormatVersion":6,"address":"0x1","name":"u8","friends":[],"structs":{},"exposedFunctions":{"bitwise_not":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["U8"]},"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["U8"]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},"uq32_32":{"fileFormatVersion":6,"address":"0x1","name":"uq32_32","friends":[],"structs":{"UQ32_32":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"pos0","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"from_int":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"from_quotient":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"from_raw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"ge":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["Bool"]},"gt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["Bool"]},"int_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["U64"]},"int_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["U64"]},"le":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["Bool"]},"lt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["Bool"]},"mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}]},"to_int":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["U32"]},"to_raw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq32_32","name":"UQ32_32","typeArguments":[]}}],"return":["U64"]}}},"uq64_64":{"fileFormatVersion":6,"address":"0x1","name":"uq64_64","friends":[],"structs":{"UQ64_64":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"pos0","type":"U128"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"from_int":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"from_quotient":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"from_raw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"ge":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["Bool"]},"gt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["Bool"]},"int_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128",{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["U128"]},"int_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128",{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["U128"]},"le":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["Bool"]},"lt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["Bool"]},"mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}},{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}]},"to_int":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["U64"]},"to_raw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"uq64_64","name":"UQ64_64","typeArguments":[]}}],"return":["U128"]}}},"vector":{"fileFormatVersion":6,"address":"0x1","name":"vector","friends":[],"structs":{},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"Vector":{"TypeParameter":0}}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"TypeParameter":0}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Vector":{"TypeParameter":0}}]},"flatten":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"Vector":{"TypeParameter":0}}}],"return":[{"Vector":{"TypeParameter":0}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool","U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0},"U64"],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["U64"]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[{"TypeParameter":0}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]},"reverse":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Vector":{"TypeParameter":0}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64","U64"],"return":[]},"swap_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0x1");
  }
}

loadAllTypes(defaultMoveCoder(IotaNetwork.MAIN_NET));
loadAllTypes(defaultMoveCoder(IotaNetwork.TEST_NET));
