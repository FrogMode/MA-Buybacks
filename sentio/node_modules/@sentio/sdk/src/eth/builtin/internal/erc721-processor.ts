/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, BytesLike } from "ethers";
import { HandlerOptions } from "@sentio/sdk";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
  encodeCallData,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC721__factory } from "./index.js";
import {
  ERC721,
  ApprovalEvent,
  ApprovalEventFilter,
  ApprovalForAllEvent,
  ApprovalForAllEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC721.js";

export interface ApproveCallObject {
  to: string;
  tokenId: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface BalanceOfCallObject {
  owner: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface GetApprovedCallObject {
  tokenId: bigint;
}

export type GetApprovedCallTrace = TypedCallTrace<
  [bigint],
  GetApprovedCallObject
>;

export interface IsApprovedForAllCallObject {
  owner: string;
  operator: string;
}

export type IsApprovedForAllCallTrace = TypedCallTrace<
  [string, string],
  IsApprovedForAllCallObject
>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface OwnerOfCallObject {
  tokenId: bigint;
}

export type OwnerOfCallTrace = TypedCallTrace<[bigint], OwnerOfCallObject>;

export interface SafeTransferFrom_address_address_uint256CallObject {
  from: string;
  to: string;
  tokenId: bigint;
}

export type SafeTransferFrom_address_address_uint256CallTrace = TypedCallTrace<
  [string, string, bigint],
  SafeTransferFrom_address_address_uint256CallObject
>;

export interface SafeTransferFrom_address_address_uint256_bytesCallObject {
  from: string;
  to: string;
  tokenId: bigint;
  data: string;
}

export type SafeTransferFrom_address_address_uint256_bytesCallTrace =
  TypedCallTrace<
    [string, string, bigint, string],
    SafeTransferFrom_address_address_uint256_bytesCallObject
  >;

export interface SetApprovalForAllCallObject {
  operator: string;
  _approved: boolean;
}

export type SetApprovalForAllCallTrace = TypedCallTrace<
  [string, boolean],
  SetApprovalForAllCallObject
>;

export interface SupportsInterfaceCallObject {
  interfaceId: string;
}

export type SupportsInterfaceCallTrace = TypedCallTrace<
  [string],
  SupportsInterfaceCallObject
>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TokenURICallObject {
  tokenId: bigint;
}

export type TokenURICallTrace = TypedCallTrace<[bigint], TokenURICallObject>;

export interface TransferFromCallObject {
  from: string;
  to: string;
  tokenId: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

const templateContract = ERC721__factory.connect("0x0", DummyProvider);

export class ERC721ContractView extends ContractView<ERC721> {
  constructor(contract: ERC721) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    owner: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        owner,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async getApproved(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("getApproved(uint256)")(
        tokenId,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async isApprovedForAll(
    owner: string,
    operator: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction(
        "isApprovedForAll(address,address)",
      )(owner, operator, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async ownerOf(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("ownerOf(uint256)")(
        tokenId,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction("supportsInterface(bytes4)")(
        interfaceId,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async tokenURI(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("tokenURI(uint256)")(
        tokenId,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("safeTransferFrom(address,address,uint256)")
          .staticCall(from, to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("safeTransferFrom(address,address,uint256,bytes)")
          .staticCall(from, to, tokenId, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setApprovalForAll(address,bool)")
          .staticCall(operator, _approved, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(from, to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    approve(
      to: string,
      tokenId: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "approve",
        "function approve(address,uint256)",
        [to, tokenId],
      );
    },
    totalSupply(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "totalSupply",
        "function totalSupply()",
        [],
      );
    },
    balanceOf(owner: string, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "balanceOf",
        "function balanceOf(address)",
        [owner],
      );
    },
    getApproved(
      tokenId: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "getApproved",
        "function getApproved(uint256)",
        [tokenId],
      );
    },
    isApprovedForAll(
      owner: string,
      operator: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "isApprovedForAll",
        "function isApprovedForAll(address,address)",
        [owner, operator],
      );
    },
    name(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "name", "function name()", []);
    },
    ownerOf(tokenId: BigNumberish, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "ownerOf",
        "function ownerOf(uint256)",
        [tokenId],
      );
    },
    safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "safeTransferFrom",
        "function safeTransferFrom(address,address,uint256)",
        [from, to, tokenId],
      );
    },
    safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "safeTransferFrom",
        "function safeTransferFrom(address,address,uint256,bytes)",
        [from, to, tokenId, data],
      );
    },
    setApprovalForAll(
      operator: string,
      _approved: boolean,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "setApprovalForAll",
        "function setApprovalForAll(address,bool)",
        [operator, _approved],
      );
    },
    supportsInterface(
      interfaceId: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "supportsInterface",
        "function supportsInterface(bytes4)",
        [interfaceId],
      );
    },
    symbol(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "symbol", "function symbol()", []);
    },
    tokenURI(tokenId: BigNumberish, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "tokenURI",
        "function tokenURI(uint256)",
        [tokenId],
      );
    },
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transferFrom",
        "function transferFrom(address,address,uint256)",
        [from, to, tokenId],
      );
    },
  };
}

export class ERC721BoundContractView extends BoundContractView<
  ERC721,
  ERC721ContractView
> {
  async totalSupply(overrides?: Overrides): Promise<bigint> {
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async balanceOf(owner: string, overrides?: Overrides): Promise<bigint> {
    return await this.view.balanceOf(
      owner,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async getApproved(
    tokenId: BigNumberish,
    overrides?: Overrides,
  ): Promise<string> {
    return await this.view.getApproved(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async isApprovedForAll(
    owner: string,
    operator: string,
    overrides?: Overrides,
  ): Promise<boolean> {
    return await this.view.isApprovedForAll(
      owner,
      operator,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async name(overrides?: Overrides): Promise<string> {
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async ownerOf(tokenId: BigNumberish, overrides?: Overrides): Promise<string> {
    return await this.view.ownerOf(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
  ): Promise<boolean> {
    return await this.view.supportsInterface(
      interfaceId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async tokenURI(
    tokenId: BigNumberish,
    overrides?: Overrides,
  ): Promise<string> {
    return await this.view.tokenURI(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.approve(
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.safeTransferFrom_address_address_uint256(
        from,
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.safeTransferFrom_address_address_uint256_bytes(
        from,
        to,
        tokenId,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.setApprovalForAll(
        operator,
        _approved,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.transferFrom(
        from,
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.approve(to, tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    balanceOf(owner: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.balanceOf(owner, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    getApproved(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.getApproved(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    isApprovedForAll(
      owner: string,
      operator: string,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.isApprovedForAll(owner, operator, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    name(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    ownerOf(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.ownerOf(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.safeTransferFrom_address_address_uint256(
        from,
        to,
        tokenId,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.safeTransferFrom_address_address_uint256_bytes(
        from,
        to,
        tokenId,
        data,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.setApprovalForAll(operator, _approved, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.supportsInterface(interfaceId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    tokenURI(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.tokenURI(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.transferFrom(from, to, tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
  };
}

export type ERC721Context = ContractContext<ERC721, ERC721BoundContractView>;

export class ERC721Processor extends BaseProcessor<
  ERC721,
  ERC721BoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC721Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC721Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalForAllEvent>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC721Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, ApproveCallTrace>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TotalSupplyCallTrace>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BalanceOfCallTrace>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallGetApproved(
    handler: (call: GetApprovedCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, GetApprovedCallTrace>,
    preprocessHandler?: (
      call: GetApprovedCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x081812fc",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallIsApprovedForAll(
    handler: (call: IsApprovedForAllCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, IsApprovedForAllCallTrace>,
    preprocessHandler?: (
      call: IsApprovedForAllCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xe985e9c5",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, NameCallTrace>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallOwnerOf(
    handler: (call: OwnerOfCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, OwnerOfCallTrace>,
    preprocessHandler?: (
      call: OwnerOfCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x6352211e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSafeTransferFrom_address_address_uint256(
    handler: (
      call: SafeTransferFrom_address_address_uint256CallTrace,
      ctx: ERC721Context,
    ) => void,
    handlerOptions?: HandlerOptions<
      EthFetchConfig,
      SafeTransferFrom_address_address_uint256CallTrace
    >,
    preprocessHandler?: (
      call: SafeTransferFrom_address_address_uint256CallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x42842e0e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSafeTransferFrom_address_address_uint256_bytes(
    handler: (
      call: SafeTransferFrom_address_address_uint256_bytesCallTrace,
      ctx: ERC721Context,
    ) => void,
    handlerOptions?: HandlerOptions<
      EthFetchConfig,
      SafeTransferFrom_address_address_uint256_bytesCallTrace
    >,
    preprocessHandler?: (
      call: SafeTransferFrom_address_address_uint256_bytesCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xb88d4fde",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSetApprovalForAll(
    handler: (call: SetApprovalForAllCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SetApprovalForAllCallTrace>,
    preprocessHandler?: (
      call: SetApprovalForAllCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa22cb465",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSupportsInterface(
    handler: (call: SupportsInterfaceCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SupportsInterfaceCallTrace>,
    preprocessHandler?: (
      call: SupportsInterfaceCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x01ffc9a7",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SymbolCallTrace>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTokenURI(
    handler: (call: TokenURICallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TokenURICallTrace>,
    preprocessHandler?: (
      call: TokenURICallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xc87b56dd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC721Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferFromCallTrace>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC721Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      approved?: string | null,
      tokenId?: BigNumberish | null,
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        approved,
        tokenId,
      );
    },
    ApprovalForAll(
      owner?: string | null,
      operator?: string | null,
      approved?: null,
    ): ApprovalForAllEventFilter {
      return templateContract.filters["ApprovalForAll(address,address,bool)"](
        owner,
        operator,
        approved,
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      tokenId?: BigNumberish | null,
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        tokenId,
      );
    },
  };

  protected CreateBoundContractView(): ERC721BoundContractView {
    const view = getERC721Contract(this.config.network, this.config.address);
    return new ERC721BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC721Processor {
    if (!options.name) {
      options.name = "ERC721";
    }
    let processor = getProcessor(options) as ERC721Processor;
    if (!processor) {
      processor = new ERC721Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC721ProcessorTemplate extends BaseProcessorTemplate<
  ERC721,
  ERC721BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC721";
    }
    let processor = getProcessor(options) as ERC721Processor;
    if (!processor) {
      processor = new ERC721Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC721Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC721Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalForAllEvent>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC721Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }
}

export function getERC721Contract(
  chainId: EthChainId,
  address: string,
): ERC721ContractView {
  let contract = getContractByABI(
    "ERC721",
    address,
    chainId,
  ) as ERC721ContractView;
  if (!contract) {
    const rawContract = ERC721__factory.connect(address, getProvider(chainId));
    contract = new ERC721ContractView(rawContract);
    addContractByABI("ERC721", address, chainId, contract);
  }
  return contract;
}

export function getERC721ContractOnContext(
  context: EthContext,
  address: string,
): ERC721BoundContractView {
  const view = getERC721Contract(context.getChainId(), address);
  const boundView = new ERC721BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
