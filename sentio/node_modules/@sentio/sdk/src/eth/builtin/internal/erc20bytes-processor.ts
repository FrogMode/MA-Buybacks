/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides } from "ethers";
import { HandlerOptions } from "@sentio/sdk";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
  encodeCallData,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC20Bytes__factory } from "./index.js";
import {
  ERC20Bytes,
  ApprovalEvent,
  ApprovalEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC20Bytes.js";

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface ApproveCallObject {
  spender: string;
  value: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface TransferFromCallObject {
  from: string;
  to: string;
  value: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

export interface DecimalsCallObject {}

export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;

export interface BalanceOfCallObject {
  who: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TransferCallObject {
  to: string;
  value: bigint;
}

export type TransferCallTrace = TypedCallTrace<
  [string, bigint],
  TransferCallObject
>;

export interface AllowanceCallObject {
  owner: string;
  spender: string;
}

export type AllowanceCallTrace = TypedCallTrace<
  [string, string],
  AllowanceCallObject
>;

const templateContract = ERC20Bytes__factory.connect("0x0", DummyProvider);

export class ERC20BytesContractView extends ContractView<ERC20Bytes> {
  constructor(contract: ERC20Bytes) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async decimals(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("decimals()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    who: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        who,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("allowance(address,address)")(
        owner,
        spender,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(spender, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(from, to, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transfer(address,uint256)")
          .staticCall(to, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    name(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "name", "function name()", []);
    },
    approve(
      spender: string,
      value: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "approve",
        "function approve(address,uint256)",
        [spender, value],
      );
    },
    totalSupply(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "totalSupply",
        "function totalSupply()",
        [],
      );
    },
    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transferFrom",
        "function transferFrom(address,address,uint256)",
        [from, to, value],
      );
    },
    decimals(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "decimals", "function decimals()", []);
    },
    balanceOf(who: string, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "balanceOf",
        "function balanceOf(address)",
        [who],
      );
    },
    symbol(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "symbol", "function symbol()", []);
    },
    transfer(
      to: string,
      value: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transfer",
        "function transfer(address,uint256)",
        [to, value],
      );
    },
    allowance(
      owner: string,
      spender: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "allowance",
        "function allowance(address,address)",
        [owner, spender],
      );
    },
  };
}

export class ERC20BytesBoundContractView extends BoundContractView<
  ERC20Bytes,
  ERC20BytesContractView
> {
  async name(overrides?: Overrides): Promise<string> {
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    return await this.view.decimals(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async balanceOf(who: string, overrides?: Overrides): Promise<bigint> {
    return await this.view.balanceOf(
      who,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
  ): Promise<bigint> {
    return await this.view.allowance(
      owner,
      spender,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.approve(
        spender,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.transferFrom(
        from,
        to,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.transfer(
        to,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    name(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.approve(spender, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.transferFrom(from, to, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    decimals(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.decimals({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    balanceOf(who: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.balanceOf(who, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.transfer(to, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    allowance(
      owner: string,
      spender: string,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.allowance(owner, spender, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
  };
}

export type ERC20BytesContext = ContractContext<
  ERC20Bytes,
  ERC20BytesBoundContractView
>;

export class ERC20BytesProcessor extends BaseProcessor<
  ERC20Bytes,
  ERC20BytesBoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20BytesContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, NameCallTrace>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, ApproveCallTrace>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TotalSupplyCallTrace>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferFromCallTrace>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallDecimals(
    handler: (call: DecimalsCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, DecimalsCallTrace>,
    preprocessHandler?: (
      call: DecimalsCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x313ce567",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BalanceOfCallTrace>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SymbolCallTrace>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransfer(
    handler: (call: TransferCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferCallTrace>,
    preprocessHandler?: (
      call: TransferCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa9059cbb",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallAllowance(
    handler: (call: AllowanceCallTrace, ctx: ERC20BytesContext) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, AllowanceCallTrace>,
    preprocessHandler?: (
      call: AllowanceCallTrace,
      ctx: ERC20BytesContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xdd62ed3e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null,
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        spender,
        value,
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null,
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        value,
      );
    },
  };

  protected CreateBoundContractView(): ERC20BytesBoundContractView {
    const view = getERC20BytesContract(
      this.config.network,
      this.config.address,
    );
    return new ERC20BytesBoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC20BytesProcessor {
    if (!options.name) {
      options.name = "ERC20Bytes";
    }
    let processor = getProcessor(options) as ERC20BytesProcessor;
    if (!processor) {
      processor = new ERC20BytesProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC20BytesProcessorTemplate extends BaseProcessorTemplate<
  ERC20Bytes,
  ERC20BytesBoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC20Bytes";
    }
    let processor = getProcessor(options) as ERC20BytesProcessor;
    if (!processor) {
      processor = new ERC20BytesProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20BytesContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }
}

export function getERC20BytesContract(
  chainId: EthChainId,
  address: string,
): ERC20BytesContractView {
  let contract = getContractByABI(
    "ERC20Bytes",
    address,
    chainId,
  ) as ERC20BytesContractView;
  if (!contract) {
    const rawContract = ERC20Bytes__factory.connect(
      address,
      getProvider(chainId),
    );
    contract = new ERC20BytesContractView(rawContract);
    addContractByABI("ERC20Bytes", address, chainId, contract);
  }
  return contract;
}

export function getERC20BytesContractOnContext(
  context: EthContext,
  address: string,
): ERC20BytesBoundContractView {
  const view = getERC20BytesContract(context.getChainId(), address);
  const boundView = new ERC20BytesBoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
