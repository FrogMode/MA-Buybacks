/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides } from "ethers";
import { HandlerOptions } from "@sentio/sdk";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
  encodeCallData,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC20__factory } from "./index.js";
import {
  ERC20,
  ApprovalEvent,
  ApprovalEventFilter,
  OwnershipTransferredEvent,
  OwnershipTransferredEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC20.js";

export interface AllowanceCallObject {
  owner: string;
  spender: string;
}

export type AllowanceCallTrace = TypedCallTrace<
  [string, string],
  AllowanceCallObject
>;

export interface ApproveCallObject {
  spender: string;
  amount: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface BalanceOfCallObject {
  account: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface BurnCallObject {
  amount: bigint;
}

export type BurnCallTrace = TypedCallTrace<[bigint], BurnCallObject>;

export interface BurnFromCallObject {
  account: string;
  amount: bigint;
}

export type BurnFromCallTrace = TypedCallTrace<
  [string, bigint],
  BurnFromCallObject
>;

export interface DecimalsCallObject {}

export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;

export interface DecreaseAllowanceCallObject {
  spender: string;
  subtractedValue: bigint;
}

export type DecreaseAllowanceCallTrace = TypedCallTrace<
  [string, bigint],
  DecreaseAllowanceCallObject
>;

export interface IncreaseAllowanceCallObject {
  spender: string;
  addedValue: bigint;
}

export type IncreaseAllowanceCallTrace = TypedCallTrace<
  [string, bigint],
  IncreaseAllowanceCallObject
>;

export interface LockerCallObject {}

export type LockerCallTrace = TypedCallTrace<[], LockerCallObject>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface OwnerCallObject {}

export type OwnerCallTrace = TypedCallTrace<[], OwnerCallObject>;

export interface RenounceOwnershipCallObject {}

export type RenounceOwnershipCallTrace = TypedCallTrace<
  [],
  RenounceOwnershipCallObject
>;

export interface SetLockerCallObject {
  _locker: string;
}

export type SetLockerCallTrace = TypedCallTrace<[string], SetLockerCallObject>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface TransferCallObject {
  recipient: string;
  amount: bigint;
}

export type TransferCallTrace = TypedCallTrace<
  [string, bigint],
  TransferCallObject
>;

export interface TransferFromCallObject {
  sender: string;
  recipient: string;
  amount: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

export interface TransferOwnershipCallObject {
  newOwner: string;
}

export type TransferOwnershipCallTrace = TypedCallTrace<
  [string],
  TransferOwnershipCallObject
>;

const templateContract = ERC20__factory.connect("0x0", DummyProvider);

export class ERC20ContractView extends ContractView<ERC20> {
  constructor(contract: ERC20) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("allowance(address,address)")(
        owner,
        spender,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    account: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        account,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async decimals(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("decimals()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async locker(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("locker()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async owner(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("owner()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(spender, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async burn(
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("burn(uint256)")
          .staticCall(amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("burnFrom(address,uint256)")
          .staticCall(account, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("decreaseAllowance(address,uint256)")
          .staticCall(spender, subtractedValue, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("increaseAllowance(address,uint256)")
          .staticCall(spender, addedValue, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async renounceOwnership(
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("renounceOwnership()")
          .staticCall(overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setLocker(
      _locker: string,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setLocker(address)")
          .staticCall(_locker, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transfer(address,uint256)")
          .staticCall(recipient, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(sender, recipient, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferOwnership(
      newOwner: string,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("transferOwnership(address)")
          .staticCall(newOwner, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    allowance(
      owner: string,
      spender: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "allowance",
        "function allowance(address,address)",
        [owner, spender],
      );
    },
    approve(
      spender: string,
      amount: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "approve",
        "function approve(address,uint256)",
        [spender, amount],
      );
    },
    balanceOf(account: string, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "balanceOf",
        "function balanceOf(address)",
        [account],
      );
    },
    burn(amount: BigNumberish, callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "burn", "function burn(uint256)", [
        amount,
      ]);
    },
    burnFrom(
      account: string,
      amount: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "burnFrom",
        "function burnFrom(address,uint256)",
        [account, amount],
      );
    },
    decimals(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "decimals", "function decimals()", []);
    },
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "decreaseAllowance",
        "function decreaseAllowance(address,uint256)",
        [spender, subtractedValue],
      );
    },
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "increaseAllowance",
        "function increaseAllowance(address,uint256)",
        [spender, addedValue],
      );
    },
    locker(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "locker", "function locker()", []);
    },
    name(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "name", "function name()", []);
    },
    owner(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "owner", "function owner()", []);
    },
    renounceOwnership(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "renounceOwnership",
        "function renounceOwnership()",
        [],
      );
    },
    setLocker(_locker: string, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "setLocker",
        "function setLocker(address)",
        [_locker],
      );
    },
    symbol(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "symbol", "function symbol()", []);
    },
    totalSupply(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "totalSupply",
        "function totalSupply()",
        [],
      );
    },
    transfer(
      recipient: string,
      amount: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transfer",
        "function transfer(address,uint256)",
        [recipient, amount],
      );
    },
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transferFrom",
        "function transferFrom(address,address,uint256)",
        [sender, recipient, amount],
      );
    },
    transferOwnership(
      newOwner: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "transferOwnership",
        "function transferOwnership(address)",
        [newOwner],
      );
    },
  };
}

export class ERC20BoundContractView extends BoundContractView<
  ERC20,
  ERC20ContractView
> {
  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
  ): Promise<bigint> {
    return await this.view.allowance(
      owner,
      spender,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async balanceOf(account: string, overrides?: Overrides): Promise<bigint> {
    return await this.view.balanceOf(
      account,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    return await this.view.decimals(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async locker(overrides?: Overrides): Promise<string> {
    return await this.view.locker(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async name(overrides?: Overrides): Promise<string> {
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async owner(overrides?: Overrides): Promise<string> {
    return await this.view.owner(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.approve(
        spender,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async burn(amount: BigNumberish, overrides?: Overrides): Promise<void> {
      return await this.view.callStatic.burn(
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.burnFrom(
        account,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.decreaseAllowance(
        spender,
        subtractedValue,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.increaseAllowance(
        spender,
        addedValue,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async renounceOwnership(overrides?: Overrides): Promise<void> {
      return await this.view.callStatic.renounceOwnership(
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async setLocker(_locker: string, overrides?: Overrides): Promise<void> {
      return await this.view.callStatic.setLocker(
        _locker,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.transfer(
        recipient,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.transferFrom(
        sender,
        recipient,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async transferOwnership(
      newOwner: string,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.transferOwnership(
        newOwner,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    allowance(
      owner: string,
      spender: string,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.allowance(owner, spender, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.approve(spender, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    balanceOf(account: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.balanceOf(account, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    burn(amount: BigNumberish, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.burn(amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.burnFrom(account, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    decimals(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.decimals({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.decreaseAllowance(spender, subtractedValue, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.increaseAllowance(spender, addedValue, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    locker(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.locker({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    name(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    owner(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.owner({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    renounceOwnership(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.renounceOwnership({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    setLocker(_locker: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.setLocker(_locker, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.transfer(recipient, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.transferFrom(sender, recipient, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    transferOwnership(newOwner: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.transferOwnership(newOwner, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
  };
}

export type ERC20Context = ContractContext<ERC20, ERC20BoundContractView>;

export class ERC20Processor extends BaseProcessor<
  ERC20,
  ERC20BoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventOwnershipTransferred(
    handler: (event: OwnershipTransferredEvent, ctx: ERC20Context) => void,
    filter?:
      | OwnershipTransferredEventFilter
      | OwnershipTransferredEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, OwnershipTransferredEvent>,
    preprocessHandler?: (
      event: OwnershipTransferredEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OwnershipTransferred(address,address)"
      ](null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallAllowance(
    handler: (call: AllowanceCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, AllowanceCallTrace>,
    preprocessHandler?: (
      call: AllowanceCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xdd62ed3e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, ApproveCallTrace>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BalanceOfCallTrace>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBurn(
    handler: (call: BurnCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BurnCallTrace>,
    preprocessHandler?: (
      call: BurnCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x42966c68",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBurnFrom(
    handler: (call: BurnFromCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BurnFromCallTrace>,
    preprocessHandler?: (
      call: BurnFromCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x79cc6790",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallDecimals(
    handler: (call: DecimalsCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, DecimalsCallTrace>,
    preprocessHandler?: (
      call: DecimalsCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x313ce567",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallDecreaseAllowance(
    handler: (call: DecreaseAllowanceCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, DecreaseAllowanceCallTrace>,
    preprocessHandler?: (
      call: DecreaseAllowanceCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa457c2d7",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallIncreaseAllowance(
    handler: (call: IncreaseAllowanceCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, IncreaseAllowanceCallTrace>,
    preprocessHandler?: (
      call: IncreaseAllowanceCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x39509351",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallLocker(
    handler: (call: LockerCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, LockerCallTrace>,
    preprocessHandler?: (
      call: LockerCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xd7b96d4e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, NameCallTrace>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallOwner(
    handler: (call: OwnerCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, OwnerCallTrace>,
    preprocessHandler?: (
      call: OwnerCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x8da5cb5b",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallRenounceOwnership(
    handler: (call: RenounceOwnershipCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, RenounceOwnershipCallTrace>,
    preprocessHandler?: (
      call: RenounceOwnershipCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x715018a6",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSetLocker(
    handler: (call: SetLockerCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SetLockerCallTrace>,
    preprocessHandler?: (
      call: SetLockerCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x171060ec",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SymbolCallTrace>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TotalSupplyCallTrace>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransfer(
    handler: (call: TransferCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferCallTrace>,
    preprocessHandler?: (
      call: TransferCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa9059cbb",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferFromCallTrace>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallTransferOwnership(
    handler: (call: TransferOwnershipCallTrace, ctx: ERC20Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferOwnershipCallTrace>,
    preprocessHandler?: (
      call: TransferOwnershipCallTrace,
      ctx: ERC20Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xf2fde38b",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null,
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        spender,
        value,
      );
    },
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter {
      return templateContract.filters["OwnershipTransferred(address,address)"](
        previousOwner,
        newOwner,
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null,
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        value,
      );
    },
  };

  protected CreateBoundContractView(): ERC20BoundContractView {
    const view = getERC20Contract(this.config.network, this.config.address);
    return new ERC20BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC20Processor {
    if (!options.name) {
      options.name = "ERC20";
    }
    let processor = getProcessor(options) as ERC20Processor;
    if (!processor) {
      processor = new ERC20Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC20ProcessorTemplate extends BaseProcessorTemplate<
  ERC20,
  ERC20BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC20";
    }
    let processor = getProcessor(options) as ERC20Processor;
    if (!processor) {
      processor = new ERC20Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalEvent>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventOwnershipTransferred(
    handler: (event: OwnershipTransferredEvent, ctx: ERC20Context) => void,
    filter?:
      | OwnershipTransferredEventFilter
      | OwnershipTransferredEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, OwnershipTransferredEvent>,
    preprocessHandler?: (
      event: OwnershipTransferredEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OwnershipTransferred(address,address)"
      ](null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferEvent>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }
}

export function getERC20Contract(
  chainId: EthChainId,
  address: string,
): ERC20ContractView {
  let contract = getContractByABI(
    "ERC20",
    address,
    chainId,
  ) as ERC20ContractView;
  if (!contract) {
    const rawContract = ERC20__factory.connect(address, getProvider(chainId));
    contract = new ERC20ContractView(rawContract);
    addContractByABI("ERC20", address, chainId, contract);
  }
  return contract;
}

export function getERC20ContractOnContext(
  context: EthContext,
  address: string,
): ERC20BoundContractView {
  const view = getERC20Contract(context.getChainId(), address);
  const boundView = new ERC20BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
