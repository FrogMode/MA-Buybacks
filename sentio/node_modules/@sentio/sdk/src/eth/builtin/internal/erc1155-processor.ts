/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, BytesLike } from "ethers";
import { HandlerOptions } from "@sentio/sdk";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
  encodeCallData,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC1155__factory } from "./index.js";
import {
  ERC1155,
  ApprovalForAllEvent,
  ApprovalForAllEventFilter,
  TransferBatchEvent,
  TransferBatchEventFilter,
  TransferSingleEvent,
  TransferSingleEventFilter,
  URIEvent,
  URIEventFilter,
} from "./ERC1155.js";

export interface BalanceOfCallObject {
  account: string;
  id: bigint;
}

export type BalanceOfCallTrace = TypedCallTrace<
  [string, bigint],
  BalanceOfCallObject
>;

export interface BalanceOfBatchCallObject {
  accounts: string[];
  ids: bigint[];
}

export type BalanceOfBatchCallTrace = TypedCallTrace<
  [string[], bigint[]],
  BalanceOfBatchCallObject
>;

export interface IsApprovedForAllCallObject {
  account: string;
  operator: string;
}

export type IsApprovedForAllCallTrace = TypedCallTrace<
  [string, string],
  IsApprovedForAllCallObject
>;

export interface SafeBatchTransferFromCallObject {
  from: string;
  to: string;
  ids: bigint[];
  amounts: bigint[];
  data: string;
}

export type SafeBatchTransferFromCallTrace = TypedCallTrace<
  [string, string, bigint[], bigint[], string],
  SafeBatchTransferFromCallObject
>;

export interface SafeTransferFromCallObject {
  from: string;
  to: string;
  id: bigint;
  amount: bigint;
  data: string;
}

export type SafeTransferFromCallTrace = TypedCallTrace<
  [string, string, bigint, bigint, string],
  SafeTransferFromCallObject
>;

export interface SetApprovalForAllCallObject {
  operator: string;
  approved: boolean;
}

export type SetApprovalForAllCallTrace = TypedCallTrace<
  [string, boolean],
  SetApprovalForAllCallObject
>;

export interface SupportsInterfaceCallObject {
  interfaceId: string;
}

export type SupportsInterfaceCallTrace = TypedCallTrace<
  [string],
  SupportsInterfaceCallObject
>;

export interface UriCallObject {
  id: bigint;
}

export type UriCallTrace = TypedCallTrace<[bigint], UriCallObject>;

const templateContract = ERC1155__factory.connect("0x0", DummyProvider);

export class ERC1155ContractView extends ContractView<ERC1155> {
  constructor(contract: ERC1155) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address,uint256)")(
        account,
        id,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint[]> {
    try {
      return await this.contract.getFunction(
        "balanceOfBatch(address[],uint256[])",
      )(accounts, ids, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async isApprovedForAll(
    account: string,
    operator: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction(
        "isApprovedForAll(address,address)",
      )(account, operator, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction("supportsInterface(bytes4)")(
        interfaceId,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async uri(
    id: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("uri(uint256)")(
        id,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction(
            "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
          )
          .staticCall(from, to, ids, amounts, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction(
            "safeTransferFrom(address,address,uint256,uint256,bytes)",
          )
          .staticCall(from, to, id, amount, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setApprovalForAll(address,bool)")
          .staticCall(operator, approved, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    balanceOf(
      account: string,
      id: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "balanceOf",
        "function balanceOf(address,uint256)",
        [account, id],
      );
    },
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "balanceOfBatch",
        "function balanceOfBatch(address[],uint256[])",
        [accounts, ids],
      );
    },
    isApprovedForAll(
      account: string,
      operator: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "isApprovedForAll",
        "function isApprovedForAll(address,address)",
        [account, operator],
      );
    },
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "safeBatchTransferFrom",
        "function safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
        [from, to, ids, amounts, data],
      );
    },
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "safeTransferFrom",
        "function safeTransferFrom(address,address,uint256,uint256,bytes)",
        [from, to, id, amount, data],
      );
    },
    setApprovalForAll(
      operator: string,
      approved: boolean,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "setApprovalForAll",
        "function setApprovalForAll(address,bool)",
        [operator, approved],
      );
    },
    supportsInterface(
      interfaceId: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "supportsInterface",
        "function supportsInterface(bytes4)",
        [interfaceId],
      );
    },
    uri(id: BigNumberish, callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "uri", "function uri(uint256)", [id]);
    },
  };
}

export class ERC1155BoundContractView extends BoundContractView<
  ERC1155,
  ERC1155ContractView
> {
  async balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: Overrides,
  ): Promise<bigint> {
    return await this.view.balanceOf(
      account,
      id,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: Overrides,
  ): Promise<bigint[]> {
    return await this.view.balanceOfBatch(
      accounts,
      ids,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async isApprovedForAll(
    account: string,
    operator: string,
    overrides?: Overrides,
  ): Promise<boolean> {
    return await this.view.isApprovedForAll(
      account,
      operator,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
  ): Promise<boolean> {
    return await this.view.supportsInterface(
      interfaceId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async uri(id: BigNumberish, overrides?: Overrides): Promise<string> {
    return await this.view.uri(
      id,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.safeBatchTransferFrom(
        from,
        to,
        ids,
        amounts,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.safeTransferFrom(
        from,
        to,
        id,
        amount,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides,
    ): Promise<void> {
      return await this.view.callStatic.setApprovalForAll(
        operator,
        approved,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.balanceOf(account, id, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.balanceOfBatch(accounts, ids, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.isApprovedForAll(account, operator, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.safeBatchTransferFrom(
        from,
        to,
        ids,
        amounts,
        data,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.safeTransferFrom(from, to, id, amount, data, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.setApprovalForAll(operator, approved, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.supportsInterface(interfaceId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    uri(id: BigNumberish, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.uri(id, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
  };
}

export type ERC1155Context = ContractContext<ERC1155, ERC1155BoundContractView>;

export class ERC1155Processor extends BaseProcessor<
  ERC1155,
  ERC1155BoundContractView
> {
  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC1155Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalForAllEvent>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransferBatch(
    handler: (event: TransferBatchEvent, ctx: ERC1155Context) => void,
    filter?: TransferBatchEventFilter | TransferBatchEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferBatchEvent>,
    preprocessHandler?: (
      event: TransferBatchEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransferSingle(
    handler: (event: TransferSingleEvent, ctx: ERC1155Context) => void,
    filter?: TransferSingleEventFilter | TransferSingleEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferSingleEvent>,
    preprocessHandler?: (
      event: TransferSingleEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventURI(
    handler: (event: URIEvent, ctx: ERC1155Context) => void,
    filter?: URIEventFilter | URIEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, URIEvent>,
    preprocessHandler?: (
      event: URIEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["URI(string,uint256)"](null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BalanceOfCallTrace>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x00fdd58e",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallBalanceOfBatch(
    handler: (call: BalanceOfBatchCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, BalanceOfBatchCallTrace>,
    preprocessHandler?: (
      call: BalanceOfBatchCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x4e1273f4",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallIsApprovedForAll(
    handler: (call: IsApprovedForAllCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, IsApprovedForAllCallTrace>,
    preprocessHandler?: (
      call: IsApprovedForAllCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xe985e9c5",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSafeBatchTransferFrom(
    handler: (
      call: SafeBatchTransferFromCallTrace,
      ctx: ERC1155Context,
    ) => void,
    handlerOptions?: HandlerOptions<
      EthFetchConfig,
      SafeBatchTransferFromCallTrace
    >,
    preprocessHandler?: (
      call: SafeBatchTransferFromCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x2eb2c2d6",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSafeTransferFrom(
    handler: (call: SafeTransferFromCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SafeTransferFromCallTrace>,
    preprocessHandler?: (
      call: SafeTransferFromCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xf242432a",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSetApprovalForAll(
    handler: (call: SetApprovalForAllCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SetApprovalForAllCallTrace>,
    preprocessHandler?: (
      call: SetApprovalForAllCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa22cb465",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallSupportsInterface(
    handler: (call: SupportsInterfaceCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, SupportsInterfaceCallTrace>,
    preprocessHandler?: (
      call: SupportsInterfaceCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x01ffc9a7",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  onCallUri(
    handler: (call: UriCallTrace, ctx: ERC1155Context) => void,
    handlerOptions?: HandlerOptions<EthFetchConfig, UriCallTrace>,
    preprocessHandler?: (
      call: UriCallTrace,
      ctx: ERC1155Context,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x0e89341c",
      handler as any,
      handlerOptions,
      preprocessHandler,
    );
  }

  public static filters = {
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null,
    ): ApprovalForAllEventFilter {
      return templateContract.filters["ApprovalForAll(address,address,bool)"](
        account,
        operator,
        approved,
      );
    },
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null,
    ): TransferBatchEventFilter {
      return templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](operator, from, to, ids, values);
    },
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null,
    ): TransferSingleEventFilter {
      return templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](operator, from, to, id, value);
    },
    URI(value?: null, id?: BigNumberish | null): URIEventFilter {
      return templateContract.filters["URI(string,uint256)"](value, id);
    },
  };

  protected CreateBoundContractView(): ERC1155BoundContractView {
    const view = getERC1155Contract(this.config.network, this.config.address);
    return new ERC1155BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC1155Processor {
    if (!options.name) {
      options.name = "ERC1155";
    }
    let processor = getProcessor(options) as ERC1155Processor;
    if (!processor) {
      processor = new ERC1155Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC1155ProcessorTemplate extends BaseProcessorTemplate<
  ERC1155,
  ERC1155BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC1155";
    }
    let processor = getProcessor(options) as ERC1155Processor;
    if (!processor) {
      processor = new ERC1155Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC1155Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, ApprovalForAllEvent>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null,
      );
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransferBatch(
    handler: (event: TransferBatchEvent, ctx: ERC1155Context) => void,
    filter?: TransferBatchEventFilter | TransferBatchEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferBatchEvent>,
    preprocessHandler?: (
      event: TransferBatchEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventTransferSingle(
    handler: (event: TransferSingleEvent, ctx: ERC1155Context) => void,
    filter?: TransferSingleEventFilter | TransferSingleEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, TransferSingleEvent>,
    preprocessHandler?: (
      event: TransferSingleEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }

  onEventURI(
    handler: (event: URIEvent, ctx: ERC1155Context) => void,
    filter?: URIEventFilter | URIEventFilter[],
    handlerOptions?: HandlerOptions<EthFetchConfig, URIEvent>,
    preprocessHandler?: (
      event: URIEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["URI(string,uint256)"](null, null);
    }
    return super.onEthEvent(
      handler,
      filter!,
      handlerOptions,
      preprocessHandler,
    );
  }
}

export function getERC1155Contract(
  chainId: EthChainId,
  address: string,
): ERC1155ContractView {
  let contract = getContractByABI(
    "ERC1155",
    address,
    chainId,
  ) as ERC1155ContractView;
  if (!contract) {
    const rawContract = ERC1155__factory.connect(address, getProvider(chainId));
    contract = new ERC1155ContractView(rawContract);
    addContractByABI("ERC1155", address, chainId, contract);
  }
  return contract;
}

export function getERC1155ContractOnContext(
  context: EthContext,
  address: string,
): ERC1155BoundContractView {
  const view = getERC1155Contract(context.getChainId(), address);
  const boundView = new ERC1155BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
